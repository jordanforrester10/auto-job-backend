This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-12T01:59:41.292Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
config/anthropic.js
config/jobBoards.js
config/mongodb.js
config/openai.js
config/postgresql.js
config/s3.js
controllers/assistant.controller.js
controllers/auth.controller.js
controllers/job.controller.js
controllers/recruiter.controller.js
controllers/resume.controller.js
controllers/search.controller.js
controllers/settings.controller.js
debug-controller-params.js
debug-recruiter-search.js
debug-search-query.js
middleware/auth.middleware.js
middleware/validation.middleware.js
models/mongodb/aiAgent.model.js
models/mongodb/aiJobSearch.model.js
models/mongodb/assistantSession.model.js
models/mongodb/conversation.model.js
models/mongodb/job.model.js
models/mongodb/outreach.model.js
models/mongodb/resume.model.js
models/mongodb/user.model.js
models/mongodb/userMemory.model.js
models/postgresql/schema.js
package.json
routes/assistant.routes.js
routes/auth.routes.js
routes/job.routes.js
routes/recruiter.routes.js
routes/resume.routes.js
routes/search.routes.js
routes/settings.routes.js
routes/test.routes.js
scripts/fix-missing-columns.js
scripts/fix-outreach-history.js
scripts/import-recruiters.js
scripts/update-recruiter-industries.js
server.js
services/assistant.service.js
services/conversationService.js
services/jobAnalysis.service.js
services/jobMatching.service.js
services/jobSearch.service.js
services/memoryService.js
services/realJobBoard.service.js
services/recruiterImport.service.js
services/resumeAnalysis.service.js
services/resumeEditor.service.js
services/resumeParser.service.js
services/resumeTailoring.service.js
test-controller.js
test-extraction.js
test-s3.js
tests/test-auth.js
tests/test-neon-connection.js
utils/email-templates.js
utils/jobBoardPatterns.js
utils/recruiter-importer.js
utils/send-email.js
verify-controller.js

================================================================
Repository Files
================================================================

================
File: config/anthropic.js
================
const Anthropic = require('@anthropic-ai/sdk');

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

module.exports = { anthropic };

================
File: config/jobBoards.js
================
// config/jobBoards.js - REAL JOB BOARD CONFIGURATION
module.exports = {
  // Supported job board platforms
  platforms: {
    greenhouse: {
      name: 'Greenhouse',
      displayName: 'Greenhouse',
      icon: 'ðŸŒ±',
      description: 'Tech startups and scale-ups with comprehensive job details',
      urlPatterns: [
        'greenhouse.io/jobs',
        'greenhouse.io/job',
        'boards.greenhouse.io'
      ],
      searchPriority: 1, // Higher priority for tech roles
      expectedFeatures: [
        'Comprehensive job descriptions',
        'Team and culture information',
        'Tech stack details',
        'Interview process overview'
      ],
      targetCompanyTypes: [
        'Tech startups',
        'Scale-ups',
        'Venture-backed companies',
        'Y Combinator companies',
        'Series A-C companies'
      ],
      averageContentQuality: 'high',
      searchModifiers: ['site:greenhouse.io', 'inurl:jobs'],
      apiEndpoints: {
        // Note: These would be used if we had direct API access
        publicJobs: 'https://boards-api.greenhouse.io/v1/boards/{board_token}/jobs',
        departments: 'https://boards-api.greenhouse.io/v1/boards/{board_token}/departments'
      }
    },
    
    lever: {
      name: 'Lever',
      displayName: 'Lever',
      icon: 'âš¡',
      description: 'Growth-stage companies with detailed role information',
      urlPatterns: [
        'jobs.lever.co',
        'lever.co/jobs'
      ],
      searchPriority: 2,
      expectedFeatures: [
        'Detailed role descriptions',
        'Career progression paths',
        'Team structure information',
        'Hiring manager details'
      ],
      targetCompanyTypes: [
        'Growth-stage companies',
        'Expanding teams',
        'Series A-D companies',
        'Scale-ups with clear structure'
      ],
      averageContentQuality: 'high',
      searchModifiers: ['site:lever.co', 'inurl:jobs'],
      apiEndpoints: {
        // Note: These would be used if we had direct API access
        postings: 'https://api.lever.co/v0/postings/{company}',
        departments: 'https://api.lever.co/v0/postings/{company}?group=department'
      }
    },
    
    indeed: {
      name: 'Indeed',
      displayName: 'Indeed',
      icon: 'ðŸ”',
      description: 'Established companies with verified direct postings',
      urlPatterns: [
        'indeed.com/viewjob',
        'indeed.com/jobs',
        'indeed.com/job'
      ],
      searchPriority: 3, // Lower priority but good for established companies
      expectedFeatures: [
        'Direct company postings',
        'Verified employer accounts',
        'Complete job details',
        'Application instructions'
      ],
      targetCompanyTypes: [
        'Established companies',
        'Enterprise organizations',
        'Public companies',
        'Direct employers'
      ],
      averageContentQuality: 'medium',
      searchModifiers: ['site:indeed.com', 'inurl:viewjob', '-recruiter', '-staffing'],
      exclusionKeywords: [
        'staffing',
        'recruiting',
        'placement',
        'consulting firm',
        'headhunter'
      ]
    }
  },
  
  // Search configuration
  searchConfig: {
    maxJobsPerPlatform: 5,
    maxTotalJobs: 12,
    minContentLength: 400,
    maxPostingAge: 30, // days
    timeoutPerPlatform: 30000, // 30 seconds
    retryAttempts: 2,
    rateLimitDelay: 1000, // 1 second between requests
    
    // Quality thresholds
    qualityThresholds: {
      minQualityScore: 60,
      minMatchScore: 70,
      requiredSections: ['requirements', 'responsibilities'],
      preferredSections: ['benefits', 'tech_stack', 'team_info']
    },
    
    // Search strategy
    searchStrategy: {
      useParallelSearch: false, // Sequential to avoid rate limiting
      prioritizeRecent: true,
      diversifyPlatforms: true,
      maxSearchQueriesPerPlatform: 3
    }
  },
  
  // Content validation rules
  contentValidation: {
    minWordCount: 100,
    maxWordCount: 5000,
    requiredKeywords: {
      jobPosting: ['position', 'role', 'job', 'opportunity'],
      requirements: ['requirement', 'qualification', 'skill', 'experience'],
      company: ['company', 'team', 'organization', 'we are']
    },
    blacklistedKeywords: [
      'this posting has expired',
      'job no longer available',
      'position filled',
      'scam',
      'pyramid scheme'
    ],
    urlValidation: {
      allowedProtocols: ['https'],
      requiredDomains: ['greenhouse.io', 'lever.co', 'indeed.com'],
      blockedDomains: ['spam.com', 'fake-jobs.com']
    }
  },
  
  // Platform-specific extraction rules
  extractionRules: {
    greenhouse: {
      selectors: {
        title: '.app-title, [data-qa="job-title"]',
        description: '.job-post-content, [data-qa="job-description"]',
        requirements: '.requirements, [data-qa="requirements"]',
        team: '.team-info, [data-qa="team"]',
        benefits: '.benefits, [data-qa="benefits"]'
      },
      identifierPatterns: {
        jobId: /\/jobs\/(\d+)/,
        officeId: /office_id=(\d+)/
      }
    },
    
    lever: {
      selectors: {
        title: '.posting-headline, [data-qa="posting-name"]',
        description: '.posting-description, [data-qa="posting-description"]',
        team: '.posting-categories, [data-qa="posting-team"]',
        requirements: '.posting-requirements'
      },
      identifierPatterns: {
        company: /jobs\.lever\.co\/([^\/]+)/,
        postingId: /jobs\.lever\.co\/[^\/]+\/([^\/\?]+)/
      }
    },
    
    indeed: {
      selectors: {
        title: '[data-jk] h1, .jobsearch-JobInfoHeader-title',
        description: '.jobsearch-jobDescriptionText, #jobDescriptionText',
        company: '[data-jk] .jobsearch-CompanyInfoContainer',
        salary: '.jobsearch-JobMetadataHeader-item'
      },
      identifierPatterns: {
        jobKey: /jk=([^&]+)/,
        companyId: /cmp=([^&]+)/
      }
    }
  },
  
  // Error handling configuration
  errorHandling: {
    retryableErrors: [
      'TIMEOUT',
      'RATE_LIMITED',
      'TEMPORARY_FAILURE',
      'NETWORK_ERROR'
    ],
    fatalErrors: [
      'INVALID_CREDENTIALS',
      'BLOCKED_ACCESS',
      'PLATFORM_DISCONTINUED'
    ],
    fallbackStrategies: {
      onPlatformFailure: 'continue_with_other_platforms',
      onAllPlatformFailure: 'return_partial_results',
      onContentExtractionFailure: 'use_fallback_extraction'
    }
  },
  
  // Analytics and monitoring
  analytics: {
    trackSearchPerformance: true,
    trackContentQuality: true,
    trackUserEngagement: true,
    metrics: {
      searchLatency: 'platform_search_duration',
      extractionSuccess: 'content_extraction_rate',
      qualityScore: 'average_content_quality',
      userSatisfaction: 'job_application_rate'
    }
  },
  
  // Rate limiting and respectful scraping
  respectfulScraping: {
    observeRobotsTxt: true,
    respectRateLimits: true,
    userAgent: 'auto-job.ai-bot/1.0 (Job Discovery Service)',
    crawlDelay: 1000, // 1 second between requests
    concurrentRequests: 1, // Sequential processing
    sessionRotation: true
  },
  
  // Legal and compliance
  compliance: {
    respectTermsOfService: true,
    attributeSource: true,
    respectCopyright: true,
    dataRetentionDays: 90,
    anonymizeUserData: true,
    complianceNotes: [
      'All job board searches respect terms of service',
      'Content is used for matching purposes only',
      'No bulk downloading or data resale',
      'Attribution to original job boards maintained'
    ]
  },
  
  // Cost optimization
  costOptimization: {
    claudeSearchCost: 0.35, // Average cost per search with Claude
    gpt4AnalysisCost: 0.02, // Average cost per job analysis
    targetTotalCost: 0.57, // Target cost per complete search
    optimizations: [
      'Batch processing for analysis',
      'Efficient content extraction',
      'Smart retry logic',
      'Quality-based filtering'
    ]
  }
};

================
File: config/mongodb.js
================
const mongoose = require('mongoose');
require('dotenv').config();

const connectMongoDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = connectMongoDB;

================
File: config/openai.js
================
// config/openai.js
const OpenAI = require('openai');
require('dotenv').config();

// Initialize the OpenAI client with your API key
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Log a message to help with debugging
if (!process.env.OPENAI_API_KEY) {
  console.warn('WARNING: OPENAI_API_KEY environment variable is not defined. AI features will not work.');
} else {
  console.log('OpenAI configuration loaded successfully');
}

module.exports = { openai };

================
File: config/postgresql.js
================
// backend/config/postgresql.js
const { Pool } = require('pg');
require('dotenv').config();

// Create a connection pool
const pool = new Pool({
  connectionString: process.env.POSTGRES_URI,
  ssl: {
    rejectUnauthorized: false // Required for Neon and many other cloud PostgreSQL providers
  }
});

// Test connection function
const testConnection = async () => {
  let client;
  try {
    client = await pool.connect();
    console.log('PostgreSQL connected successfully');
    return true;
  } catch (error) {
    console.error('PostgreSQL connection error:', error);
    return false;
  } finally {
    if (client) client.release();
  }
};

// Execute when module is loaded to test the connection
testConnection();

module.exports = {
  query: (text, params) => pool.query(text, params),
  pool,
  testConnection
};

================
File: config/s3.js
================
// config/s3.js
const { S3Client } = require('@aws-sdk/client-s3');
require('dotenv').config();

// Create S3 client with proper configuration
const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-2',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
  }
});

// Export the AWS S3 bucket name as a constant
// Look for either AWS_S3_BUCKET or AWS_BUCKET_NAME to be backward compatible
const S3_BUCKET = process.env.AWS_S3_BUCKET || process.env.AWS_BUCKET_NAME;

// If the bucket name is not defined, log a warning
if (!S3_BUCKET) {
  console.warn('WARNING: AWS_BUCKET_NAME environment variable is not defined. File uploads will fail.');
}

module.exports = { s3Client, S3_BUCKET };

================
File: controllers/assistant.controller.js
================
// controllers/assistant.controller.js - COMPLETE WITH RESUME EDITING AND ANALYSIS REFRESH
const { openai } = require('../config/openai');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const User = require('../models/mongodb/user.model');
const Conversation = require('../models/mongodb/conversation.model');
const UserMemory = require('../models/mongodb/userMemory.model');
const MemoryService = require('../services/memoryService');
const ConversationService = require('../services/conversationService');

// ===================================================================
// CORE AI CHAT WITH MEMORY & CONVERSATIONS
// ===================================================================

/**
 * Enhanced chat endpoint with ACTUAL resume editing using your existing service
 */
exports.chat = async (req, res) => {
  try {
    const userId = req.user._id;
    const { 
      message, 
      context, 
      conversationHistory, 
      conversationId, 
      newConversation = false 
    } = req.body;

    if (!message || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Message is required'
      });
    }

    console.log(`ðŸ¤– AI Chat request from user ${userId}: ${message.substring(0, 50)}...`);

    // ================================================================
    // ðŸ”§ RESUME EDITING: Detect and handle resume editing requests
    // ================================================================
    const isResumeEditingRequest = detectResumeEditingIntent(message, context);
    
    if (isResumeEditingRequest && context?.currentResume?.id) {
      console.log(`ðŸŽ¯ Detected resume editing request for resume: ${context.currentResume.id}`);
      
      try {
        // Use your existing ResumeEditorService
        const ResumeEditorService = require('../services/resumeEditor.service');
        
        // Apply the actual resume changes using your existing service
        const editResult = await ResumeEditorService.applyResumeChanges(
          context.currentResume.id,
          userId,
          message  // Your service handles natural language parsing
        );

        console.log(`âœ… Resume editing completed:`, {
          changesCount: editResult.changes?.length || 0,
          newFileUrl: editResult.newFileUrl ? 'Generated' : 'Not generated',
          summary: editResult.changesSummary
        });

        // ðŸ”¥ CRITICAL FIX: Re-analyze the resume for new scores (like Auto-Fix button does)
        console.log(`ðŸ” Re-analyzing resume for updated scores...`);
        const resumeAnalysisService = require('../services/resumeAnalysis.service');
        const newAnalysis = await resumeAnalysisService.analyzeResume(context.currentResume.id);
        
        // Update the resume with new analysis
        const updatedResume = await Resume.findById(context.currentResume.id);
        updatedResume.analysis = newAnalysis;
        await updatedResume.save();
        
        console.log(`âœ… Resume re-analysis completed:`, {
          previousScore: context.currentResume.score || 'Unknown',
          newOverallScore: newAnalysis.overallScore,
          newATSScore: newAnalysis.atsCompatibility
        });

        // Generate success response with actual changes and NEW SCORES
        const successMessage = `âœ… I've successfully updated your resume "${context.currentResume.name}"!

${editResult.changesSummary}

ðŸ“Š **Updated Scores:**
- Overall Score: ${newAnalysis.overallScore}%
- ATS Compatibility: ${newAnalysis.atsCompatibility}%

${editResult.changes?.length > 0 ? 
  `\nChanges made:\n${editResult.changes.map(change => 
    `â€¢ ${change.action.charAt(0).toUpperCase() + change.action.slice(1)} ${change.section}: ${change.reason || 'Updated content'}`
  ).join('\n')}` : 
  'Your resume has been improved and optimized.'
}

The updated resume with new scores is ready to download.`;

        // Save the interaction to conversation
        let conversation = await getOrCreateConversation(conversationId, userId, newConversation, message, context);
        
        await ConversationService.addMessage(conversation._id, {
          type: 'user',
          content: message,
          metadata: { 
            context, 
            isResumeEdit: true,
            resumeId: context.currentResume.id
          }
        });

        await ConversationService.addMessage(conversation._id, {
          type: 'ai',
          content: successMessage,
          metadata: {
            isResumeEdit: true,
            resumeChanges: editResult.changes,
            newFileUrl: editResult.newFileUrl,
            changesSummary: editResult.changesSummary,
            // ðŸ”¥ CRITICAL: Include new analysis scores
            newAnalysis: {
              overallScore: newAnalysis.overallScore,
              atsCompatibility: newAnalysis.atsCompatibility
            },
            suggestions: [
              'Make more changes',
              'Optimize for ATS', 
              'View updated resume',
              'Download new version'
            ]
          }
        });

        // Extract memories from this resume editing session
        try {
          await MemoryService.extractMemoriesFromMessage(userId, 
            `Updated resume: ${editResult.changesSummary}. New scores: Overall ${newAnalysis.overallScore}%, ATS ${newAnalysis.atsCompatibility}%`, 
            {
              conversationId: conversation._id,
              resumeId: context.currentResume.id,
              category: 'resume_improvement',
              tags: ['resume_editing', 'ai_assistance', 'score_improvement']
            }
          );
        } catch (memoryError) {
          console.warn('Memory extraction failed:', memoryError);
        }

        // Return success response with resume editing confirmation AND NEW SCORES
        return res.json({
          success: true,
          message: successMessage,
          suggestions: [
            'Make more changes',
            'Optimize for ATS', 
            'View updated resume',
            'Download new version'
          ],
          actions: [],
          confidence: 0.95,
          conversationId: conversation._id,
          conversationTitle: conversation.title,
          // Resume editing specific fields
          resumeUpdated: true, // â† Critical flag to trigger UI refresh
          resumeChanges: editResult.changes,
          newFileUrl: editResult.newFileUrl,
          changesSummary: editResult.changesSummary,
          // ðŸ”¥ CRITICAL FIX: Include new analysis data for frontend refresh
          newAnalysis: {
            overallScore: newAnalysis.overallScore,
            atsCompatibility: newAnalysis.atsCompatibility,
            strengths: newAnalysis.strengths,
            weaknesses: newAnalysis.weaknesses,
            improvementAreas: newAnalysis.improvementAreas
          },
          usage: {
            tokens: 0 // Resume editing tokens counted separately
          }
        });

      } catch (resumeEditError) {
        console.error('Resume editing failed:', resumeEditError);
        
        // Fall back to regular AI response with error context
        const errorMessage = `I encountered an issue updating your resume: ${resumeEditError.message}. Let me provide some guidance instead.

Here's what I would suggest for your resume improvement:
- Focus on quantifying your achievements with specific numbers
- Use strong action verbs to start each bullet point
- Ensure your skills section includes relevant keywords
- Consider adding more details about your AI and Python experience

Would you like me to try a different approach to updating your resume?`;
        
        return res.json({
          success: true,
          message: errorMessage,
          suggestions: [
            'Try a simpler request',
            'Focus on one section',
            'Check resume format',
            'Contact support'
          ],
          resumeEditError: true,
          error: resumeEditError.message
        });
      }
    }

    // ================================================================
    // ðŸ¤– REGULAR AI CHAT: Continue with normal AI conversation
    // ================================================================
    
    // Get or create conversation
    let conversation = await getOrCreateConversation(conversationId, userId, newConversation, message, context);

    // Build AI context with memory
    const user = await User.findById(userId);
    const resumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    const jobs = await Job.find({ userId }).sort({ createdAt: -1 });
    const memoryContext = await MemoryService.buildAIContext(userId, context);
    
    const systemPrompt = buildSystemPrompt(user, resumes, jobs, context, conversation, memoryContext);
    const messages = buildMessages(systemPrompt, conversation.messages.slice(-10), message);

    // Call OpenAI for regular chat
    const aiResponse = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: messages,
      temperature: 0.7,
      max_tokens: 1200,
      presence_penalty: 0.1,
      frequency_penalty: 0.1
    });

    const aiMessage = aiResponse.choices[0].message.content;
    const parsedResponse = parseResponse(aiMessage, context);

    // Save messages to conversation
    await ConversationService.addMessage(conversation._id, {
      type: 'user',
      content: message,
      metadata: { context }
    });

    await ConversationService.addMessage(conversation._id, {
      type: 'ai',
      content: parsedResponse.message,
      metadata: {
        suggestions: parsedResponse.suggestions,
        actions: parsedResponse.actions,
        confidence: parsedResponse.confidence,
        tokens: aiResponse.usage?.total_tokens || 0
      }
    });

    // Extract memories from conversation
    try {
      await MemoryService.extractMemoriesFromMessage(userId, message, {
        conversationId: conversation._id,
        page: context?.page,
        category: conversation.category
      });
    } catch (memoryError) {
      console.warn('Memory extraction failed:', memoryError);
    }

    console.log(`âœ… AI response generated (${aiResponse.usage?.total_tokens || 0} tokens)`);

    res.json({
      success: true,
      message: parsedResponse.message,
      suggestions: parsedResponse.suggestions,
      actions: parsedResponse.actions,
      confidence: parsedResponse.confidence,
      conversationId: conversation._id,
      conversationTitle: conversation.title,
      usage: {
        tokens: aiResponse.usage?.total_tokens || 0
      }
    });

  } catch (error) {
    console.error('Chat error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to process chat message',
      fallback_message: getFallbackResponse(req.body.message, req.body.context)
    });
  }
};

// [REST OF THE FILE REMAINS THE SAME - all other exports, helper functions, etc.]

// ===================================================================
// CONVERSATION MANAGEMENT
// ===================================================================

exports.getConversations = async (req, res) => {
  try {
    const userId = req.user._id;
    const options = {
      category: req.query.category,
      tags: req.query.tags ? req.query.tags.split(',') : undefined,
      search: req.query.search,
      pinned: req.query.pinned === 'true' ? true : req.query.pinned === 'false' ? false : undefined,
      starred: req.query.starred === 'true' ? true : req.query.starred === 'false' ? false : undefined,
      limit: parseInt(req.query.limit) || 20,
      offset: parseInt(req.query.offset) || 0,
      sortBy: req.query.sortBy || 'lastActiveAt'
    };

    const result = await ConversationService.getUserConversations(userId, options);
    res.json({ success: true, ...result });

  } catch (error) {
    console.error('Get conversations error:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch conversations' });
  }
};

exports.getConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const conversation = await ConversationService.getConversation(conversationId, userId);
    res.json({ success: true, conversation });
  } catch (error) {
    console.error('Get conversation error:', error);
    res.status(404).json({ success: false, error: 'Conversation not found' });
  }
};

exports.updateConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const conversation = await ConversationService.updateConversation(conversationId, userId, req.body);
    res.json({ success: true, conversation });
  } catch (error) {
    console.error('Update conversation error:', error);
    res.status(500).json({ success: false, error: 'Failed to update conversation' });
  }
};

exports.deleteConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const { permanent = false } = req.query;
    
    await ConversationService.deleteConversation(conversationId, userId, permanent === 'true');
    res.json({ success: true, message: 'Conversation deleted' });
  } catch (error) {
    console.error('Delete conversation error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete conversation' });
  }
};

// ===================================================================
// MEMORY MANAGEMENT
// ===================================================================

exports.getMemories = async (req, res) => {
  try {
    const userId = req.user._id;
    const { type, category, search, minConfidence = 0.5, limit = 50 } = req.query;

    const userMemory = await UserMemory.findByUserId(userId);
    if (!userMemory) {
      return res.json({ success: true, memories: [], total: 0 });
    }

    let memories = userMemory.memories.filter(m => m.isActive);

    // Apply filters
    if (type) memories = memories.filter(m => m.type === type);
    if (category) memories = memories.filter(m => m.category === category);
    if (search) {
      const searchRegex = new RegExp(search, 'i');
      memories = memories.filter(m => searchRegex.test(m.content) || m.tags.some(tag => searchRegex.test(tag)));
    }
    
    memories = memories.filter(m => m.confidence >= parseFloat(minConfidence));
    memories.sort((a, b) => b.confidence - a.confidence);

    res.json({
      success: true,
      memories: memories.slice(0, parseInt(limit)),
      total: memories.length,
      analytics: userMemory.analytics
    });

  } catch (error) {
    console.error('Get memories error:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch memories' });
  }
};

exports.updateMemory = async (req, res) => {
  try {
    const userId = req.user._id;
    const { memoryData } = req.body;

    const memory = await MemoryService.addMemoryToUser(userId, {
      ...memoryData,
      source: { extractionMethod: 'user_added', timestamp: new Date() }
    });

    res.json({ success: true, memory, message: 'Memory updated successfully' });
  } catch (error) {
    console.error('Update memory error:', error);
    res.status(500).json({ success: false, error: 'Failed to update memory' });
  }
};

exports.deleteMemory = async (req, res) => {
  try {
    const userId = req.user._id;
    const { memoryId } = req.params;

    const userMemory = await UserMemory.findByUserId(userId);
    if (!userMemory) {
      return res.status(404).json({ success: false, error: 'User memory not found' });
    }

    const memory = userMemory.memories.find(m => m.id === memoryId);
    if (!memory) {
      return res.status(404).json({ success: false, error: 'Memory not found' });
    }

    memory.isActive = false;
    userMemory.updateProfile();
    await userMemory.save();

    res.json({ success: true, message: 'Memory deleted successfully' });
  } catch (error) {
    console.error('Delete memory error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete memory' });
  }
};

/**
 * Get memory insights and analytics
 */
exports.getMemoryInsights = async (req, res) => {
  try {
    const userId = req.user._id;
    console.log('ðŸ§  Getting memory insights for user:', userId);

    const userMemory = await UserMemory.findByUserId(userId);
    if (!userMemory) {
      console.log('ðŸ“ No user memory found, returning empty insights');
      return res.json({
        success: true,
        insights: [],
        analytics: {
          totalMemories: 0,
          averageConfidence: 0,
          memoriesByType: [],
          memoriesByCategory: []
        },
        profile: {}
      });
    }

    console.log('ðŸ“Š Found user memory with', userMemory.memories?.length || 0, 'memories');

    // Generate fresh insights if needed
    if (!userMemory.analytics?.lastAnalyzedAt || 
        Date.now() - new Date(userMemory.analytics.lastAnalyzedAt).getTime() > 24 * 60 * 60 * 1000) {
      
      console.log('ðŸ”„ Generating fresh memory insights...');
      try {
        const insights = await generateMemoryInsights(userMemory);
        
        // Ensure analytics object exists
        if (!userMemory.analytics) {
          userMemory.analytics = {
            totalMemories: 0,
            memoriesByType: [],
            memoriesByCategory: [],
            averageConfidence: 0,
            insights: []
          };
        }
        
        userMemory.analytics.insights = insights;
        userMemory.analytics.lastAnalyzedAt = new Date();
        userMemory.updateProfile();
        
        await userMemory.save();
        console.log('âœ… Generated and saved', insights.length, 'new insights');
      } catch (insightError) {
        console.error('âš ï¸ Error generating insights:', insightError);
      }
    }

    const response = {
      success: true,
      insights: userMemory.analytics?.insights || [],
      analytics: {
        totalMemories: userMemory.memories?.filter(m => m.isActive).length || 0,
        averageConfidence: userMemory.analytics?.averageConfidence || 0,
        memoriesByType: userMemory.analytics?.memoriesByType || [],
        memoriesByCategory: userMemory.analytics?.memoriesByCategory || [],
        lastAnalyzedAt: userMemory.analytics?.lastAnalyzedAt
      },
      profile: userMemory.profile || {}
    };

    console.log('ðŸ“¤ Sending memory insights:', {
      insightsCount: response.insights.length,
      totalMemories: response.analytics.totalMemories
    });

    res.json(response);

  } catch (error) {
    console.error('âŒ Get memory insights error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get memory insights',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

exports.performMemoryMaintenance = async (req, res) => {
  try {
    const userId = req.user._id;
    const result = await MemoryService.performMemoryMaintenance(userId);
    
    if (!result) {
      return res.status(404).json({ success: false, error: 'User memory not found' });
    }

    res.json({ success: true, maintenance: result, message: 'Memory maintenance completed' });
  } catch (error) {
    console.error('Memory maintenance error:', error);
    res.status(500).json({ success: false, error: 'Failed to perform memory maintenance' });
  }
};

// ===================================================================
// SEARCH & ANALYTICS
// ===================================================================

exports.search = async (req, res) => {
  try {
    const userId = req.user._id;
    const { query, searchType = 'all', limit = 20 } = req.query;

    const results = {};

    if (searchType === 'conversations' || searchType === 'all') {
      results.conversations = await ConversationService.searchAllConversations(userId, query, { limit: parseInt(limit) });
    }

    if (searchType === 'memories' || searchType === 'all') {
      results.memories = await MemoryService.searchMemories(userId, query, { limit: parseInt(limit) });
    }

    res.json({
      success: true,
      query,
      results,
      totalResults: (results.conversations?.length || 0) + (results.memories?.length || 0)
    });

  } catch (error) {
    console.error('Search error:', error);
    res.status(500).json({ success: false, error: 'Search failed' });
  }
};

exports.getAnalytics = async (req, res) => {
  try {
    const userId = req.user._id;
    const { timeframe = '30d' } = req.query;
    const analytics = await ConversationService.getConversationAnalytics(userId, timeframe);
    res.json({ success: true, analytics });
  } catch (error) {
    console.error('Get analytics error:', error);
    res.status(500).json({ success: false, error: 'Failed to get analytics' });
  }
};

// ===================================================================
// ENHANCED RESUME OPERATIONS - FULL IMPLEMENTATION
// ===================================================================

/**
 * Apply AI-suggested resume changes in real-time
 */
exports.applyResumeChanges = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, changes, changeType = 'ai_enhancement' } = req.body;

    console.log(`ðŸ¤– AJ: Applying resume changes for user ${userId}`);

    // Validate input
    if (!resumeId || !changes) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID and changes are required'
      });
    }

    // Import the resume editor service
    const ResumeEditorService = require('../services/resumeEditor.service');

    // Apply changes using AI
    const result = await ResumeEditorService.applyResumeChanges(resumeId, userId, changes);

    // Track the interaction for memory system
    try {
      await MemoryService.extractMemoriesFromMessage(userId, 
        `Updated resume: ${result.changesSummary}`, 
        {
          resumeId: resumeId,
          changeType: changeType,
          category: 'resume_improvement'
        }
      );
    } catch (memoryError) {
      console.warn('Memory extraction failed:', memoryError);
    }

    res.json({
      success: true,
      message: 'Resume updated successfully by AJ',
      result: {
        updatedResume: {
          id: result.updatedResume._id,
          name: result.updatedResume.name,
          parsedData: result.updatedResume.parsedData,
          analysis: result.updatedResume.analysis,
          updatedAt: result.updatedResume.updatedAt,
          versions: result.updatedResume.versions
        },
        changes: result.changes,
        changesSummary: result.changesSummary,
        newFileUrl: result.newFileUrl
      }
    });

  } catch (error) {
    console.error('Apply resume changes error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to apply resume changes',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Optimize resume for ATS systems
 */
exports.optimizeForATS = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, targetJobId } = req.body;

    console.log(`ðŸ¤– AJ: Optimizing resume ${resumeId} for ATS`);

    // Validate input
    if (!resumeId) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID is required'
      });
    }

    // Get target job if provided
    let targetJob = null;
    if (targetJobId) {
      targetJob = await Job.findOne({ _id: targetJobId, userId });
    }

    // Import the resume editor service
    const ResumeEditorService = require('../services/resumeEditor.service');

    // Optimize for ATS
    const result = await ResumeEditorService.optimizeForATS(resumeId, userId, targetJob);

    // Track the interaction for memory system
    try {
      const improvementMessage = `Optimized resume for ATS. Score improved from ${result.previousScore} to ${result.newATSScore}`;
      await MemoryService.extractMemoriesFromMessage(userId, improvementMessage, {
        resumeId: resumeId,
        targetJobId: targetJobId,
        category: 'ats_optimization'
      });
    } catch (memoryError) {
      console.warn('Memory extraction failed:', memoryError);
    }

    res.json({
      success: true,
      message: 'Resume optimized for ATS by AJ',
      result: {
        optimizations: result.optimizations,
        atsScoreImprovement: {
          previous: result.previousScore,
          new: result.newATSScore,
          improvement: result.newATSScore - result.previousScore
        },
        updatedResume: {
          id: result.updatedResume._id,
          name: result.updatedResume.name,
          analysis: result.updatedResume.analysis,
          updatedAt: result.updatedResume.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('ATS optimization error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to optimize resume for ATS',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Enhanced resume analysis with AI recommendations
 */
exports.analyzeResume = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, analysisType = 'comprehensive', includeImprovements = true } = req.body;

    console.log(`ðŸ¤– AJ: Analyzing resume ${resumeId}`);

    // Validate input
    if (!resumeId) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID is required'
      });
    }

    // Get the resume
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({
        success: false,
        error: 'Resume not found'
      });
    }

    // Perform comprehensive analysis
    const resumeAnalysisService = require('../services/resumeAnalysis.service');
    const analysis = await resumeAnalysisService.analyzeResume(resumeId);

    // Get memory context for personalized recommendations
    const memoryContext = await MemoryService.buildAIContext(userId, { page: 'resumes', resumeId });

    // Generate AI-powered improvement suggestions
    let improvements = [];
    if (includeImprovements) {
      improvements = await generatePersonalizedImprovements(resume.parsedData, analysis, memoryContext);
    }

    // Update resume with new analysis
    resume.analysis = analysis;
    await resume.save();

    res.json({
      success: true,
      analysis: analysis,
      improvements: improvements,
      recommendations: {
        priority: prioritizeImprovements(improvements),
        quickWins: improvements.filter(imp => imp.effort === 'low'),
        highImpact: improvements.filter(imp => imp.impact === 'high')
      },
      memoryInsights: memoryContext ? ['Used your career goals and preferences for personalized analysis'] : []
    });

  } catch (error) {
    console.error('Enhanced resume analysis error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to analyze resume',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

// ===================================================================
// SYSTEM ENDPOINTS
// ===================================================================

exports.healthCheck = async (req, res) => {
  try {
    const testResponse = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: 'test' }],
      max_tokens: 5
    });

    const memoryStats = await UserMemory.countDocuments();
    const conversationStats = await Conversation.countDocuments();

    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      openai_status: 'connected',
      memory_system: 'operational',
      database_stats: {
        total_memories: memoryStats,
        total_conversations: conversationStats
      },
      test_tokens: testResponse.usage?.total_tokens || 0
    });

  } catch (error) {
    console.error('AI health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString(),
      openai_status: 'disconnected'
    });
  }
};

exports.getCapabilities = async (req, res) => {
  res.json({
    available: true,
    features: [
      'contextual_chat',
      'conversation_management',
      'persistent_memory',
      'user_profiling',
      'career_advice',
      'real_time_suggestions',
      'conversation_search',
      'memory_insights',
      'resume_editing',
      'ats_optimization'
    ],
    models: {
      primary: 'gpt-4-turbo-preview',
      fallback: 'gpt-3.5-turbo'
    },
    memory_features: {
      max_memories_per_user: 1000,
      memory_types: ['preference', 'skill', 'career_goal', 'experience', 'achievement', 'challenge'],
      auto_decay: true,
memory_search: true,
     conversation_context: true
   },
   resume_features: {
     real_time_editing: true,
     ats_optimization: true,
     ai_analysis: true,
     version_tracking: true
   },
   status: process.env.OPENAI_API_KEY ? 'fully_configured' : 'missing_api_key'
 });
};

exports.getUsageStats = async (req, res) => {
 try {
   const userId = req.user._id;
   const stats = {
     messagesThisMonth: 0,
     conversationsCreated: 0,
     memoriesStored: 0,
     tokensUsed: 0,
     resumeEdits: 0,
     atsOptimizations: 0
   };
   res.json({ success: true, stats, userId });
 } catch (error) {
   console.error('Usage stats error:', error);
   res.status(500).json({ success: false, error: 'Failed to get usage statistics' });
 }
};

exports.trackInteraction = async (req, res) => {
 try {
   const userId = req.user._id;
   const { type, data } = req.body;
   console.log(`ðŸ” User ${userId} - ${type}:`, data);
   res.json({ success: true, message: 'Interaction tracked successfully' });
 } catch (error) {
   console.error('Track interaction error:', error);
   res.status(500).json({ success: false, error: 'Failed to track interaction' });
 }
};

exports.resetContext = async (req, res) => {
 try {
   const userId = req.user._id;
   console.log(`Context reset for user: ${userId}`);
   res.json({ success: true, message: 'Context reset successfully' });
 } catch (error) {
   console.error('Reset context error:', error);
   res.status(500).json({ success: false, error: 'Failed to reset context' });
 }
};

// ===================================================================
// LEGACY PLACEHOLDER ENDPOINTS
// ===================================================================

exports.analyzeJobMatch = async (req, res) => {
 res.json({
   success: true,
   analysis: {
     matchScore: 78,
     strengths: ['Relevant experience'],
     gaps: ['Missing some technical skills']
   }
 });
};

exports.generateCoverLetter = async (req, res) => {
 res.json({
   success: true,
   coverLetter: {
     content: 'Sample cover letter content...',
     style: req.body.style || 'professional'
   }
 });
};

exports.getCareerAdvice = async (req, res) => {
 res.json({
   success: true,
   advice: {
     advice: 'Focus on developing your technical skills and building your network.',
     actionItems: ['Take online courses', 'Attend networking events']
   }
 });
};

exports.getContextualSuggestions = async (req, res) => {
 const suggestions = getContextualSuggestions(req.body.page || 'general');
 res.json({ success: true, suggestions });
};

exports.getPersonalizedTips = async (req, res) => {
 const tips = getPersonalizedTips(req.body.category || 'general');
 res.json({ success: true, tips });
};

// Legacy placeholders
exports.applyResumeChanges_legacy = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.optimizeForATS_legacy = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.generateSummary = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.getConversationInsights = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.exportConversation = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.bulkUpdateConversations = (req, res) => res.json({ success: true, message: 'Feature coming soon' });

// ===================================================================
// HELPER FUNCTIONS
// ===================================================================

function buildSystemPrompt(user, resumes, jobs, context, conversation, memoryContext) {
 const resumeCount = resumes.length;
 const jobCount = jobs.length;
 const currentPage = context?.page || 'unknown';

 let prompt = `You are AJ, an expert AI career assistant for auto-job.ai with advanced memory capabilities and resume editing powers.

CURRENT CONTEXT:
- User: ${user.firstName} ${user.lastName}
- Current Page: ${currentPage}
- Resumes: ${resumeCount}
- Jobs Tracked: ${jobCount}
- Conversation: "${conversation.title}" (${conversation.category})

${memoryContext}

RESUME EDITING CAPABILITIES:
- You can update any section of the user's resume in real-time
- You can optimize resumes for ATS systems
- You can enhance bullet points, summaries, and skills
- Always ask before making changes unless explicitly requested

PERSONALITY & APPROACH:
- Professional but warm and encouraging
- Personalize responses based on user's memory profile
- Provide specific, actionable advice
- Keep responses under 250 words unless complex analysis needed
- Always end with a relevant follow-up question or suggestion

Use this memory context to personalize your responses, but don't explicitly mention that you're using memory unless directly asked about it.`;

 // Add page-specific context
 if (currentPage === 'resumes' && context.currentResume) {
   prompt += `\n\nCURRENT RESUME: "${context.currentResume.name}" - You can edit this resume directly!`;
 }

 if (currentPage === 'jobs' && context.currentJob) {
   prompt += `\n\nCURRENT JOB: "${context.currentJob.title}" at ${context.currentJob.company}`;
 }

 return prompt;
}

function buildMessages(systemPrompt, recentMessages, currentMessage) {
 const messages = [{ role: 'system', content: systemPrompt }];

 if (recentMessages && recentMessages.length > 0) {
   recentMessages.forEach(msg => {
     messages.push({
       role: msg.type === 'user' ? 'user' : 'assistant',
       content: msg.content
     });
   });
 }

 messages.push({ role: 'user', content: currentMessage });
 return messages;
}

function parseResponse(aiMessage, context) {
 const suggestions = [];
 const actions = [];
 
 // Extract suggestions using pattern matching
 const suggestionRegex = /(?:^|\n)[-â€¢*]\s*(.+)/gm;
 let match;
 while ((match = suggestionRegex.exec(aiMessage)) !== null) {
   if (match[1] && match[1].length < 60) {
     suggestions.push(match[1].trim());
   }
 }

 // Generate contextual suggestions if none found
 if (suggestions.length === 0) {
   suggestions.push(...getContextualSuggestions(context?.page || 'general'));
 }

 return {
   message: aiMessage,
   suggestions: suggestions.slice(0, 4),
   actions: actions,
   confidence: 0.85
 };
}

// ================================================================
// ðŸ”§ HELPER FUNCTIONS FOR RESUME EDITING DETECTION
// ================================================================

/**
* Detect if the message is a resume editing request
*/
function detectResumeEditingIntent(message, context) {
 // Must be on resume page with current resume
 if (context?.page !== 'resumes' || !context?.currentResume?.id) {
   return false;
 }

 const messageLower = message.toLowerCase();
 
 // Resume editing keywords
 const editingKeywords = [
   'update', 'change', 'edit', 'modify', 'improve', 'enhance', 
   'add', 'remove', 'rewrite', 'fix', 'optimize', 'tailor',
   'highlight', 'emphasize', 'strengthen', 'quantify', 'make better'
 ];

 // Resume section keywords
 const sectionKeywords = [
   'experience', 'work', 'job', 'summary', 'skills', 'education',
   'achievements', 'bullets', 'bullet points', 'responsibilities',
   'thomson reuters', 'company', 'position', 'role'  // Specific to user's request
 ];

 // Check for editing intent
 const hasEditingKeyword = editingKeywords.some(keyword => 
   messageLower.includes(keyword)
 );

 const hasSectionKeyword = sectionKeywords.some(keyword => 
   messageLower.includes(keyword)
 );

 // Direct resume references
 const hasResumeReference = messageLower.includes('resume') || 
                          messageLower.includes('cv') ||
                          messageLower.includes('my experience') ||
                          messageLower.includes('my work');

 // Must have editing intent AND (section reference OR resume reference)
 const isEditingRequest = hasEditingKeyword && (hasSectionKeyword || hasResumeReference);
 
 console.log(`ðŸ” Resume edit detection:`, {
   message: message.substring(0, 30) + '...',
   hasEditingKeyword,
   hasSectionKeyword,
   hasResumeReference,
   isEditingRequest,
   contextPage: context?.page,
   hasResumeId: !!context?.currentResume?.id
 });

 return isEditingRequest;
}

/**
* Get or create conversation with enhanced logging
*/
async function getOrCreateConversation(conversationId, userId, newConversation, message, context) {
 try {
   if (conversationId && !newConversation) {
     console.log(`ðŸ“– Loading existing conversation: ${conversationId}`);
     return await ConversationService.getConversation(conversationId, userId);
   } else {
     const title = generateSimpleTitle(message, context);
     console.log(`ðŸ“ Creating new conversation: ${title}`);
     return await ConversationService.createConversation(userId, {
       title,
       category: detectCategory(message, context),
       tags: extractTags(message, context)
     });
   }
 } catch (error) {
   console.error('Error handling conversation:', error);
   throw error;
 }
}

function getContextualSuggestions(page) {
 const suggestions = {
   dashboard: ['Review my career progress', 'What should I focus on next?', 'Find new job opportunities'],
   resumes: ['How can I improve this resume?', 'Update my work experience', 'Optimize for ATS', 'Add missing skills'],
   jobs: ['How well do I match this position?', 'What skills am I missing?', 'Help me tailor my application'],
   general: ['Help with resume', 'Find job opportunities', 'Career guidance']
 };
 return suggestions[page] || suggestions.general;
}

function getPersonalizedTips(category) {
 const tips = {
   resume: ['Use action verbs', 'Quantify achievements'],
   job_search: ['Apply within 48 hours', 'Customize each application'],
   career: ['Set SMART goals', 'Build your network'],
   general: ['Stay updated', 'Practice interviewing']
 };
 return tips[category] || tips.general;
}

function generateSimpleTitle(message, context) {
 const content = message.toLowerCase();
 if (content.includes('resume')) return 'Resume Assistance';
 if (content.includes('job') || content.includes('application')) return 'Job Search Help';
 if (content.includes('interview')) return 'Interview Preparation';
 if (content.includes('career')) return 'Career Guidance';
 if (content.includes('skill')) return 'Skill Development';
 
 const contextTitles = {
   'resumes': 'Resume Help',
   'jobs': 'Job Search',
   'dashboard': 'Career Planning'
 };
 
 return contextTitles[context?.page] || 'Career Assistance';
}

function detectCategory(message, context) {
 const messageLower = message.toLowerCase();
 
 if (messageLower.includes('resume') || messageLower.includes('cv')) return 'resume_help';
 if (messageLower.includes('job') || messageLower.includes('application')) return 'job_search';
 if (messageLower.includes('interview')) return 'interview_prep';
 if (messageLower.includes('skill') || messageLower.includes('learn')) return 'skill_development';
 if (messageLower.includes('career') || messageLower.includes('future')) return 'career_advice';

 if (context?.page === 'resumes') return 'resume_help';
 if (context?.page === 'jobs') return 'job_search';
 
 return 'general';
}

function extractTags(message, context) {
 const tags = [];
 const messageLower = message.toLowerCase();
 
 const techKeywords = ['python', 'javascript', 'react', 'node', 'sql', 'aws', 'docker'];
 const roleKeywords = ['developer', 'manager', 'designer', 'analyst', 'engineer'];
 
 techKeywords.forEach(tech => {
   if (messageLower.includes(tech)) tags.push(tech);
 });
 
 roleKeywords.forEach(role => {
   if (messageLower.includes(role)) tags.push(role);
 });
 
 if (context?.page) tags.push(context.page);
 
 return tags.slice(0, 5);
}

function getFallbackResponse(message, context) {
 if (!message) return "I didn't receive your message. Could you please try again?";
 
 if (message.toLowerCase().includes('resume')) {
   return "I'd be happy to help with your resume! I can provide personalized suggestions and even edit it in real-time.";
 }
 
 if (message.toLowerCase().includes('job')) {
   return "I can help you with job searching and applications! What specific area would you like assistance with?";
 }
 
 return "I'm here to help with your career journey. What would you like to explore?";
}

/**
* Generate personalized resume improvements using AI and memory context
*/
async function generatePersonalizedImprovements(resumeData, analysis, memoryContext) {
 try {
   const prompt = `You are an expert career coach with access to the user's profile and career history. Generate personalized resume improvement suggestions.

RESUME DATA:
${JSON.stringify(resumeData, null, 2)}

CURRENT ANALYSIS:
${JSON.stringify(analysis, null, 2)}

USER MEMORY CONTEXT:
${memoryContext}

Generate personalized improvement suggestions in JSON format:
{
 "improvements": [
   {
     "type": "content|formatting|keywords|structure|ats",
     "section": "summary|experience|skills|education|etc",
     "title": "Brief improvement title",
     "description": "Detailed explanation of the improvement",
     "before": "current content (if applicable)",
     "after": "suggested improvement",
     "impact": "low|medium|high",
     "effort": "low|medium|high",
     "reason": "why this improvement helps based on user's profile",
     "keywords": ["relevant", "keywords"],
     "personalized": true
   }
 ]
}

Focus on:
1. Improvements aligned with user's career goals from memory
2. Skills gaps identified in their profile
3. Industry-specific optimizations
4. Personalized content based on their background
5. ATS optimizations for their target roles

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

   const response = await openai.chat.completions.create({
     model: 'gpt-4-turbo-preview',
     messages: [
       {
         role: 'system',
         content: 'You are an expert career coach. Generate personalized resume improvements based on user profile and memory context. Return only valid JSON.'
       },
       {
         role: 'user',
         content: prompt
       }
     ],
     temperature: 0.3,
     max_tokens: 2000
   });

   const responseContent = response.choices[0].message.content.trim();
   const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
   const improvements = JSON.parse(cleanedResponse);

   return improvements.improvements || [];

 } catch (error) {
   console.error('Error generating personalized improvements:', error);
   return [];
 }
}

/**
* Prioritize improvements based on impact and effort
*/
function prioritizeImprovements(improvements) {
 return improvements.sort((a, b) => {
   const impactScore = { high: 3, medium: 2, low: 1 };
   const effortScore = { low: 3, medium: 2, high: 1 };
   
   const aScore = impactScore[a.impact] + effortScore[a.effort];
   const bScore = impactScore[b.impact] + effortScore[b.effort];
   
   return bScore - aScore;
 });
}

/**
* Generate memory insights using AI
*/
async function generateMemoryInsights(userMemory) {
 try {
   const recentMemories = userMemory.memories
     .filter(m => m.isActive)
     .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
     .slice(0, 20);

   if (recentMemories.length === 0) {
     console.log('ðŸ“ No memories to analyze, returning empty insights');
     return [];
   }

   const memoryText = recentMemories
     .map(m => `${m.type}: ${m.content}`)
     .join('\n');

   console.log('ðŸ§  Generating insights from', recentMemories.length, 'memories');

   const systemPrompt = `Analyze these user memories and generate actionable insights about their career journey.

MEMORIES:
${memoryText}

Provide insights as JSON in this EXACT format:
{
 "insights": [
   {
     "type": "strength|opportunity|challenge|recommendation",
     "description": "Clear insight about the user",
     "confidence": 0.8,
     "actionable": true
   }
 ]
}

Maximum 5 insights. Focus on career development opportunities.`;

   const response = await openai.chat.completions.create({
     model: 'gpt-3.5-turbo',
     messages: [
       { role: 'system', content: systemPrompt },
       { role: 'user', content: 'Generate insights' }
     ],
     temperature: 0.3,
     max_tokens: 600,
     response_format: { type: 'json_object' }
   });

   console.log('ðŸ¤– Raw AI response:', response.choices[0].message.content);

   let parsedResponse;
   try {
     parsedResponse = JSON.parse(response.choices[0].message.content);
   } catch (parseError) {
     console.error('âŒ Failed to parse AI response JSON:', parseError);
     return [];
   }

   if (!parsedResponse || !parsedResponse.insights || !Array.isArray(parsedResponse.insights)) {
     console.warn('âš ï¸ AI response missing insights array:', parsedResponse);
     return [];
   }

   const validInsights = parsedResponse.insights
     .filter(insight => {
       return insight && 
              typeof insight.type === 'string' && 
              typeof insight.description === 'string' &&
              typeof insight.confidence === 'number' &&
              typeof insight.actionable === 'boolean';
     })
     .map(insight => ({
       type: insight.type,
       description: insight.description,
       confidence: Math.min(1, Math.max(0, insight.confidence)),
       actionable: insight.actionable,
       generatedAt: new Date()
     }));

   console.log('âœ… Generated', validInsights.length, 'valid insights');
   return validInsights;

 } catch (error) {
   console.error('âŒ Generate memory insights error:', error);
   return [];
 }
}

================
File: controllers/auth.controller.js
================
// backend/controllers/auth.controller.js
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const User = require('../models/mongodb/user.model');
const sendEmail = require('../utils/send-email');
const emailTemplates = require('../utils/email-templates');

/**
 * Generate JWT token for a user
 * @param {Object} user User object
 * @returns {String} JWT token
 */
const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, email: user.email, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRE || '30d' }
  );
};

/**
 * Register a new user
 * @route POST /api/auth/register
 * @access Public
 */
exports.register = async (req, res) => {
  try {
    const { email, password, firstName, lastName } = req.body;
    
    // Validate required fields
    if (!email || !password || !firstName || !lastName) {
      return res.status(400).json({
        success: false,
        error: 'All fields are required'
      });
    }
    
    // Check if user already exists
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: 'Email already in use'
      });
    }
    
    // Create the user
    const user = await User.create({
      email: email.toLowerCase(),
      password,
      firstName,
      lastName,
      isEmailVerified: true // TEMPORARILY SET TO TRUE FOR TESTING
    });
    
    // Generate email verification token (but don't require it for now)
    const verificationToken = user.generateEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Create verification URL
    const verificationUrl = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    // Try to send verification email, but don't fail registration if it fails
    try {
      await sendEmail({
        email: user.email,
        subject: 'Email Verification',
        html: emailTemplates.generateVerificationEmail(user.firstName, verificationUrl)
      });
      console.log('Verification email sent successfully');
    } catch (emailError) {
      console.error('Failed to send verification email:', emailError.message);
      // Don't fail registration due to email issues
    }
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    // Remove password from response
    user.password = undefined;
    
    res.status(201).json({
      success: true,
      token,
      data: {
        user,
        message: 'Registration successful'
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      error: 'Registration failed: ' + error.message
    });
  }
};

/**
 * Login user
 * @route POST /api/auth/login
 * @access Public
 */
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Validate email & password
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Please provide email and password'
      });
    }
    
    // Check for user
    const user = await User.findOne({ email: email.toLowerCase() }).select('+password +loginAttempts +lockUntil');
    
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Check if account is locked
    if (user.isLocked()) {
      return res.status(401).json({
        success: false,
        error: 'Account is temporarily locked. Please try again later.'
      });
    }
    
    // Check if password matches
    const isMatch = await user.comparePassword(password);
    
    if (!isMatch) {
      // Increment login attempts
      await user.incrementLoginAttempts();
      
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Reset login attempts on successful login
    await user.resetLoginAttempts();
    
    // Update last login
    user.lastLogin = Date.now();
    await user.save({ validateBeforeSave: false });
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    // Remove password and security fields from response
    user.password = undefined;
    user.loginAttempts = undefined;
    user.lockUntil = undefined;
    
    res.status(200).json({
      success: true,
      token,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      error: 'Login failed: ' + error.message
    });
  }
};

/**
 * Logout user
 * @route POST /api/auth/logout
 * @access Private
 */
exports.logout = (req, res) => {
  res.cookie('token', 'none', {
    expires: new Date(Date.now() + 10 * 1000),
    httpOnly: true
  });
  
  res.status(200).json({
    success: true,
    data: {
      message: 'Logged out successfully'
    }
  });
};

/**
 * Verify email
 * @route GET /api/auth/verify-email/:token
 * @access Public
 */
exports.verifyEmail = async (req, res) => {
  try {
    // Get hashed token
    const hashedToken = crypto
      .createHash('sha256')
      .update(req.params.token)
      .digest('hex');
    
    // Find user by verification token
    const user = await User.findOne({
      emailVerificationToken: hashedToken,
      emailVerificationExpires: { $gt: Date.now() }
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired token'
      });
    }
    
    // Set email as verified
    user.isEmailVerified = true;
    user.emailVerificationToken = undefined;
    user.emailVerificationExpires = undefined;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Email verified successfully'
      }
    });
  } catch (error) {
    console.error('Email verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Email verification failed'
    });
  }
};

/**
 * Resend verification email
 * @route POST /api/auth/resend-verification
 * @access Private
 */
exports.resendVerification = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    if (user.isEmailVerified) {
      return res.status(400).json({
        success: false,
        error: 'Email already verified'
      });
    }
    
    // Generate new verification token
    const verificationToken = user.generateEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Create verification URL
    const verificationUrl = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    try {
      await sendEmail({
        email: user.email,
        subject: 'Email Verification',
        html: emailTemplates.generateVerificationEmail(user.firstName, verificationUrl)
      });
      
      res.status(200).json({
        success: true,
        data: {
          message: 'Verification email sent. Please check your inbox.'
        }
      });
    } catch (error) {
      user.emailVerificationToken = undefined;
      user.emailVerificationExpires = undefined;
      await user.save({ validateBeforeSave: false });
      
      return res.status(500).json({
        success: false,
        error: 'Email could not be sent'
      });
    }
  } catch (error) {
    console.error('Resend verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to resend verification email'
    });
  }
};

/**
 * Forgot password
 * @route POST /api/auth/forgot-password
 * @access Public
 */
exports.forgotPassword = async (req, res) => {
  try {
    const user = await User.findOne({ email: req.body.email?.toLowerCase() });
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'There is no user with this email'
      });
    }
    
    // Generate reset token
    const resetToken = user.generatePasswordResetToken();
    await user.save({ validateBeforeSave: false });
    
    // Create reset URL
    const resetUrl = `${req.protocol}://${req.get('host')}/api/auth/reset-password/${resetToken}`;
    
    try {
      await sendEmail({
        email: user.email,
        subject: 'Password Reset',
        html: emailTemplates.generatePasswordResetEmail(user.firstName, resetUrl)
      });
      
      res.status(200).json({
        success: true,
        data: {
          message: 'Password reset email sent. Please check your inbox.'
        }
      });
    } catch (error) {
      user.passwordResetToken = undefined;
      user.passwordResetExpires = undefined;
      await user.save({ validateBeforeSave: false });
      
      return res.status(500).json({
        success: false,
        error: 'Email could not be sent'
      });
    }
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({
      success: false,
      error: 'Forgot password request failed'
    });
  }
};

/**
 * Reset password
 * @route PUT /api/auth/reset-password/:token
 * @access Public
 */
exports.resetPassword = async (req, res) => {
  try {
    // Get hashed token
    const hashedToken = crypto
      .createHash('sha256')
      .update(req.params.token)
      .digest('hex');
    
    // Find user by reset token
    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() }
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired token'
      });
    }
    
    // Set new password
    user.password = req.body.password;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Password reset successful'
      }
    });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({
      success: false,
      error: 'Password reset failed'
    });
  }
};

/**
 * Get current logged in user
 * @route GET /api/auth/me
 * @access Private
 */
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    res.status(200).json({
      success: true,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Get me error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get user data'
    });
  }
};

/**
 * Update user details
 * @route PUT /api/auth/update-details
 * @access Private
 */
exports.updateDetails = async (req, res) => {
  try {
    const fieldsToUpdate = {
      firstName: req.body.firstName,
      lastName: req.body.lastName,
      phoneNumber: req.body.phoneNumber,
      location: req.body.location,
      socialProfiles: req.body.socialProfiles
    };
    
    // Remove undefined fields
    Object.keys(fieldsToUpdate).forEach(key => 
      fieldsToUpdate[key] === undefined && delete fieldsToUpdate[key]
    );
    
    const user = await User.findByIdAndUpdate(
      req.user.id,
      fieldsToUpdate,
      {
        new: true,
        runValidators: true
      }
    );
    
    res.status(200).json({
      success: true,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Update details error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update user details'
    });
  }
};

/**
 * Update password
 * @route PUT /api/auth/update-password
 * @access Private
 */
exports.updatePassword = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('+password');
    
    // Check current password
    const isMatch = await user.comparePassword(req.body.currentPassword);
    
    if (!isMatch) {
      return res.status(401).json({
        success: false,
        error: 'Current password is incorrect'
      });
    }
    
    // Set new password
    user.password = req.body.newPassword;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Password updated successfully'
      }
    });
  } catch (error) {
    console.error('Update password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update password'
    });
  }
};

/**
 * Delete user account
 * @route DELETE /api/auth/delete-account
 * @access Private
 */
exports.deleteAccount = async (req, res) => {
  try {
    // Soft delete - set active to false
    await User.findByIdAndUpdate(req.user.id, {
      active: false
    });
    
    res.cookie('token', 'none', {
      expires: new Date(Date.now() + 10 * 1000),
      httpOnly: true
    });
    
    res.status(200).json({
      success: true,
      data: {
        message: 'Account deactivated successfully'
      }
    });
  } catch (error) {
    console.error('Delete account error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete account'
    });
  }
};

================
File: controllers/job.controller.js
================
// controllers/job.controller.js - UPDATED FOR REAL JOB BOARD INTEGRATION - FIXED
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const jobAnalysisService = require('../services/jobAnalysis.service');
const jobMatchingService = require('../services/jobMatching.service');
const resumeTailoringService = require('../services/resumeTailoring.service');
const jobSearchService = require('../services/jobSearch.service');
const mongoose = require('mongoose');

// Enhanced background processing for manual jobs (uses premium GPT-4o)
async function processJobInBackground(jobId, jobMetadata = {}) {
  try {
    console.log(`ðŸ” Starting premium analysis for manually uploaded job: ${jobId}`);
    
    // Get the job from the database
    const job = await Job.findById(jobId);
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Update status: Starting analysis (10%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 10, 'Starting premium job analysis...');
    
    // Add realistic delay to show progress
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Update status: Extracting requirements (40%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 40, 'Extracting job requirements with GPT-4o...');
    
    // Analyze the job using PREMIUM GPT-4o service for manual uploads
    console.log('ðŸ¤– Starting premium job analysis with GPT-4o...');
    const parsedData = await jobAnalysisService.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location,
      ...jobMetadata
    }, {
      isAiDiscovery: false,    // Use premium GPT-4o for manual jobs
      prioritizeCost: false    // Prioritize quality for manual uploads
    });
    
    // Update status: Processing results (80%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 80, 'Processing premium analysis results...');
    
    // Add small delay for UX
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Update the job with parsed data
    job.parsedData = parsedData;
    job.updatedAt = new Date();
    
    // Mark analysis as complete with final status
    await updateJobAnalysisStatus(jobId, 'completed', 100, 
      `Premium analysis complete! Found ${parsedData.keySkills?.length || 0} key skills with GPT-4o.`, {
        completedAt: new Date(),
        skillsFound: parsedData.keySkills?.length || 0,
        experienceLevel: parsedData.experienceLevel,
        canViewJob: true,
        modelUsed: parsedData.analysisMetadata?.model || 'gpt-4o',
        analysisType: 'manual_upload_premium'
      });
    
    await job.save();
    
    console.log(`âœ… Premium job analysis completed successfully for: ${job.title}`);
    console.log(`ðŸ“Š Results: ${parsedData.keySkills?.length || 0} skills, model: ${parsedData.analysisMetadata?.model}, cost: ${parsedData.analysisMetadata?.estimatedCost}`);
    
    return true;
  } catch (error) {
    console.error('âŒ Error in premium background processing:', error);
    
    // Update job to indicate analysis failed
    await updateJobAnalysisStatus(jobId, 'error', 0, `Premium analysis failed: ${error.message}`, {
      error: error.message,
      canViewJob: true,
      modelUsed: 'error'
    });
    
    throw error;
  }
}

async function updateJobAnalysisStatus(jobId, status, progress, message, additionalData = {}) {
  try {
    const job = await Job.findById(jobId);
    if (!job) {
      console.error(`Job not found for status update: ${jobId}`);
      return false;
    }
    
    job.analysisStatus = {
      status,
      progress,
      message,
      updatedAt: new Date(),
      ...additionalData
    };
    
    if (status === 'completed') {
      job.analysisStatus.completedAt = new Date();
    }
    
    await job.save();
    console.log(`ðŸ“Š Updated analysis status for ${jobId}: ${status} (${progress}%) - ${message}`);
    return true;
  } catch (err) {
    console.error('Error updating job analysis status:', err);
    return false;
  }
}

// Create a new job with premium analysis
exports.createJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { 
      title, 
      company, 
      location, 
      description, 
      sourceUrl, 
      salary,
      jobType 
    } = req.body;
    
    // Validate required fields
    if (!title || !company || !description) {
      return res.status(400).json({ 
        message: 'Job title, company, and description are required' 
      });
    }
    
    // Create the job with initial analysis status
    const job = new Job({
      userId,
      title,
      company,
      location: location || {},
      description,
      sourceUrl,
      salary: salary || {},
      jobType: jobType || 'FULL_TIME',
      sourcePlatform: 'MANUAL',
      analysisStatus: {
        status: 'pending',
        progress: 0,
        message: 'Premium analysis queued...',
        startedAt: new Date(),
        canViewJob: false,
        estimatedCompletion: new Date(Date.now() + 45000), // 45 seconds for premium analysis
        analysisType: 'manual_upload_premium'
      }
    });
    
    // Save job to database
    await job.save();
    
    console.log(`ðŸ” Manual job created: ${job.title} at ${job.company} - Starting premium analysis...`);
    
    // Process job in background with premium analysis
    processJobInBackground(job._id, { title, company, location }).catch(err => {
      console.error('Background job processing error:', err);
    });
    
    res.status(201).json({
      message: 'Job created successfully and premium analysis initiated',
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        createdAt: job.createdAt,
        analysisStatus: job.analysisStatus
      }
    });
  } catch (error) {
    console.error('Error creating job:', error);
    res.status(500).json({ message: 'Failed to create job', error: error.message });
  }
};

// Get all user jobs with enhanced analysis status and real job board info
exports.getUserJobs = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobs = await Job.find({ userId }).sort({ createdAt: -1 });
    
    // Enhance jobs with analysis status information and job board approach info
    const enhancedJobs = jobs.map(job => {
      const jobObj = job.toObject();
      
      // Determine analysis status
      let analysisStatus = 'completed';
      let progress = 100;
      let message = 'Analysis complete';
      let canViewJob = true;
      let modelUsed = 'unknown';
      let analysisType = 'unknown';
      let isRealJobBoardDiscovery = false;
      let sourceJobBoard = null;
      
      if (job.analysisStatus) {
        analysisStatus = job.analysisStatus.status;
        progress = job.analysisStatus.progress;
        message = job.analysisStatus.message;
        canViewJob = job.analysisStatus.status === 'completed' || job.analysisStatus.status === 'error';
        modelUsed = job.analysisStatus.modelUsed || 'unknown';
        analysisType = job.analysisStatus.analysisType || 'unknown';
      } else if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
        analysisStatus = 'pending';
        progress = 0;
        message = 'Analysis pending...';
        canViewJob = false;
      } else if (job.parsedData.analysisMetadata) {
        modelUsed = job.parsedData.analysisMetadata.model || 'completed';
        analysisType = job.parsedData.analysisMetadata.analysisType || 'completed';
      }
      
      // Check if this is from real job board discovery
      isRealJobBoardDiscovery = job.sourcePlatform && (
        job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
        job.sourcePlatform.includes('AI_FOUND_LEVER') ||
        job.sourcePlatform.includes('AI_FOUND_INDEED')
      );
      
      // Extract source job board
      if (isRealJobBoardDiscovery) {
        if (job.sourcePlatform.includes('GREENHOUSE')) sourceJobBoard = 'Greenhouse';
        else if (job.sourcePlatform.includes('LEVER')) sourceJobBoard = 'Lever';
        else if (job.sourcePlatform.includes('INDEED')) sourceJobBoard = 'Indeed';
      }
      
      return {
        ...jobObj,
        analysisStatus: {
          status: analysisStatus,
          progress: progress,
          message: message,
          canViewJob: canViewJob,
          skillsFound: job.parsedData?.keySkills?.length || 0,
          experienceLevel: job.parsedData?.experienceLevel,
          modelUsed: modelUsed,
          analysisType: analysisType,
          isAiDiscovery: job.sourcePlatform === 'AI_FOUND' || 
                        job.sourcePlatform === 'AI_FOUND_OPTIMIZED' ||
                        job.sourcePlatform === 'AI_FOUND_INTELLIGENT' ||
                        isRealJobBoardDiscovery,
          isRealJobBoardDiscovery: isRealJobBoardDiscovery,
          sourceJobBoard: sourceJobBoard,
          searchApproach: isRealJobBoardDiscovery ? '3-phase-real-job-boards' : 
                         (job.sourcePlatform?.includes('AI_FOUND') ? 'legacy-ai' : 'manual'),
          qualityLevel: analysisType?.includes('premium') ? 'premium' : 'standard',
          updatedAt: job.analysisStatus?.updatedAt || job.updatedAt,
          realJobBoardData: job.parsedData?.realJobBoardData || null
        }
      };
    });
    
    res.status(200).json({ jobs: enhancedJobs });
  } catch (error) {
    console.error('Error fetching jobs:', error);
    res.status(500).json({ message: 'Failed to fetch jobs', error: error.message });
  }
};

// Get job by ID with real job board context
exports.getJobById = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    res.status(200).json({ job });
  } catch (error) {
    console.error('Error fetching job:', error);
    res.status(500).json({ message: 'Failed to fetch job', error: error.message });
  }
};

// Get job analysis status with real job board information
exports.getJobAnalysisStatus = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId }, 'analysisStatus parsedData title company createdAt sourcePlatform');
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    let status = 'completed';
    let progress = 100;
    let message = 'Analysis complete';
    let canViewJob = true;
    let skillsFound = 0;
    let experienceLevel = null;
    let modelUsed = 'unknown';
    let analysisType = 'unknown';
    let isRealJobBoardDiscovery = false;
    let sourceJobBoard = null;
    
    if (job.analysisStatus && job.analysisStatus.status) {
      status = job.analysisStatus.status;
      progress = job.analysisStatus.progress || 0;
      message = job.analysisStatus.message || 'Processing...';
      canViewJob = job.analysisStatus.canViewJob !== false;
      skillsFound = job.analysisStatus.skillsFound || 0;
      experienceLevel = job.analysisStatus.experienceLevel;
      modelUsed = job.analysisStatus.modelUsed || 'unknown';
      analysisType = job.analysisStatus.analysisType || 'unknown';
    } 
    else if (job.parsedData && Object.keys(job.parsedData).length > 0 && !job.parsedData.analysisError) {
      status = 'completed';
      progress = 100;
      message = `Premium analysis complete! Found ${job.parsedData.keySkills?.length || 0} key skills.`;
      canViewJob = true;
      skillsFound = job.parsedData.keySkills?.length || 0;
      experienceLevel = job.parsedData.experienceLevel;
      modelUsed = job.parsedData.analysisMetadata?.model || 'gpt-4o';
      analysisType = job.parsedData.analysisMetadata?.analysisType || 'premium';
    }
    else if (job.parsedData && job.parsedData.analysisError) {
      status = 'error';
      progress = 0;
      message = 'Analysis failed';
      canViewJob = true;
    }
    else {
      status = 'pending';
      progress = 0;
      message = 'Analysis pending...';
      canViewJob = false;
    }
    
    // Check if this is from real job board discovery
    isRealJobBoardDiscovery = job.sourcePlatform && (
      job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
      job.sourcePlatform.includes('AI_FOUND_LEVER') ||
      job.sourcePlatform.includes('AI_FOUND_INDEED')
    );
    
    // Extract source job board
    if (isRealJobBoardDiscovery) {
      if (job.sourcePlatform.includes('GREENHOUSE')) sourceJobBoard = 'Greenhouse';
      else if (job.sourcePlatform.includes('LEVER')) sourceJobBoard = 'Lever';
      else if (job.sourcePlatform.includes('INDEED')) sourceJobBoard = 'Indeed';
    }
    
    console.log(`ðŸ“Š Analysis Status for job ${jobId}: ${status} (${progress}%) - ${message}`);
    
    res.status(200).json({ 
      analysisStatus: {
        status,
        progress,
        message,
        updatedAt: job.analysisStatus?.updatedAt || new Date(),
        skillsFound,
        experienceLevel,
        isAnalysisComplete: status === 'completed',
        canViewJob: canViewJob,
        modelUsed: modelUsed,
        analysisType: analysisType,
        isRealJobBoardDiscovery: isRealJobBoardDiscovery,
        sourceJobBoard: sourceJobBoard,
        searchApproach: isRealJobBoardDiscovery ? '3-phase-real-job-boards' : 
                       (job.sourcePlatform?.includes('AI_FOUND') ? 'legacy-ai' : 'manual'),
        qualityLevel: analysisType?.includes('premium') ? 'premium' : 'standard',
        error: job.analysisStatus?.error || job.parsedData?.analysisError
      },
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        createdAt: job.createdAt,
        sourcePlatform: job.sourcePlatform
      },
      realJobBoardInfo: isRealJobBoardDiscovery ? {
        description: 'This job was discovered using our ENHANCED 3-Phase approach with REAL job board integration',
        sourceJobBoard: sourceJobBoard,
        benefits: [
          `Discovered from actual ${sourceJobBoard} company posting`,
          'Real job content from company ATS platform',
          'Premium GPT-4o analysis (same quality as manual jobs)',
          'Enhanced job matching and relevance',
          'Direct company posting verification'
        ],
        jobBoardFeatures: {
          greenhouse: 'Tech startups and scale-ups with comprehensive job details',
          lever: 'Growth-stage companies with detailed role information',
          indeed: 'Established companies with verified direct postings'
        }[sourceJobBoard?.toLowerCase()] || 'High-quality company job posting'
      } : null
    });
  } catch (error) {
    console.error('Error fetching job analysis status:', error);
    res.status(500).json({ message: 'Failed to fetch analysis status', error: error.message });
  }
};

// Update job
exports.updateJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const { 
      title, 
      company, 
      location, 
      description, 
      sourceUrl, 
      salary,
      jobType,
      applicationStatus,
      notes
    } = req.body;
    
    let needsReanalysis = false;
    
    // Update fields if provided
    if (title && title !== job.title) {
      job.title = title;
      needsReanalysis = true;
    }
    if (company && company !== job.company) {
      job.company = company;
      needsReanalysis = true;
    }
    if (location) job.location = location;
    if (description && description !== job.description) {
      job.description = description;
      job.parsedData = {}; // Clear parsedData to trigger re-analysis
      needsReanalysis = true;
    }
    if (sourceUrl) job.sourceUrl = sourceUrl;
    if (salary) job.salary = salary;
    if (jobType) job.jobType = jobType;
    if (applicationStatus) job.applicationStatus = applicationStatus;
    
    // Add a new note if provided
    if (notes && notes.content) {
      job.notes.push({
        content: notes.content,
        createdAt: new Date()
      });
    }
    
    await job.save();
    
    // If significant changes were made, trigger re-analysis with PREMIUM model
    if (needsReanalysis) {
      processJobInBackground(job._id, {
        title: job.title,
        company: job.company,
        location: job.location
      }).catch(err => {
        console.error('Background job processing error after update:', err);
      });
    }
    
    res.status(200).json({
      message: 'Job updated successfully',
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        updatedAt: job.updatedAt
      },
      reanalysisTriggered: needsReanalysis,
      reanalysisNote: needsReanalysis ? 'Premium re-analysis initiated with GPT-4o' : null
    });
  } catch (error) {
    console.error('Error updating job:', error);
    res.status(500).json({ message: 'Failed to update job', error: error.message });
  }
};

// Delete job
exports.deleteJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    await Job.deleteOne({ _id: jobId });
    
    res.status(200).json({ message: 'Job deleted successfully' });
  } catch (error) {
    console.error('Error deleting job:', error);
    res.status(500).json({ message: 'Failed to delete job', error: error.message });
  }
};

// Match resume with job
exports.matchResumeWithJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { jobId, resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(jobId) || !mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid job ID or resume ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Check if the job has been analyzed
    if (!job.parsedData || Object.keys(job.parsedData).length === 0 || job.parsedData.analysisError) {
      console.log('Job analysis missing or failed, attempting re-analysis...');
      try {
        await processJobInBackground(jobId, {
          title: job.title,
          company: job.company,
          location: job.location
        });
        const updatedJob = await Job.findById(jobId);
        if (!updatedJob.parsedData || Object.keys(updatedJob.parsedData).length === 0) {
          throw new Error('Job re-analysis failed');
        }
        Object.assign(job, updatedJob);
      } catch (analysisError) {
        console.error('Job re-analysis failed:', analysisError);
        return res.status(400).json({ 
          message: 'Job analysis not complete and re-analysis failed. Please try again later.',
          error: analysisError.message
        });
      }
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    console.log(`Starting enhanced matching for job "${job.title}" with resume "${resume.name}"`);
    
    const matchResults = await jobMatchingService.matchResumeWithJob(resumeId, jobId);
    
    job.matchAnalysis = {
      resumeId,
      lastAnalyzed: new Date(),
      ...matchResults
    };
    await job.save();
    
    console.log(`Enhanced matching completed - Overall Score: ${matchResults.overallScore}%`);
    
    res.status(200).json({
      message: 'Enhanced resume-job matching completed successfully',
      matchAnalysis: job.matchAnalysis,
      matchingVersion: matchResults.analysisMetadata?.algorithmVersion || '2.0'
    });
  } catch (error) {
    console.error('Error in enhanced matching:', error);
    res.status(500).json({ 
      message: 'Failed to match resume with job', 
      error: error.message,
      suggestion: 'Please ensure both the job and resume have been properly analyzed'
    });
  }
};

// Get tailoring recommendations
exports.tailorResumeToJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { jobId, resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(jobId) || !mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid job ID or resume ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    if (!job.parsedData || Object.keys(job.parsedData).length === 0 || job.parsedData.analysisError) {
      return res.status(400).json({ message: 'Job analysis not complete. Please try again later.' });
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    if (!job.matchAnalysis || !job.matchAnalysis.overallScore) {
      console.log('No match analysis found, performing matching first...');
      const matchResults = await jobMatchingService.matchResumeWithJob(resumeId, jobId);
      job.matchAnalysis = {
        resumeId,
        lastAnalyzed: new Date(),
        ...matchResults
      };
      await job.save();
    }
    
    const tailoringResult = await resumeTailoringService.getTailoringRecommendations(resumeId, jobId);
    
    res.status(200).json({
      message: 'Resume tailoring recommendations generated successfully',
      tailoringResult,
      matchScore: job.matchAnalysis.overallScore
    });
  } catch (error) {
    console.error('Error generating resume tailoring recommendations:', error);
    res.status(500).json({ 
      message: 'Failed to generate resume tailoring recommendations', 
      error: error.message 
    });
  }
};

// Find jobs with ENHANCED AI (Real Job Board Integration)
exports.findJobsWithAi = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    // Start ENHANCED AI job search with REAL Job Board Integration
    res.status(202).json({
      message: 'ENHANCED 3-Phase AI job search with REAL job board integration initiated! Jobs will be discovered from actual company postings.',
      status: 'processing',
      realJobBoardIntegrationInfo: {
        phase1: 'Career Analysis (GPT-4 Turbo) - $0.05',
        phase2: 'REAL Job Board Discovery (Claude 3.5 Sonnet + Web Search) - $0.30-0.50',
        phase3: 'Premium Analysis (GPT-4o batch) - $0.01-0.02',
        totalCost: '$0.36-0.57 per search',
        targetJobBoards: ['Greenhouse', 'Lever', 'Indeed'],
        enhancements: [
          'Search actual company job boards (Greenhouse, Lever, Indeed)',
          'Extract real job postings from company ATS platforms',
          'Premium GPT-4o analysis for all discovered jobs',
          'Same quality as manually uploaded jobs',
          'Direct company posting verification',
          'Enhanced job matching with real job content'
        ],
        expectedResults: [
          'Higher quality job content from real company postings',
          'More accurate job requirements from ATS platforms',
          'Better skill matching with actual job descriptions',
          'Verified company postings (no recruiter spam)',
          'Faster processing with premium analysis pipeline',
          'Comprehensive job details including tech stack and team info'
        ]
      }
    });
    
    // Perform ENHANCED AI job search with REAL Job Board Integration in the background
    jobSearchService.findJobsWithAi(userId, resumeId)
      .then(result => {
        console.log('ENHANCED AI job search with real job board integration completed:', result);
      })
      .catch(error => {
        console.error('ENHANCED AI job search with real job board integration error:', error);
      });
  } catch (error) {
    console.error('Error initiating ENHANCED AI job search with real job board integration:', error);
    res.status(500).json({ 
      message: 'Failed to initiate ENHANCED AI job search with real job board integration', 
      error: error.message 
    });
  }
};

// Re-analyze a job with premium model
exports.reAnalyzeJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    console.log(`Manual re-analysis triggered for job: ${job.title} at ${job.company}`);
    
    // Perform re-analysis with PREMIUM model for manual triggers
    const analysisResult = await jobAnalysisService.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location
    }, {
      isAiDiscovery: false,    // Use premium GPT-4o for manual re-analysis
      prioritizeCost: false    // Prioritize quality
    });
    
    // Update the job
    job.parsedData = analysisResult;
    job.updatedAt = new Date();
    
    // Clear any existing match analysis since the job has changed
    if (job.matchAnalysis) {
      job.matchAnalysis = null;
    }
    
    await job.save();
    
    res.status(200).json({
      message: 'Job re-analysis completed successfully with premium model',
      analysisResult: {
        skillsFound: analysisResult.keySkills?.length || 0,
        experienceLevel: analysisResult.experienceLevel,
        algorithmVersion: analysisResult.analysisMetadata?.algorithmVersion,
        modelUsed: analysisResult.analysisMetadata?.model,
        estimatedCost: analysisResult.analysisMetadata?.estimatedCost,
        analysisType: analysisResult.analysisMetadata?.analysisType,
        analyzedAt: analysisResult.analysisMetadata?.analyzedAt
      }
    });
  } catch (error) {
    console.error('Error re-analyzing job:', error);
    res.status(500).json({ 
      message: 'Failed to re-analyze job', 
      error: error.message 
    });
  }
};

// Re-match job with best available resume
exports.rematchJobWithBestResume = async (req, res) => {
  try {
    const { jobId } = req.params;
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    console.log(`Re-matching job ${jobId} with best resume for user ${userId}`);
    
    const result = await jobMatchingService.matchJobWithBestResume(jobId, userId);
    
    console.log('Re-matching completed:', {
      jobId,
      usedResumeId: result.usedResume.id,
      usedResumeName: result.usedResume.name,
      isTailored: result.usedResume.isTailored,
      newMatchScore: result.matchAnalysis.overallScore
    });
    
    res.status(200).json({
      message: 'Job re-matched with best available resume',
      matchAnalysis: result.matchAnalysis,
      usedResume: result.usedResume
    });
    
  } catch (error) {
    console.error('Error re-matching job:', error);
    res.status(500).json({ 
      message: 'Failed to re-match job with best resume', 
      error: error.message 
    });
  }
};

// Get resume match status for a specific job
exports.getResumeMatchStatus = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const resumes = await Resume.find({ userId });
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const tailoredResumes = await Resume.find({ 
      userId, 
      isTailored: true, 
      'tailoredForJob.jobId': jobId 
    });
    
    const resumeStatusMap = {};
    
    resumes.forEach(resume => {
      const resumeId = resume._id.toString();
      resumeStatusMap[resumeId] = {
        id: resume._id,
        name: resume.name,
        isMatched: job.matchAnalysis && job.matchAnalysis.resumeId && 
                   job.matchAnalysis.resumeId.toString() === resumeId,
        isTailored: false,
        tailoredVersions: []
      };
    });
    
    tailoredResumes.forEach(tailoredResume => {
      const originalResumeId = tailoredResume.tailoredForJob?.originalResumeId?.toString();
      
      if (originalResumeId && resumeStatusMap[originalResumeId]) {
        resumeStatusMap[originalResumeId].isTailored = true;
        resumeStatusMap[originalResumeId].tailoredVersions.push({
          id: tailoredResume._id,
          name: tailoredResume.name,
          createdAt: tailoredResume.createdAt
        });
      } else {
        console.log('Found tailored resume without clear original reference:', tailoredResume.name);
      }
    });
    
    res.status(200).json({ 
      resumeStatusMap,
      jobMatchedResumeId: job.matchAnalysis?.resumeId?.toString() || null
    });
  } catch (error) {
    console.error('Error fetching resume match status:', error);
    res.status(500).json({ message: 'Failed to fetch resume match status', error: error.message });
  }
};

// Get job analysis insights with real job board statistics
exports.getJobAnalysisInsights = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    // Get all user's jobs with analysis data
    const jobs = await Job.find({ 
      userId,
      parsedData: { $exists: true, $ne: {} }
    });
    
    // Calculate insights with model usage breakdown and real job board stats
    const insights = {
      totalJobsAnalyzed: jobs.length,
      experienceLevels: {},
      topSkillsRequired: {},
      industryDistribution: {},
      averageSkillsPerJob: 0,
      recentAnalyses: [],
      modelUsageStats: {
        'gpt-4o': 0,           // Premium for both manual and AI discovery
        'gpt-4o-mini': 0,      // Legacy (now deprecated)
        'fallback': 0,         // Fallback analyses
        'unknown': 0
      },
      costBreakdown: {
        manualJobs: { count: 0, estimatedCost: 0 },
        aiDiscoveryJobs: { count: 0, estimatedCost: 0 },
        totalEstimatedCost: 0
      },
      // ENHANCED: Real job board statistics
      realJobBoardStats: {
        totalRealJobBoardJobs: 0,
        jobBoardBreakdown: {
          greenhouse: 0,
          lever: 0,
          indeed: 0
        },
        averageContentQuality: 'unknown',
        realVsLegacyAI: {
          realJobBoards: 0,
          legacyAI: 0,
          manual: 0
        }
      }
    };
    
    let totalSkills = 0;
    
    jobs.forEach(job => {
      if (job.parsedData && !job.parsedData.analysisError) {
        // Experience levels
        const expLevel = job.parsedData.experienceLevel || 'unknown';
        insights.experienceLevels[expLevel] = (insights.experienceLevels[expLevel] || 0) + 1;
        
        // Industry distribution
        const industry = job.parsedData.industryContext || 'unknown';
        insights.industryDistribution[industry] = (insights.industryDistribution[industry] || 0) + 1;
        
        // Skills aggregation
        if (job.parsedData.keySkills && Array.isArray(job.parsedData.keySkills)) {
          totalSkills += job.parsedData.keySkills.length;
          job.parsedData.keySkills.forEach(skill => {
            const skillName = skill.name || skill;
            insights.topSkillsRequired[skillName] = (insights.topSkillsRequired[skillName] || 0) + 1;
          });
        }
        
        // Model usage tracking
        const model = job.parsedData.analysisMetadata?.model || 'unknown';
        const modelKey = model.includes('mini') ? 'gpt-4o-mini' : 
                        model.includes('gpt-4o') ? 'gpt-4o' : 
                        model.includes('fallback') ? 'fallback' : 'unknown';
        insights.modelUsageStats[modelKey]++;
        
        // Enhanced job classification with real job board detection
        const isRealJobBoard = job.sourcePlatform && (
          job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
          job.sourcePlatform.includes('AI_FOUND_LEVER') ||
          job.sourcePlatform.includes('AI_FOUND_INDEED')
        );
        
        const isAiDiscovery = job.sourcePlatform === 'AI_FOUND' || 
                             job.sourcePlatform === 'AI_FOUND_OPTIMIZED' ||
                             job.sourcePlatform === 'AI_FOUND_INTELLIGENT' ||
                             isRealJobBoard;
        
        if (isRealJobBoard) {
          insights.realJobBoardStats.totalRealJobBoardJobs++;
          insights.realJobBoardStats.realVsLegacyAI.realJobBoards++;
          
          // Track specific job board
          if (job.sourcePlatform.includes('GREENHOUSE')) {
            insights.realJobBoardStats.jobBoardBreakdown.greenhouse++;
          } else if (job.sourcePlatform.includes('LEVER')) {
            insights.realJobBoardStats.jobBoardBreakdown.lever++;
          } else if (job.sourcePlatform.includes('INDEED')) {
            insights.realJobBoardStats.jobBoardBreakdown.indeed++;
          }
        } else if (isAiDiscovery) {
          insights.realJobBoardStats.realVsLegacyAI.legacyAI++;
        } else {
          insights.realJobBoardStats.realVsLegacyAI.manual++;
        }
        
        // Cost tracking
        if (isAiDiscovery) {
          insights.costBreakdown.aiDiscoveryJobs.count++;
          insights.costBreakdown.aiDiscoveryJobs.estimatedCost += 0.02; // Premium analysis cost
        } else {
          insights.costBreakdown.manualJobs.count++;
          insights.costBreakdown.manualJobs.estimatedCost += 0.02; // Premium analysis cost
        }
        
        // Recent analyses with job board info
        if (job.parsedData.analysisMetadata?.analyzedAt) {
          insights.recentAnalyses.push({
            jobId: job._id,
            title: job.title,
            company: job.company,
            analyzedAt: job.parsedData.analysisMetadata.analyzedAt,
            skillsFound: job.parsedData.keySkills?.length || 0,
            model: job.parsedData.analysisMetadata.model,
            analysisType: job.parsedData.analysisMetadata.analysisType,
            sourcePlatform: job.sourcePlatform,
            isRealJobBoardDiscovery: isRealJobBoard,
            sourceJobBoard: isRealJobBoard ? (
              job.sourcePlatform.includes('GREENHOUSE') ? 'Greenhouse' :
              job.sourcePlatform.includes('LEVER') ? 'Lever' :
              job.sourcePlatform.includes('INDEED') ? 'Indeed' : 'Unknown'
            ) : null
          });
        }
      }
    });
    
    // Calculate totals and averages
    insights.averageSkillsPerJob = jobs.length > 0 ? Math.round(totalSkills / jobs.length) : 0;
    insights.costBreakdown.totalEstimatedCost = 
      insights.costBreakdown.manualJobs.estimatedCost + 
      insights.costBreakdown.aiDiscoveryJobs.estimatedCost;
    
    // Calculate real job board average content quality
    if (insights.realJobBoardStats.totalRealJobBoardJobs > 0) {
      insights.realJobBoardStats.averageContentQuality = 'high'; // Real job boards typically have high quality
    }
    
    // Sort top skills by frequency
    insights.topSkillsRequired = Object.entries(insights.topSkillsRequired)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .reduce((obj, [skill, count]) => {
        obj[skill] = count;
        return obj;
      }, {});
    
    // Sort recent analyses by date
    insights.recentAnalyses = insights.recentAnalyses
      .sort((a, b) => new Date(b.analyzedAt) - new Date(a.analyzedAt))
      .slice(0, 5);
    
    res.status(200).json({ 
      insights,
      enhancedRealJobBoardInfo: {
        description: 'ENHANCED 3-Phase Approach with REAL Job Board Integration: Career Analysis â†’ Real Job Board Discovery â†’ Premium Analysis',
        improvements: [
          'Phase 1: Enhanced career targeting with GPT-4 Turbo',
          'Phase 2: REAL job board discovery from Greenhouse, Lever, and Indeed',
          'Phase 3: Premium job analysis with GPT-4o (same quality for all jobs)',
          'Direct company posting verification',
          'Enhanced job content quality from ATS platforms'
        ],
        realJobBoardBenefits: [
          'Search actual company job boards (no recruiter spam)',
          'Extract comprehensive job details from ATS platforms',
          'Verify direct company postings with enhanced metadata',
          'Access to tech stack, team info, and hiring manager details',
          'Higher quality job content and requirements'
        ],
        costStructure: {
          phase1: 'Career Analysis: $0.05 (GPT-4 Turbo)',
          phase2: 'Real Job Board Discovery: $0.30-0.50 (Claude 3.5 Sonnet)',
          phase3: 'Premium Analysis: $0.01-0.02 (GPT-4o batch)',
          totalPerSearch: '$0.36-0.57',
          comparison: 'Same cost as previous but now searches REAL job boards'
        },
        targetJobBoards: {
          greenhouse: 'Tech startups and scale-ups with comprehensive postings',
          lever: 'Growth-stage companies with detailed role information',
          indeed: 'Established companies with verified direct postings'
        }
      }
    });
  } catch (error) {
    console.error('Error getting job analysis insights:', error);
    res.status(500).json({ 
      message: 'Failed to get job analysis insights', 
      error: error.message 
    });
  }
};

// AI Search Management Routes

// Get user AI searches
exports.getUserAiSearches = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const searches = await jobSearchService.getUserAiSearches(userId);
    
    res.status(200).json({ searches });
  } catch (error) {
    console.error('Error fetching AI searches:', error);
    res.status(500).json({ 
      message: 'Failed to fetch AI job searches', 
      error: error.message 
    });
  }
};

// Pause AI search
exports.pauseAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.pauseAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error pausing AI search:', error);
    res.status(500).json({ 
      message: 'Failed to pause AI search', 
      error: error.message 
    });
  }
};

// Resume AI search
exports.resumeAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.resumeAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error resuming AI search:', error);
    res.status(500).json({ 
      message: 'Failed to resume AI search', 
      error: error.message 
    });
  }
};

// Delete AI search
exports.deleteAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.deleteAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error deleting AI search:', error);
    res.status(500).json({ 
      message: 'Failed to delete AI search', 
      error: error.message 
    });
  }
};

================
File: controllers/recruiter.controller.js
================
// backend/controllers/recruiter.controller.js - COMPLETE UPDATED VERSION
const { Pool } = require('pg');
const Outreach = require('../models/mongodb/outreach.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const { openai } = require('../config/openai');

// PostgreSQL connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

/**
 * Search recruiters with simplified filtering (no experience or sort filters)
 */
exports.searchRecruiters = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      query = '',
      company = '',
      industry = '',
      location = '',
      title = '',
      limit = 20,
      offset = 0
    } = req.query;

    console.log(`ðŸ” Searching recruiters for user ${userId}:`, {
      query, company, industry, location, title, limit: parseInt(limit)
    });

    // Build the SQL query dynamically
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone as phone,
        r.title,
        r.linkedin_profile_url as linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        i.name as industry_name,
        l.city,
        l.state,
        l.country,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    // Add search filters with COALESCE to handle NULL values
    if (query) {
      sqlQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${paramIndex} OR
        COALESCE(r.title, '') ILIKE $${paramIndex} OR
        COALESCE(c.name, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${query.toLowerCase()}%`);
      paramIndex++;
    }

    if (company) {
      sqlQuery += ` AND COALESCE(c.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${company.toLowerCase()}%`);
      paramIndex++;
    }

    if (industry) {
      sqlQuery += ` AND COALESCE(i.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${industry.toLowerCase()}%`);
      paramIndex++;
    }

    if (location) {
      sqlQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${paramIndex} OR
        COALESCE(l.state, '') ILIKE $${paramIndex} OR
        COALESCE(l.country, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${location.toLowerCase()}%`);
      paramIndex++;
    }

    if (title) {
      sqlQuery += ` AND COALESCE(r.title, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${title.toLowerCase()}%`);
      paramIndex++;
    }

    // Simple ordering by ID (most recent recruiters first)
    sqlQuery += ` ORDER BY r.id DESC`;
    
    // Add pagination
    sqlQuery += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    queryParams.push(parseInt(limit), parseInt(offset));

    console.log('ðŸ—„ï¸ Executing SQL query with params:', queryParams);

    // Execute the query
    const result = await pool.query(sqlQuery, queryParams);

    // Get total count for pagination
    let countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;
    
    const countParams = [userId.toString()];
    let countParamIndex = 2;

    // Apply same filters to count query
    if (query) {
      countQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${countParamIndex} OR
        COALESCE(r.title, '') ILIKE $${countParamIndex} OR
        COALESCE(c.name, '') ILIKE $${countParamIndex}
      )`;
      countParams.push(`%${query.toLowerCase()}%`);
      countParamIndex++;
    }

    if (company) {
      countQuery += ` AND COALESCE(c.name, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${company.toLowerCase()}%`);
      countParamIndex++;
    }

    if (industry) {
      countQuery += ` AND COALESCE(i.name, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${industry.toLowerCase()}%`);
      countParamIndex++;
    }

    if (location) {
      countQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${countParamIndex} OR
        COALESCE(l.state, '') ILIKE $${countParamIndex} OR
        COALESCE(l.country, '') ILIKE $${countParamIndex}
      )`;
      countParams.push(`%${location.toLowerCase()}%`);
      countParamIndex++;
    }

    if (title) {
      countQuery += ` AND COALESCE(r.title, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${title.toLowerCase()}%`);
      countParamIndex++;
    }

    const countResult = await pool.query(countQuery, countParams);

    const recruiters = result.rows.map(row => ({
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      fullName: `${row.first_name || ''} ${row.last_name || ''}`.trim(),
      email: row.email,
      phone: row.phone,
      title: row.title,
      linkedinUrl: row.linkedin_url,
      experienceYears: row.experience_years,
      lastActiveDate: row.last_active_date,
      rating: row.rating,
      company: {
        name: row.company_name,
        website: row.company_website,
        size: row.company_size,
        logo: row.company_logo
      },
      industry: row.industry_name,
      location: {
        city: row.city,
        state: row.state,
        country: row.country
      },
      outreach: {
        hasContacted: !!row.last_contact_date,
        lastContactDate: row.last_contact_date,
        status: row.outreach_status
      }
    }));

    console.log(`âœ… Found ${recruiters.length} recruiters (Total: ${countResult.rows[0].count})`);

    res.json({
      success: true,
      recruiters,
      pagination: {
        total: parseInt(countResult.rows[0].count),
        limit: parseInt(limit),
        offset: parseInt(offset),
        hasMore: parseInt(offset) + parseInt(limit) < parseInt(countResult.rows[0].count)
      }
    });

  } catch (error) {
    console.error('Search recruiters error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to search recruiters',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get recruiter details by ID
 */
exports.getRecruiterById = async (req, res) => {
  try {
    const userId = req.user._id;
    const { recruiterId } = req.params;

    console.log(`ðŸ‘¤ Getting recruiter details for ID: ${recruiterId}`);

    const sqlQuery = `
      SELECT 
        r.*,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        c.description as company_description,
        c.founded_year,
        i.name as industry_name,
        i.description as industry_description,
        l.city,
        l.state,
        l.country,
        l.postal_code,
        -- Outreach history
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.id = $2
    `;

    const result = await pool.query(sqlQuery, [userId.toString(), recruiterId]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const row = result.rows[0];
    
    // Get recruiter's skills
    const skillsQuery = `
      SELECT s.name, s.category
      FROM recruiter_skills rs
      JOIN skills s ON rs.skill_id = s.id
      WHERE rs.recruiter_id = $1
    `;
    const skillsResult = await pool.query(skillsQuery, [recruiterId]);

    // Get outreach history from MongoDB
    const outreachHistory = await Outreach.find({
      userId,
      recruiterId: recruiterId
    }).sort({ createdAt: -1 }).limit(10);

    const recruiter = {
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      fullName: `${row.first_name || ''} ${row.last_name || ''}`.trim(),
      email: row.email,
      phone: row.direct_phone,
      title: row.title,
      linkedinUrl: row.linkedin_profile_url,
      otherSocialUrls: row.other_social_urls,
      experienceYears: row.experience_years,
      lastActiveDate: row.last_active_date,
      rating: row.rating,
      notes: row.notes,
      specializations: row.specializations,
      company: {
        name: row.company_name,
        website: row.company_website,
        size: row.company_size,
        logo: row.company_logo,
        description: row.company_description,
        foundedYear: row.founded_year
      },
      industry: {
        name: row.industry_name,
        description: row.industry_description
      },
      location: {
        city: row.city,
        state: row.state,
        country: row.country,
        postalCode: row.postal_code
      },
      skills: skillsResult.rows.map(skill => ({
        name: skill.name,
        category: skill.category
      })),
      outreach: {
        hasContacted: !!row.last_contact_date,
        lastContactDate: row.last_contact_date,
        status: row.outreach_status,
        history: outreachHistory
      },
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };

    console.log(`âœ… Retrieved recruiter: ${recruiter.fullName} at ${recruiter.company.name}`);

    res.json({
      success: true,
      recruiter
    });

  } catch (error) {
    console.error('Get recruiter details error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get recruiter details',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get filter options for recruiter search (simplified - no experience ranges)
 */
exports.getFilterOptions = async (req, res) => {
  try {
    console.log('ðŸ“Š Getting filter options for recruiter search');

    // Get top companies
    const companiesQuery = `
      SELECT c.name, COUNT(r.id) as recruiter_count
      FROM companies c
      JOIN recruiters r ON c.id = r.current_company_id
      WHERE r.is_active = true
      GROUP BY c.id, c.name
      ORDER BY recruiter_count DESC
      LIMIT 50
    `;

    // Get industries
    const industriesQuery = `
      SELECT i.name, COUNT(r.id) as recruiter_count
      FROM industries i
      JOIN recruiters r ON i.id = r.industry_id
      WHERE r.is_active = true
      GROUP BY i.id, i.name
      ORDER BY recruiter_count DESC
      LIMIT 30
    `;

    // Get locations
    const locationsQuery = `
      SELECT 
        CASE 
          WHEN l.state IS NOT NULL THEN l.city || ', ' || l.state || ', ' || l.country
          ELSE l.city || ', ' || l.country
        END as location,
        COUNT(r.id) as recruiter_count
      FROM locations l
      JOIN recruiters r ON l.id = r.location_id
      WHERE r.is_active = true
      GROUP BY l.city, l.state, l.country
      ORDER BY recruiter_count DESC
      LIMIT 50
    `;

    const [companies, industries, locations] = await Promise.all([
      pool.query(companiesQuery),
      pool.query(industriesQuery),
      pool.query(locationsQuery)
    ]);

    const filterOptions = {
      companies: companies.rows.map(row => ({
        name: row.name,
        count: parseInt(row.recruiter_count)
      })),
      industries: industries.rows.map(row => ({
        name: row.name,
        count: parseInt(row.recruiter_count)
      })),
      locations: locations.rows.map(row => ({
        name: row.location,
        count: parseInt(row.recruiter_count)
      }))
    };

    console.log(`âœ… Retrieved filter options - ${filterOptions.companies.length} companies, ${filterOptions.industries.length} industries`);

    res.json({
      success: true,
      filterOptions
    });

  } catch (error) {
    console.error('Get filter options error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get filter options',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Create outreach campaign
 */
exports.createOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      recruiterId,
      jobId,
      messageContent,
      messageTemplate,
      sentVia = 'linkedin',
      customizations = []
    } = req.body;

    console.log(`ðŸ“§ Creating outreach for recruiter ${recruiterId} by user ${userId}`);

    // Validate inputs
    if (!recruiterId || !messageContent) {
      return res.status(400).json({
        success: false,
        error: 'Recruiter ID and message content are required'
      });
    }

    // Get recruiter details for validation
    const recruiterQuery = `SELECT id, first_name, last_name, email FROM recruiters WHERE id = $1`;
    const recruiterResult = await pool.query(recruiterQuery, [recruiterId]);

    if (recruiterResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const recruiter = recruiterResult.rows[0];

    // Create outreach record in MongoDB
    const outreach = new Outreach({
      userId,
      recruiterId: recruiterId.toString(),
      jobId,
      messageContent,
      messageTemplate,
      customizations,
      sentVia,
      status: 'drafted',
      createdAt: new Date()
    });

    await outreach.save();

    // Update PostgreSQL outreach history
    const upsertQuery = `
      INSERT INTO outreach_history (recruiter_id, mongodb_outreach_id, mongodb_user_id, status, last_contact_date)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (recruiter_id, mongodb_user_id) 
      DO UPDATE SET 
        mongodb_outreach_id = $2,
        status = $4,
        last_contact_date = $5,
        updated_at = NOW()
    `;

    await pool.query(upsertQuery, [
      recruiterId,
      outreach._id.toString(),
      userId.toString(),
      'drafted',
      new Date()
    ]);

    console.log(`âœ… Created outreach campaign: ${outreach._id}`);

    res.json({
      success: true,
      outreach: {
        id: outreach._id,
        recruiterId: outreach.recruiterId,
        recruiterName: `${recruiter.first_name} ${recruiter.last_name}`,
        messageContent: outreach.messageContent,
        status: outreach.status,
        createdAt: outreach.createdAt
      },
      message: 'Outreach campaign created successfully'
    });

  } catch (error) {
    console.error('Create outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Update outreach campaign - NEW METHOD
 */
exports.updateOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;
    const updates = req.body;

    console.log(`ðŸ“ Updating outreach ${outreachId} for user ${userId}`);

    // Find and update outreach
    const outreach = await Outreach.findOneAndUpdate(
      { _id: outreachId, userId },
      { ...updates, updatedAt: new Date() },
      { new: true }
    );

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    // Update PostgreSQL record if status changed
    if (updates.status) {
      await pool.query(
        'UPDATE outreach_history SET status = $1, updated_at = NOW() WHERE mongodb_outreach_id = $2',
        [updates.status, outreachId]
      );
    }

    console.log(`âœ… Outreach updated successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach campaign updated successfully',
      outreach: {
        id: outreach._id,
        status: outreach.status,
        messageContent: outreach.messageContent,
        updatedAt: outreach.updatedAt
      }
    });

  } catch (error) {
    console.error('Update outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Delete outreach campaign - NEW METHOD
 */
exports.deleteOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;

    console.log(`ðŸ—‘ï¸ Deleting outreach ${outreachId} for user ${userId}`);

    // Find and delete outreach from MongoDB
    const outreach = await Outreach.findOneAndDelete({ _id: outreachId, userId });

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    // Delete from PostgreSQL outreach history
    await pool.query(
      'DELETE FROM outreach_history WHERE mongodb_outreach_id = $1 AND mongodb_user_id = $2',
      [outreachId, userId.toString()]
    );

    console.log(`âœ… Outreach deleted successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach campaign deleted successfully',
      deletedId: outreachId
    });

  } catch (error) {
    console.error('Delete outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Send outreach message
 */
exports.sendOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;

    console.log(`ðŸ“¤ Sending outreach ${outreachId} for user ${userId}`);

    // Find and update outreach
    const outreach = await Outreach.findOne({ _id: outreachId, userId });

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    if (outreach.status !== 'drafted') {
      return res.status(400).json({
        success: false,
        error: 'Outreach has already been sent'
      });
    }

    // Update outreach status
    outreach.status = 'sent';
    outreach.sentAt = new Date();
    await outreach.save();

    // Update PostgreSQL record
    await pool.query(
      'UPDATE outreach_history SET status = $1, last_contact_date = $2 WHERE mongodb_outreach_id = $3',
      ['sent', new Date(), outreachId]
    );

    console.log(`âœ… Outreach sent successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach sent successfully',
      outreach: {
        id: outreach._id,
        status: outreach.status,
        sentAt: outreach.sentAt
      }
    });

  } catch (error) {
    console.error('Send outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send outreach',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get user's outreach campaigns
 */
exports.getUserOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { status, limit = 20, offset = 0 } = req.query;

    console.log(`ðŸ“‹ Getting outreach campaigns for user ${userId}`);

    // Build filter
    const filter = { userId };
    if (status) {
      filter.status = status;
    }

    // Get outreach campaigns
    const outreaches = await Outreach.find(filter)
      .sort({ createdAt: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));

    // Get recruiter details for each outreach
    const recruiterIds = outreaches.map(o => o.recruiterId);
    
    if (recruiterIds.length > 0) {
      const recruitersQuery = `
        SELECT r.id, r.first_name, r.last_name, r.title, r.email,
               c.name as company_name, c.logo_url as company_logo
        FROM recruiters r
        LEFT JOIN companies c ON r.current_company_id = c.id
        WHERE r.id = ANY($1)
      `;
      
      const recruitersResult = await pool.query(recruitersQuery, [recruiterIds]);
      const recruitersMap = new Map(recruitersResult.rows.map(r => [r.id.toString(), r]));

      // Combine data
      const enrichedOutreaches = outreaches.map(outreach => {
        const recruiter = recruitersMap.get(outreach.recruiterId);
        return {
          id: outreach._id,
          recruiterId: outreach.recruiterId,
          recruiter: recruiter ? {
            name: `${recruiter.first_name} ${recruiter.last_name}`,
            title: recruiter.title,
            email: recruiter.email,
            company: {
              name: recruiter.company_name,
              logo: recruiter.company_logo
            }
          } : null,
          messageContent: outreach.messageContent,
          status: outreach.status,
          sentVia: outreach.sentVia,
          createdAt: outreach.createdAt,
          sentAt: outreach.sentAt,
          repliesCount: outreach.replies ? outreach.replies.length : 0,
          followUpsCount: outreach.followUps ? outreach.followUps.length : 0
        };
      });

      res.json({
        success: true,
        outreaches: enrichedOutreaches,
        pagination: {
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: outreaches.length === parseInt(limit)
        }
      });
    } else {
      res.json({
        success: true,
        outreaches: [],
        pagination: {
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: false
        }
      });
    }

  } catch (error) {
    console.error('Get user outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get outreach campaigns',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Generate AI-powered personalized message
 */
exports.generatePersonalizedMessage = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      recruiterId,
      resumeId,
      jobId,
      messageType = 'introduction',
      tone = 'professional',
      customRequirements = ''
    } = req.body;

    console.log(`ðŸ¤– Generating personalized message for recruiter ${recruiterId}`);

    // Get recruiter details
    const recruiterQuery = `
      SELECT r.first_name, r.last_name, r.title, r.specializations,
             c.name as company_name, c.description as company_description,
             i.name as industry_name
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      WHERE r.id = $1
    `;
    const recruiterResult = await pool.query(recruiterQuery, [recruiterId]);

    if (recruiterResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const recruiter = recruiterResult.rows[0];

    // Get user's resume if provided
    let resume = null;
    if (resumeId) {
      resume = await Resume.findOne({ _id: resumeId, userId });
    }

    // Get job details if provided
    let job = null;
    if (jobId) {
      job = await Job.findOne({ _id: jobId, userId });
    }

    // Build AI prompt
    const prompt = buildPersonalizedMessagePrompt(recruiter, resume, job, messageType, tone, customRequirements);

    // Generate message using OpenAI
    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: 'You are an expert career coach and networking specialist. Generate professional, personalized outreach messages that are engaging and authentic.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 500
    });

    const generatedMessage = response.choices[0].message.content;

    console.log(`âœ… Generated personalized message (${generatedMessage.length} characters)`);

    res.json({
      success: true,
      message: generatedMessage,
      metadata: {
        recruiterName: `${recruiter.first_name} ${recruiter.last_name}`,
        company: recruiter.company_name,
        messageType,
        tone,
        tokensUsed: response.usage?.total_tokens || 0
      }
    });

  } catch (error) {
    console.error('Generate personalized message error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to generate personalized message',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get outreach analytics
 */
exports.getOutreachAnalytics = async (req, res) => {
  try {
    const userId = req.user._id;
    const { timeframe = '30d' } = req.query;

    console.log(`ðŸ“Š Getting outreach analytics for user ${userId}`);

    // Calculate date range
    const startDate = new Date();
    switch (timeframe) {
      case '7d':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(startDate.getDate() - 30);
        break;
      case '90d':
        startDate.setDate(startDate.getDate() - 90);
        break;
    }

    // Get analytics from MongoDB
    const analytics = await Outreach.aggregate([
      {
        $match: {
          userId: userId,
          createdAt: { $gte: startDate }
        }
      },
      {
        $group: {
          _id: null,
          totalOutreach: { $sum: 1 },
sent: { $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] } },
         replied: { $sum: { $cond: [{ $eq: ['$status', 'replied'] }, 1, 0] } },
         drafted: { $sum: { $cond: [{ $eq: ['$status', 'drafted'] }, 1, 0] } },
         totalReplies: { $sum: { $size: { $ifNull: ['$replies', []] } } },
         totalFollowUps: { $sum: { $size: { $ifNull: ['$followUps', []] } } }
       }
     }
   ]);

   const stats = analytics[0] || {
     totalOutreach: 0,
     sent: 0,
     replied: 0,
     drafted: 0,
     totalReplies: 0,
     totalFollowUps: 0
   };

   // Calculate rates
   const responseRate = stats.sent > 0 ? (stats.replied / stats.sent) * 100 : 0;
   const sendRate = stats.totalOutreach > 0 ? (stats.sent / stats.totalOutreach) * 100 : 0;

   res.json({
     success: true,
     analytics: {
       ...stats,
       responseRate: Math.round(responseRate * 100) / 100,
       sendRate: Math.round(sendRate * 100) / 100,
       timeframe
     }
   });

 } catch (error) {
   console.error('Get outreach analytics error:', error);
   res.status(500).json({
     success: false,
     error: 'Failed to get outreach analytics',
     details: process.env.NODE_ENV !== 'production' ? error.message : undefined
   });
 }
};

// Helper function to build AI prompt
function buildPersonalizedMessagePrompt(recruiter, resume, job, messageType, tone, customRequirements) {
 const recruiterName = `${recruiter.first_name} ${recruiter.last_name}`;
 const company = recruiter.company_name;
 
 let prompt = `Generate a ${tone} ${messageType} message to ${recruiterName}, a ${recruiter.title} at ${company}.\n\n`;
 
 prompt += `RECRUITER CONTEXT:\n`;
 prompt += `- Name: ${recruiterName}\n`;
 prompt += `- Title: ${recruiter.title}\n`;
 prompt += `- Company: ${company}\n`;
 if (recruiter.specializations) {
   prompt += `- Specializations: ${recruiter.specializations.join(', ')}\n`;
 }
 if (recruiter.industry_name) {
   prompt += `- Industry: ${recruiter.industry_name}\n`;
 }
 
 if (resume) {
   prompt += `\nUSER BACKGROUND:\n`;
   prompt += `- Name: ${resume.parsedData?.contactInfo?.name || 'Professional'}\n`;
   if (resume.parsedData?.summary) {
     prompt += `- Summary: ${resume.parsedData.summary}\n`;
   }
   if (resume.parsedData?.experience?.length > 0) {
     const currentRole = resume.parsedData.experience[0];
     prompt += `- Current Role: ${currentRole.title} at ${currentRole.company}\n`;
   }
   if (resume.parsedData?.skills?.length > 0) {
     const topSkills = resume.parsedData.skills.slice(0, 5).map(s => typeof s === 'string' ? s : s.name);
     prompt += `- Key Skills: ${topSkills.join(', ')}\n`;
   }
 }
 
 if (job) {
   prompt += `\nTARGET POSITION:\n`;
   prompt += `- Title: ${job.title}\n`;
   prompt += `- Company: ${job.company}\n`;
   if (job.description) {
     prompt += `- Description: ${job.description.substring(0, 200)}...\n`;
   }
 }
 
 if (customRequirements) {
   prompt += `\nCUSTOM REQUIREMENTS:\n${customRequirements}\n`;
 }
 
 prompt += `\nGUIDELINES:\n`;
 prompt += `- Keep the message concise (2-3 paragraphs)\n`;
 prompt += `- Make it personal and specific to ${recruiterName}\n`;
 prompt += `- Use a ${tone} tone\n`;
 prompt += `- Include a clear call-to-action\n`;
 prompt += `- Avoid overly salesy language\n`;
 prompt += `- Make it authentic and professional\n`;
 
 if (messageType === 'introduction') {
   prompt += `- Focus on introducing yourself and expressing interest in their company\n`;
 } else if (messageType === 'follow_up') {
   prompt += `- Reference previous contact and provide additional value\n`;
 } else if (messageType === 'application') {
   prompt += `- Express interest in a specific role and highlight relevant qualifications\n`;
 }
 
 return prompt;
}

module.exports = exports;

================
File: controllers/resume.controller.js
================
// controllers/resume.controller.js - COMPLETE FIXED VERSION
const { PutObjectCommand, GetObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const { s3Client, S3_BUCKET } = require('../config/s3');
const Resume = require('../models/mongodb/resume.model');
const resumeParserService = require('../services/resumeParser.service');
const resumeAnalysisService = require('../services/resumeAnalysis.service');
const mongoose = require('mongoose');
const path = require('path');
const uuid = require('uuid').v4;

// Helper function to generate S3 key for a resume file
const generateS3Key = (userId, originalFilename) => {
  const extension = path.extname(originalFilename);
  return `resumes/${userId}/${uuid()}${extension}`;
};

// Upload a new resume
exports.uploadResume = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Get userId from either req.user._id or req.userId (depending on how auth middleware works)
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }

    const originalFilename = req.file.originalname;
    
    // Determine file type - IMPORTANT: Use UPPERCASE to match the schema enum
    let fileType;
    if (req.file.mimetype === 'application/pdf' || originalFilename.toLowerCase().endsWith('.pdf')) {
      fileType = 'PDF'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
      originalFilename.toLowerCase().endsWith('.docx')
    ) {
      fileType = 'DOCX'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/msword' || 
      originalFilename.toLowerCase().endsWith('.doc')
    ) {
      fileType = 'DOC'; // Uppercase to match schema enum
    } else {
      return res.status(400).json({ message: 'Only PDF, DOCX, and DOC files are supported' });
    }
    
    console.log('Determined file type:', fileType); // Log for debugging
    
    const s3Key = generateS3Key(userId, originalFilename);
    
    // Create resume record in MongoDB with initial processing status
    const resume = new Resume({
      userId,
      name: req.body.name || originalFilename,
      originalFilename,
      fileUrl: s3Key,
      fileType: fileType, // Using uppercase file type to match schema enum
      processingStatus: {
        status: 'uploading',
        progress: 10,
        message: 'Uploading file to storage...',
        updatedAt: new Date()
      },
      parsedData: {}, // Will be populated after analysis
      analysis: {}, // Will be populated after analysis
      versions: []
    });

    await resume.save();
    console.log('Resume record created in MongoDB');
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: req.file.buffer,
      ContentType: req.file.mimetype
    };

    // Log the upload attempt for debugging
    console.log('Attempting S3 upload with params:', {
      Bucket: S3_BUCKET,
      Key: `${s3Key.substring(0, 20)}...`, // Don't log the full key for security
      ContentType: req.file.mimetype,
      FileSize: req.file.size
    });

    await s3Client.send(new PutObjectCommand(uploadParams));
    console.log('S3 upload successful');
    
    // Update processing status after successful upload
    resume.processingStatus = {
      status: 'parsing',
      progress: 25,
      message: 'Parsing resume content...',
      updatedAt: new Date()
    };
    await resume.save();

    // IMPORTANT: Initiate async parsing and analysis in the background
    // This way the user doesn't have to wait for the process to complete
    processResumeInBackground(resume._id, s3Key, fileType).catch(err => {
      console.error('Background resume processing error:', err);
      // Update status to error if background processing fails
      updateResumeProcessingStatus(resume._id, 'error', 0, 'Error processing resume', err.message)
        .catch(updateErr => console.error('Error updating processing status:', updateErr));
    });

    // Return response with resume data and processing status
    res.status(201).json({
      message: 'Resume uploaded successfully and processing initiated',
      resume: {
        id: resume._id,
        name: resume.name,
        originalFilename: resume.originalFilename,
        fileType: resume.fileType,
        createdAt: resume.createdAt,
        processingStatus: resume.processingStatus
      }
    });
  } catch (error) {
    console.error('Error uploading resume:', error);
    res.status(500).json({ message: 'Failed to upload resume', error: error.message });
  }
};

// Helper function to update resume processing status
async function updateResumeProcessingStatus(resumeId, status, progress, message, error = '') {
  try {
    const resume = await Resume.findById(resumeId);
    if (!resume) {
      console.error(`Resume not found for ID: ${resumeId}`);
      return false;
    }
    
    resume.processingStatus = {
      status,
      progress,
      message,
      error,
      updatedAt: new Date()
    };
    
    await resume.save();
    console.log(`Updated processing status for resume ${resumeId}: ${status} (${progress}%)`);
    return true;
  } catch (err) {
    console.error('Error updating resume processing status:', err);
    return false;
  }
}

// Background processing function - UPDATED WITH BETTER ERROR HANDLING AND LOGGING
async function processResumeInBackground(resumeId, fileUrl, fileType) {
  try {
    console.log(`Starting background processing for resume: ${resumeId}`);
    
    // Get the resume from the database
    const resume = await Resume.findById(resumeId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    // Step 1: Parse the resume using OpenAI
    console.log('Starting resume parsing...');
    // Update status to parsing (25-50%)
    await updateResumeProcessingStatus(resumeId, 'parsing', 30, 'Extracting content from resume...');
    
    const parsedData = await resumeParserService.parseResume(fileUrl, fileType);
    
    // CRITICAL FIX: Ensure parsedData is valid before saving
    if (!parsedData || typeof parsedData !== 'object') {
      throw new Error('Invalid parsed data received from parser service');
    }
    
    // Update the resume with parsed data
    resume.parsedData = parsedData;
    await resume.save();
    console.log('Resume parsing completed, data saved to database');
    
    // Update status to analyzing (50-90%)
    await updateResumeProcessingStatus(resumeId, 'analyzing', 50, 'Parsing complete. Starting AI analysis...');
    
    // Step 2: Analyze the resume using OpenAI
    console.log('Starting resume analysis...');
    const analysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // CRITICAL FIX: Validate analysis data before saving
    if (!analysis || typeof analysis !== 'object') {
      throw new Error('Invalid analysis data received from analysis service');
    }
    
    console.log('Analysis completed, data structure:', {
      overallScore: analysis.overallScore,
      atsCompatibility: analysis.atsCompatibility,
      hasProfileSummary: !!analysis.profileSummary,
      strengthsCount: analysis.strengths?.length || 0,
      weaknessesCount: analysis.weaknesses?.length || 0,
      improvementAreasCount: analysis.improvementAreas?.length || 0
    });
    
    // Update progress during analysis
    await updateResumeProcessingStatus(resumeId, 'analyzing', 75, 'AI analysis in progress...');
    
    // CRITICAL FIX: Ensure analysis data is properly assigned and saved
    resume.analysis = analysis;
    
    // Force save and verify
    const savedResume = await resume.save();
    console.log('Resume analysis saved to database:', {
      resumeId: savedResume._id,
      hasAnalysis: !!savedResume.analysis,
      overallScore: savedResume.analysis?.overallScore,
      atsCompatibility: savedResume.analysis?.atsCompatibility
    });
    
    // Double-check by re-fetching from database
    const verificationResume = await Resume.findById(resumeId);
    if (!verificationResume.analysis || !verificationResume.analysis.overallScore) {
      console.error('CRITICAL ERROR: Analysis data was not saved properly to database');
      throw new Error('Failed to save analysis data to database');
    }
    
    console.log('Database verification successful - analysis data persisted correctly');
    
    // Update status to completed (100%)
    await updateResumeProcessingStatus(resumeId, 'completed', 100, 'Resume processing completed successfully');
    console.log('Resume analyzed successfully');
    
    return true;
  } catch (error) {
    console.error('Error in background processing:', error);
    // Update status to error
    await updateResumeProcessingStatus(
      resumeId, 
      'error', 
      0, 
      'Error processing resume', 
      error.message || 'Unknown error'
    );
    throw error;
  }
}

// Create a tailored resume
exports.createTailoredResume = async (req, res) => {
  try {
    const { resumeId, jobId } = req.params;
    const { name, notes } = req.body;
    
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    // Validate input
    if (!resumeId || !jobId) {
      return res.status(400).json({ message: 'Resume ID and Job ID are required' });
    }
    
    console.log(`Creating tailored resume: resumeId=${resumeId}, jobId=${jobId}, userId=${userId}`);
    
    // Import the tailoring service
    const resumeTailoringService = require('../services/resumeTailoring.service');
    
    // Create the tailored resume with improved PDF generation and fresh analysis
    const result = await resumeTailoringService.createTailoredResume(resumeId, jobId, {
      name,
      notes
    });
    
    console.log('Tailored resume created successfully:', {
      resumeId: result.resume.id,
      hasAnalysis: !!result.resume.analysis,
      overallScore: result.resume.analysis?.overallScore,
      downloadUrl: !!result.resume.downloadUrl
    });
    
    res.status(201).json(result);
  } catch (error) {
    console.error('Error creating tailored resume:', error);
    res.status(500).json({ 
      message: 'Failed to create tailored resume', 
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// Get all resumes for a user
exports.getUserResumes = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    
    // Generate temporary signed URLs for each resume
    const resumesWithUrls = await Promise.all(resumes.map(async (resume) => {
      const getObjectParams = {
        Bucket: S3_BUCKET,
        Key: resume.fileUrl
      };
      
      const command = new GetObjectCommand(getObjectParams);
      const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 }); // URL expires in 1 hour
      
      return {
        _id: resume._id,
        name: resume.name,
        originalFilename: resume.originalFilename,
        fileType: resume.fileType,
        createdAt: resume.createdAt,
        updatedAt: resume.updatedAt,
        downloadUrl: signedUrl,
        analysis: resume.analysis,
        processingStatus: resume.processingStatus || {
          status: 'completed',
          progress: 100,
          message: 'Resume processing completed'
        },
        isTailored: resume.isTailored || false,
        tailoredForJob: resume.tailoredForJob || null,
        versions: resume.versions.map(v => ({
          id: v._id,
          versionNumber: v.versionNumber,
          createdAt: v.createdAt,
          changesDescription: v.changesDescription
        }))
      };
    }));
    
    res.status(200).json({ resumes: resumesWithUrls });
  } catch (error) {
    console.error('Error fetching resumes:', error);
    res.status(500).json({ message: 'Failed to fetch resumes', error: error.message });
  }
};

// Get a specific resume by ID
exports.getResumeById = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // CRITICAL DEBUG: Log what we're retrieving
    console.log('Retrieved resume from database:', {
      resumeId: resume._id,
      hasAnalysis: !!resume.analysis,
      hasProcessingStatus: !!resume.processingStatus,
      overallScore: resume.analysis?.overallScore,
      atsCompatibility: resume.analysis?.atsCompatibility,
      analysisKeys: resume.analysis ? Object.keys(resume.analysis) : []
    });
    
    // Generate temporary signed URL for the resume
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: resume.fileUrl
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 }); // URL expires in 1 hour
    
    // Generate URLs for all versions if they exist
    const versionsWithUrls = await Promise.all((resume.versions || []).map(async (version) => {
      const versionParams = {
        Bucket: S3_BUCKET,
        Key: version.fileUrl
      };
      
      const versionCommand = new GetObjectCommand(versionParams);
      const versionUrl = await getSignedUrl(s3Client, versionCommand, { expiresIn: 3600 });
      
      return {
        id: version._id,
        versionNumber: version.versionNumber,
        createdAt: version.createdAt,
        changesDescription: version.changesDescription,
        downloadUrl: versionUrl,
        jobId: version.jobId
      };
    }));
    
    // CRITICAL FIX: Ensure analysis data is properly structured for the frontend
    const analysisData = resume.analysis || {};
    
    const resumeData = {
      id: resume._id,
      name: resume.name,
      originalFilename: resume.originalFilename,
      fileType: resume.fileType,
      createdAt: resume.createdAt,
      updatedAt: resume.updatedAt,
      downloadUrl: signedUrl,
      parsedData: resume.parsedData || {},
      analysis: {
        overallScore: analysisData.overallScore || 0,
        atsCompatibility: analysisData.atsCompatibility || 0,
        profileSummary: analysisData.profileSummary || {
          currentRole: "Not specified",
          careerLevel: "Mid-level",
          industries: [],
          suggestedJobTitles: [],
          suggestedIndustries: []
        },
        strengths: analysisData.strengths || [],
        weaknesses: analysisData.weaknesses || [],
        keywordsSuggestions: analysisData.keywordsSuggestions || [],
        improvementAreas: analysisData.improvementAreas || []
      },
      processingStatus: resume.processingStatus || {
        status: 'completed',
        progress: 100,
        message: 'Resume processing completed'
      },
      isTailored: resume.isTailored || false,
      tailoredForJob: resume.tailoredForJob || null,
      versions: versionsWithUrls
    };
    
    // CRITICAL DEBUG: Log what we're sending to frontend
    console.log('Sending resume data to frontend:', {
      hasAnalysis: !!resumeData.analysis,
      overallScore: resumeData.analysis.overallScore,
      atsCompatibility: resumeData.analysis.atsCompatibility,
      strengthsCount: resumeData.analysis.strengths.length,
      weaknessesCount: resumeData.analysis.weaknesses.length
    });
    
    res.status(200).json({ resume: resumeData });
  } catch (error) {
    console.error('Error fetching resume:', error);
    res.status(500).json({ message: 'Failed to fetch resume', error: error.message });
  }
};

// Optimize resume for ATS with real-time progress via SSE
exports.optimizeResumeForATS = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    console.log(`ðŸ¤– AJ: Starting ATS optimization for resume ${resumeId}`);
    
    // Import the resume editor service
    const ResumeEditorService = require('../services/resumeEditor.service');
    
    // Get optional target job from request body
    const targetJob = req.body.targetJob || null;
    
    // Store original resume data for before/after comparison
    const Resume = require('../models/mongodb/resume.model');
    const originalResume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!originalResume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Store original data for comparison
    const originalData = {
      parsedData: JSON.parse(JSON.stringify(originalResume.parsedData)),
      analysis: JSON.parse(JSON.stringify(originalResume.analysis || {}))
    };
    
    // Create progress callback function
    const progressCallback = (stage, percentage, message) => {
      console.log(`ðŸ“Š Backend Progress: ${percentage}% - ${message}`);
      // In a real implementation, you might store this in Redis or broadcast via WebSocket
      // For now, we'll rely on the backend logs and frontend timing
    };
    
    // Call the ATS optimization service with progress callback
    const result = await ResumeEditorService.optimizeForATSWithProgress(
      resumeId, 
      userId, 
      targetJob,
      originalData,
      progressCallback
    );
    
    console.log(`âœ… AJ: ATS optimization completed. New score: ${result.newATSScore}%`);
    
    res.status(200).json({
      success: true,
      message: 'Resume optimized for ATS successfully',
      data: {
        optimizations: result.optimizations,
        previousATSScore: result.previousScore,
        newATSScore: result.newATSScore,
        improvementGain: result.newATSScore - result.previousScore,
        updatedResume: {
          id: result.updatedResume._id,
          name: result.updatedResume.name,
          analysis: result.updatedResume.analysis,
          versions: result.updatedResume.versions
        },
        // Add before/after comparison data
        comparison: result.comparison,
        // Add timing information for frontend
        processingTime: result.processingTime,
        stages: result.stages
      }
    });
  } catch (error) {
    console.error('âŒ ATS optimization error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to optimize resume for ATS', 
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// ðŸ“¡ SSE endpoint for real-time optimization progress - FIXED SINGLE VERSION
exports.getOptimizationProgress = async (req, res) => {
  try {
    console.log('ðŸ“¡ SSE optimization-progress endpoint hit:', req.params.id, 'Query:', req.query);
    
    const resumeId = req.params.id;
    let userId;
    
    // Handle authentication via token query parameter
    if (req.query.token) {
      try {
        const jwt = require('jsonwebtoken');
        const User = require('../models/mongodb/user.model');
        
        const decoded = jwt.verify(req.query.token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.id);
        
        if (!user || !user.active) {
          console.error('âŒ Invalid user for SSE');
          return res.status(401).json({ error: 'Invalid user' });
        }
        
        userId = user._id;
        console.log('ðŸ“¡ SSE authenticated for resume:', resumeId, 'user:', userId);
        
      } catch (tokenError) {
        console.error('âŒ SSE Token verification failed:', tokenError.message);
        return res.status(401).json({ error: 'Invalid token' });
      }
    } else {
      console.error('âŒ SSE No token provided');
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    console.log('ðŸ“¡ Setting up SSE headers for resume:', resumeId);
    
    // Set SSE headers
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // Send initial connection message
    const welcomeMessage = {
      type: 'connected',
      message: 'Progress stream connected successfully',
      resumeId: resumeId,
      timestamp: new Date().toISOString()
    };
    
    res.write(`data: ${JSON.stringify(welcomeMessage)}\n\n`);
    console.log('ðŸ“¡ Sent welcome message:', welcomeMessage);

    // Store client for progress updates
    const clientId = `${userId}_${resumeId}_${Date.now()}`;
    
    if (!global.progressClients) {
      global.progressClients = new Map();
    }
    
    global.progressClients.set(clientId, res);
    console.log(`ðŸ“¡ SSE client registered: ${clientId}. Total clients: ${global.progressClients.size}`);
    
    // Send a test progress message
    setTimeout(() => {
      try {
        const testMessage = {
          type: 'progress',
          percentage: 10,
          message: 'SSE connection established, ready for progress updates',
          resumeId: resumeId,
          timestamp: new Date().toISOString()
        };
        res.write(`data: ${JSON.stringify(testMessage)}\n\n`);
        console.log('ðŸ“¡ Sent test progress message');
      } catch (error) {
        console.error('âŒ Error sending test message:', error);
      }
    }, 1000);
    
    // Cleanup on client disconnect
    req.on('close', () => {
      console.log(`ðŸ“¡ SSE client disconnected: ${clientId}`);
      global.progressClients.delete(clientId);
      console.log(`ðŸ“¡ Remaining SSE clients: ${global.progressClients.size}`);
    });
    
    req.on('error', (err) => {
      console.error('ðŸ“¡ SSE connection error:', err);
      global.progressClients.delete(clientId);
    });

    // Keep connection alive with heartbeat
    const heartbeat = setInterval(() => {
      try {
        if (global.progressClients.has(clientId)) {
          res.write(`data: ${JSON.stringify({ 
            type: 'heartbeat', 
            timestamp: new Date().toISOString() 
          })}\n\n`);
        } else {
          clearInterval(heartbeat);
        }
      } catch (error) {
        console.error('âŒ SSE heartbeat failed:', error);
        clearInterval(heartbeat);
        global.progressClients.delete(clientId);
      }
    }, 30000);

    // Cleanup heartbeat on disconnect
    req.on('close', () => {
      clearInterval(heartbeat);
    });

  } catch (error) {
    console.error('âŒ SSE Setup Error:', error);
    try {
      res.status(500).json({ error: 'Failed to setup progress stream', details: error.message });
    } catch (responseError) {
      console.error('âŒ Error sending error response:', responseError);
    }
  }
};

// Manually trigger resume analysis
exports.analyzeResume = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // If resume hasn't been parsed yet, parse it first
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      try {
        const parsedData = await resumeParserService.parseResume(resume.fileUrl, resume.fileType);
        resume.parsedData = parsedData;
        await resume.save();
      } catch (parseError) {
        console.error('Error parsing resume:', parseError);
        return res.status(500).json({ 
          message: 'Failed to parse resume',
          error: parseError.message
        });
      }
    }
    
    // Analyze the resume using OpenAI
    try {
      const analysis = await resumeAnalysisService.analyzeResume(resumeId);
      
      // Update the resume with analysis data
      resume.analysis = analysis;
      await resume.save();
      
      res.status(200).json({ 
        message: 'Resume analyzed successfully',
        analysis
      });
    } catch (analysisError) {
      console.error('Error analyzing resume:', analysisError);
      res.status(500).json({ 
        message: 'Failed to analyze resume',
        error: analysisError.message
      });
    }
  } catch (error) {
    console.error('Error in analyze resume endpoint:', error);
    res.status(500).json({ message: 'Failed to process request', error: error.message });
  }
};

// Add a new version to an existing resume
exports.addResumeVersion = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    const originalFilename = req.file.originalname;
    
// Determine file type - IMPORTANT: Use UPPERCASE to match the schema enum
    let fileType;
    if (req.file.mimetype === 'application/pdf' || originalFilename.toLowerCase().endsWith('.pdf')) {
      fileType = 'PDF'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
      originalFilename.toLowerCase().endsWith('.docx')
    ) {
      fileType = 'DOCX'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/msword' || 
      originalFilename.toLowerCase().endsWith('.doc')
    ) {
      fileType = 'DOC'; // Uppercase to match schema enum
    } else {
      return res.status(400).json({ message: 'Only PDF, DOCX, and DOC files are supported' });
    }
    
    const s3Key = generateS3Key(userId, originalFilename);
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: req.file.buffer,
      ContentType: req.file.mimetype
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    
    // Create new version
    const versionNumber = (resume.versions || []).length + 2; // +2 because original is version 1
    const newVersion = {
      versionNumber,
      createdAt: new Date(),
      fileUrl: s3Key,
      changesDescription: req.body.changesDescription || `Version ${versionNumber}`,
      jobId: req.body.jobId || null
    };
    
    // Add to versions array
    if (!resume.versions) {
      resume.versions = [];
    }
    resume.versions.push(newVersion);
    await resume.save();
    
    // Generate signed URL for the new version
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: s3Key
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
    
    res.status(200).json({
      message: 'Resume version added successfully',
      version: {
        id: newVersion._id,
        versionNumber: newVersion.versionNumber,
        createdAt: newVersion.createdAt,
        changesDescription: newVersion.changesDescription,
        downloadUrl: signedUrl,
        jobId: newVersion.jobId
      }
    });
  } catch (error) {
    console.error('Error adding resume version:', error);
    res.status(500).json({ message: 'Failed to add resume version', error: error.message });
  }
};

// Get resume processing status
exports.getResumeProcessingStatus = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId }, 'processingStatus');
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Return just the processing status
    const processingStatus = resume.processingStatus || {
      status: 'completed',
      progress: 100,
      message: 'Resume processing completed'
    };
    
    res.status(200).json({ processingStatus });
  } catch (error) {
    console.error('Error fetching resume processing status:', error);
    res.status(500).json({ message: 'Failed to fetch processing status', error: error.message });
  }
};

// Delete a resume
exports.deleteResume = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Delete resume document from MongoDB
    await Resume.deleteOne({ _id: resumeId, userId });
    
    res.status(200).json({ message: 'Resume deleted successfully' });
  } catch (error) {
    console.error('Error deleting resume:', error);
    res.status(500).json({ message: 'Failed to delete resume', error: error.message });
  }
};

================
File: controllers/search.controller.js
================
// backend/controllers/search.controller.js - FIXED VERSION
const User = require('../models/mongodb/user.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const db = require('../config/postgresql');

/**
 * Global search controller that searches across multiple data types
 */
class SearchController {
  /**
   * Unified search across jobs, resumes, and recruiters
   */
  static async globalSearch(req, res) {
    try {
      const { 
        query, 
        category = 'all', 
        limit = 20, 
        includeContent = false 
      } = req.query;
      
      const userId = req.user._id;

      if (!query || query.trim().length < 2) {
        return res.status(400).json({
          success: false,
          error: 'Search query must be at least 2 characters long'
        });
      }

      console.log(`ðŸ” Global search: "${query}" for user ${userId}, category: ${category}`);

      const searchResults = {
        query: query.trim(),
        category,
        results: {
          jobs: [],
          resumes: [],
          recruiters: [],
          totalCount: 0
        },
        suggestions: [],
        recentSearches: []
      };

      // Parallel search execution
      const searchPromises = [];

      if (category === 'all' || category === 'jobs') {
        searchPromises.push(SearchController.searchJobs(userId, query, limit));
      }

      if (category === 'all' || category === 'resumes') {
        searchPromises.push(SearchController.searchResumes(userId, query, limit));
      }

      if (category === 'all' || category === 'recruiters') {
        searchPromises.push(SearchController.searchRecruiters(userId, query, limit));
      }

      // Execute all searches in parallel
      const results = await Promise.allSettled(searchPromises);

      // Process results
      let resultIndex = 0;
      if (category === 'all' || category === 'jobs') {
        const jobResults = results[resultIndex];
        if (jobResults.status === 'fulfilled') {
          searchResults.results.jobs = jobResults.value || [];
        } else {
          console.error('Job search failed:', jobResults.reason);
        }
        resultIndex++;
      }

      if (category === 'all' || category === 'resumes') {
        const resumeResults = results[resultIndex];
        if (resumeResults.status === 'fulfilled') {
          searchResults.results.resumes = resumeResults.value || [];
        } else {
          console.error('Resume search failed:', resumeResults.reason);
        }
        resultIndex++;
      }

      if (category === 'all' || category === 'recruiters') {
        const recruiterResults = results[resultIndex];
        if (recruiterResults.status === 'fulfilled') {
          searchResults.results.recruiters = recruiterResults.value || [];
        } else {
          console.error('Recruiter search failed:', recruiterResults.reason);
        }
        resultIndex++;
      }

      // Calculate total count
      searchResults.results.totalCount = 
        searchResults.results.jobs.length +
        searchResults.results.resumes.length +
        searchResults.results.recruiters.length;

      // Generate suggestions if no results found
      if (searchResults.results.totalCount === 0) {
        searchResults.suggestions = await SearchController.generateSuggestions(query);
      }

      // Get recent searches
      searchResults.recentSearches = await SearchController.getRecentSearches(userId);

      // Save this search
      await SearchController.saveSearch(userId, query, category, searchResults.results.totalCount);

      console.log(`âœ… Search completed: ${searchResults.results.totalCount} total results`);

      res.json({
        success: true,
        data: searchResults
      });

    } catch (error) {
      console.error('Global search error:', error);
      res.status(500).json({
        success: false,
        error: 'Search failed',
        details: error.message
      });
    }
  }

  /**
   * Search jobs
   */
  static async searchJobs(userId, query, limit = 10) {
    try {
      const searchRegex = new RegExp(query, 'i');
      
      const jobs = await Job.find({
        userId,
        $or: [
          { title: searchRegex },
          { company: searchRegex },
          { description: searchRegex },
          { 'parsedData.keySkills.name': searchRegex },
          { 'parsedData.requirements': searchRegex },
          { 'parsedData.responsibilities': searchRegex }
        ]
      })
      .select('title company description parsedData.keySkills matchAnalysis applicationStatus createdAt')
      .sort({ createdAt: -1 })
      .limit(limit)
      .lean();

      return jobs.map(job => ({
        id: job._id,
        type: 'job',
        title: job.title,
        subtitle: job.company,
        description: job.description ? job.description.substring(0, 150) + '...' : '',
        matchScore: job.matchAnalysis?.overallScore || null,
        status: job.applicationStatus || 'not_applied',
        skills: job.parsedData?.keySkills?.slice(0, 5) || [],
        createdAt: job.createdAt,
        url: `/jobs/${job._id}`
      }));

    } catch (error) {
      console.error('Job search error:', error);
      return [];
    }
  }

  /**
   * Search resumes
   */
  static async searchResumes(userId, query, limit = 10) {
    try {
      const searchRegex = new RegExp(query, 'i');
      
      const resumes = await Resume.find({
        userId,
        $or: [
          { name: searchRegex },
          { 'parsedData.summary': searchRegex },
          { 'parsedData.experience.title': searchRegex },
          { 'parsedData.experience.company': searchRegex },
          { 'parsedData.skills.name': searchRegex },
          { 'parsedData.education.institution': searchRegex },
          { 'parsedData.education.degree': searchRegex }
        ]
      })
      .select('name parsedData.summary parsedData.skills analysis isActive createdAt')
      .sort({ isActive: -1, createdAt: -1 })
      .limit(limit)
      .lean();

      return resumes.map(resume => ({
        id: resume._id,
        type: 'resume',
        title: resume.name,
        subtitle: resume.parsedData?.summary ? 
          resume.parsedData.summary.substring(0, 100) + '...' : 
          'Professional Resume',
        description: `${resume.parsedData?.skills?.length || 0} skills listed`,
        score: resume.analysis?.overallScore || null,
        isActive: resume.isActive,
        skills: resume.parsedData?.skills?.slice(0, 5) || [],
        createdAt: resume.createdAt,
        url: `/resumes/${resume._id}`
      }));

    } catch (error) {
      console.error('Resume search error:', error);
      return [];
    }
  }

  /**
   * Search recruiters
   */
  static async searchRecruiters(userId, query, limit = 10) {
    try {
      // Simplified search - just search by name and title for now
      const searchTerm = `%${query.toLowerCase()}%`;
      
      const recruitersQuery = `
        SELECT 
          r.id,
          r.first_name,
          r.last_name,
          r.title,
          r.email,
          r.linkedin_url,
          r.experience_years,
          r.last_active_date,
          companies.name as company_name,
          industries.name as industry_name,
          locations.city,
          locations.state,
          locations.country
        FROM recruiters r
        LEFT JOIN companies ON r.current_company_id = companies.id
        LEFT JOIN industries ON r.industry_id = industries.id
        LEFT JOIN locations ON r.location_id = locations.id
        WHERE r.is_active = true 
        AND (
          LOWER(r.first_name) LIKE $1 OR 
          LOWER(r.last_name) LIKE $1 OR 
          LOWER(r.title) LIKE $1 OR 
          LOWER(companies.name) LIKE $1
        )
        ORDER BY r.last_active_date DESC NULLS LAST
        LIMIT $2
      `;

      const result = await db.query(recruitersQuery, [searchTerm, limit]);

      return result.rows.map(recruiter => ({
        id: recruiter.id,
        type: 'recruiter',
        title: `${recruiter.first_name} ${recruiter.last_name}`,
        subtitle: recruiter.title || 'Recruiter',
        description: `${recruiter.company_name || 'Unknown Company'}${recruiter.industry_name ? ` â€¢ ${recruiter.industry_name}` : ''}`,
        location: recruiter.city ? 
          `${recruiter.city}${recruiter.state ? `, ${recruiter.state}` : ''}` : 
          null,
        experience: recruiter.experience_years,
        hasContact: !!(recruiter.email || recruiter.linkedin_url),
        hasBeenContacted: false, // Simplified for now
        lastActiveDate: recruiter.last_active_date,
        url: `/recruiters/${recruiter.id}`
      }));

    } catch (error) {
      console.error('Recruiter search error:', error);
      return [];
    }
  }

  /**
   * Generate search suggestions
   */
  static async generateSuggestions(query) {
    try {
      const suggestions = [];
      
      // Common job titles
      const jobTitles = [
        'Software Engineer', 'Product Manager', 'Data Scientist', 
        'Marketing Manager', 'Sales Representative', 'Business Analyst'
      ];
      
      // Common skills
      const skills = [
        'JavaScript', 'Python', 'React', 'Node.js', 'SQL', 
        'Machine Learning', 'Project Management', 'Marketing'
      ];
      
      // Common companies (you could populate this from your database)
      const companies = [
        'Google', 'Microsoft', 'Amazon', 'Apple', 'Meta', 'Netflix'
      ];

      // Find matching suggestions
      const queryLower = query.toLowerCase();
      
      jobTitles.forEach(title => {
        if (title.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: title, type: 'job_title' });
        }
      });
      
      skills.forEach(skill => {
        if (skill.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: skill, type: 'skill' });
        }
      });
      
      companies.forEach(company => {
        if (company.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: company, type: 'company' });
        }
      });

      return suggestions.slice(0, 5);

    } catch (error) {
      console.error('Generate suggestions error:', error);
      return [];
    }
  }

  /**
   * Get recent searches for user
   */
  static async getRecentSearches(userId, limit = 5) {
    try {
      // You could implement a search history collection in MongoDB
      // For now, return empty array
      return [];
    } catch (error) {
      console.error('Get recent searches error:', error);
      return [];
    }
  }

  /**
   * Save search for analytics and recent searches
   */
  static async saveSearch(userId, query, category, resultCount) {
    try {
      // You could implement search analytics here
      console.log(`ðŸ“Š Search saved: ${query} (${resultCount} results)`);
    } catch (error) {
      console.error('Save search error:', error);
    }
  }

  /**
   * Get search suggestions as user types
   */
  static async getSearchSuggestions(req, res) {
    try {
      const { query, limit = 5 } = req.query;
      
      if (!query || query.length < 2) {
        return res.json({
          success: true,
          data: { suggestions: [] }
        });
      }

      const suggestions = await SearchController.generateSuggestions(query);
      
      res.json({
        success: true,
        data: { suggestions: suggestions.slice(0, limit) }
      });

    } catch (error) {
      console.error('Get search suggestions error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get suggestions'
      });
    }
  }

  /**
   * Get popular searches
   */
  static async getPopularSearches(req, res) {
    try {
      // Return common search terms
      const popularSearches = [
        'Software Engineer',
        'Product Manager',
        'JavaScript',
        'Remote Jobs',
        'Data Science',
        'Marketing',
        'Google',
        'Startup'
      ];

      res.json({
        success: true,
        data: { searches: popularSearches }
      });

    } catch (error) {
      console.error('Get popular searches error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get popular searches'
      });
    }
  }
}

module.exports = SearchController;

================
File: controllers/settings.controller.js
================
// backend/controllers/settings.controller.js
const bcrypt = require('bcrypt');
const crypto = require('crypto');
const User = require('../models/mongodb/user.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const Outreach = require('../models/mongodb/outreach.model');
const sendEmail = require('../utils/send-email');

/**
 * Get user profile information
 */
exports.getProfile = async (req, res) => {
  try {
    console.log('ðŸ“‹ Getting profile for user:', req.user.id);
    
    const user = await User.findById(req.user.id).select('-password -passwordResetToken -passwordResetExpires');
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    console.log('âœ… Profile retrieved successfully');
    
    res.status(200).json({
      success: true,
      data: {
        user: {
          id: user._id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          phoneNumber: user.phoneNumber,
          isEmailVerified: user.isEmailVerified,
          profilePicture: user.profilePicture,
          location: user.location,
          socialProfiles: user.socialProfiles,
          createdAt: user.createdAt,
          updatedAt: user.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('âŒ Get profile error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve profile information'
    });
  }
};

/**
 * Update user profile information
 */
exports.updateProfile = async (req, res) => {
  try {
    const { firstName, lastName, email, phoneNumber, location, socialProfiles } = req.body;
    const userId = req.user.id;

    console.log('ðŸ“ Updating profile for user:', userId);
    console.log('ðŸ“ Update data:', { firstName, lastName, email, phoneNumber });

    // Validation
    if (!firstName || !lastName || !email) {
      return res.status(400).json({
        success: false,
        error: 'First name, last name, and email are required'
      });
    }

    // Email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        error: 'Please provide a valid email address'
      });
    }

    // Check if email is already taken by another user
    if (email !== req.user.email) {
      const existingUser = await User.findOne({ email, _id: { $ne: userId } });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          error: 'Email address is already in use'
        });
      }
    }

    // Prepare update data
    const updateData = {
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      email: email.toLowerCase().trim(),
      phoneNumber: phoneNumber ? phoneNumber.trim() : '',
      updatedAt: new Date()
    };

    // If email changed, mark as unverified
    if (email !== req.user.email) {
      updateData.isEmailVerified = false;
      updateData.emailVerificationToken = crypto.randomBytes(32).toString('hex');
      updateData.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours
    }

    // Update location if provided
    if (location) {
      updateData.location = location;
    }

    // Update social profiles if provided
    if (socialProfiles) {
      updateData.socialProfiles = socialProfiles;
    }

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      updateData,
      { new: true, runValidators: true }
    ).select('-password -passwordResetToken -passwordResetExpires');

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Send verification email if email changed
    if (email !== req.user.email) {
      try {
        const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${updateData.emailVerificationToken}`;
        
        await sendEmail({
          email: updatedUser.email,
          subject: 'Verify Your New Email Address - auto-job.ai',
          message: `Hi ${updatedUser.firstName},\n\nPlease verify your new email address by clicking the link below:\n\n${verificationUrl}\n\nThis link will expire in 24 hours.\n\nBest regards,\nThe auto-job.ai Team`
        });

        console.log('ðŸ“§ Verification email sent to:', updatedUser.email);
      } catch (emailError) {
        console.error('ðŸ“§ Failed to send verification email:', emailError);
        // Don't fail the update if email sending fails
      }
    }

    console.log('âœ… Profile updated successfully');

    res.status(200).json({
      success: true,
      message: email !== req.user.email ? 'Profile updated successfully. Please check your email to verify your new email address.' : 'Profile updated successfully',
      data: {
        user: {
          id: updatedUser._id,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          email: updatedUser.email,
          phoneNumber: updatedUser.phoneNumber,
          isEmailVerified: updatedUser.isEmailVerified,
          profilePicture: updatedUser.profilePicture,
          location: updatedUser.location,
          socialProfiles: updatedUser.socialProfiles,
          createdAt: updatedUser.createdAt,
          updatedAt: updatedUser.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('âŒ Update profile error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update profile'
    });
  }
};

/**
 * Change user password
 */
exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const userId = req.user.id;

    console.log('ðŸ”’ Changing password for user:', userId);

    // Validation
    if (!currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        error: 'Current password and new password are required'
      });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        error: 'New password must be at least 6 characters long'
      });
    }

    // Get user with password
    const user = await User.findById(userId).select('+password');
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Verify current password
    const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isCurrentPasswordValid) {
      return res.status(400).json({
        success: false,
        error: 'Current password is incorrect'
      });
    }

    // Check if new password is different from current
    const isSamePassword = await bcrypt.compare(newPassword, user.password);
    if (isSamePassword) {
      return res.status(400).json({
        success: false,
        error: 'New password must be different from current password'
      });
    }

    // Hash new password
    const salt = await bcrypt.genSalt(10); // Use 10 rounds to match your user model
    const hashedNewPassword = await bcrypt.hash(newPassword, salt);

    // Update password
    await User.findByIdAndUpdate(userId, {
      password: hashedNewPassword,
      updatedAt: new Date(),
      // Clear any password reset tokens
      passwordResetToken: undefined,
      passwordResetExpires: undefined
    });

    console.log('âœ… Password changed successfully');

    // Send notification email
    try {
      await sendEmail({
        email: user.email,
        subject: 'Password Changed Successfully - auto-job.ai',
        message: `Hi ${user.firstName},\n\nYour password has been changed successfully.\n\nIf you did not make this change, please contact our support team immediately.\n\nBest regards,\nThe auto-job.ai Team`
      });
    } catch (emailError) {
      console.error('ðŸ“§ Failed to send password change notification:', emailError);
    }

    res.status(200).json({
      success: true,
      message: 'Password changed successfully'
    });

  } catch (error) {
    console.error('âŒ Change password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to change password'
    });
  }
};

/**
 * Delete user account and all associated data
 */
exports.deleteAccount = async (req, res) => {
  try {
    const userId = req.user.id;
    const { confirmationText } = req.body;

    console.log('ðŸ—‘ï¸ Deleting account for user:', userId);

    // Optional: Require confirmation text
    if (confirmationText && confirmationText !== 'DELETE') {
      return res.status(400).json({
        success: false,
        error: 'Please type DELETE to confirm account deletion'
      });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Start deletion process
    console.log('ðŸ—‘ï¸ Starting account deletion process...');

    // Delete user's resumes
    const deletedResumes = await Resume.deleteMany({ userId });
    console.log(`ðŸ—‘ï¸ Deleted ${deletedResumes.deletedCount} resumes`);

    // Delete user's jobs
    const deletedJobs = await Job.deleteMany({ userId });
    console.log(`ðŸ—‘ï¸ Deleted ${deletedJobs.deletedCount} jobs`);

    // Delete user's outreach campaigns
    const deletedOutreach = await Outreach.deleteMany({ userId });
    console.log(`ðŸ—‘ï¸ Deleted ${deletedOutreach.deletedCount} outreach campaigns`);

    // TODO: Delete from PostgreSQL tables if needed
    // This would include recruiter outreach history, etc.

    // Finally, delete the user account
    await User.findByIdAndDelete(userId);
    console.log('ðŸ—‘ï¸ User account deleted');

    // Send farewell email
    try {
      await sendEmail({
        email: user.email,
        subject: 'Account Deleted Successfully - auto-job.ai',
        message: `Hi ${user.firstName},\n\nYour auto-job.ai account has been successfully deleted along with all associated data.\n\nWe're sorry to see you go. If you have any feedback or would like to return in the future, we'd love to hear from you.\n\nBest regards,\nThe auto-job.ai Team`
      });
    } catch (emailError) {
      console.error('ðŸ“§ Failed to send farewell email:', emailError);
    }

    console.log('âœ… Account deletion completed successfully');

    res.status(200).json({
      success: true,
      message: 'Account deleted successfully'
    });

  } catch (error) {
    console.error('âŒ Delete account error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete account'
    });
  }
};

/**
 * Send email verification
 */
exports.sendVerificationEmail = async (req, res) => {
  try {
    const userId = req.user.id;

    console.log('ðŸ“§ Sending verification email for user:', userId);

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    if (user.isEmailVerified) {
      return res.status(400).json({
        success: false,
        error: 'Email is already verified'
      });
    }

    // Generate verification token
    const verificationToken = crypto.randomBytes(32).toString('hex');
    const verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours

    // Update user with verification token
    await User.findByIdAndUpdate(userId, {
      emailVerificationToken: verificationToken,
      emailVerificationExpires: verificationExpires
    });

    // Send verification email
    const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`;
    
    await sendEmail({
      email: user.email,
      subject: 'Verify Your Email Address - auto-job.ai',
      message: `Hi ${user.firstName},\n\nPlease verify your email address by clicking the link below:\n\n${verificationUrl}\n\nThis link will expire in 24 hours.\n\nBest regards,\nThe auto-job.ai Team`
    });

    console.log('âœ… Verification email sent successfully');

    res.status(200).json({
      success: true,
      message: 'Verification email sent successfully'
    });

  } catch (error) {
    console.error('âŒ Send verification email error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send verification email'
    });
  }
};

/**
 * Verify email address
 */
exports.verifyEmail = async (req, res) => {
  try {
    const { token } = req.params;

    console.log('âœ‰ï¸ Verifying email with token:', token);

    if (!token) {
      return res.status(400).json({
        success: false,
        error: 'Verification token is required'
      });
    }

    // Find user with valid verification token
    const user = await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: Date.now() }
    });

    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired verification token'
      });
    }

    // Mark email as verified
    await User.findByIdAndUpdate(user._id, {
      isEmailVerified: true,
      emailVerificationToken: undefined,
      emailVerificationExpires: undefined,
      updatedAt: new Date()
    });

    console.log('âœ… Email verified successfully for user:', user.email);

    res.status(200).json({
      success: true,
      message: 'Email verified successfully'
    });

  } catch (error) {
    console.error('âŒ Verify email error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify email'
    });
  }
};

================
File: debug-controller-params.js
================
// backend/debug-controller-params.js - Debug what's happening with parameters
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugControllerParams() {
  try {
    console.log('ðŸ› DEBUGGING CONTROLLER PARAMETERS');
    console.log('====================================');
    
    // Simulate the exact request parameters from your log
    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';
    const company = '';
    const industry = '';
    const location = '';
    const title = '';
    const experience_min = '';
    const experience_max = '20'; // This is what's in your query string
    const limit = 20;
    const offset = 0;
    const sort_by = 'last_active_date';
    const sort_order = 'DESC';

    console.log('ðŸ“‹ Input Parameters:');
    console.log(`   userId: ${userId}`);
    console.log(`   query: "${query}"`);
    console.log(`   company: "${company}"`);
    console.log(`   industry: "${industry}"`);
    console.log(`   location: "${location}"`);
    console.log(`   title: "${title}"`);
    console.log(`   experience_min: "${experience_min}"`);
    console.log(`   experience_max: "${experience_max}"`);
    console.log(`   limit: ${limit}`);
    console.log(`   offset: ${offset}`);

    // Build query exactly like the controller
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone as phone,
        r.title,
        r.linkedin_profile_url as linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        i.name as industry_name,
        l.city,
        l.state,
        l.country,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    console.log('\nðŸ”§ Building Query Step by Step:');
    console.log(`1. Base query with userId: ${userId}`);

    // Add search filters with COALESCE to handle NULL values
    if (query) {
      sqlQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${paramIndex} OR
        COALESCE(r.title, '') ILIKE $${paramIndex} OR
        COALESCE(c.name, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${query.toLowerCase()}%`);
      console.log(`2. Added query filter: %${query.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (company) {
      sqlQuery += ` AND COALESCE(c.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${company.toLowerCase()}%`);
      console.log(`3. Added company filter: %${company.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (industry) {
      sqlQuery += ` AND COALESCE(i.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${industry.toLowerCase()}%`);
      console.log(`4. Added industry filter: %${industry.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (location) {
      sqlQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${paramIndex} OR
        COALESCE(l.state, '') ILIKE $${paramIndex} OR
        COALESCE(l.country, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${location.toLowerCase()}%`);
      console.log(`5. Added location filter: %${location.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (title) {
      sqlQuery += ` AND COALESCE(r.title, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${title.toLowerCase()}%`);
      console.log(`6. Added title filter: %${title.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    // âš ï¸ CRITICAL: Check if experience filters are being applied
    console.log(`\nâš ï¸  EXPERIENCE FILTER CHECK:`);
    console.log(`   experience_min: "${experience_min}" (truthy: ${!!experience_min})`);
    console.log(`   experience_max: "${experience_max}" (truthy: ${!!experience_max})`);

    if (experience_min) {
      sqlQuery += ` AND r.experience_years >= $${paramIndex}`;
      queryParams.push(parseInt(experience_min));
      console.log(`7. Added experience_min filter: >= ${experience_min} (param $${paramIndex})`);
      paramIndex++;
    }

    if (experience_max) {
      sqlQuery += ` AND r.experience_years <= $${paramIndex}`;
      queryParams.push(parseInt(experience_max));
      console.log(`8. âš ï¸  Added experience_max filter: <= ${experience_max} (param $${paramIndex})`);
      paramIndex++;
    }

    // Add ordering
    const validSortFields = ['last_active_date', 'rating', 'experience_years', 'first_name'];
    const sortField = validSortFields.includes(sort_by) ? sort_by : 'last_active_date';
    const sortDirection = sort_order.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
    
    sqlQuery += ` ORDER BY r.${sortField} ${sortDirection}`;
    console.log(`9. Added sorting: ORDER BY r.${sortField} ${sortDirection}`);
    
    // Add pagination
    sqlQuery += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    queryParams.push(parseInt(limit), parseInt(offset));
    console.log(`10. Added pagination: LIMIT ${limit} OFFSET ${offset} (params $${paramIndex}, $${paramIndex + 1})`);

    console.log('\nðŸ“ FINAL QUERY:');
    console.log(sqlQuery);
    console.log('\nðŸ“‹ FINAL PARAMETERS:');
    console.log(queryParams);

    // Execute the query
    console.log('\nðŸ—„ï¸ EXECUTING QUERY...');
    const result = await pool.query(sqlQuery, queryParams);
    console.log(`âœ… Query executed successfully: ${result.rows.length} rows returned`);

    if (result.rows.length > 0) {
      console.log('\nðŸ‘¥ SAMPLE RESULTS:');
      result.rows.slice(0, 3).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title} (Experience: ${row.experience_years || 'N/A'} years)`);
      });
    }

    // Test without experience_max filter
    console.log('\nðŸ§ª TESTING WITHOUT EXPERIENCE_MAX FILTER:');
    
    let testQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $2 OR
           COALESCE(r.title, '') ILIKE $2 OR
           COALESCE(c.name, '') ILIKE $2)
    `;
    
    const testResult = await pool.query(testQuery, [userId, `%${query.toLowerCase()}%`]);
    console.log(`ðŸ“Š Without experience_max filter: ${testResult.rows[0].count} matches`);

    // Test with experience_max filter
    testQuery += ` AND r.experience_years <= $3`;
    const testResult2 = await pool.query(testQuery, [userId, `%${query.toLowerCase()}%`, parseInt(experience_max)]);
    console.log(`ðŸ“Š With experience_max <= ${experience_max}: ${testResult2.rows[0].count} matches`);

    // Check experience_years distribution
    console.log('\nðŸ“ˆ EXPERIENCE YEARS DISTRIBUTION FOR SARAH:');
    const expQuery = `
      SELECT 
        r.experience_years,
        COUNT(*) as count,
        array_agg(r.first_name || ' ' || r.last_name) as names
      FROM recruiters r
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $1)
      GROUP BY r.experience_years
      ORDER BY r.experience_years
    `;
    
    const expResult = await pool.query(expQuery, [`%${query.toLowerCase()}%`]);
    expResult.rows.forEach(row => {
      console.log(`   ${row.experience_years || 'NULL'} years: ${row.count} people`);
      if (row.count <= 3) {
        console.log(`      Names: ${row.names.join(', ')}`);
      }
    });

  } catch (error) {
    console.error('âŒ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

debugControllerParams();

================
File: debug-recruiter-search.js
================
// backend/debug-recruiter-search.js - Debug script to check recruiter data
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugRecruiterSearch() {
  try {
    console.log('ðŸ” DEBUGGING RECRUITER SEARCH');
    console.log('================================');

    // 1. Check basic table counts
    console.log('\n1ï¸âƒ£ CHECKING TABLE COUNTS:');
    const counts = await Promise.all([
      pool.query('SELECT COUNT(*) as count FROM recruiters'),
      pool.query('SELECT COUNT(*) as count FROM companies'),
      pool.query('SELECT COUNT(*) as count FROM industries'),
      pool.query('SELECT COUNT(*) as count FROM locations')
    ]);

    console.log(`   Recruiters: ${counts[0].rows[0].count}`);
    console.log(`   Companies: ${counts[1].rows[0].count}`);
    console.log(`   Industries: ${counts[2].rows[0].count}`);
    console.log(`   Locations: ${counts[3].rows[0].count}`);

    // 2. Check for active recruiters
    console.log('\n2ï¸âƒ£ CHECKING ACTIVE RECRUITERS:');
    const activeCount = await pool.query('SELECT COUNT(*) as count FROM recruiters WHERE is_active = true');
    const inactiveCount = await pool.query('SELECT COUNT(*) as count FROM recruiters WHERE is_active = false OR is_active IS NULL');
    
    console.log(`   Active recruiters: ${activeCount.rows[0].count}`);
    console.log(`   Inactive/NULL recruiters: ${inactiveCount.rows[0].count}`);

    // 3. Sample recruiter data
    console.log('\n3ï¸âƒ£ SAMPLE RECRUITER DATA:');
    const sampleRecruiters = await pool.query(`
      SELECT 
        r.id, r.first_name, r.last_name, r.email, r.title, r.is_active,
        c.name as company_name,
        i.name as industry_name
      FROM recruiters r 
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LIMIT 10
    `);

    sampleRecruiters.rows.forEach((recruiter, index) => {
      console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} (${recruiter.email}) - Active: ${recruiter.is_active}`);
      console.log(`      Title: ${recruiter.title}`);
      console.log(`      Company: ${recruiter.company_name}`);
      console.log(`      Industry: ${recruiter.industry_name}`);
      console.log('');
    });

    // 4. Check for "Sarah" specifically (case insensitive)
    console.log('\n4ï¸âƒ£ SEARCHING FOR "SARAH" (CASE INSENSITIVE):');
    const sarahSearch = await pool.query(`
      SELECT 
        r.first_name, r.last_name, r.email, r.is_active,
        c.name as company_name
      FROM recruiters r 
      LEFT JOIN companies c ON r.current_company_id = c.id
      WHERE LOWER(r.first_name) LIKE LOWER('%sarah%') 
         OR LOWER(r.last_name) LIKE LOWER('%sarah%')
      LIMIT 5
    `);

    if (sarahSearch.rows.length > 0) {
      console.log(`   Found ${sarahSearch.rows.length} results for "Sarah":`);
      sarahSearch.rows.forEach((recruiter, index) => {
        console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} (${recruiter.email}) - Active: ${recruiter.is_active}`);
        console.log(`      Company: ${recruiter.company_name}`);
      });
    } else {
      console.log('   âŒ No results found for "Sarah"');
    }

    // 5. Check the exact search query that's failing
    console.log('\n5ï¸âƒ£ TESTING EXACT SEARCH QUERY:');
    
    const testQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.title,
        r.is_active,
        c.name as company_name
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      WHERE r.is_active = true
        AND (
          LOWER(r.first_name || ' ' || r.last_name) LIKE LOWER('%sarah%') OR
          LOWER(r.title) LIKE LOWER('%sarah%') OR
          LOWER(c.name) LIKE LOWER('%sarah%')
        )
      LIMIT 5
    `;

    const exactSearch = await pool.query(testQuery);
    
    if (exactSearch.rows.length > 0) {
      console.log(`   âœ… Found ${exactSearch.rows.length} results with exact query:`);
      exactSearch.rows.forEach((recruiter, index) => {
        console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} - ${recruiter.title}`);
        console.log(`      Company: ${recruiter.company_name}`);
        console.log(`      Active: ${recruiter.is_active}`);
      });
    } else {
      console.log('   âŒ No results with exact search query');
    }

    // 6. Check for null values that might cause issues
    console.log('\n6ï¸âƒ£ CHECKING FOR NULL VALUES:');
    const nullCheck = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(first_name) as has_first_name,
        COUNT(last_name) as has_last_name,
        COUNT(title) as has_title,
        COUNT(is_active) as has_is_active
      FROM recruiters
    `);

    const nullStats = nullCheck.rows[0];
    console.log(`   Total recruiters: ${nullStats.total}`);
    console.log(`   With first_name: ${nullStats.has_first_name}`);
    console.log(`   With last_name: ${nullStats.has_last_name}`);
    console.log(`   With title: ${nullStats.has_title}`);
    console.log(`   With is_active: ${nullStats.has_is_active}`);

    // 7. Check industry data specifically
    console.log('\n7ï¸âƒ£ CHECKING INDUSTRY DATA:');
    const industryData = await pool.query(`
      SELECT i.name, COUNT(r.id) as recruiter_count
      FROM industries i
      LEFT JOIN recruiters r ON i.id = r.industry_id AND r.is_active = true
      GROUP BY i.id, i.name
      ORDER BY recruiter_count DESC
      LIMIT 10
    `);

    if (industryData.rows.length > 0) {
      console.log('   Top industries:');
      industryData.rows.forEach((industry, index) => {
        console.log(`   ${index + 1}. ${industry.name}: ${industry.recruiter_count} recruiters`);
      });
    } else {
      console.log('   âŒ No industry data found');
    }

    // 8. Test if the issue is with the is_active column
    console.log('\n8ï¸âƒ£ TESTING WITHOUT is_active FILTER:');
    const noActiveFilter = await pool.query(`
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      WHERE LOWER(r.first_name || ' ' || r.last_name) LIKE LOWER('%sarah%')
    `);

    console.log(`   Results without is_active filter: ${noActiveFilter.rows[0].count}`);

    // 9. Check schema for is_active column
    console.log('\n9ï¸âƒ£ CHECKING SCHEMA FOR is_active COLUMN:');
    const schemaCheck = await pool.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns 
      WHERE table_name = 'recruiters' AND column_name = 'is_active'
    `);

    if (schemaCheck.rows.length > 0) {
      const col = schemaCheck.rows[0];
      console.log(`   is_active column exists: ${col.data_type}, nullable: ${col.is_nullable}, default: ${col.column_default}`);
    } else {
      console.log('   âŒ is_active column does not exist!');
    }

    console.log('\nâœ… Debug complete!');

  } catch (error) {
    console.error('âŒ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

// Run the debug
debugRecruiterSearch();

================
File: debug-search-query.js
================
// backend/debug-search-query.js - Debug the exact search query
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugSearchQuery() {
  try {
    console.log('ðŸ” DEBUGGING SEARCH QUERY FOR "SARAH"');
    console.log('===========================================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Test 1: Basic recruiter count
    console.log('\n1ï¸âƒ£ TOTAL ACTIVE RECRUITERS:');
    const totalActiveResult = await pool.query(`
      SELECT COUNT(*) as count FROM recruiters WHERE is_active = true
    `);
    console.log(`   Active recruiters: ${totalActiveResult.rows[0].count}`);

    // Test 2: Sarah search without joins
    console.log('\n2ï¸âƒ£ SARAH SEARCH WITHOUT JOINS:');
    const sarahBasicResult = await pool.query(`
      SELECT COUNT(*) as count 
      FROM recruiters r
      WHERE r.is_active = true 
        AND ((r.first_name || ' ' || r.last_name) ILIKE $1 OR r.title ILIKE $1)
    `, [`%${query}%`]);
    console.log(`   Sarah matches without joins: ${sarahBasicResult.rows[0].count}`);

    // Test 3: Exact query from controller
    console.log('\n3ï¸âƒ£ EXACT CONTROLLER QUERY (with outreach join):');
    const exactQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE $2 OR r.title ILIKE $2)
      ORDER BY r.first_name ASC
      LIMIT 20 OFFSET 0
    `;

    const exactResult = await pool.query(exactQuery, [userId, `%${query}%`]);
    console.log(`   Exact controller query results: ${exactResult.rows.length}`);

    if (exactResult.rows.length > 0) {
      console.log('\n   ðŸ“‹ Sample results:');
      exactResult.rows.slice(0, 5).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    }

    // Test 4: Check the count query specifically
    console.log('\n4ï¸âƒ£ CONTROLLER COUNT QUERY:');
    const countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
      AND ((r.first_name || ' ' || r.last_name) ILIKE '%${query}%' OR r.title ILIKE '%${query}%')
    `;
    console.log('   Count query SQL:');
    console.log(`   ${countQuery}`);
    
    const countResult = await pool.query(countQuery);
    console.log(`   Count query result: ${countResult.rows[0].count}`);

    // Test 5: Check if there's a parameter binding issue
    console.log('\n5ï¸âƒ£ PARAMETER BINDING TEST:');
    const parameterTestQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE $1 OR r.title ILIKE $1)
    `;
    const parameterTestResult = await pool.query(parameterTestQuery, [`%${query}%`]);
    console.log(`   Parameterized count result: ${parameterTestResult.rows[0].count}`);

    // Test 6: Check outreach_history table
    console.log('\n6ï¸âƒ£ OUTREACH HISTORY CHECK:');
    const outreachHistoryResult = await pool.query(`
      SELECT COUNT(*) as count FROM outreach_history WHERE mongodb_user_id = $1
    `, [userId]);
    console.log(`   Outreach history records for user: ${outreachHistoryResult.rows[0].count}`);

    // Test 7: Check if the issue is with the name concatenation
    console.log('\n7ï¸âƒ£ NAME CONCATENATION TEST:');
    const nameTestResult = await pool.query(`
      SELECT first_name, last_name, (first_name || ' ' || last_name) as full_name
      FROM recruiters 
      WHERE is_active = true
        AND LOWER(first_name) LIKE LOWER('%sarah%')
      LIMIT 5
    `);
    console.log('   Sample name concatenation results:');
    nameTestResult.rows.forEach((row, index) => {
      console.log(`   ${index + 1}. "${row.first_name}" + "${row.last_name}" = "${row.full_name}"`);
    });

    // Test 8: Check for NULL values that might break concatenation
    console.log('\n8ï¸âƒ£ NULL VALUE CHECK:');
    const nullCheckResult = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(first_name) as has_first_name,
        COUNT(last_name) as has_last_name,
        COUNT(CASE WHEN first_name IS NULL OR last_name IS NULL THEN 1 END) as has_null_names
      FROM recruiters 
      WHERE is_active = true
    `);
    const nullStats = nullCheckResult.rows[0];
    console.log(`   Total active: ${nullStats.total}`);
    console.log(`   Has first_name: ${nullStats.has_first_name}`);
    console.log(`   Has last_name: ${nullStats.has_last_name}`);
    console.log(`   Has NULL names: ${nullStats.has_null_names}`);

    console.log('\nâœ… Debug complete!');

  } catch (error) {
    console.error('âŒ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

// Run the debug
debugSearchQuery();

================
File: middleware/auth.middleware.js
================
// backend/middleware/auth.middleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/mongodb/user.model');

/**
 * Middleware to protect routes that require authentication
 */
exports.protect = async (req, res, next) => {
  try {
    let token;
    
    // Check for token in Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    }
    // Also check for token in cookies
    else if (req.cookies && req.cookies.token) {
      token = req.cookies.token;
    }
    
    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to access this route - no token provided'
      });
    }
    
    try {
      // Verify the token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Find the user by ID
      const user = await User.findById(decoded.id);
      
      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'The user belonging to this token no longer exists'
        });
      }
      
      // Check if user is active
      if (!user.active) {
        return res.status(401).json({
          success: false,
          error: 'This account has been deactivated'
        });
      }
      
      // TEMPORARILY DISABLED EMAIL VERIFICATION CHECK FOR DEBUGGING
      // TODO: Re-enable this after login is working
      /*
      if (!user.isEmailVerified) {
        return res.status(403).json({
          success: false,
          error: 'Please verify your email to access this resource'
        });
      }
      */
      
      // Set user in request object
      req.user = user;
      req.userId = user._id; // Add this for compatibility
      next();
    } catch (jwtError) {
      console.error('JWT verification error:', jwtError.message);
      return res.status(401).json({
        success: false,
        error: 'Invalid token'
      });
    }
  } catch (error) {
    console.error('Auth middleware error:', error);
    return res.status(500).json({
      success: false,
      error: 'Authentication server error'
    });
  }
};

/**
 * Middleware to restrict access based on user role
 */
exports.restrictTo = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to perform this action'
      });
    }
    next();
  };
};

/**
 * Middleware to check if email is verified
 * Soft check - allows request but adds verified status to req object
 */
exports.checkEmailVerification = async (req, res, next) => {
  try {
    if (req.user && !req.user.isEmailVerified) {
      req.isEmailVerified = false;
    } else {
      req.isEmailVerified = true;
    }
    next();
  } catch (error) {
    next(error);
  }
};

/**
 * Optional authentication middleware - doesn't fail if no token
 * Useful for routes that work for both authenticated and non-authenticated users
 */
exports.optionalAuth = async (req, res, next) => {
  try {
    let token;
    
    // Check for token in Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    }
    // Also check for token in cookies
    else if (req.cookies && req.cookies.token) {
      token = req.cookies.token;
    }
    
    if (token) {
      try {
        // Verify the token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // Find the user by ID
        const user = await User.findById(decoded.id);
        
        if (user && user.active) {
          req.user = user;
          req.userId = user._id;
          req.isAuthenticated = true;
        }
      } catch (jwtError) {
        // Token is invalid, but that's okay for optional auth
        console.log('Optional auth - invalid token:', jwtError.message);
      }
    }
    
    // Always continue regardless of token validity
    next();
  } catch (error) {
    // Even if there's an error, continue (optional auth)
    console.error('Optional auth middleware error:', error);
    next();
  }
};

================
File: middleware/validation.middleware.js
================
// backend/middleware/validation.middleware.js
const { validationResult, check } = require('express-validator');

// Middleware to handle validation errors
exports.handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      errors: errors.array()
    });
  }
  next();
};

// Validation rules for registration
exports.validateRegistration = [
  check('firstName')
    .trim()
    .notEmpty()
    .withMessage('First name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters'),
  
  check('lastName')
    .trim()
    .notEmpty()
    .withMessage('Last name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters'),
  
  check('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

// Validation rules for login
exports.validateLogin = [
  check('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
];

// Validation rules for password reset
exports.validatePasswordReset = [
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

// Validation rules for update details
exports.validateUpdateDetails = [
  check('firstName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters'),
  
  check('lastName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters'),
  
  check('phoneNumber')
    .optional()
    .trim()
    .isMobilePhone()
    .withMessage('Please provide a valid phone number'),
  
  check('location.city')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('City must be between 2 and 100 characters'),
  
  check('location.state')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('State must be between 2 and 100 characters'),
  
  check('location.country')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Country must be between 2 and 100 characters')
];

// Validation rules for update password
exports.validateUpdatePassword = [
  check('currentPassword')
    .trim()
    .notEmpty()
    .withMessage('Current password is required'),
  
  check('newPassword')
    .trim()
    .notEmpty()
    .withMessage('New password is required')
    .isLength({ min: 8 })
    .withMessage('New password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

================
File: models/mongodb/aiAgent.model.js
================
// backend/models/mongodb/aiAgent.model.js
const mongoose = require('mongoose');

const aiAgentSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true
  },
  description: String,
  type: {
    type: String,
    enum: ['ResumeAnalysis', 'JobMatching', 'ContentGeneration', 'JobDiscovery'],
    required: true
  },
  config: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  },
  api: {
    endpoint: String,
    apiKey: String,
    modelName: String,
    parameters: mongoose.Schema.Types.Mixed
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastRun: Date,
  performance: {
    averageResponseTime: Number,
    successRate: Number,
    errorRate: Number
  },
  version: String
}, {
  timestamps: true
});

// Add method to invoke the agent
aiAgentSchema.methods.invoke = async function(input, context = {}) {
  // This is a placeholder for actual API call logic
  try {
    // Implement agent-specific processing logic here based on agent type
    switch(this.type) {
      case 'ResumeAnalysis':
        return await this.analyzeResume(input, context);
      case 'JobMatching':
        return await this.matchJob(input, context);
      case 'ContentGeneration':
        return await this.generateContent(input, context);
      case 'JobDiscovery':
        return await this.discoverJobs(input, context);
      default:
        throw new Error(`Unknown agent type: ${this.type}`);
    }
  } catch (error) {
    console.error(`Error invoking AI agent ${this.name}:`, error);
    throw error;
  }
};

// Placeholder for actual implementation
aiAgentSchema.methods.analyzeResume = async function(resume, context) {
  // Implementation will involve calling an NLP service or LLM API
  return { message: 'Resume analysis not yet implemented' };
};

aiAgentSchema.methods.matchJob = async function(data, context) {
  // Implementation will compare resume and job description
  return { message: 'Job matching not yet implemented' };
};

aiAgentSchema.methods.generateContent = async function(data, context) {
  // Implementation will generate content based on input
  return { message: 'Content generation not yet implemented' };
};

aiAgentSchema.methods.discoverJobs = async function(data, context) {
  // Implementation will search for relevant jobs
  return { message: 'Job discovery not yet implemented' };
};

const AIAgent = mongoose.model('AIAgent', aiAgentSchema);

module.exports = AIAgent;

================
File: models/mongodb/aiJobSearch.model.js
================
// models/mongodb/aiJobSearch.model.js - UPDATED WITH NEW SEARCH APPROACHES
const mongoose = require('mongoose');

const aiJobSearchSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    required: true
  },
  resumeName: {
    type: String,
    required: true
  },
  searchCriteria: {
    jobTitle: String,
    skills: [String],
    location: String,
    experienceLevel: String,
    salaryRange: {
      min: Number,
      max: Number,
      currency: String
    },
    jobTypes: [String], // ['FULL_TIME', 'CONTRACT', etc.]
    industries: [String],
    companySizes: [String],
    workEnvironment: String // 'remote', 'hybrid', 'onsite', 'any'
  },
  status: {
    type: String,
    enum: ['running', 'paused', 'completed', 'failed', 'cancelled'],
    default: 'running'
  },
  searchType: {
    type: String,
    enum: ['basic', 'enhanced', 'premium', 'intelligent'],
    default: 'intelligent'
  },
  dailyLimit: {
    type: Number,
    default: 10
  },
  jobsFoundToday: {
    type: Number,
    default: 0
  },
  totalJobsFound: {
    type: Number,
    default: 0
  },
  lastSearchDate: {
    type: Date,
    default: null
  },
  
  // Enhanced tracking
  jobsFound: [{
    jobId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    },
    title: String,
    company: String,
    foundAt: Date,
    contentQuality: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    extractionSuccess: Boolean,
    matchScore: Number,
    sourceUrl: String,
    sourcePlatform: String,
    extractionMethod: String,
    premiumAnalysis: {
      type: Boolean,
      default: false
    }
  }],
  
  // Search performance metrics
  searchMetrics: {
    totalSearchesPerformed: {
      type: Number,
      default: 0
    },
    totalJobsDiscovered: {
      type: Number,
      default: 0
    },
    successfulExtractions: {
      type: Number,
      default: 0
    },
    failedExtractions: {
      type: Number,
      default: 0
    },
    premiumAnalysesCompleted: {
      type: Number,
      default: 0
    },
    avgContentQuality: String,
    avgProcessingTime: Number, // in seconds
    lastPerformanceUpdate: Date,
    // Phase specific metrics
    phase1Duration: Number, // Career analysis time
    phase2Duration: Number, // Job discovery time
    phase3Duration: Number, // Premium analysis time
    totalSearchDuration: Number,
    webSearchSuccessRate: Number, // Percentage of successful web searches
    premiumAnalysisSuccessRate: Number // Percentage of successful premium analyses
  },
  
  // Search history
  searchHistory: [{
    searchDate: Date,
    searchApproach: {
      type: String,
      enum: [
        '5-phase-legacy', 
        '3-phase-intelligent', 
        '3-phase-intelligent-real-boards',
        '3-phase-intelligent-claude-web-search'
      ],
      default: '3-phase-intelligent-claude-web-search'
    },
    phase1Results: { // Career Analysis
      jobTitles: [String],
      keywords: [String],
      experienceLevel: String,
      duration: Number
    },
    phase2Results: { // Job Discovery (Claude Web Search)
      jobUrlsFound: Number,
      successfulExtractions: Number,
      averageContentLength: Number,
      duration: Number,
      webSearchQueries: Number,
      platformsSearched: [String]
    },
    phase3Results: { // Premium Analysis
      jobsAnalyzed: Number,
      successfulAnalyses: Number,
      averageSkillsFound: Number,
      duration: Number
    },
    totalDuration: Number,
    costBreakdown: {
      phase1Cost: String, // "$0.05"
      phase2Cost: String, // "$0.30-0.50"
      phase3Cost: String, // "$0.01-0.02"
      totalCost: String   // "$0.36-0.57"
    },
    errors: [String],
    qualityMetrics: {
      averageMatchScore: Number,
      contentQualityDistribution: {
        high: Number,
        medium: Number,
        low: Number
      }
    }
  }],
  
  // Error tracking
  errors: [{
    timestamp: Date,
    errorType: {
      type: String,
      enum: [
        'career_analysis_failed', 
        'web_search_failed',
        'job_discovery_failed', 
        'premium_analysis_failed',
        'content_extraction_failed',
        'api_error', 
        'validation_error', 
        'rate_limit',
        'claude_error',
        'openai_error'
      ]
    },
    errorMessage: String,
    phase: {
      type: String,
      enum: ['career_analysis', 'web_search_discovery', 'content_extraction', 'premium_analysis', 'job_saving', 'general']
    },
    context: String,
    resolved: {
      type: Boolean,
      default: false
    }
  }],
  
  // AI Model usage tracking
  aiUsage: {
    // Phase 1: Career Analysis
    openaiCareerAnalysis: {
      type: Number,
      default: 0
    },
    // Phase 2: Claude Web Search Discovery
    claudeWebSearches: {
      type: Number,
      default: 0
    },
    claudeContentExtractions: {
      type: Number,
      default: 0
    },
    // Phase 3: Premium Analysis
    openaiPremiumAnalyses: {
      type: Number,
      default: 0
    },
    openaiBatchAnalyses: {
      type: Number,
      default: 0
    },
    totalTokensUsed: {
      type: Number,
      default: 0
    },
    estimatedCost: {
      type: Number,
      default: 0
    },
    // Cost breakdown by phase
    costBreakdown: {
      phase1Cost: Number, // Career analysis
      phase2Cost: Number, // Claude web search discovery
      phase3Cost: Number, // Premium analysis
      totalCost: Number
    }
  },
  
  // Search optimization
  optimization: {
    successRate: Number, // percentage of successful job discoveries
    avgRelevanceScore: Number,
    webSearchEfficiency: Number, // Jobs found per web search
    premiumAnalysisAccuracy: Number, // Successful analyses percentage
    bestSearchTimes: [String], // times of day with best results
    recommendedAdjustments: [String],
    // Quality metrics
    contentQualityTrend: String, // 'improving', 'stable', 'declining'
    matchScoreTrend: String,
    userSatisfactionIndicators: {
      viewedJobsRate: Number,
      appliedJobsRate: Number,
      favoriteJobsRate: Number
    }
  },
  
  // User preferences learned over time
  learnedPreferences: {
    preferredCompanies: [String],
    avoidedCompanies: [String],
    preferredLocations: [String],
    successfulKeywords: [String],
    // Learned from web search discovery
    effectiveJobTitles: [String],
    preferredWorkArrangements: [String],
    salaryExpectationLearned: {
      min: Number,
      max: Number,
      currency: String
    },
    interactionPatterns: {
      viewedJobs: Number,
      appliedJobs: Number,
      favoriteJobs: Number,
      avgTimeSpentPerJob: Number,
      preferredJobTypes: [String]
    }
  },
  
  // Schedule and automation
  schedule: {
    isScheduled: {
      type: Boolean,
      default: false
    },
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'bi-weekly', 'monthly'],
      default: 'daily'
    },
    preferredTime: String, // '09:00' format
    timezone: String,
    nextScheduledRun: Date,
    pauseUntil: Date,
    intelligentScheduling: {
      type: Boolean,
      default: false
    },
    optimalSearchDays: [String], // Days with best results
    lastSuccessfulSearchTime: Date
  },
  
  // Notification settings
  notifications: {
    emailOnNewJobs: {
      type: Boolean,
      default: true
    },
    emailOnHighMatch: {
      type: Boolean,
      default: true
    },
    emailOnErrors: {
      type: Boolean,
      default: true
    },
    matchScoreThreshold: {
      type: Number,
      default: 75
    },
    maxEmailsPerDay: {
      type: Number,
      default: 5
    },
    // Intelligent notifications
    smartNotifications: {
      type: Boolean,
      default: true
    },
    notifyOnQualityJobs: {
      type: Boolean,
      default: true
    },
    premiumAnalysisAlerts: {
      type: Boolean,
      default: true
    }
  },
  
  // AI Reasoning Logs for search process tracking
  reasoningLogs: [{
    phase: {
      type: String,
      enum: [
        'initialization', 
        'career_analysis', 
        'intelligent_discovery', // Web search + content extraction
        'web_search_discovery',  // NEW: Specific for web search
        'content_extraction',    // NEW: Specific for content extraction
        'premium_analysis',      
        'job_saving', 
        'completion', 
        'error'
      ],
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    message: {
      type: String,
      required: true
    },
    details: {
      type: mongoose.Schema.Types.Mixed,
      default: {}
    },
    success: {
      type: Boolean,
      default: true
    },
    duration: {
      type: Number, // Duration in milliseconds
      default: 0
    },
    metadata: {
      // Phase 1: Career Analysis
      targetJobTitles: [String],
      targetKeywords: [String],
      experienceLevel: String,
      
      // Phase 2: Web Search Discovery
      webSearchQueries: Number,
      jobUrlsFound: Number,
      successfulExtractions: Number,
      averageContentLength: Number,
      platformsSearched: [String],
      
      // Phase 3: Premium Analysis
      jobsAnalyzed: Number,
      successfulAnalyses: Number,
      averageSkillsFound: Number,
      
      // General metadata
      aiModel: String,
      errorDetails: String,
      companyName: String,
      jobTitle: String,
      contentLength: Number,
      extractionMethod: String,
      batchSize: Number,
      qualityLevel: String,
      
      // Cost tracking per log entry
      estimatedCost: String,
      tokenUsage: Number,
      
      // Quality indicators
      matchScore: Number,
      contentQuality: String,
      analysisAccuracy: String,
      
      // NEW: Web search specific metadata
      searchQuery: String,
      searchResultsCount: Number,
      webSearchMethod: String,
      discoveryPlatform: String
    }
  }],
  
  lastUpdateMessage: String,
  lastUpdated: {
    type: Date,
    default: Date.now
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  
  // UPDATED: Search approach metadata with new enum values
  searchApproach: {
    type: String,
    enum: [
      '5-phase-legacy', 
      '3-phase-intelligent', 
      '3-phase-intelligent-real-boards',
      '3-phase-intelligent-claude-web-search'
    ],
    default: '3-phase-intelligent-claude-web-search'
  },
  approachVersion: {
    type: String,
    default: '3.2-claude-web-search-api'
  },
  qualityLevel: {
    type: String,
    enum: ['standard', 'premium', 'intelligent', 'claude-web-search'],
    default: 'claude-web-search'
  }
});

// Indexes for better performance
aiJobSearchSchema.index({ userId: 1, status: 1 });
aiJobSearchSchema.index({ userId: 1, createdAt: -1 });
aiJobSearchSchema.index({ status: 1, 'schedule.nextScheduledRun': 1 });
aiJobSearchSchema.index({ 'jobsFound.jobId': 1 });
aiJobSearchSchema.index({ lastSearchDate: 1 });
aiJobSearchSchema.index({ 'reasoningLogs.timestamp': -1 });
aiJobSearchSchema.index({ 'reasoningLogs.phase': 1 });
// NEW: Indexes for Claude web search approach
aiJobSearchSchema.index({ searchApproach: 1 });
aiJobSearchSchema.index({ qualityLevel: 1 });
aiJobSearchSchema.index({ 'reasoningLogs.metadata.qualityLevel': 1 });
aiJobSearchSchema.index({ 'reasoningLogs.metadata.webSearchMethod': 1 });

// Middleware
aiJobSearchSchema.pre('save', function(next) {
  this.lastUpdated = Date.now();
  
  // Update performance metrics
  if (this.isModified('jobsFound')) {
    this.updatePerformanceMetrics();
  }
  
  next();
});

// Instance methods
aiJobSearchSchema.methods.updatePerformanceMetrics = function() {
  const jobs = this.jobsFound;
  if (jobs.length === 0) return;
  
  // Calculate success rate
  const successfulExtractions = jobs.filter(job => job.extractionSuccess).length;
  this.searchMetrics.successfulExtractions = successfulExtractions;
  this.searchMetrics.failedExtractions = jobs.length - successfulExtractions;
  
  // Calculate premium analyses
  const premiumAnalyses = jobs.filter(job => job.premiumAnalysis).length;
  this.searchMetrics.premiumAnalysesCompleted = premiumAnalyses;
  
  // Calculate average content quality
  const qualityScores = jobs.map(job => {
    switch(job.contentQuality) {
      case 'high': return 3;
      case 'medium': return 2;
      case 'low': return 1;
      default: return 1;
    }
  });
  
  const avgQuality = qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length;
  if (avgQuality >= 2.5) this.searchMetrics.avgContentQuality = 'high';
  else if (avgQuality >= 1.5) this.searchMetrics.avgContentQuality = 'medium';
  else this.searchMetrics.avgContentQuality = 'low';
  
  // Update optimization data
  this.optimization.successRate = (successfulExtractions / jobs.length) * 100;
  this.optimization.premiumAnalysisAccuracy = premiumAnalyses > 0 ? (premiumAnalyses / jobs.length) * 100 : 0;
  this.optimization.webSearchEfficiency = jobs.length / Math.max(this.searchMetrics.totalSearchesPerformed, 1);
  
  this.searchMetrics.lastPerformanceUpdate = new Date();
};

aiJobSearchSchema.methods.addJobFound = function(jobData) {
  this.jobsFound.push({
    jobId: jobData.jobId,
    title: jobData.title,
    company: jobData.company,
    foundAt: new Date(),
    contentQuality: jobData.contentQuality || 'medium',
    extractionSuccess: jobData.extractionSuccess !== false,
    matchScore: jobData.matchScore,
    sourceUrl: jobData.sourceUrl,
    sourcePlatform: jobData.sourcePlatform,
    extractionMethod: jobData.extractionMethod || 'claude_web_search_discovery',
    premiumAnalysis: jobData.premiumAnalysis || true
  });
  
  this.totalJobsFound += 1;
  this.jobsFoundToday += 1;
  
  return this.save();
};

aiJobSearchSchema.methods.addError = function(errorType, message, phase, context) {
  this.errors.push({
    timestamp: new Date(),
    errorType,
    errorMessage: message,
    phase: phase || 'general',
    context,
    resolved: false
  });
  
  return this.save();
};

// UPDATED: Track AI usage for Claude web search approach
aiJobSearchSchema.methods.updateAiUsage = function(phase, type, tokens = 0, cost = 0) {
  switch(phase) {
    case 'career_analysis':
      if (type === 'openai') this.aiUsage.openaiCareerAnalysis += 1;
      if (!this.aiUsage.costBreakdown.phase1Cost) this.aiUsage.costBreakdown.phase1Cost = 0;
      this.aiUsage.costBreakdown.phase1Cost += cost;
      break;
      
    case 'web_search_discovery':
    case 'intelligent_discovery':
      if (type === 'claude_web_search') this.aiUsage.claudeWebSearches += 1;
      if (type === 'claude_content_extraction') this.aiUsage.claudeContentExtractions += 1;
      if (!this.aiUsage.costBreakdown.phase2Cost) this.aiUsage.costBreakdown.phase2Cost = 0;
      this.aiUsage.costBreakdown.phase2Cost += cost;
      break;
      
    case 'premium_analysis':
      if (type === 'openai_analysis') this.aiUsage.openaiPremiumAnalyses += 1;
      if (type === 'openai_batch') this.aiUsage.openaiBatchAnalyses += 1;
      if (!this.aiUsage.costBreakdown.phase3Cost) this.aiUsage.costBreakdown.phase3Cost = 0;
      this.aiUsage.costBreakdown.phase3Cost += cost;
      break;
  }
  
  this.aiUsage.totalTokensUsed += tokens;
  this.aiUsage.estimatedCost += cost;
  this.aiUsage.costBreakdown.totalCost = 
    (this.aiUsage.costBreakdown.phase1Cost || 0) +
    (this.aiUsage.costBreakdown.phase2Cost || 0) +
    (this.aiUsage.costBreakdown.phase3Cost || 0);
  
  return this.save();
};

// UPDATED: Method to add reasoning log for Claude web search approach
aiJobSearchSchema.methods.addReasoningLog = function(phase, message, details = {}, success = true, duration = 0) {
  // Helper function to sanitize numeric values
  const sanitizeNumeric = (value) => {
    if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
      return 0;
    }
    return value;
  };
  
  // Sanitize all numeric fields in details and metadata
  const sanitizedDetails = { ...details };
  Object.keys(sanitizedDetails).forEach(key => {
    sanitizedDetails[key] = sanitizeNumeric(sanitizedDetails[key]);
  });
  
  const reasoningLog = {
    phase,
    message,
    details: sanitizedDetails,
    success,
    duration: sanitizeNumeric(duration),
    timestamp: new Date(),
    metadata: {
      aiModel: details.aiModel || this.getDefaultModelForPhase(phase),
      
      // Phase-specific metadata (sanitized)
      targetJobTitles: details.targetJobTitles,
      targetKeywords: details.targetKeywords,
      experienceLevel: details.experienceLevel,
      
      // Web search specific metadata
      webSearchQueries: sanitizeNumeric(details.webSearchQueries),
      jobUrlsFound: sanitizeNumeric(details.jobUrlsFound),
      successfulExtractions: sanitizeNumeric(details.successfulExtractions),
      averageContentLength: sanitizeNumeric(details.averageContentLength),
      platformsSearched: details.platformsSearched,
      
      // Analysis metadata
      jobsAnalyzed: sanitizeNumeric(details.jobsAnalyzed),
      successfulAnalyses: sanitizeNumeric(details.successfulAnalyses),
      averageSkillsFound: sanitizeNumeric(details.averageSkillsFound),
      
      // General metadata
      errorDetails: details.error,
      companyName: details.company || details.companyName,
      jobTitle: details.jobTitle,
      contentLength: sanitizeNumeric(details.contentLength),
      extractionMethod: details.extractionMethod,
      batchSize: sanitizeNumeric(details.batchSize),
      qualityLevel: details.qualityLevel || 'claude-web-search',
      estimatedCost: details.costEstimate || details.estimatedCost,
      tokenUsage: sanitizeNumeric(details.tokenUsage),
      matchScore: sanitizeNumeric(details.matchScore),
      contentQuality: details.contentQuality,
      analysisAccuracy: details.analysisAccuracy,
      
      // Web search specific
      searchQuery: details.searchQuery,
      searchResultsCount: sanitizeNumeric(details.searchResultsCount),
      webSearchMethod: details.webSearchMethod || 'claude_web_search_api',
      discoveryPlatform: details.discoveryPlatform || details.platform
    }
  };
  
  this.reasoningLogs.push(reasoningLog);
  
  // Keep only the last 100 logs to prevent document from growing too large
  if (this.reasoningLogs.length > 100) {
    this.reasoningLogs = this.reasoningLogs.slice(-100);
  }
  
  return this.save();
};

// UPDATED: Helper method to get default model for each phase
aiJobSearchSchema.methods.getDefaultModelForPhase = function(phase) {
  switch(phase) {
    case 'career_analysis': return 'gpt-4-turbo';
    case 'web_search_discovery':
    case 'intelligent_discovery':
    case 'content_extraction': return 'claude-3.5-sonnet';
    case 'premium_analysis': return 'gpt-4o';
    default: return 'unknown';
  }
};

// Method to get recent reasoning logs (for UI display)
aiJobSearchSchema.methods.getRecentReasoningLogs = function(limit = 10) {
  return this.reasoningLogs
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, limit);
};

// Method to get reasoning logs by phase
aiJobSearchSchema.methods.getReasoningLogsByPhase = function(phase) {
  return this.reasoningLogs
    .filter(log => log.phase === phase)
    .sort((a, b) => b.timestamp - a.timestamp);
};

// UPDATED: Method to get performance summary for Claude web search approach
aiJobSearchSchema.methods.getClaudeWebSearchPerformanceSummary = function() {
  return {
    searchApproach: this.searchApproach || '3-phase-intelligent-claude-web-search',
    approachVersion: this.approachVersion || '3.2-claude-web-search-api',
    qualityLevel: this.qualityLevel || 'claude-web-search',
    totalJobsFound: this.totalJobsFound,
    successRate: this.optimization?.successRate || 0,
    webSearchEfficiency: this.optimization?.webSearchEfficiency || 0,
    premiumAnalysisAccuracy: this.optimization?.premiumAnalysisAccuracy || 0,
    avgContentQuality: this.searchMetrics?.avgContentQuality || 'unknown',
    costBreakdown: this.aiUsage?.costBreakdown || {},
    lastSuccessfulSearch: this.lastSearchDate,
    isHighPerformance: (this.optimization?.successRate || 0) > 80 && 
                       (this.optimization?.webSearchEfficiency || 0) > 0.5
  };
};

aiJobSearchSchema.methods.scheduleNextRun = function(frequency = 'daily', preferredTime = '09:00') {
  const now = new Date();
  const nextRun = new Date();
  
  switch(frequency) {
    case 'daily':
      nextRun.setDate(now.getDate() + 1);
      break;
    case 'weekly':
      nextRun.setDate(now.getDate() + 7);
      break;
    case 'bi-weekly':
      nextRun.setDate(now.getDate() + 14);
      break;
    case 'monthly':
      nextRun.setMonth(now.getMonth() + 1);
      break;
  }
  
  const [hours, minutes] = preferredTime.split(':');
  nextRun.setHours(parseInt(hours), parseInt(minutes), 0, 0);
  
  this.schedule.nextScheduledRun = nextRun;
  this.schedule.frequency = frequency;
  this.schedule.preferredTime = preferredTime;
  this.schedule.isScheduled = true;
  
  return this.save();
};

aiJobSearchSchema.methods.pause = function(pauseUntil) {
  this.status = 'paused';
  if (pauseUntil) {
    this.schedule.pauseUntil = pauseUntil;
  }
  this.lastUpdateMessage = 'Search paused by user';
  return this.save();
};

aiJobSearchSchema.methods.resume = function() {
  this.status = 'running';
  this.schedule.pauseUntil = null;
  this.lastUpdateMessage = 'Search resumed by user - using Claude web search approach';
  return this.save();
};

// Static methods
aiJobSearchSchema.statics.findActiveClaudeWebSearches = function() {
  return this.find({ 
    status: 'running',
    searchApproach: '3-phase-intelligent-claude-web-search',
    $or: [
      { 'schedule.nextScheduledRun': { $lte: new Date() } },
      { 'schedule.isScheduled': false }
    ]
  });
};

aiJobSearchSchema.statics.findUserSearches = function(userId) {
  return this.find({ userId }).sort({ createdAt: -1 });
};

// Static method to get AI searches with reasoning logs for Claude web search approach
aiJobSearchSchema.statics.getWithReasoningLogs = function(userId, includeDeleted = false) {
  const query = { userId };
  
  if (!includeDeleted) {
    query.status = { $ne: 'cancelled' };
  }
  
  return this.find(query)
    .populate('resumeId', 'name')
    .sort({ createdAt: -1 })
    .select('+reasoningLogs');
};

// UPDATED: Get search statistics for Claude web search approach
aiJobSearchSchema.statics.getSearchStatistics = function(userId) {
  return this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId) } },
    {
      $group: {
        _id: null,
        totalSearches: { $sum: 1 },
        claudeWebSearches: { $sum: { $cond: [{ $eq: ['$searchApproach', '3-phase-intelligent-claude-web-search'] }, 1, 0] } },
        activeSearches: { $sum: { $cond: [{ $eq: ['$status', 'running'] }, 1, 0] } },
        totalJobsFound: { $sum: '$totalJobsFound' },
        avgJobsPerSearch: { $avg: '$totalJobsFound' },
        totalPremiumAnalyses: { $sum: '$searchMetrics.premiumAnalysesCompleted' },
        totalAiUsage: { $sum: '$aiUsage.totalTokensUsed' },
        estimatedTotalCost: { $sum: '$aiUsage.estimatedCost' },
        avgSuccessRate: { $avg: '$optimization.successRate' },
        avgWebSearchEfficiency: { $avg: '$optimization.webSearchEfficiency' }
      }
    }
  ]);
};

aiJobSearchSchema.statics.findScheduledSearches = function() {
  return this.find({
    'schedule.isScheduled': true,
    'schedule.nextScheduledRun': { $lte: new Date() },
    status: 'running',
    $or: [
      { 'schedule.pauseUntil': { $exists: false } },
      { 'schedule.pauseUntil': null },
      { 'schedule.pauseUntil': { $lte: new Date() } }
    ]
  });
};

// Virtual for search performance
aiJobSearchSchema.virtual('claudeWebSearchPerformanceSummary').get(function() {
  return {
    searchApproach: this.searchApproach || '3-phase-intelligent-claude-web-search',
    successRate: this.optimization?.successRate || 0,
    webSearchEfficiency: this.optimization?.webSearchEfficiency || 0,
    premiumAnalysisAccuracy: this.optimization?.premiumAnalysisAccuracy || 0,
    avgContentQuality: this.searchMetrics?.avgContentQuality || 'unknown',
    totalJobs: this.totalJobsFound,
    avgJobsPerSearch: this.totalJobsFound / Math.max(1, this.searchHistory.length),
    estimatedCost: this.aiUsage?.estimatedCost || 0,
    costBreakdown: this.aiUsage?.costBreakdown || {},
    isHighPerformance: (this.optimization?.successRate || 0) > 80 && 
                       (this.optimization?.webSearchEfficiency || 0) > 0.5,
    qualityLevel: this.qualityLevel || 'claude-web-search'
  };
});

// Virtual for recent reasoning logs (for UI)
aiJobSearchSchema.virtual('recentClaudeWebSearchLogs').get(function() {
  return this.reasoningLogs
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, 10);
});

module.exports = mongoose.model('AiJobSearch', aiJobSearchSchema);

================
File: models/mongodb/assistantSession.model.js
================
// backend/models/mongodb/assistantSession.model.js
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['user', 'assistant', 'system'],
    required: true
  },
  content: {
    type: String,
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  metadata: {
    suggestions: [String],
    resumeEdits: mongoose.Schema.Types.Mixed,
    actionItems: [String],
    confidence: Number,
    processingTime: Number,
    tokensUsed: Number
  }
});

const assistantSessionSchema = new mongoose.Schema({
  sessionId: {
    type: String,
    required: true,
    unique: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    required: false
  },
  resumeSnapshot: {
    // Store resume data at time of session start for context
    name: String,
    parsedData: mongoose.Schema.Types.Mixed,
    version: Number,
    capturedAt: Date
  },
  context: {
    type: String,
    enum: ['resume_editing', 'job_matching', 'career_advice', 'interview_prep', 'general'],
    default: 'resume_editing'
  },
  status: {
    type: String,
    enum: ['active', 'ended', 'expired'],
    default: 'active'
  },
  messages: [messageSchema],
  
  // Session analytics
  analytics: {
    totalMessages: {
      type: Number,
      default: 0
    },
    userMessages: {
      type: Number,
      default: 0
    },
    assistantMessages: {
      type: Number,
      default: 0
    },
    totalTokensUsed: {
      type: Number,
      default: 0
    },
    averageResponseTime: Number,
    sessionsLength: Number, // in seconds
    resumeChangesApplied: {
      type: Number,
      default: 0
    },
    userSatisfactionRating: Number,
    helpfulnessRating: Number
  },

  // AI Context and Memory
  aiContext: {
    userPreferences: {
      communicationStyle: String, // formal, casual, detailed, concise
      focusAreas: [String], // skills, experience, formatting, content
      careerGoals: String,
      industryFocus: String,
      experienceLevel: String
    },
    conversationSummary: String,
    keyTopicsDiscussed: [String],
    actionItemsGenerated: [String],
    improvementsImplemented: [String],
    pendingRecommendations: [String]
  },

  // Resume editing history during session
  resumeEditHistory: [{
    timestamp: Date,
    section: String,
    changeType: {
      type: String,
      enum: ['suggestion', 'applied', 'rejected', 'modified']
    },
    originalContent: String,
    suggestedContent: String,
    finalContent: String,
    aiReasoning: String
  }],

  // Session settings
  settings: {
    language: {
      type: String,
      default: 'en'
    },
    assistantPersonality: {
      type: String,
      enum: ['professional', 'friendly', 'detailed', 'concise'],
      default: 'professional'
    },
    autoApplyChanges: {
      type: Boolean,
      default: false
    },
    notificationsEnabled: {
      type: Boolean,
      default: true
    }
  },

  // Integration data
  integrations: {
    connectedJobs: [mongoose.Schema.Types.ObjectId],
    sharedWithRecruiter: Boolean,
    exportedSuggestions: [{
      timestamp: Date,
      format: String,
      destination: String
    }]
  },

  startedAt: {
    type: Date,
    default: Date.now
  },
  lastActivityAt: {
    type: Date,
    default: Date.now
  },
  endedAt: Date,
  
  // Auto-expire sessions after 24 hours of inactivity
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 24 * 60 * 60 * 1000)
  }
});

// Indexes
assistantSessionSchema.index({ sessionId: 1 }, { unique: true });
assistantSessionSchema.index({ userId: 1, status: 1 });
assistantSessionSchema.index({ resumeId: 1 });
assistantSessionSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
assistantSessionSchema.index({ lastActivityAt: 1 });

// Middleware
assistantSessionSchema.pre('save', function(next) {
  this.lastActivityAt = new Date();
  
  // Update analytics
  if (this.isModified('messages')) {
    this.analytics.totalMessages = this.messages.length;
    this.analytics.userMessages = this.messages.filter(m => m.type === 'user').length;
    this.analytics.assistantMessages = this.messages.filter(m => m.type === 'assistant').length;
    
    // Calculate total tokens used
    this.analytics.totalTokensUsed = this.messages.reduce((total, msg) => {
      return total + (msg.metadata?.tokensUsed || 0);
    }, 0);
    
    // Calculate session length if ended
    if (this.status === 'ended' && this.endedAt) {
      this.analytics.sessionsLength = Math.round((this.endedAt - this.startedAt) / 1000);
    }
  }
  
  next();
});

// Instance methods
assistantSessionSchema.methods.addMessage = function(messageData) {
  const message = {
    id: messageData.id || new mongoose.Types.ObjectId().toString(),
    type: messageData.type,
    content: messageData.content,
    timestamp: new Date(),
    metadata: messageData.metadata || {}
  };
  
  this.messages.push(message);
  this.lastActivityAt = new Date();
  
  return this.save();
};

assistantSessionSchema.methods.updateContext = function(contextUpdates) {
  Object.assign(this.aiContext, contextUpdates);
  return this.save();
};

assistantSessionSchema.methods.addResumeEdit = function(editData) {
  const edit = {
    timestamp: new Date(),
    section: editData.section,
    changeType: editData.changeType,
    originalContent: editData.originalContent,
    suggestedContent: editData.suggestedContent,
    finalContent: editData.finalContent,
    aiReasoning: editData.aiReasoning
  };
  
  this.resumeEditHistory.push(edit);
  
  if (editData.changeType === 'applied') {
    this.analytics.resumeChangesApplied += 1;
  }
  
  return this.save();
};

assistantSessionSchema.methods.endSession = function(endData = {}) {
  this.status = 'ended';
  this.endedAt = new Date();
  
  if (endData.userSatisfactionRating) {
    this.analytics.userSatisfactionRating = endData.userSatisfactionRating;
  }
  
  if (endData.helpfulnessRating) {
    this.analytics.helpfulnessRating = endData.helpfulnessRating;
  }
  
  return this.save();
};

assistantSessionSchema.methods.getRecentMessages = function(limit = 10) {
  return this.messages.slice(-limit);
};

assistantSessionSchema.methods.getContextSummary = function() {
  return {
    sessionId: this.sessionId,
    context: this.context,
    resumeName: this.resumeSnapshot?.name,
    messageCount: this.messages.length,
    keyTopics: this.aiContext.keyTopicsDiscussed,
    userPreferences: this.aiContext.userPreferences,
    conversationSummary: this.aiContext.conversationSummary
  };
};

// Static methods
assistantSessionSchema.statics.findActiveSession = function(userId, resumeId = null) {
  const query = { 
    userId, 
    status: 'active',
    expiresAt: { $gt: new Date() }
  };
  
  if (resumeId) {
    query.resumeId = resumeId;
  }
  
  return this.findOne(query).sort({ lastActivityAt: -1 });
};

// Continuation of assistantSession.model.js

assistantSessionSchema.statics.getUserSessions = function(userId, limit = 20) {
  return this.find({ userId })
    .sort({ lastActivityAt: -1 })
    .limit(limit)
    .select('sessionId context resumeSnapshot.name analytics startedAt lastActivityAt status');
};

assistantSessionSchema.statics.getSessionAnalytics = function(userId, timeframe = '30d') {
  const startDate = new Date();
  
  switch(timeframe) {
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(startDate.getDate() - 90);
      break;
  }

  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        startedAt: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: null,
        totalSessions: { $sum: 1 },
        totalMessages: { $sum: '$analytics.totalMessages' },
        totalTokensUsed: { $sum: '$analytics.totalTokensUsed' },
        totalResumeChanges: { $sum: '$analytics.resumeChangesApplied' },
        avgSessionLength: { $avg: '$analytics.sessionsLength' },
        avgSatisfactionRating: { $avg: '$analytics.userSatisfactionRating' },
        avgHelpfulnessRating: { $avg: '$analytics.helpfulnessRating' }
      }
    }
  ]);
};

assistantSessionSchema.statics.cleanupExpiredSessions = function() {
  return this.updateMany(
    { 
      status: 'active',
      expiresAt: { $lt: new Date() }
    },
    { 
      $set: { 
        status: 'expired',
        endedAt: new Date()
      }
    }
  );
};

// Virtual for session duration
assistantSessionSchema.virtual('duration').get(function() {
  if (this.endedAt) {
    return Math.round((this.endedAt - this.startedAt) / 1000);
  }
  return Math.round((new Date() - this.startedAt) / 1000);
});

// Virtual for session summary
assistantSessionSchema.virtual('summary').get(function() {
  return {
    id: this.sessionId,
    duration: this.duration,
    messageCount: this.messages.length,
    resumeName: this.resumeSnapshot?.name,
    context: this.context,
    changesApplied: this.analytics.resumeChangesApplied,
    isActive: this.status === 'active',
    lastActivity: this.lastActivityAt
  };
});

module.exports = mongoose.model('AssistantSession', assistantSessionSchema);

================
File: models/mongodb/conversation.model.js
================
// backend/models/mongodb/conversation.model.js
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true
  },
  type: {
    type: String,
    enum: ['user', 'ai', 'system'],
    required: true
  },
  content: {
    type: String,
    required: true
  },
  metadata: {
    tokens: Number,
    model: String,
    temperature: Number,
    context: {
      page: String,
      resumeId: String,
      jobId: String,
      action: String
    },
    suggestions: [String],
    actions: [{
      type: String,
      confidence: Number,
      data: mongoose.Schema.Types.Mixed
    }],
    sentiment: {
      score: Number,
      magnitude: Number,
      label: String
    }
  },
  attachments: [{
    type: String,
    name: String,
    url: String,
    size: Number
  }],
  isEdited: {
    type: Boolean,
    default: false
  },
  editHistory: [{
    originalContent: String,
    editedAt: Date,
    reason: String
  }]
}, {
  timestamps: true,
  _id: false
});

const conversationSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  category: {
    type: String,
    enum: [
      'resume_help',
      'job_search',
      'career_advice',
      'interview_prep',
      'skill_development',
      'general',
      'troubleshooting'
    ],
    default: 'general'
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  messages: [messageSchema],
  summary: {
    content: String,
    keyTopics: [String],
    actionItems: [String],
    outcomes: [String],
    generatedAt: Date,
    version: {
      type: Number,
      default: 1
    }
  },
  context: {
    primaryResumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    },
    relatedJobIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    }],
    skillsFocused: [String],
    careerGoals: [String],
    userSentiment: {
      overall: String,
      trend: String,
      lastUpdated: Date
    }
  },
  analytics: {
    messageCount: {
      type: Number,
      default: 0
    },
    tokensUsed: {
      type: Number,
      default: 0
    },
    averageResponseTime: {
      type: Number,
      default: 0
    },
    userSatisfaction: {
      rating: Number,
      feedback: String,
      ratedAt: Date
    },
    topActions: [{
      action: String,
      count: Number
    }],
    engagementScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    }
  },
  settings: {
    memoryEnabled: {
      type: Boolean,
      default: true
    },
    autoSummarize: {
      type: Boolean,
      default: true
    },
    shareWithTeam: {
      type: Boolean,
      default: false
    },
    archiveAfterDays: {
      type: Number,
      default: 90
    }
  },
  status: {
    type: String,
    enum: ['active', 'archived', 'deleted'],
    default: 'active'
  },
  lastActiveAt: {
    type: Date,
    default: Date.now
  },
  pinned: {
    type: Boolean,
    default: false
  },
  starred: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});

// Indexes for performance
conversationSchema.index({ userId: 1, status: 1, lastActiveAt: -1 });
conversationSchema.index({ userId: 1, category: 1 });
conversationSchema.index({ userId: 1, tags: 1 });
conversationSchema.index({ 'messages.type': 1, 'messages.createdAt': -1 });
conversationSchema.index({ 'summary.keyTopics': 1 });
conversationSchema.index({ lastActiveAt: -1 });

// Virtual for message count
conversationSchema.virtual('totalMessages').get(function() {
  return this.messages.length;
});

// Virtual for last message
conversationSchema.virtual('lastMessage').get(function() {
  return this.messages.length > 0 ? this.messages[this.messages.length - 1] : null;
});

// Pre-save middleware to update analytics
conversationSchema.pre('save', function(next) {
  if (this.isModified('messages')) {
    this.analytics.messageCount = this.messages.length;
    this.analytics.tokensUsed = this.messages.reduce((total, msg) => {
      return total + (msg.metadata?.tokens || 0);
    }, 0);
    this.lastActiveAt = new Date();
  }
  next();
});

// Instance methods
conversationSchema.methods.addMessage = function(messageData) {
  const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  const message = {
    id: messageId,
    type: messageData.type,
    content: messageData.content,
    metadata: messageData.metadata || {},
    attachments: messageData.attachments || [],
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  this.messages.push(message);
  this.lastActiveAt = new Date();
  
  return message;
};

conversationSchema.methods.getRecentMessages = function(limit = 10) {
  return this.messages
    .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
    .slice(0, limit);
};

conversationSchema.methods.getMessagesByType = function(type) {
  return this.messages.filter(msg => msg.type === type);
};

conversationSchema.methods.searchMessages = function(query) {
  const searchRegex = new RegExp(query, 'i');
  return this.messages.filter(msg => 
    searchRegex.test(msg.content) || 
    (msg.metadata?.suggestions && msg.metadata.suggestions.some(s => searchRegex.test(s)))
  );
};

conversationSchema.methods.updateSummary = function(summaryData) {
  this.summary = {
    ...this.summary,
    ...summaryData,
    generatedAt: new Date(),
    version: (this.summary?.version || 0) + 1
  };
};

conversationSchema.methods.calculateEngagementScore = function() {
  const messageCount = this.messages.length;
  const userMessages = this.messages.filter(m => m.type === 'user').length;
  const aiMessages = this.messages.filter(m => m.type === 'ai').length;
  
  // Base score on conversation length
  let score = Math.min(messageCount * 2, 40);
  
  // Bonus for balanced conversation
  if (userMessages > 0 && aiMessages > 0) {
    const balance = Math.min(userMessages, aiMessages) / Math.max(userMessages, aiMessages);
    score += balance * 20;
  }
  
  // Bonus for user actions taken
  const actionCount = this.messages.reduce((count, msg) => {
    return count + (msg.metadata?.actions?.length || 0);
  }, 0);
  score += Math.min(actionCount * 5, 20);
  
  // Bonus for user satisfaction
  if (this.analytics.userSatisfaction?.rating) {
    score += (this.analytics.userSatisfaction.rating / 5) * 20;
  }
  
  this.analytics.engagementScore = Math.min(Math.round(score), 100);
  return this.analytics.engagementScore;
};

// Static methods
conversationSchema.statics.findByUserId = function(userId, options = {}) {
  const query = { userId, status: { $ne: 'deleted' } };
  
  if (options.category) query.category = options.category;
  if (options.tags && options.tags.length > 0) query.tags = { $in: options.tags };
  if (options.pinned !== undefined) query.pinned = options.pinned;
  if (options.starred !== undefined) query.starred = options.starred;
  
  return this.find(query)
    .sort(options.sort || { lastActiveAt: -1 })
    .limit(options.limit || 50)
    .populate('context.primaryResumeId', 'name analysis.overallScore')
    .populate('context.relatedJobIds', 'title company');
};

conversationSchema.statics.searchConversations = function(userId, searchQuery, options = {}) {
  const searchRegex = new RegExp(searchQuery, 'i');
  
  return this.find({
    userId,
    status: { $ne: 'deleted' },
    $or: [
      { title: searchRegex },
      { description: searchRegex },
      { tags: searchRegex },
      { 'summary.keyTopics': searchRegex },
      { 'messages.content': searchRegex }
    ]
  })
  .sort({ lastActiveAt: -1 })
  .limit(options.limit || 20);
};

conversationSchema.statics.getConversationStats = function(userId) {
  return this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId), status: { $ne: 'deleted' } } },
    {
      $group: {
        _id: null,
        totalConversations: { $sum: 1 },
        totalMessages: { $sum: '$analytics.messageCount' },
        totalTokens: { $sum: '$analytics.tokensUsed' },
        avgEngagement: { $avg: '$analytics.engagementScore' },
        categoriesCount: { $addToSet: '$category' }
      }
    }
  ]);
};

// Text search index
conversationSchema.index({
  title: 'text',
  description: 'text',
  'messages.content': 'text',
  'summary.keyTopics': 'text'
});

const Conversation = mongoose.model('Conversation', conversationSchema);

module.exports = Conversation;

================
File: models/mongodb/job.model.js
================
// models/mongodb/job.model.js - ENHANCED FOR REAL JOB BOARD INTEGRATION
const mongoose = require('mongoose');

const jobSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    index: true
  },
  company: {
    type: String,
    required: true,
    index: true
  },
  location: {
    city: String,
    state: String,
    country: String,
    remote: Boolean,
    fullAddress: String
  },
  description: {
    type: String,
    required: true
  },
  sourceUrl: {
    type: String,
    index: true
  },
  sourcePlatform: {
    type: String,
    enum: [
      'MANUAL',
      'AI_FOUND',
      'AI_FOUND_OPTIMIZED', 
      'AI_FOUND_INTELLIGENT',
      // NEW: Real job board platforms
      'AI_FOUND_GREENHOUSE',
      'AI_FOUND_LEVER', 
      'AI_FOUND_INDEED'
    ],
    default: 'MANUAL',
    index: true
  },
  salary: {
    min: Number,
    max: Number,
    currency: {
      type: String,
      default: 'USD'
    },
    isExplicit: Boolean
  },
  jobType: {
    type: String,
    enum: ['FULL_TIME', 'PART_TIME', 'CONTRACT', 'FREELANCE', 'INTERNSHIP', 'TEMPORARY'],
    default: 'FULL_TIME'
  },
  applicationStatus: {
    type: String,
    enum: ['NOT_APPLIED', 'APPLIED', 'INTERVIEW', 'OFFER', 'REJECTED', 'WITHDRAWN'],
    default: 'NOT_APPLIED',
    index: true
  },
  applicationDate: Date,
  isAiGenerated: {
    type: Boolean,
    default: false,
    index: true
  },
  aiSearchId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'AiJobSearch',
    index: true
  },
  
  // Enhanced parsed data with real job board support
  parsedData: {
    requirements: [String],
    responsibilities: [String],
    qualifications: {
      required: [String],
      preferred: [String]
    },
    benefits: [String],
    keySkills: [{
      name: String,
      importance: {
        type: Number,
        min: 1,
        max: 10
      },
      category: {
        type: String,
        enum: ['technical', 'soft', 'domain', 'certification']
      },
      skillType: String
    }],
    experienceLevel: {
      type: String,
      enum: ['entry', 'junior', 'mid', 'senior', 'lead', 'principal', 'executive']
    },
    yearsOfExperience: {
      minimum: Number,
      preferred: Number
    },
    educationRequirements: [String],
    workArrangement: {
      type: String,
      enum: ['remote', 'hybrid', 'onsite', 'unknown']
    },
    industryContext: String,
    roleCategory: String,
    seniorityLevel: String,
    technicalComplexity: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    leadershipRequired: Boolean,
    certifications: [String],
    softSkills: [String],
    technicalSkills: [String],
    toolsAndTechnologies: [String],
    companySize: String,
    extractedAt: Date,
    extractionMethod: String,
    
    // NEW: Enhanced real job board specific data
    realJobBoardData: {
      platform: {
        type: String,
        enum: ['Greenhouse', 'Lever', 'Indeed']
      },
      originalUrl: String,
      postedDate: Date,
      applicationDeadline: Date,
      hiringManager: String,
      teamSize: String,
      techStack: [String],
      department: String,
      directCompanyPosting: {
        type: Boolean,
        default: false
      },
      atsSystem: String,
      jobBoardSpecificData: {
        // Greenhouse specific
        greenhouseJobId: String,
        greenhouseOfficeId: String,
        
        // Lever specific
        leverPostingId: String,
        leverTeam: String,
        
        // Indeed specific
        indeedJobKey: String,
        indeedCompanyId: String
      }
    },
    
    analysisMetadata: {
      analyzedAt: Date,
      algorithmVersion: String,
      model: String,
      originalLength: Number,
      extractedSkillsCount: Number,
      costOptimized: Boolean,
      analysisType: String,
      estimatedCost: String,
      qualityLevel: String,
      sourceJobBoard: String,
      realJobBoardPosting: Boolean
    }
  },
  
  // Enhanced AI search metadata for real job boards
  aiSearchMetadata: {
    searchScore: Number,
    discoveryMethod: String,
    extractionSuccess: Boolean,
    contentQuality: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    premiumAnalysis: Boolean,
    intelligentDiscovery: Boolean,
    realJobBoardDiscovery: Boolean,
    phase: String,
    originalJobBoard: String,
    postedDate: Date,
    workArrangement: String,
    experienceLevel: String,
    department: String,
    companySize: String,
    industry: String,
    keyRequirements: [String],
    matchReason: String,
    benefits: [String],
    techStack: [String],
    teamInfo: {
      hiringManager: String,
      teamSize: String,
      department: String
    },
    
    // NEW: Real job board quality metrics
    jobBoardQualityMetrics: {
      urlValidated: Boolean,
      contentLength: Number,
      hasComprehensiveDetails: Boolean,
      hasTechStack: Boolean,
      hasTeamInfo: Boolean,
      hasApplicationDeadline: Boolean,
      verifiedCompanyPosting: Boolean
    }
  },
  
  // Analysis status for tracking background processing
  analysisStatus: {
    status: {
      type: String,
      enum: ['pending', 'analyzing', 'completed', 'error'],
      default: 'pending'
    },
    progress: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    message: String,
    startedAt: Date,
    completedAt: Date,
    updatedAt: Date,
    canViewJob: {
      type: Boolean,
      default: true
    },
    skillsFound: Number,
    experienceLevel: String,
    modelUsed: String,
    analysisType: String,
    error: String,
    estimatedCompletion: Date
  },
  
  // Match analysis results
  matchAnalysis: {
    resumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    },
    overallScore: Number,
    categoryScores: {
      skills: Number,
      experience: Number,
      education: Number
    },
    matchedSkills: [{
      skill: String,
      found: Boolean,
      importance: Number,
      resumeStrength: Number
    }],
    missingSkills: [{
      skill: String,
      importance: Number,
      suggestionToAdd: String
    }],
    strengthAreas: [String],
    improvementAreas: [String],
    lastAnalyzed: Date,
    analysisMetadata: {
      algorithmVersion: String,
      modelUsed: String
    }
  },
  
  // Cover letter reference
  coverLetterId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'CoverLetter'
  },
  
  // Notes and interactions
  notes: [{
    content: String,
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // User interactions
  userInteractions: {
    viewCount: {
      type: Number,
      default: 0
    },
    lastViewed: Date,
    bookmarked: {
      type: Boolean,
      default: false
    },
    bookmarkedAt: Date,
    applied: {
      type: Boolean,
      default: false
    },
    appliedAt: Date,
    rating: {
      type: Number,
      min: 1,
      max: 5
    },
    feedback: String
  }
}, {
  timestamps: true
});

// Indexes for better performance
jobSchema.index({ userId: 1, createdAt: -1 });
jobSchema.index({ userId: 1, applicationStatus: 1 });
jobSchema.index({ userId: 1, sourcePlatform: 1 });
jobSchema.index({ userId: 1, 'parsedData.experienceLevel': 1 });
jobSchema.index({ userId: 1, 'parsedData.workArrangement': 1 });
jobSchema.index({ title: 'text', company: 'text', description: 'text' });
jobSchema.index({ 'parsedData.keySkills.name': 1 });
jobSchema.index({ aiSearchId: 1 });
jobSchema.index({ sourceUrl: 1 });

// NEW: Indexes for real job board queries
jobSchema.index({ 'parsedData.realJobBoardData.platform': 1 });
jobSchema.index({ 'parsedData.realJobBoardData.directCompanyPosting': 1 });
jobSchema.index({ 'aiSearchMetadata.realJobBoardDiscovery': 1 });
jobSchema.index({ 'aiSearchMetadata.originalJobBoard': 1 });

// Compound indexes for common queries
jobSchema.index({ userId: 1, sourcePlatform: 1, createdAt: -1 });
jobSchema.index({ userId: 1, applicationStatus: 1, createdAt: -1 });
jobSchema.index({ userId: 1, 'matchAnalysis.overallScore': -1 });

// Virtual for checking if job is from real job boards
jobSchema.virtual('isFromRealJobBoard').get(function() {
  return this.sourcePlatform && (
    this.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
    this.sourcePlatform.includes('AI_FOUND_LEVER') ||
    this.sourcePlatform.includes('AI_FOUND_INDEED')
  );
});

// Virtual for getting source job board name
jobSchema.virtual('sourceJobBoardName').get(function() {
  if (!this.isFromRealJobBoard) return null;
  
  if (this.sourcePlatform.includes('GREENHOUSE')) return 'Greenhouse';
  if (this.sourcePlatform.includes('LEVER')) return 'Lever';
  if (this.sourcePlatform.includes('INDEED')) return 'Indeed';
  return null;
});

// Virtual for enhanced job quality score
jobSchema.virtual('qualityScore').get(function() {
  let score = 50; // Base score
  
  // Real job board bonus
  if (this.isFromRealJobBoard) score += 20;
  
  // Content quality
  if (this.aiSearchMetadata?.contentQuality === 'high') score += 15;
  else if (this.aiSearchMetadata?.contentQuality === 'medium') score += 10;
  
  // Premium analysis bonus
  if (this.aiSearchMetadata?.premiumAnalysis) score += 10;
  
  // Comprehensive details bonus
  if (this.aiSearchMetadata?.jobBoardQualityMetrics?.hasComprehensiveDetails) score += 5;
  
  return Math.min(score, 100);
});

// Method to check if job analysis is complete
jobSchema.methods.isAnalysisComplete = function() {
  return this.analysisStatus?.status === 'completed' &&
         this.parsedData && 
         Object.keys(this.parsedData).length > 0 && 
         !this.parsedData.analysisError;
};

// Method to get real job board specific data
jobSchema.methods.getRealJobBoardData = function() {
  if (!this.isFromRealJobBoard) return null;
  
  return {
    platform: this.sourceJobBoardName,
    originalUrl: this.parsedData?.realJobBoardData?.originalUrl,
    postedDate: this.parsedData?.realJobBoardData?.postedDate,
    techStack: this.parsedData?.realJobBoardData?.techStack || [],
    hiringManager: this.parsedData?.realJobBoardData?.hiringManager,
    teamSize: this.parsedData?.realJobBoardData?.teamSize,
    department: this.parsedData?.realJobBoardData?.department,
    directCompanyPosting: this.parsedData?.realJobBoardData?.directCompanyPosting || false,
    qualityMetrics: this.aiSearchMetadata?.jobBoardQualityMetrics || {}
  };
};

// Method to update user interaction
jobSchema.methods.recordUserInteraction = function(interactionType, data = {}) {
  if (!this.userInteractions) {
    this.userInteractions = { viewCount: 0 };
  }
  
  switch (interactionType) {
    case 'view':
      this.userInteractions.viewCount += 1;
      this.userInteractions.lastViewed = new Date();
      break;
    case 'bookmark':
      this.userInteractions.bookmarked = true;
      this.userInteractions.bookmarkedAt = new Date();
      break;
    case 'unbookmark':
      this.userInteractions.bookmarked = false;
      this.userInteractions.bookmarkedAt = null;
      break;
    case 'apply':
      this.userInteractions.applied = true;
      this.userInteractions.appliedAt = new Date();
      this.applicationStatus = 'APPLIED';
      this.applicationDate = new Date();
      break;
    case 'rate':
      this.userInteractions.rating = data.rating;
      this.userInteractions.feedback = data.feedback;
      break;
  }
  
  return this.save();
};

// Static method to find jobs from real job boards
jobSchema.statics.findRealJobBoardJobs = function(userId, options = {}) {
  const query = {
    userId,
    sourcePlatform: {
      $in: ['AI_FOUND_GREENHOUSE', 'AI_FOUND_LEVER', 'AI_FOUND_INDEED']
    }
  };
  
  if (options.jobBoard) {
    query.sourcePlatform = `AI_FOUND_${options.jobBoard.toUpperCase()}`;
  }
  
  if (options.dateRange) {
    query.createdAt = {
      $gte: options.dateRange.start,
      $lte: options.dateRange.end
    };
  }
  
  return this.find(query).sort({ createdAt: -1 });
};

// Static method to get real job board statistics
jobSchema.statics.getRealJobBoardStats = function(userId) {
  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        sourcePlatform: {
          $in: ['AI_FOUND_GREENHOUSE', 'AI_FOUND_LEVER', 'AI_FOUND_INDEED']
        }
      }
    },
    {
      $group: {
        _id: '$sourcePlatform',
        count: { $sum: 1 },
        avgQualityScore: { $avg: '$aiSearchMetadata.searchScore' },
        totalViews: { $sum: '$userInteractions.viewCount' },
        appliedJobs: {
          $sum: {
            $cond: [{ $eq: ['$applicationStatus', 'APPLIED'] }, 1, 0]
          }
        }
      }
    },
    {
      $project: {
        jobBoard: {
          $switch: {
            branches: [
              { case: { $eq: ['$_id', 'AI_FOUND_GREENHOUSE'] }, then: 'Greenhouse' },
              { case: { $eq: ['$_id', 'AI_FOUND_LEVER'] }, then: 'Lever' },
              { case: { $eq: ['$_id', 'AI_FOUND_INDEED'] }, then: 'Indeed' }
            ],
            default: 'Unknown'
          }
        },
        count: 1,
        avgQualityScore: { $round: ['$avgQualityScore', 1] },
        totalViews: 1,
        appliedJobs: 1,
        applicationRate: {
          $round: [{ $multiply: [{ $divide: ['$appliedJobs', '$count'] }, 100] }, 1]
        }
      }
    }
  ]);
};

// Pre-save middleware
jobSchema.pre('save', function(next) {
  // Auto-detect real job board from source platform
  if (this.isModified('sourcePlatform') && this.isFromRealJobBoard) {
    if (!this.aiSearchMetadata) this.aiSearchMetadata = {};
    this.aiSearchMetadata.realJobBoardDiscovery = true;
    this.aiSearchMetadata.originalJobBoard = this.sourceJobBoardName;
  }
  
  // Ensure real job board data consistency
  if (this.isFromRealJobBoard && this.parsedData?.realJobBoardData) {
    this.parsedData.realJobBoardData.platform = this.sourceJobBoardName;
    this.parsedData.realJobBoardData.directCompanyPosting = true;
  }
  
  next();
});

// Post-save middleware for analytics
jobSchema.post('save', function(doc) {
  // Could trigger analytics events here for real job board tracking
  if (doc.isFromRealJobBoard && doc.isNew) {
    console.log(`ðŸ“Š New real job board job saved: ${doc.title} from ${doc.sourceJobBoardName}`);
  }
});

module.exports = mongoose.model('Job', jobSchema);

================
File: models/mongodb/outreach.model.js
================
// backend/models/mongodb/outreach.model.js
const mongoose = require('mongoose');

const replySchema = new mongoose.Schema({
  content: {
    type: String,
    required: true
  },
  receivedAt: {
    type: Date,
    default: Date.now
  },
  sentiment: {
    type: String,
    enum: ['positive', 'neutral', 'negative'],
    default: 'neutral'
  },
  extractedInfo: {
    nextSteps: [String],
    scheduledMeeting: {
      type: Boolean,
      default: false
    },
    referralMade: {
      type: Boolean,
      default: false
    }
  }
}, {
  timestamps: true,
  _id: true
});

const followUpSchema = new mongoose.Schema({
  content: {
    type: String,
    required: true
  },
  sentAt: {
    type: Date,
    default: Date.now
  },
  status: {
    type: String,
    enum: ['drafted', 'sent', 'replied'],
    default: 'drafted'
  },
  type: {
    type: String,
    enum: ['reminder', 'additional_info', 'thank_you', 'check_in'],
    default: 'reminder'
  },
  scheduledFor: Date
}, {
  timestamps: true,
  _id: true
});

const outreachSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  recruiterId: {
    type: String, // PostgreSQL recruiter ID
    required: true,
    index: true
  },
  jobId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Job',
    index: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    index: true
  },
  
  // Message content
  messageContent: {
    type: String,
    required: true
  },
  messageTemplate: {
    type: String,
    enum: ['introduction', 'follow_up', 'application', 'thank_you', 'custom'],
    default: 'custom'
  },
  subject: String,
  
  // Customizations and personalization
  customizations: [{
    type: {
      type: String,
      enum: ['tone_adjustment', 'content_addition', 'length_modification', 'style_change']
    },
    description: String,
    appliedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // AI generation metadata
  aiGenerated: {
    type: Boolean,
    default: false
  },
  aiMetadata: {
    model: String,
    tokensUsed: Number,
    confidence: Number,
    generatedAt: Date,
    prompt: String
  },
  
  // Communication details
  sentVia: {
    type: String,
    enum: ['email', 'linkedin', 'phone', 'other'],
    default: 'linkedin'
  },
  status: {
    type: String,
    enum: ['drafted', 'sent', 'delivered', 'opened', 'replied', 'no_reply', 'bounced'],
    default: 'drafted'
  },
  
  // Timing
  sentAt: Date,
  deliveredAt: Date,
  openedAt: Date,
  scheduledFor: Date,
  
  // Responses and follow-ups
  replies: [replySchema],
  followUps: [followUpSchema],
  
  // Tracking and analytics
  analytics: {
    views: {
      type: Number,
      default: 0
    },
    clicks: {
      type: Number,
      default: 0
    },
    responseTime: Number, // Time to first response in hours
    engagementScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    }
  },
  
  // Campaign information
  campaignId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Campaign'
  },
  campaignName: String,
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  
  // Outcome tracking
  outcome: {
    result: {
      type: String,
      enum: ['meeting_scheduled', 'referral_received', 'application_submitted', 'no_response', 'not_interested', 'connection_made']
    },
    notes: String,
    nextSteps: [String],
    followUpDate: Date
  },
  
  // Tags and categorization
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  category: {
    type: String,
    enum: ['cold_outreach', 'warm_introduction', 'referral_request', 'application_follow_up', 'networking'],
    default: 'cold_outreach'
  },
  
  // Relationship context
  relationship: {
    connectionLevel: {
      type: String,
      enum: ['1st', '2nd', '3rd', 'none'],
      default: 'none'
    },
    mutualConnections: [String],
    previousInteractions: [{
      date: Date,
      type: String,
      notes: String
    }]
  },
  
  // Reminders and notifications
  reminders: [{
    type: {
      type: String,
      enum: ['follow_up', 'response_check', 'next_action']
    },
    scheduledFor: Date,
    completed: {
      type: Boolean,
      default: false
    },
    completedAt: Date
  }],
  
  // Integration data
  integrations: {
    linkedinMessageId: String,
    emailMessageId: String,
    crmId: String,
    externalData: mongoose.Schema.Types.Mixed
  },
  
  // Archival and cleanup
  isActive: {
    type: Boolean,
    default: true
  },
  archivedAt: Date,
  archivedReason: String,
  
  // User notes
  notes: String,
  privateNotes: String,
  
}, {
  timestamps: true
});

// Indexes for performance
outreachSchema.index({ userId: 1, status: 1 });
outreachSchema.index({ userId: 1, createdAt: -1 });
outreachSchema.index({ recruiterId: 1, userId: 1 });
outreachSchema.index({ jobId: 1 });
outreachSchema.index({ status: 1, sentAt: 1 });
outreachSchema.index({ campaignId: 1 });
outreachSchema.index({ scheduledFor: 1 });
outreachSchema.index({ 'reminders.scheduledFor': 1, 'reminders.completed': 1 });

// Text search index
outreachSchema.index({
  messageContent: 'text',
  subject: 'text',
  notes: 'text',
  tags: 'text'
});

// Virtual for response time calculation
outreachSchema.virtual('responseTimeHours').get(function() {
  if (this.sentAt && this.replies && this.replies.length > 0) {
    const firstReply = this.replies[0];
    return Math.round((firstReply.receivedAt - this.sentAt) / (1000 * 60 * 60));
  }
  return null;
});

// Virtual for days since sent
outreachSchema.virtual('daysSinceSent').get(function() {
  if (this.sentAt) {
    return Math.floor((Date.now() - this.sentAt) / (1000 * 60 * 60 * 24));
  }
  return null;
});

// Virtual for reply count
outreachSchema.virtual('replyCount').get(function() {
  return this.replies ? this.replies.length : 0;
});

// Virtual for follow-up count
outreachSchema.virtual('followUpCount').get(function() {
  return this.followUps ? this.followUps.length : 0;
});

// Pre-save middleware
outreachSchema.pre('save', function(next) {
  // Update engagement score based on interactions
  if (this.isModified('replies') || this.isModified('analytics')) {
    this.calculateEngagementScore();
  }
  
  // Update response time
  if (this.isModified('replies') && this.replies.length > 0 && this.sentAt) {
    const firstReply = this.replies[0];
    this.analytics.responseTime = (firstReply.receivedAt - this.sentAt) / (1000 * 60 * 60);
  }
  
  next();
});

// Instance methods
outreachSchema.methods.addReply = function(replyData) {
  this.replies.push({
    content: replyData.content,
    receivedAt: replyData.receivedAt || new Date(),
    sentiment: replyData.sentiment || 'neutral',
    extractedInfo: replyData.extractedInfo || {}
  });
  
  // Update status
  if (this.status === 'sent' || this.status === 'delivered') {
    this.status = 'replied';
  }
  
  return this.save();
};

outreachSchema.methods.addFollowUp = function(followUpData) {
  this.followUps.push({
    content: followUpData.content,
    type: followUpData.type || 'reminder',
    scheduledFor: followUpData.scheduledFor,
    status: followUpData.status || 'drafted'
  });
  
  return this.save();
};

outreachSchema.methods.markAsSent = function() {
  this.status = 'sent';
  this.sentAt = new Date();
  
  // Schedule follow-up reminder if not replied within 7 days
  this.reminders.push({
    type: 'follow_up',
    scheduledFor: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  });
  
  return this.save();
};

outreachSchema.methods.calculateEngagementScore = function() {
  let score = 0;
  
  // Base score for being sent
  if (this.status === 'sent' || this.status === 'delivered' || this.status === 'replied') {
    score += 20;
  }
  
  // Bonus for being opened/delivered
  if (this.status === 'delivered' || this.status === 'opened' || this.status === 'replied') {
    score += 20;
  }
  
  // Major bonus for replies
  score += Math.min(this.replies.length * 30, 60);
  
  // Bonus for positive sentiment
  const positivReplies = this.replies.filter(r => r.sentiment === 'positive').length;
  score += positiveReplies * 10;
  
  // Bonus for quick response
  if (this.analytics.responseTime && this.analytics.responseTime <= 24) {
    score += 15;
  }
  
  // Bonus for follow-ups
  score += Math.min(this.followUps.length * 5, 15);
  
  this.analytics.engagementScore = Math.min(score, 100);
  return this.analytics.engagementScore;
};

outreachSchema.methods.scheduleReminder = function(type, date) {
  this.reminders.push({
    type: type,
    scheduledFor: date,
    completed: false
  });
  
  return this.save();
};

outreachSchema.methods.markReminderComplete = function(reminderId) {
  const reminder = this.reminders.id(reminderId);
  if (reminder) {
    reminder.completed = true;
    reminder.completedAt = new Date();
  }
  
  return this.save();
};

// Static methods
outreachSchema.statics.findByRecruiter = function(recruiterId, userId, options = {}) {
  const query = { recruiterId, userId };
  
  if (options.status) {
    query.status = options.status;
  }
  
  return this.find(query)
    .sort(options.sort || { createdAt: -1 })
    .limit(options.limit || 10);
};

outreachSchema.statics.getAnalytics = function(userId, timeframe = '30d') {
  const startDate = new Date();
  
  switch(timeframe) {
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(startDate.getDate() - 90);
      break;
  }

  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        createdAt: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: null,
        totalOutreach: { $sum: 1 },
        sent: { $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] } },
        replied: { $sum: { $cond: [{ $eq: ['$status', 'replied'] }, 1, 0] } },
        avgEngagement: { $avg: '$analytics.engagementScore' },
        avgResponseTime: { $avg: '$analytics.responseTime' }
      }
    }
  ]);
};

outreachSchema.statics.findPendingReminders = function() {
  return this.find({
    'reminders.scheduledFor': { $lte: new Date() },
    'reminders.completed': false,
    isActive: true
  });
};

outreachSchema.statics.getTopPerformingTemplates = function(userId, limit = 5) {
  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        status: { $in: ['sent', 'replied'] }
      }
    },
    {
      $group: {
        _id: '$messageTemplate',
        count: { $sum: 1 },
        responseRate: {
          $avg: {
            $cond: [{ $eq: ['$status', 'replied'] }, 1, 0]
          }
        },
        avgEngagement: { $avg: '$analytics.engagementScore' }
      }
    },
    {
      $sort: { responseRate: -1, avgEngagement: -1 }
    },
    {
      $limit: limit
    }
  ]);
};

const Outreach = mongoose.model('Outreach', outreachSchema);

module.exports = Outreach;

================
File: models/mongodb/resume.model.js
================
// models/mongodb/resume.model.js
const mongoose = require('mongoose');

const resumeSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  processingStatus: {
    status: {
      type: String,
      enum: ['pending', 'uploading', 'parsing', 'analyzing', 'completed', 'error'],
      default: 'pending'
    },
    progress: {
      type: Number,
      default: 0,
      min: 0,
      max: 100
    },
    message: {
      type: String,
      default: ''
    },
    error: {
      type: String,
      default: ''
    },
    updatedAt: {
      type: Date,
      default: Date.now
    }
  },
  name: {
    type: String,
    required: true
  },
  originalFilename: {
    type: String,
    required: true
  },
  fileUrl: {
    type: String,
    required: true
  },
  fileType: {
    type: String,
    enum: ['PDF', 'DOCX', 'DOC'],
    required: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  parsedData: {
    contactInfo: {
      name: String,
      email: String,
      phone: String,
      location: String,
      websites: [String]
    },
    summary: String,
    experience: [{
      company: String,
      title: String,
      location: String,
      startDate: Date,
      endDate: Date,
      description: String,
      highlights: [String],
      skills: [String]
    }],
    education: [{
      institution: String,
      degree: String,
      field: String,
      startDate: Date,
      endDate: Date,
      gpa: Number,
      highlights: [String]
    }],
    skills: [{
      name: String,
      level: String,
      yearsOfExperience: Number
    }],
    certifications: [{
      name: String,
      issuer: String,
      dateObtained: Date,
      validUntil: Date
    }],
    languages: [{
      language: String,
      proficiency: String
    }],
    projects: [{
      name: String,
      description: String,
      url: String,
      startDate: Date,
      endDate: Date,
      skills: [String]
    }]
  },
  analysis: {
    overallScore: Number,
    atsCompatibility: Number,
    profileSummary: {
      currentRole: String,
      careerLevel: String,
      industries: [String],
      suggestedJobTitles: [String],
      suggestedIndustries: [String]
    },
    strengths: [String],
    weaknesses: [String],
    keywordsSuggestions: [String],
    improvementAreas: [{
      section: String,
      suggestions: [String],
      improvedSnippets: [{
        original: String,
        improved: String
      }]
    }]
  },
  // New fields for tailored resumes
  isTailored: {
    type: Boolean,
    default: false
  },
  tailoredForJob: {
    jobId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    },
    jobTitle: String,
    company: String,
    originalResumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    }
  },
  versions: [{
    versionNumber: Number,
    createdAt: Date,
    fileUrl: String,
    changesDescription: String,
    jobId: mongoose.Schema.Types.ObjectId
  }],
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Resume', resumeSchema);

================
File: models/mongodb/user.model.js
================
// backend/models/mongodb/user.model.js
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const crypto = require('crypto');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Please provide an email'],
    unique: true,
    trim: true,
    lowercase: true,
    match: [
      /^([\w-\.]+@([\w-]+\.)+[\w-]{2,4})?$/,
      'Please provide a valid email'
    ]
  },
  password: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: [8, 'Password should be at least 8 characters'],
    select: false // Don't return password by default
  },
  firstName: {
    type: String,
    required: [true, 'Please provide your first name'],
    trim: true
  },
  lastName: {
    type: String,
    required: [true, 'Please provide your last name'],
    trim: true
  },
  profilePicture: {
    type: String
  },
  location: {
    city: String,
    state: String,
    country: String
  },
  phoneNumber: {
    type: String,
    trim: true
  },
  socialProfiles: {
    linkedin: String,
    github: String,
    portfolio: String
  },
  preferences: {
    jobTypes: [String],
    industries: [String],
    locations: [{
      city: String,
      state: String,
      country: String,
      remote: Boolean
    }],
    salaryRange: {
      min: Number,
      max: Number,
      currency: String
    },
    notifications: {
      email: {
        type: Boolean,
        default: true
      },
      jobAlerts: {
        type: Boolean,
        default: true
      }
    }
  },
  accountType: {
    type: String,
    enum: ['Free', 'Basic', 'Premium'],
    default: 'Free'
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isEmailVerified: {
    type: Boolean,
    default: false
  },
  emailVerificationToken: String,
  emailVerificationExpires: Date,
  passwordResetToken: String,
  passwordResetExpires: Date,
  loginAttempts: {
    type: Number,
    default: 0
  },
  lockUntil: Date,
  lastLogin: Date,
  active: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  // Only hash the password if it's modified (or new)
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

// Generate email verification token
userSchema.methods.generateEmailVerificationToken = function() {
  // Create a token
  const token = crypto.randomBytes(32).toString('hex');
  
  // Hash token and set to emailVerificationToken field
  this.emailVerificationToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Set expiration (24 hours)
  this.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000;
  
  return token;
};

// Generate password reset token
userSchema.methods.generatePasswordResetToken = function() {
  // Create a token
  const token = crypto.randomBytes(32).toString('hex');
  
  // Hash token and set to passwordResetToken field
  this.passwordResetToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Set expiration (10 minutes)
  this.passwordResetExpires = Date.now() + 10 * 60 * 1000;
  
  return token;
};

// Check if account is locked
userSchema.methods.isLocked = function() {
  return !!(this.lockUntil && this.lockUntil > Date.now());
};

// Increment login attempts and lock account if needed
userSchema.methods.incrementLoginAttempts = async function() {
  // If previous lock has expired, restart at 1
  if (this.lockUntil && this.lockUntil < Date.now()) {
    return this.updateOne({
      $set: { loginAttempts: 1 },
      $unset: { lockUntil: 1 }
    });
  }
  
  // Otherwise increment login attempts
  const updates = { $inc: { loginAttempts: 1 } };
  
  // Lock the account if we've reached max attempts (5) and it's not locked
  if (this.loginAttempts + 1 >= 5 && !this.isLocked()) {
    // Lock for 1 hour
    updates.$set = { lockUntil: Date.now() + 60 * 60 * 1000 };
  }
  
  return this.updateOne(updates);
};

// Reset login attempts
userSchema.methods.resetLoginAttempts = function() {
  return this.updateOne({
    $set: { loginAttempts: 0 },
    $unset: { lockUntil: 1 }
  });
};

const User = mongoose.model('User', userSchema);

module.exports = User;

================
File: models/mongodb/userMemory.model.js
================
// backend/models/mongodb/userMemory.model.js - FIXED SCHEMA FOR INSIGHTS
const mongoose = require('mongoose');

const memoryEntrySchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true
  },
  type: {
    type: String,
    enum: [
      'preference',
      'skill',
      'career_goal',
      'experience',
      'achievement',
      'challenge',
      'personality_trait',
      'communication_style',
      'work_style',
      'industry_knowledge',
      'tool_preference',
      'feedback_pattern',
      'education',           // ADDED: For degrees, certifications, etc.
      'learning_goal',       // ADDED: For things like "want to learn Python"
      'weakness'             // ADDED: For challenges like "system design interviews"
    ],
    required: true
  },
  category: {
    type: String,
    enum: [
      'personal',
      'professional',
      'technical',
      'behavioral',
      'contextual'
    ],
    required: true
  },
  content: {
    type: String,
    required: true,
    trim: true
  },
  confidence: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.8
  },
  importance: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  source: {
    conversationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Conversation'
    },
    messageId: String,
    extractionMethod: {
      type: String,
      enum: [
        'explicit', 
        'inferred', 
        'pattern_detected', 
        'user_confirmed',
        'ai_extracted',
        'summary_extracted',
        'user_added'
      ],
      default: 'inferred'
    },
    model: String,
    timestamp: {
      type: Date,
      default: Date.now
    }
  },
  context: {
    resumeIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    }],
    jobIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    }],
    timeframe: {
      from: Date,
      to: Date
    },
    situation: String
  },
  verification: {
    isVerified: {
      type: Boolean,
      default: false
    },
    verifiedAt: Date,
    verificationMethod: {
      type: String,
      enum: ['user_confirmed', 'repeated_observation', 'cross_referenced']
    },
    verificationCount: {
      type: Number,
      default: 0
    }
  },
  usage: {
    accessCount: {
      type: Number,
      default: 0
    },
    lastAccessedAt: Date,
    effectivenessRating: {
      type: Number,
      min: 1,
      max: 5
    },
    userFeedback: String
  },
  relationships: [{
    relatedMemoryId: String,
    relationshipType: {
      type: String,
      enum: ['reinforces', 'contradicts', 'builds_on', 'specifies', 'generalizes']
    },
    strength: {
      type: Number,
      min: 0,
      max: 1
    }
  }],
  decay: {
    lastReinforced: {
      type: Date,
      default: Date.now
    },
    reinforcementCount: {
      type: Number,
      default: 1
    },
    decayRate: {
      type: Number,
      default: 0.1
    }
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true,
  _id: false
});

const userMemorySchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    unique: true,
    index: true
  },
  memories: [memoryEntrySchema],
  
  // User profile intelligence derived from memories
  profile: {
    careerStage: {
      type: String,
      enum: ['student', 'entry_level', 'mid_level', 'senior_level', 'executive', 'career_changer', 'returning_professional'],
      confidence: Number
    },
    industries: [{
      name: String,
      experience_level: String,
      interest_level: Number,
      confidence: Number
    }],
    skills: [{
      name: String,
      level: {
        type: String,
        enum: ['beginner', 'intermediate', 'advanced', 'expert']
      },
      confidence: Number,
      lastMentioned: Date
    }],
    personalityTraits: [{
      trait: String,
      strength: Number,
      confidence: Number
    }],
    communicationStyle: {
      formality: {
        type: String,
        enum: ['very_formal', 'formal', 'neutral', 'casual', 'very_casual']
      },
      detail_preference: {
        type: String,
        enum: ['brief', 'moderate', 'detailed', 'comprehensive']
      },
      learning_style: {
        type: String,
        enum: ['visual', 'auditory', 'kinesthetic', 'reading']
      },
      feedback_preference: {
        type: String,
        enum: ['direct', 'gentle', 'detailed', 'actionable']
      }
    },
    goals: [{
      type: {
        type: String,
        enum: ['short_term', 'medium_term', 'long_term']
      },
      category: {
        type: String,
        enum: ['career', 'skill', 'personal', 'financial']
      },
      description: String,
      priority: Number,
      deadline: Date,
      progress: Number,
      confidence: Number
    }],
    preferences: {
      work_environment: [{
        type: String,
        preference_level: Number
      }],
      company_size: {
        type: String,
        enum: ['startup', 'small', 'medium', 'large', 'enterprise']
      },
      work_style: {
        type: String,
        enum: ['independent', 'collaborative', 'mixed']
      },
      communication_frequency: {
        type: String,
        enum: ['minimal', 'regular', 'frequent', 'constant']
      }
    }
  },

  // FIXED: Memory analytics with proper object schemas
  analytics: {
    totalMemories: {
      type: Number,
      default: 0
    },
    // FIXED: Array of objects with proper schema definition
    memoriesByType: [{
      _id: false,  // Disable _id for subdocuments
      type: {
        type: String,
        required: true
      },
      count: {
        type: Number,
        required: true
      }
    }],
    // FIXED: Array of objects with proper schema definition
    memoriesByCategory: [{
      _id: false,  // Disable _id for subdocuments
      category: {
        type: String,
        required: true
      },
      count: {
        type: Number,
        required: true
      }
    }],
    averageConfidence: {
      type: Number,
      default: 0
    },
    memoryAccuracy: {
      type: Number,
      default: 0
    },
    lastAnalyzedAt: Date,
    // FIXED: Array of insight objects with proper schema definition
    insights: [{
      _id: false,  // Disable _id for subdocuments
      type: {
        type: String,
        enum: ['pattern', 'opportunity', 'strength', 'challenge', 'recommendation'],
        required: true
      },
      description: {
        type: String,
        required: true
      },
      confidence: {
        type: Number,
        min: 0,
        max: 1,
        required: true
      },
      actionable: {
        type: Boolean,
        required: true
      },
      generatedAt: {
        type: Date,
        default: Date.now
      }
    }]
  },

  // Memory management settings
  settings: {
    memoryRetention: {
      type: String,
      enum: ['aggressive', 'normal', 'conservative'],
      default: 'normal'
    },
    autoDecay: {
      type: Boolean,
      default: true
    },
    requireVerification: {
      type: Boolean,
      default: false
    },
    shareInsights: {
      type: Boolean,
      default: true
    },
    maxMemories: {
      type: Number,
      default: 1000
    }
  },

  lastUpdated: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Indexes for efficient querying
userMemorySchema.index({ userId: 1 });
userMemorySchema.index({ 'memories.type': 1 });
userMemorySchema.index({ 'memories.category': 1 });
userMemorySchema.index({ 'memories.importance': 1 });
userMemorySchema.index({ 'memories.tags': 1 });
userMemorySchema.index({ 'memories.isActive': 1 });
userMemorySchema.index({ 'memories.confidence': -1 });

// Instance methods
userMemorySchema.methods.addMemory = function(memoryData) {
  const memoryId = `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  const memory = {
    id: memoryId,
    type: memoryData.type,
    category: memoryData.category,
    content: memoryData.content,
    confidence: memoryData.confidence || 0.8,
    importance: memoryData.importance || 'medium',
    source: {
      ...memoryData.source,
      timestamp: new Date()
    },
    context: memoryData.context || {},
    tags: memoryData.tags || [],
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  // Check for similar memories to avoid duplicates
  const similarMemory = this.findSimilarMemory(memory);
  if (similarMemory) {
    return this.reinforceMemory(similarMemory.id, memory);
  }
  
  this.memories.push(memory);
  this.analytics.totalMemories = this.memories.length;
  this.lastUpdated = new Date();
  
  return memory;
};

userMemorySchema.methods.findSimilarMemory = function(newMemory) {
  return this.memories.find(existing => 
    existing.type === newMemory.type &&
    existing.category === newMemory.category &&
    this.calculateSimilarity(existing.content, newMemory.content) > 0.8
  );
};

userMemorySchema.methods.calculateSimilarity = function(content1, content2) {
  const words1 = content1.toLowerCase().split(' ');
  const words2 = content2.toLowerCase().split(' ');
  const commonWords = words1.filter(word => words2.includes(word));
  return commonWords.length / Math.max(words1.length, words2.length);
};

userMemorySchema.methods.reinforceMemory = function(memoryId, reinforcementData) {
  const memory = this.memories.find(m => m.id === memoryId);
  if (memory) {
    memory.decay.lastReinforced = new Date();
    memory.decay.reinforcementCount += 1;
    memory.confidence = Math.min(1, memory.confidence + 0.1);
    
    if (reinforcementData) {
      memory.content = reinforcementData.content || memory.content;
      memory.tags = [...new Set([...memory.tags, ...(reinforcementData.tags || [])])];
    }
    
    this.lastUpdated = new Date();
    return memory;
  }
  return null;
};

userMemorySchema.methods.getMemoriesByType = function(type, options = {}) {
  let memories = this.memories.filter(m => m.type === type && m.isActive);
  
  if (options.minConfidence) {
    memories = memories.filter(m => m.confidence >= options.minConfidence);
  }
  
  if (options.importance) {
    memories = memories.filter(m => m.importance === options.importance);
  }
  
  return memories.sort((a, b) => {
    if (options.sortBy === 'confidence') return b.confidence - a.confidence;
    if (options.sortBy === 'recent') return new Date(b.updatedAt) - new Date(a.updatedAt);
    return b.decay.reinforcementCount - a.decay.reinforcementCount;
  });
};

userMemorySchema.methods.searchMemories = function(query, options = {}) {
  const searchRegex = new RegExp(query, 'i');
  
  let memories = this.memories.filter(m => 
    m.isActive && (
      searchRegex.test(m.content) ||
      m.tags.some(tag => searchRegex.test(tag)) ||
      searchRegex.test(m.type) ||
      searchRegex.test(m.category)
    )
  );
  
  if (options.minConfidence) {
    memories = memories.filter(m => m.confidence >= options.minConfidence);
  }
  
  return memories.sort((a, b) => b.confidence - a.confidence);
};

userMemorySchema.methods.getRelevantMemories = function(context, limit = 10) {
  let relevantMemories = [];
  
  // Get memories by context tags
  if (context.tags && context.tags.length > 0) {
    const taggedMemories = this.memories.filter(m => 
      m.isActive && m.tags.some(tag => context.tags.includes(tag))
    );
    relevantMemories.push(...taggedMemories);
  }
  
  // Get memories by type/category
  if (context.types && context.types.length > 0) {
    const typedMemories = this.memories.filter(m => 
      m.isActive && context.types.includes(m.type)
    );
    relevantMemories.push(...typedMemories);
  }
  
  // Get high-importance memories
  const importantMemories = this.memories.filter(m => 
    m.isActive && ['high', 'critical'].includes(m.importance)
  );
  relevantMemories.push(...importantMemories);
  
  // Remove duplicates and sort by relevance
  const uniqueMemories = Array.from(new Set(relevantMemories.map(m => m.id)))
    .map(id => relevantMemories.find(m => m.id === id))
    .sort((a, b) => {
      const aScore = this.calculateRelevanceScore(a, context);
      const bScore = this.calculateRelevanceScore(b, context);
      return bScore - aScore;
    });
  
  return uniqueMemories.slice(0, limit);
};

userMemorySchema.methods.calculateRelevanceScore = function(memory, context) {
  let score = memory.confidence;
  
  // Boost score for importance
  const importanceBoost = {
    'critical': 0.4,
    'high': 0.3,
    'medium': 0.1,
    'low': 0
  };
  score += importanceBoost[memory.importance] || 0;
  
  // Boost score for recent reinforcement
  const daysSinceReinforced = (Date.now() - memory.decay.lastReinforced) / (1000 * 60 * 60 * 24);
  score += Math.max(0, 0.2 - (daysSinceReinforced * 0.01));
  
  // Boost score for tag matches
  if (context.tags) {
    const tagMatches = memory.tags.filter(tag => context.tags.includes(tag)).length;
    score += tagMatches * 0.1;
  }
  
  return Math.min(1, score);
};

// FIXED: Update profile method with correct object structure - PROPER VERSION
userMemorySchema.methods.updateProfile = function() {
  // Initialize analytics if it doesn't exist
  if (!this.analytics) {
    this.analytics = {
      totalMemories: 0,
      memoriesByType: [],
      memoriesByCategory: [],
      averageConfidence: 0,
      insights: []
    };
  }

  const activeMemories = this.memories.filter(m => m.isActive);
  
  // Update basic analytics
  this.analytics.totalMemories = activeMemories.length;
  this.analytics.averageConfidence = activeMemories.length > 0 
    ? activeMemories.reduce((sum, m) => sum + m.confidence, 0) / activeMemories.length 
    : 0;
  
  // FIXED: Clear existing arrays before rebuilding
  this.analytics.memoriesByType = [];
  this.analytics.memoriesByCategory = [];
  
  // Update memory counts by type as objects
  const typeGroups = activeMemories.reduce((groups, memory) => {
    groups[memory.type] = (groups[memory.type] || 0) + 1;
    return groups;
  }, {});
  
  // FIXED: Build new array properly
  for (const [type, count] of Object.entries(typeGroups)) {
    this.analytics.memoriesByType.push({ type, count });
  }
  
  // Update memory counts by category as objects  
  const categoryGroups = activeMemories.reduce((groups, memory) => {
    groups[memory.category] = (groups[memory.category] || 0) + 1;
    return groups;
  }, {});
  
  // FIXED: Build new array properly
  for (const [category, count] of Object.entries(categoryGroups)) {
    this.analytics.memoriesByCategory.push({ category, count });
  }
  
  this.analytics.lastAnalyzedAt = new Date();
  this.lastUpdated = new Date();
  
  // Mark the analytics as modified to ensure Mongoose saves it
  this.markModified('analytics');
};

userMemorySchema.methods.decayMemories = function() {
  const now = Date.now();
  let decayedCount = 0;
  
  this.memories.forEach(memory => {
    if (!memory.isActive) return;
    
    const daysSinceReinforced = (now - memory.decay.lastReinforced) / (1000 * 60 * 60 * 24);
    const decayAmount = daysSinceReinforced * memory.decay.decayRate;
    
    memory.confidence = Math.max(0.1, memory.confidence - decayAmount);
    
    // Deactivate memories with very low confidence
    if (memory.confidence < 0.2) {
      memory.isActive = false;
      decayedCount++;
    }
  });
  
  if (decayedCount > 0) {
    this.updateProfile();
  }
  
  return decayedCount;
};

// Static methods
userMemorySchema.statics.findByUserId = function(userId) {
  return this.findOne({ userId });
};

userMemorySchema.statics.createForUser = function(userId) {
  return this.create({
    userId,
    memories: [],
    profile: {},
    analytics: {
      totalMemories: 0,
      memoriesByType: [],
      memoriesByCategory: [],
      averageConfidence: 0,
      memoryAccuracy: 0,
      insights: []
    },
    settings: {
      memoryRetention: 'normal',
      autoDecay: true,
      requireVerification: false,
      shareInsights: true,
      maxMemories: 1000
    }
  });
};

const UserMemory = mongoose.model('UserMemory', userMemorySchema);

module.exports = UserMemory;

================
File: models/postgresql/schema.js
================
// backend/models/postgresql/schema.js
const db = require('../../config/postgresql');

const createTables = async () => {
  try {
    console.log('Creating PostgreSQL tables...');
    
    // Industries Table with additional classification codes
    await db.query(`
      CREATE TABLE IF NOT EXISTS industries (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        description TEXT,
        sic_codes TEXT[],
        naics_codes TEXT[],
        primary_category VARCHAR(255),
        sub_category VARCHAR(255),
        hierarchical_category VARCHAR(255),
        all_industries TEXT[],
        all_sub_industries TEXT[],
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Locations Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS locations (
        id SERIAL PRIMARY KEY,
        street_address TEXT,
        city VARCHAR(100),
        state VARCHAR(100),
        postal_code VARCHAR(20),
        country VARCHAR(100) NOT NULL,
        is_remote BOOLEAN DEFAULT FALSE,
        full_address TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Companies Table with expanded fields
    await db.query(`
      CREATE TABLE IF NOT EXISTS companies (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        website VARCHAR(255),
        industry_id INTEGER REFERENCES industries(id),
        company_size VARCHAR(50),
        employee_count INTEGER,
        employee_range VARCHAR(50),
        founded_year INTEGER,
        headquarters_location_id INTEGER REFERENCES locations(id),
        description TEXT,
        logo_url VARCHAR(255),
        phone VARCHAR(50),
        fax VARCHAR(50),
        email_domain VARCHAR(255),
        revenue DECIMAL(15,2),
        revenue_range VARCHAR(50),
        revenue_usd_thousands INTEGER,
        ownership_type VARCHAR(50),
        business_model VARCHAR(50),
        stock_ticker VARCHAR(20),
        alexa_rank INTEGER,
        zoominfo_id VARCHAR(50),
        zoominfo_url TEXT,
        linkedin_url TEXT,
        facebook_url TEXT,
        twitter_url TEXT,
        funding_total DECIMAL(15,2),
        funding_total_usd_thousands INTEGER,
        recent_funding DECIMAL(15,2),
        recent_funding_usd_thousands INTEGER,
        recent_funding_round VARCHAR(50),
        recent_funding_date DATE,
        recent_investors TEXT[],
        all_investors TEXT[],
        location_count INTEGER,
        sic_codes TEXT[],
        naics_codes TEXT[],
        is_certified_active BOOLEAN DEFAULT FALSE,
        certification_date DATE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Add missing columns to companies table if they don't exist
    console.log('Checking and adding missing columns to companies table...');
    
    const companyColumnsToAdd = [
      { name: 'revenue_usd_thousands', type: 'INTEGER' },
      { name: 'funding_total_usd_thousands', type: 'INTEGER' },
      { name: 'recent_funding_usd_thousands', type: 'INTEGER' },
      { name: 'sic_codes', type: 'TEXT[]' },
      { name: 'naics_codes', type: 'TEXT[]' },
      { name: 'recent_investors', type: 'TEXT[]' },
      { name: 'all_investors', type: 'TEXT[]' },
      { name: 'is_certified_active', type: 'BOOLEAN DEFAULT FALSE' },
      { name: 'certification_date', type: 'DATE' },
      { name: 'zoominfo_id', type: 'VARCHAR(50)' },
      { name: 'zoominfo_url', type: 'TEXT' },
      { name: 'stock_ticker', type: 'VARCHAR(20)' },
      { name: 'alexa_rank', type: 'INTEGER' },
      { name: 'location_count', type: 'INTEGER' },
      { name: 'recent_funding_round', type: 'VARCHAR(50)' },
      { name: 'recent_funding_date', type: 'DATE' }
    ];

    for (const column of companyColumnsToAdd) {
      try {
        await db.query(`
          ALTER TABLE companies ADD COLUMN IF NOT EXISTS ${column.name} ${column.type};
        `);
        console.log(`âœ… Added column ${column.name} to companies table`);
      } catch (error) {
        console.log(`Column ${column.name} already exists or cannot be added: ${error.message}`);
      }
    }

    // Add unique constraint to companies if it doesn't exist
    try {
      await db.query(`
        ALTER TABLE companies ADD CONSTRAINT companies_name_website_unique UNIQUE (name, website);
      `);
    } catch (error) {
      // Constraint might already exist, that's okay
      console.log('Companies unique constraint already exists or cannot be added');
    }
    
    // Recruiters Table with expanded fields for CSV data
    await db.query(`
      CREATE TABLE IF NOT EXISTS recruiters (
        id SERIAL PRIMARY KEY,
        first_name VARCHAR(100) NOT NULL,
        last_name VARCHAR(100) NOT NULL,
        middle_name VARCHAR(100),
        salutation VARCHAR(20),
        suffix VARCHAR(20),
        email VARCHAR(255),
        email_domain VARCHAR(255),
        supplemental_email VARCHAR(255),
        direct_phone VARCHAR(50),
        mobile_phone VARCHAR(50),
        current_company_id INTEGER REFERENCES companies(id),
        title VARCHAR(255),
        job_title_hierarchy_level INTEGER,
        management_level VARCHAR(50),
        job_start_date DATE,
        job_function VARCHAR(100),
        department VARCHAR(100),
        company_division VARCHAR(100),
        education_level VARCHAR(100),
        highest_education VARCHAR(100),
        accuracy_score INTEGER,
        accuracy_grade VARCHAR(10),
        contact_accuracy_score INTEGER,
        contact_accuracy_grade VARCHAR(10),
        zoominfo_url TEXT,
        linkedin_url TEXT,
        zoominfo_profile_url TEXT,
        linkedin_profile_url TEXT,
        notice_provided_date DATE,
        location_id INTEGER REFERENCES locations(id),
        industry_id INTEGER REFERENCES industries(id),
        specializations VARCHAR(255)[],
        experience_years INTEGER,
        last_active_date DATE,
        rating DECIMAL(3,2),
        notes TEXT,
        is_active BOOLEAN DEFAULT TRUE,
        last_contacted DATE,
        contact_attempts INTEGER DEFAULT 0,
        response_rate DECIMAL(5,2) DEFAULT 0,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Add missing columns to recruiters table if they don't exist
    console.log('Checking and adding missing columns to recruiters table...');
    
    const recruiterColumnsToAdd = [
      { name: 'person_street', type: 'VARCHAR(255)' },
      { name: 'person_city', type: 'VARCHAR(100)' },
      { name: 'person_state', type: 'VARCHAR(100)' },
      { name: 'person_zip_code', type: 'VARCHAR(20)' },
      { name: 'person_country', type: 'VARCHAR(100)' },
      { name: 'is_active', type: 'BOOLEAN DEFAULT TRUE' }
    ];

    for (const column of recruiterColumnsToAdd) {
      try {
        await db.query(`
          ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS ${column.name} ${column.type};
        `);
        console.log(`âœ… Added column ${column.name} to recruiters table`);
      } catch (error) {
        console.log(`Column ${column.name} already exists or cannot be added`);
      }
    }

    // Add unique constraint to recruiters email if it doesn't exist
    try {
      await db.query(`
        ALTER TABLE recruiters ADD CONSTRAINT recruiters_email_unique UNIQUE (email);
      `);
    } catch (error) {
      // Constraint might already exist, that's okay
      console.log('Recruiters email unique constraint already exists or cannot be added');
    }
    
    // Skills Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS skills (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        category VARCHAR(100),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // RecruiterSkills Table (Junction)
    await db.query(`
      CREATE TABLE IF NOT EXISTS recruiter_skills (
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        skill_id INTEGER REFERENCES skills(id) ON DELETE CASCADE,
        PRIMARY KEY (recruiter_id, skill_id)
      );
    `);
    
    // Outreach Campaigns Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_campaigns (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(50) NOT NULL,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        status VARCHAR(50) DEFAULT 'active',
        target_job_title VARCHAR(255),
        target_companies TEXT[],
        target_locations TEXT[],
        message_template TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);

    // Outreach Messages Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_messages (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(50) NOT NULL,
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        campaign_id INTEGER REFERENCES outreach_campaigns(id) ON DELETE SET NULL,
        subject VARCHAR(255),
        message_content TEXT NOT NULL,
        sent_via VARCHAR(50) DEFAULT 'email',
        sent_at TIMESTAMP,
        status VARCHAR(50) DEFAULT 'draft',
        response_received BOOLEAN DEFAULT FALSE,
        response_content TEXT,
        response_received_at TIMESTAMP,
        follow_up_scheduled DATE,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);
    
    // OutreachHistory Table (Connecting MongoDB to PostgreSQL)
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_history (
        id SERIAL PRIMARY KEY,
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        mongodb_outreach_id VARCHAR(24) NOT NULL,
        mongodb_user_id VARCHAR(24) NOT NULL,
        status VARCHAR(50) NOT NULL,
        last_contact_date TIMESTAMP,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // EmailTemplates Table for outreach
    await db.query(`
      CREATE TABLE IF NOT EXISTS email_templates (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        subject_template TEXT NOT NULL,
        body_template TEXT NOT NULL,
        context_variables JSONB,
        category VARCHAR(100),
        tags VARCHAR(50)[],
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Job Boards Table for scraping
    await db.query(`
      CREATE TABLE IF NOT EXISTS job_boards (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        url TEXT NOT NULL,
        scraping_config JSONB,
        is_active BOOLEAN DEFAULT TRUE,
        last_scraped_at TIMESTAMP,
        scraping_frequency_hours INTEGER DEFAULT 24,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    console.log('âœ… Tables created successfully');
    
    // Create Indexes in a separate step to ensure all columns exist
    console.log('Creating indexes...');
    
    // Helper function to check if column exists before creating index
    const columnExists = async (tableName, columnName) => {
      try {
        const result = await db.query(`
          SELECT column_name 
          FROM information_schema.columns 
          WHERE table_name = $1 AND column_name = $2
        `, [tableName, columnName]);
        return result.rows.length > 0;
      } catch (error) {
        return false;
      }
    };

    // Basic indexes that should always work
    const basicIndexes = [
      'CREATE INDEX IF NOT EXISTS idx_recruiters_company ON recruiters(current_company_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_industry ON recruiters(industry_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_location ON recruiters(location_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_name ON recruiters(last_name, first_name)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_email ON recruiters(email)',
      'CREATE INDEX IF NOT EXISTS idx_companies_industry ON companies(industry_id)',
      'CREATE INDEX IF NOT EXISTS idx_companies_name ON companies(name)',
      'CREATE INDEX IF NOT EXISTS idx_companies_domain ON companies(email_domain)',
      'CREATE INDEX IF NOT EXISTS idx_companies_website ON companies(website)',
      'CREATE INDEX IF NOT EXISTS idx_recruiter_skills ON recruiter_skills(skill_id)',
      'CREATE INDEX IF NOT EXISTS idx_skills_name ON skills(name)',
      'CREATE INDEX IF NOT EXISTS idx_skills_category ON skills(category)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_recruiter ON outreach_history(recruiter_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_mongodb_ids ON outreach_history(mongodb_outreach_id, mongodb_user_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_user ON outreach_messages(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_recruiter ON outreach_messages(recruiter_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_status ON outreach_messages(status)'
    ];

    for (const indexQuery of basicIndexes) {
      try {
        await db.query(indexQuery);
      } catch (error) {
        console.log(`Index creation failed (this is usually okay): ${error.message}`);
      }
    }

    // Conditional indexes that depend on specific columns
    if (await columnExists('recruiters', 'title')) {
      try {
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_recruiters_title ON recruiters USING gin(to_tsvector('english', title));
        `);
      } catch (error) {
        console.log('Title index creation failed (this is usually okay)');
      }
    }

    if (await columnExists('recruiters', 'person_city') && await columnExists('recruiters', 'person_state')) {
      try {
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_recruiters_city_state ON recruiters(person_city, person_state);
        `);
        console.log('âœ… Created city/state index');
      } catch (error) {
        console.log('City/state index creation failed (this is usually okay)');
      }
    } else {
      console.log('âš ï¸ Skipping city/state index - columns do not exist yet');
    }

    if (await columnExists('recruiters', 'is_active')) {
      try {
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_recruiters_active ON recruiters(is_active);
        `);
        console.log('âœ… Created is_active index');
      } catch (error) {
        console.log('is_active index creation failed (this is usually okay)');
      }
    }
    
    console.log('âœ… Indexes created successfully');
    console.log('âœ… PostgreSQL tables setup completed successfully');
    
  } catch (error) {
    console.error('Error creating PostgreSQL tables:', error);
    throw error;
  }
};

// Function to seed some initial data for testing
const seedInitialData = async () => {
  try {
    // Minimal seeding for now - we'll add the recruiter import utility later
    const industryCount = await db.query('SELECT COUNT(*) FROM industries');
    
    if (parseInt(industryCount.rows[0].count) === 0) {
      console.log('Seeding initial industry data...');
      
      await db.query(`
        INSERT INTO industries (name, description, primary_category, sub_category) VALUES
        ('Business Services', 'Business consulting, professional services', 'Business Services', 'Custom Software & IT Services'),
        ('Technology', 'Software, hardware, and IT services', 'Business Services', 'Custom Software & IT Services'),
        ('Healthcare', 'Medical services, pharmaceuticals, and healthcare technology', 'Healthcare', 'Healthcare Services'),
        ('Finance', 'Banking, investments, and financial services', 'Financial Services', 'Banking & Financial Services'),
        ('Education', 'Schools, universities, and educational technology', 'Education', 'Education Services'),
        ('Manufacturing', 'Production of goods and related services', 'Manufacturing', 'General Manufacturing'),
        ('Telecommunications', 'Telecom infrastructure and services', 'Telecommunications', 'Telephony & Wireless'),
        ('HR & Staffing', 'Human resources and staffing services', 'Business Services', 'HR & Staffing')
        ON CONFLICT (name) DO NOTHING;
      `);
      
      console.log('Initial industry data seeded successfully');
    }
    
    // Add skills data
    const skillCount = await db.query('SELECT COUNT(*) FROM skills');
    
    if (parseInt(skillCount.rows[0].count) === 0) {
      console.log('Seeding initial skill data...');
      
      await db.query(`
        INSERT INTO skills (name, category) VALUES
        ('JavaScript', 'Programming Languages'),
        ('Python', 'Programming Languages'),
        ('Java', 'Programming Languages'),
        ('React', 'Frontend Development'),
        ('Node.js', 'Backend Development'),
        ('AWS', 'Cloud Computing'),
        ('SQL', 'Database'),
        ('Machine Learning', 'Data Science'),
        ('Product Management', 'Management'),
        ('Technical Recruiting', 'Recruiting'),
        ('Business Development', 'Sales'),
        ('Talent Acquisition', 'Recruiting'),
        ('HR Specialist', 'Human Resources'),
        ('ERP Support', 'Technical Support')
        ON CONFLICT (name) DO NOTHING;
      `);
      
      console.log('Initial skill data seeded successfully');
    }
    
    console.log('Basic initial data seeded successfully');
  } catch (error) {
    console.error('Error seeding initial data:', error);
    throw error;
  }
};

module.exports = { createTables, seedInitialData };

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.52.0",
    "@aws-sdk/client-s3": "^3.817.0",
    "@aws-sdk/s3-request-presigner": "^3.803.0",
    "aws-sdk": "^2.1692.0",
    "axios": "^1.9.0",
    "bcrypt": "^5.1.1",
    "cheerio": "^1.0.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "csv-parse": "^5.6.0",
    "csv-parser": "^3.2.0",
    "docx": "^8.5.0",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "fs": "^0.0.1-security",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mammoth": "^1.9.0",
    "mongoose": "^8.14.1",
    "multer": "^1.4.5-lts.2",
    "multer-s3": "^3.0.1",
    "natural": "^8.0.1",
    "nodemailer": "^6.10.1",
    "openai": "^4.97.0",
    "pdf-parse": "^1.1.1",
    "pdfkit": "^0.17.1",
    "pg": "^8.15.6",
    "puppeteer": "^24.10.0",
    "uuid": "^11.1.0",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

================
File: routes/assistant.routes.js
================
// backend/routes/assistant.routes.js - COMPLETE WITH RESUME EDITING ROUTES
const express = require('express');
const router = express.Router();
const assistantController = require('../controllers/assistant.controller');
const { protect } = require('../middleware/auth.middleware'); // FIXED: Proper import
const rateLimit = require('express-rate-limit');

// All assistant routes require authentication
router.use(protect);

// ===================================================================
// RATE LIMITING SETUP
// ===================================================================

// Rate limiting for AI operations (more restrictive due to cost)
const aiLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 50, // limit each IP to 50 AI operations per windowMs
  message: {
    success: false,
    error: 'AI operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting for memory operations
const memoryLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 memory operations per windowMs
  message: {
    success: false,
    error: 'Memory operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting for resume operations (moderate)
const resumeLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 20, // limit each IP to 20 resume operations per windowMs
  message: {
    success: false,
    error: 'Resume operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// ===================================================================
// ENHANCED CHAT & CONVERSATION MANAGEMENT
// ===================================================================

// Enhanced main chat endpoint with conversation management
router.post('/chat', aiLimiter, assistantController.chat);

// Conversation management
router.get('/conversations', assistantController.getConversations);
router.get('/conversations/:conversationId', assistantController.getConversation);
router.put('/conversations/:conversationId', assistantController.updateConversation);
router.delete('/conversations/:conversationId', assistantController.deleteConversation);

// Conversation utilities (placeholders - implement if needed)
router.post('/conversations/:conversationId/summary', assistantController.generateSummary);
router.get('/conversations/:conversationId/insights', assistantController.getConversationInsights);
router.get('/conversations/:conversationId/export', assistantController.exportConversation);

// Bulk operations
router.post('/conversations/bulk-update', assistantController.bulkUpdateConversations);

// ===================================================================
// MEMORY MANAGEMENT (with rate limiting)
// ===================================================================

// Memory CRUD operations
router.get('/memories', memoryLimiter, assistantController.getMemories);
router.post('/memories', memoryLimiter, assistantController.updateMemory);
router.delete('/memories/:memoryId', memoryLimiter, assistantController.deleteMemory);

// Memory insights and analytics
router.get('/memory-insights', memoryLimiter, assistantController.getMemoryInsights);
router.post('/memory-maintenance', memoryLimiter, assistantController.performMemoryMaintenance);

// ===================================================================
// ENHANCED RESUME OPERATIONS - FULL IMPLEMENTATION
// ===================================================================

// Core resume editing operations (with rate limiting) - THESE EXIST
router.post('/apply-resume-changes', resumeLimiter, assistantController.applyResumeChanges);
router.post('/optimize-ats', resumeLimiter, assistantController.optimizeForATS);
router.post('/analyze-resume', resumeLimiter, assistantController.analyzeResume);

// Real-time resume editing (PLACEHOLDER IMPLEMENTATIONS)
router.post('/resume/quick-edit', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Quick edit feature coming soon',
    suggestion: 'Use the apply-resume-changes endpoint for now'
  });
});

router.post('/resume/bulk-update', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Bulk update feature coming soon',
    suggestion: 'Use multiple apply-resume-changes calls for now'
  });
});

router.post('/resume/improvements', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Improvement suggestions feature coming soon',
    suggestion: 'Use the analyze-resume endpoint for detailed analysis'
  });
});

// Resume-specific AI operations (PLACEHOLDERS)
router.post('/resume/tailor-for-job', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Resume tailoring feature coming soon',
    suggestion: 'Use the apply-resume-changes endpoint for now'
  });
});

router.post('/resume/version-compare', (req, res) => {
  res.json({
    success: true,
    message: 'Version comparison feature coming soon',
    suggestion: 'Check the versions array in your resume data'
  });
});

// ===================================================================
// UNIVERSAL SEARCH
// ===================================================================

// Search across conversations and memories
router.get('/search', assistantController.search);

// ===================================================================
// ANALYTICS & INSIGHTS
// ===================================================================

// User analytics
router.get('/analytics', assistantController.getAnalytics);

// ===================================================================
// JOB MATCHING & CAREER GUIDANCE
// ===================================================================

// Job matching with memory context
router.post('/analyze-job-match', aiLimiter, assistantController.analyzeJobMatch);
router.post('/generate-cover-letter', aiLimiter, assistantController.generateCoverLetter);

// Career guidance with memory context
router.post('/career-advice', aiLimiter, assistantController.getCareerAdvice);
router.post('/contextual-suggestions', assistantController.getContextualSuggestions);
router.post('/personalized-tips', assistantController.getPersonalizedTips);

// ===================================================================
// SYSTEM & HEALTH
// ===================================================================

// Enhanced system endpoints
router.get('/capabilities', assistantController.getCapabilities);
router.get('/health', assistantController.healthCheck);
router.get('/usage-stats', assistantController.getUsageStats);
router.post('/track-interaction', assistantController.trackInteraction);
router.post('/reset-context', assistantController.resetContext);

// ===================================================================
// PLACEHOLDER ROUTES REMOVED - ALREADY DEFINED ABOVE
// ===================================================================

// ===================================================================
// ERROR HANDLING MIDDLEWARE
// ===================================================================

// Enhanced error handling for all operations
router.use((error, req, res, next) => {
  console.error('Assistant route error:', {
    error: error.message,
    stack: error.stack,
    route: req.route?.path,
    method: req.method,
    userId: req.user?._id,
    timestamp: new Date().toISOString()
  });

  // Resume-specific errors
  if (error.message.includes('resume') || error.message.includes('Resume')) {
    return res.status(500).json({
      success: false,
      error: 'Resume processing error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try refreshing the page or uploading the resume again'
    });
  }

  // Memory-specific errors
  if (error.message.includes('memory') || error.message.includes('Memory')) {
    return res.status(500).json({
      success: false,
      error: 'Memory system error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try refreshing the page or contact support if the issue persists'
    });
  }

  // Conversation-specific errors
  if (error.message.includes('conversation') || error.message.includes('Conversation')) {
    return res.status(500).json({
      success: false,
      error: 'Conversation system error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try starting a new conversation or contact support'
    });
  }

  // OpenAI API errors
  if (error.message.includes('OpenAI') || error.status === 429) {
    return res.status(503).json({
      success: false,
      error: 'AI service temporarily unavailable',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Please try again in a few moments'
    });
  }

  // Rate limiting errors
  if (error.status === 429 || error.message.includes('rate limit')) {
    return res.status(429).json({
      success: false,
      error: 'Too many requests',
      details: 'Rate limit exceeded for AI operations',
      suggestion: 'Please wait a few minutes before trying again',
      retryAfter: error.retryAfter || 300
    });
  }

  // File/upload errors
  if (error.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({
      success: false,
      error: 'File too large',
      suggestion: 'Please upload a file smaller than 10MB'
    });
  }

  // Authentication errors
  if (error.status === 401) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required',
      suggestion: 'Please log in again'
    });
  }

  // Default error response
  res.status(error.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : error.message,
    ...(process.env.NODE_ENV !== 'production' && { 
      stack: error.stack,
      timestamp: new Date().toISOString()
    })
  });
});

module.exports = router;

================
File: routes/auth.routes.js
================
// backend/routes/auth.routes.js (updated)
const express = require('express');
const authController = require('../controllers/auth.controller');
const { protect } = require('../middleware/auth.middleware');
const { 
  validateRegistration, 
  validateLogin, 
  validatePasswordReset,
  validateUpdateDetails,
  validateUpdatePassword,
  handleValidationErrors
} = require('../middleware/validation.middleware');

const router = express.Router();

// Public routes
router.post('/register', validateRegistration, handleValidationErrors, authController.register);
router.post('/login', validateLogin, handleValidationErrors, authController.login);
router.post('/forgot-password', authController.forgotPassword);
router.put('/reset-password/:token', validatePasswordReset, handleValidationErrors, authController.resetPassword);
router.get('/verify-email/:token', authController.verifyEmail);

// Protected routes
router.use(protect); // All routes below this require authentication
router.get('/me', authController.getMe);
router.post('/logout', authController.logout);
router.post('/resend-verification', authController.resendVerification);
router.put('/update-details', validateUpdateDetails, handleValidationErrors, authController.updateDetails);
router.put('/update-password', validateUpdatePassword, handleValidationErrors, authController.updatePassword);
router.delete('/delete-account', authController.deleteAccount);

module.exports = router;

================
File: routes/job.routes.js
================
// routes/job.routes.js
const express = require('express');
const router = express.Router();
const jobController = require('../controllers/job.controller');
const authMiddleware = require('../middleware/auth.middleware');

// All job routes require authentication
router.use(authMiddleware.protect);

// Create a new job
router.post('/', jobController.createJob);

// Get all user jobs
router.get('/', jobController.getUserJobs);

// IMPORTANT: Place specific routes BEFORE parameterized routes

// Get analysis insights (must be before /:id)
router.get('/analysis-insights', jobController.getJobAnalysisInsights);

// AI Search Management Routes (must be before /:id)
router.get('/ai-searches', jobController.getUserAiSearches);
router.post('/ai-search/:searchId/pause', jobController.pauseAiSearch);
router.post('/ai-search/:searchId/resume', jobController.resumeAiSearch);
router.delete('/ai-search/:searchId', jobController.deleteAiSearch);

// Re-analyze job (must be before /:id)
router.post('/re-analyze/:id', jobController.reAnalyzeJob);

// Re-match job with best available resume (NEW - must be before /:id)
router.post('/rematch-best/:jobId', jobController.rematchJobWithBestResume);

// NEW: Get job analysis status (must be before /:id)
router.get('/analysis-status/:id', jobController.getJobAnalysisStatus);

// Get job by ID (this catches all /jobs/:id patterns, so it must come after specific routes)
router.get('/:id', jobController.getJobById);

// Get resume match status for a specific job
router.get('/:id/resume-match-status', jobController.getResumeMatchStatus);

// Update job
router.put('/:id', jobController.updateJob);

// Delete job
router.delete('/:id', jobController.deleteJob);

// Match resume with job
router.post('/match/:jobId/:resumeId', jobController.matchResumeWithJob);

// Get tailoring recommendations
router.post('/tailor/:jobId/:resumeId', jobController.tailorResumeToJob);

// Find jobs with AI
router.post('/find-with-ai/:resumeId', jobController.findJobsWithAi);

module.exports = router;

================
File: routes/recruiter.routes.js
================
// backend/routes/recruiter.routes.js - FIXED ROUTE ORDERING
const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/auth.middleware');
const recruiterController = require('../controllers/recruiter.controller');

// Simple validation middleware (since we don't have express-validator setup)
const validate = (req, res, next) => {
  // For now, just pass through - we can add validation later
  next();
};

// ===================================================================
// VALIDATION MIDDLEWARE (Simplified for now)
// ===================================================================

const validateSearch = [validate];
const validateRecruiterParams = [validate];
const validateOutreachCreation = [validate];
const validateMessageGeneration = [validate];
const validateOutreachParams = [validate];

// ===================================================================
// SPECIFIC ROUTES (MUST COME BEFORE PARAMETERIZED ROUTES)
// ===================================================================

/**
 * @route   GET /api/recruiters/search
 * @desc    Search recruiters with advanced filtering
 * @access  Private
 */
router.get('/search', protect, validateSearch, recruiterController.searchRecruiters);

/**
 * @route   GET /api/recruiters/filters
 * @desc    Get available filter options for recruiter search
 * @access  Private
 */
router.get('/filters', protect, recruiterController.getFilterOptions);

/**
 * @route   GET /api/recruiters/analytics
 * @desc    Get outreach analytics and performance metrics
 * @access  Private
 */
router.get('/analytics', protect, recruiterController.getOutreachAnalytics);

/**
 * @route   POST /api/recruiters/generate-message
 * @desc    Generate AI-powered personalized message
 * @access  Private
 */
router.post('/generate-message', protect, validateMessageGeneration, recruiterController.generatePersonalizedMessage);

// ===================================================================
// OUTREACH MANAGEMENT ROUTES (SPECIFIC PATHS)
// ===================================================================

/**
 * @route   GET /api/recruiters/outreach
 * @desc    Get user's outreach campaigns
 * @access  Private
 */
router.get('/outreach', protect, recruiterController.getUserOutreach);

/**
 * @route   POST /api/recruiters/outreach
 * @desc    Create a new outreach campaign
 * @access  Private
 */
router.post('/outreach', protect, validateOutreachCreation, recruiterController.createOutreach);

/**
 * @route   PUT /api/recruiters/outreach/:outreachId/send
 * @desc    Send a drafted outreach message
 * @access  Private
 */
router.put('/outreach/:outreachId/send', protect, validateOutreachParams, recruiterController.sendOutreach);

/**
 * @route   PUT /api/recruiters/outreach/:outreachId
 * @desc    Update an outreach campaign
 * @access  Private
 */
router.put('/outreach/:outreachId', protect, validateOutreachParams, recruiterController.updateOutreach);

/**
 * @route   DELETE /api/recruiters/outreach/:outreachId
 * @desc    Delete an outreach campaign
 * @access  Private
 */
router.delete('/outreach/:outreachId', protect, validateOutreachParams, recruiterController.deleteOutreach);

// ===================================================================
// FUTURE IMPLEMENTATION ROUTES (SPECIFIC PATHS)
// ===================================================================

/**
 * @route   GET /api/recruiters/campaigns
 * @desc    Get outreach campaigns
 * @access  Private
 * @note    Future implementation for campaign management
 */
router.get('/campaigns', protect, (req, res) => {
  res.json({
    success: true,
    message: 'Campaign management feature coming soon',
    feature: 'campaign_management'
  });
});

/**
 * @route   POST /api/recruiters/bulk-outreach
 * @desc    Create bulk outreach to multiple recruiters
 * @access  Private
 * @note    Future implementation for bulk messaging
 */
router.post('/bulk-outreach', protect, (req, res) => {
  res.json({
    success: true,
    message: 'Bulk outreach feature coming soon',
    feature: 'bulk_messaging'
  });
});

/**
 * @route   GET /api/recruiters/recommendations
 * @desc    Get AI-recommended recruiters based on user profile
 * @access  Private
 * @note    Future implementation for AI recommendations
 */
router.get('/recommendations', protect, (req, res) => {
  res.json({
    success: true,
    message: 'AI recruiter recommendations coming soon',
    feature: 'ai_recommendations'
  });
});

// ===================================================================
// PARAMETERIZED ROUTES (MUST COME AFTER ALL SPECIFIC ROUTES)
// ===================================================================

/**
 * @route   GET /api/recruiters/:recruiterId
 * @desc    Get detailed recruiter information
 * @access  Private
 */
router.get('/:recruiterId', protect, validateRecruiterParams, recruiterController.getRecruiterById);

// ===================================================================
// ADVANCED OUTREACH FEATURES (Future Implementation)
// ===================================================================

/**
 * @route   POST /api/recruiters/outreach/:outreachId/reply
 * @desc    Record a reply to an outreach message
 * @access  Private
 * @note    Future implementation for reply tracking
 */
router.post('/outreach/:outreachId/reply', protect, validateOutreachParams, (req, res) => {
  res.json({
    success: true,
    message: 'Reply tracking feature coming soon',
    feature: 'reply_tracking'
  });
});

/**
 * @route   POST /api/recruiters/outreach/:outreachId/follow-up
 * @desc    Create a follow-up message
 * @access  Private
 * @note    Future implementation for automated follow-ups
 */
router.post('/outreach/:outreachId/follow-up', protect, validateOutreachParams, (req, res) => {
  res.json({
    success: true,
    message: 'Automated follow-up feature coming soon',
    feature: 'automated_follow_ups'
  });
});

// ===================================================================
// ERROR HANDLING
// ===================================================================

// Handle 404 for recruiter routes
router.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Recruiter API endpoint not found',
    suggestion: 'Check the API documentation for available recruiter endpoints',
    requestedPath: req.path,
    method: req.method,
    availableEndpoints: [
      'GET /api/recruiters/search - Search recruiters',
      'GET /api/recruiters/filters - Get filter options',
      'GET /api/recruiters/analytics - Get analytics',
      'POST /api/recruiters/generate-message - Generate AI message',
      'GET /api/recruiters/outreach - Get outreach campaigns',
      'POST /api/recruiters/outreach - Create outreach',
      'PUT /api/recruiters/outreach/:id - Update outreach',
      'DELETE /api/recruiters/outreach/:id - Delete outreach',
      'PUT /api/recruiters/outreach/:id/send - Send outreach',
      'GET /api/recruiters/:id - Get recruiter details'
    ]
  });
});

module.exports = router;

================
File: routes/resume.routes.js
================
// backend/routes/resume.routes.js - FINAL WORKING VERSION
const express = require('express');
const router = express.Router();
const resumeController = require('../controllers/resume.controller');
const authMiddleware = require('../middleware/auth.middleware');
const multer = require('multer');
const upload = multer({ storage: multer.memoryStorage() });

console.log('ðŸ”§ Setting up resume routes...');



// ðŸ“¡ REAL SSE endpoint - MUST be before auth middleware
console.log('ðŸ“¡ Registering SSE endpoint: /:id/optimization-progress');
router.get('/:id/optimization-progress', resumeController.getOptimizationProgress);

// ðŸ”’ Apply auth middleware to all other routes
console.log('ðŸ”’ Applying auth middleware to remaining routes');
router.use(authMiddleware.protect);

// ðŸ“ Other routes (all require authentication)
router.post('/upload', upload.single('file'), resumeController.uploadResume);
router.get('/', resumeController.getUserResumes);

// Specific routes BEFORE generic /:id
router.get('/status/:id', resumeController.getResumeProcessingStatus);
router.post('/:id/optimize-ats', resumeController.optimizeResumeForATS);
router.post('/analyze/:id', resumeController.analyzeResume);
router.post('/versions/:id', upload.single('file'), resumeController.addResumeVersion);
router.post('/tailor/:resumeId/:jobId', resumeController.createTailoredResume);
router.delete('/:id', resumeController.deleteResume);

// Generic /:id route LAST
router.get('/:id', resumeController.getResumeById);

console.log('âœ… Resume routes setup complete');

module.exports = router;

================
File: routes/search.routes.js
================
// backend/routes/search.routes.js
const express = require('express');
const router = express.Router();
const SearchController = require('../controllers/search.controller');
const { protect } = require('../middleware/auth.middleware');

/**
 * Search Routes
 * All routes require authentication
 */

// @desc    Global search across all content types
// @route   GET /api/search
// @access  Private
// @params  query (required), category (optional: all|jobs|resumes|recruiters), limit (optional)
router.get('/', protect, SearchController.globalSearch);

// @desc    Get search suggestions as user types
// @route   GET /api/search/suggestions
// @access  Private
// @params  query (required), limit (optional)
router.get('/suggestions', protect, SearchController.getSearchSuggestions);

// @desc    Get popular/trending searches
// @route   GET /api/search/popular
// @access  Private
router.get('/popular', protect, SearchController.getPopularSearches);

module.exports = router;

================
File: routes/settings.routes.js
================
// backend/routes/settings.routes.js
const express = require('express');
const router = express.Router();
const settingsController = require('../controllers/settings.controller');
const { protect } = require('../middleware/auth.middleware');

// All routes require authentication
router.use(protect);

// Profile management routes
router.get('/profile', settingsController.getProfile);
router.put('/profile', settingsController.updateProfile);

// Security routes
router.put('/change-password', settingsController.changePassword);
router.delete('/delete-account', settingsController.deleteAccount);

// Account verification routes
router.post('/send-verification-email', settingsController.sendVerificationEmail);
router.get('/verify-email/:token', settingsController.verifyEmail);

module.exports = router;

================
File: routes/test.routes.js
================
// backend/routes/test.routes.js
const express = require('express');
const sendEmail = require('../utils/send-email');
const emailTemplates = require('../utils/email-templates');

const router = express.Router();

router.post('/test-email', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({
        success: false,
        error: 'Please provide an email address'
      });
    }
    
    const testUrl = 'http://localhost:3000/test';
    
    await sendEmail({
      email,
      subject: 'Test Email',
      html: emailTemplates.generateVerificationEmail('Test User', testUrl)
    });
    
    res.status(200).json({
      success: true,
      message: 'Test email sent successfully'
    });
  } catch (error) {
    console.error('Error sending test email:', error);
    res.status(500).json({
      success: false,
      error: 'Email could not be sent'
    });
  }
});

module.exports = router;

================
File: scripts/fix-missing-columns.js
================
// backend/scripts/fix-missing-columns.js
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const db = require('../config/postgresql');

async function addMissingColumns() {
  try {
    console.log('Adding missing columns to recruiters table...');
    
    const columnsToAdd = [
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS highest_education VARCHAR(100);',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS contact_accuracy_score INTEGER;',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS contact_accuracy_grade VARCHAR(10);',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS zoominfo_profile_url TEXT;',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS linkedin_profile_url TEXT;'
    ];
    
    for (const sql of columnsToAdd) {
      try {
        await db.query(sql);
        console.log(`âœ… Executed: ${sql}`);
      } catch (error) {
        console.log(`Column might already exist: ${error.message}`);
      }
    }
    
    console.log('âœ… All missing columns added to recruiters table');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error adding columns:', error);
    process.exit(1);
  }
}

addMissingColumns();

================
File: scripts/fix-outreach-history.js
================
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const db = require('../config/postgresql');

async function fixOutreachHistory() {
  try {
    console.log('ðŸ”§ Fixing outreach_history table...');
    
    // Check if constraint exists
    const constraintCheck = await db.query(`
      SELECT constraint_name 
      FROM information_schema.table_constraints 
      WHERE table_name = 'outreach_history' 
      AND constraint_type = 'UNIQUE'
      AND constraint_name = 'outreach_history_recruiter_user_unique'
    `);
    
    if (constraintCheck.rows.length === 0) {
      console.log('ðŸ“Š Adding unique constraint...');
      
      await db.query(`
        ALTER TABLE outreach_history 
        ADD CONSTRAINT outreach_history_recruiter_user_unique 
        UNIQUE (recruiter_id, mongodb_user_id)
      `);
      
      console.log('âœ… Unique constraint added successfully');
    } else {
      console.log('âœ… Unique constraint already exists');
    }
    
    // Verify table structure
    const tableInfo = await db.query(`
      SELECT column_name, data_type, is_nullable
      FROM information_schema.columns 
      WHERE table_name = 'outreach_history'
      ORDER BY ordinal_position
    `);
    
    console.log('ðŸ“‹ Current table structure:');
    tableInfo.rows.forEach(row => {
      console.log(`  ${row.column_name}: ${row.data_type} (${row.is_nullable === 'YES' ? 'nullable' : 'not null'})`);
    });
    
    console.log('âœ… Outreach history table is ready');
    
  } catch (error) {
    console.error('âŒ Error fixing outreach history:', error);
  } finally {
    process.exit(0);
  }
}

fixOutreachHistory();

================
File: scripts/import-recruiters.js
================
// backend/scripts/import-recruiters.js
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const { createTables, seedInitialData } = require('../models/postgresql/schema');
const RecruiterImportService = require('../services/recruiterImport.service');

async function main() {
  try {
    console.log('ðŸš€ Starting recruiter database setup...');
    
    // Create/update tables
    await createTables();
    
    // Seed initial data
    await seedInitialData();
    
    // Import from CSV if file exists
    const csvPath = process.argv[2];
    if (csvPath) {
      if (!require('fs').existsSync(csvPath)) {
        console.error('âŒ CSV file not found:', csvPath);
        process.exit(1);
      }
      
      console.log(`ðŸ“¥ Importing from CSV: ${csvPath}`);
      const result = await RecruiterImportService.importFromCSV(csvPath);
      
      console.log('âœ… Import Results:');
      console.log(`   Companies: ${result.companiesImported}`);
      console.log(`   Recruiters: ${result.recruitersImported}`);
      console.log(`   Total Processed: ${result.totalProcessed}`);
      console.log(`   Errors: ${result.errors}`);
    } else {
      console.log('â„¹ï¸  Tables created. To import data, run:');
      console.log('   node scripts/import-recruiters.js /path/to/your/csv/file.csv');
    }
    
    process.exit(0);
  } catch (error) {
    console.error('âŒ Setup failed:', error);
    process.exit(1);
  }
}

main();

================
File: scripts/update-recruiter-industries.js
================
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const db = require('../config/postgresql');

async function updateRecruiterIndustries() {
  try {
    console.log('ðŸ” Checking current state...');
    
    // Check current state
    const beforeCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters 
      WHERE industry_id IS NULL
    `);
    
    console.log(`ðŸ“Š Recruiters without industry: ${beforeCount.rows[0].count}`);
    
    // Check how many can be updated
    const canUpdateCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters r
      JOIN companies c ON r.current_company_id = c.id
      WHERE r.industry_id IS NULL 
      AND c.industry_id IS NOT NULL
    `);
    
    console.log(`ðŸ“Š Recruiters that can get industry from company: ${canUpdateCount.rows[0].count}`);
    
    // Perform the update
    console.log('ðŸ”„ Updating recruiter industries...');
    
    const updateResult = await db.query(`
      UPDATE recruiters 
      SET 
        industry_id = companies.industry_id,
        updated_at = NOW()
      FROM companies 
      WHERE recruiters.current_company_id = companies.id 
        AND recruiters.industry_id IS NULL
        AND companies.industry_id IS NOT NULL
    `);
    
    console.log(`âœ… Updated ${updateResult.rowCount} recruiters with industries`);
    
    // Check final state
    const afterCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters 
      WHERE industry_id IS NOT NULL
    `);
    
    console.log(`ðŸ“Š Recruiters with industry after update: ${afterCount.rows[0].count}`);
    
    // Show sample results
    console.log('ðŸ“‹ Sample results:');
    const sampleResults = await db.query(`
      SELECT 
        r.first_name,
        r.last_name,
        r.title,
        c.name as company_name,
        i.name as industry_name
      FROM recruiters r
      JOIN companies c ON r.current_company_id = c.id
      JOIN industries i ON r.industry_id = i.id
      LIMIT 5
    `);
    
    sampleResults.rows.forEach((row, index) => {
      console.log(`${index + 1}. ${row.first_name} ${row.last_name} (${row.title}) at ${row.company_name} - Industry: ${row.industry_name}`);
    });
    
    console.log('âœ… Update completed successfully!');
    
  } catch (error) {
    console.error('âŒ Error updating recruiter industries:', error);
  } finally {
    process.exit(0);
  }
}

updateRecruiterIndustries();

================
File: server.js
================
// backend/server.js - UPDATED WITH SETTINGS ROUTES
const express = require('express');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Database connections
const connectMongoDB = require('./config/mongodb');
const { createTables, seedInitialData } = require('./models/postgresql/schema');

// Import routes
const authRoutes = require('./routes/auth.routes');
const resumeRoutes = require('./routes/resume.routes');
const jobRoutes = require('./routes/job.routes');
const assistantRoutes = require('./routes/assistant.routes');
const recruiterRoutes = require('./routes/recruiter.routes');
const searchRoutes = require('./routes/search.routes');
const settingsRoutes = require('./routes/settings.routes'); // NEW: Settings routes

// Initialize Express
const app = express();

console.log('ðŸš€ Starting Job Application Platform API...');

// Trust proxy for production
if (process.env.NODE_ENV === 'production') {
  app.set('trust proxy', 1);
}

// CORS configuration (simplified - the complex version wasn't the issue)
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.FRONTEND_URL || 'https://yourproductiondomain.com'
    : 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: [
    'Content-Type',
    'Authorization', 
    'X-Requested-With',
    'Accept',
    'Origin'
  ]
}));

// Security middleware
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: false // Disable CSP for development
}));

// Body parser middleware
app.use(express.json({ 
  limit: '10mb',
  strict: true
}));
app.use(express.urlencoded({ 
  extended: true, 
  limit: '10mb' 
}));

// Cookie parser middleware
app.use(cookieParser());

// Request sanitization middleware - FIXED VERSION
const sanitizeRequest = (req, res, next) => {
  const sanitize = (obj) => {
    if (!obj) return obj;
    
    if (typeof obj === 'object' && obj !== null) {
      // Handle arrays
      if (Array.isArray(obj)) {
        return obj.map(sanitize);
      }
      
      // Handle objects - FIXED: Use Object.prototype.hasOwnProperty.call()
      const sanitized = {};
      for (const key in obj) {
        // FIXED: Use Object.prototype.hasOwnProperty.call instead of obj.hasOwnProperty
        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
        
        // Check for MongoDB injection patterns
        if (key.startsWith('$') || key.includes('.')) {
          console.warn(`Potentially malicious key detected and removed: ${key}`);
          continue;
        }
        
        sanitized[key] = sanitize(obj[key]);
      }
      return sanitized;
    }
    return obj;
  };
  
  // Sanitize request data
  try {
    if (req.body) req.body = sanitize(req.body);
    if (req.query) req.query = sanitize(req.query);
    if (req.params) req.params = sanitize(req.params);
  } catch (error) {
    console.warn('Sanitization error:', error);
    // Continue without sanitization if there's an error
  }
  
  next();
};

app.use(sanitizeRequest);

// Rate limiting (more lenient for AI Assistant)
const generalLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: 'Too many requests from this IP, please try again later.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for AI Assistant (more restrictive due to cost)
const aiLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 50, // limit AI requests to 50 per 10 minutes
  message: {
    success: false,
    error: 'AI Assistant rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for Recruiter API (moderate limits)
const recruiterLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 150, // Higher limit for recruiter searches
  message: {
    success: false,
    error: 'Recruiter API rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for Search API (moderate limits)
const searchLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 100, // Allow frequent searches
  message: {
    success: false,
    error: 'Search rate limit exceeded. Please wait before searching again.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// NEW: Special rate limiter for Settings API (moderate limits)
const settingsLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 30, // Allow reasonable settings updates
  message: {
    success: false,
    error: 'Settings rate limit exceeded. Please wait before making more changes.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', generalLimiter);
app.use('/api/assistant', aiLimiter);
app.use('/api/recruiters', recruiterLimiter);
app.use('/api/search', searchLimiter);
app.use('/api/settings', settingsLimiter); // NEW: Settings-specific rate limiting

// Request logging middleware (development only)
if (process.env.NODE_ENV !== 'production') {
  app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.originalUrl}`);
    next();
  });
}

// Database initialization
const initializeDatabases = async () => {
  try {
    console.log('ðŸ”Œ Initializing databases...');
    
    // Connect to MongoDB
    await connectMongoDB();
    console.log('âœ… MongoDB connected successfully');
    
    // Set up PostgreSQL tables
    await createTables();
    console.log('âœ… PostgreSQL tables created successfully');
    
    // Seed initial data
    await seedInitialData();
    console.log('âœ… Initial data seeded successfully');
    
    console.log('ðŸŽ‰ All database connections completed successfully');
  } catch (error) {
    console.error('âŒ Database initialization error:', error.message);
    
    // In production, exit on database failure
    if (process.env.NODE_ENV === 'production') {
      process.exit(1);
    } else {
      console.log('âš ï¸ Continuing in development mode without full database setup...');
    }
  }
};

// Initialize databases
initializeDatabases();

// API Routes
app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'Job Application Platform API is running',
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString(),
    features: [
      'User Authentication',
      'Resume Management', 
      'Job Tracking',
      'AI Career Assistant',
      'Job Matching',
      'AI Job Search',
      'Recruiter Outreach',
      'Global Search',
      'User Settings & Security' // NEW: Added settings feature
    ]
  });
});

app.get('/api/health', (req, res) => {
  res.status(200).json({ 
    success: true,
    status: 'OK', 
    message: 'API is healthy',
    timestamp: new Date().toISOString(),
    uptime: Math.floor(process.uptime()),
    memory: process.memoryUsage(),
    environment: process.env.NODE_ENV || 'development',
    ai_status: process.env.OPENAI_API_KEY ? 'configured' : 'not_configured',
    database_status: {
      mongodb: 'connected',
      postgresql: 'connected'
    }
  });
});

// Mount API routes
app.use('/api/auth', authRoutes);
app.use('/api/resumes', resumeRoutes);
app.use('/api/jobs', jobRoutes);
app.use('/api/assistant', assistantRoutes);
app.use('/api/recruiters', recruiterRoutes);
app.use('/api/search', searchRoutes);
app.use('/api/settings', settingsRoutes); // NEW: Mount settings routes

// FIXED: Catch-all route with named parameter (this was the problem!)
// Changed from '/api/*' to '/api/*path' - the wildcard MUST be named
app.all('/api/*path', (req, res) => {
  res.status(404).json({
    success: false,
    error: `API endpoint ${req.originalUrl} not found`,
    suggestion: 'Check the API documentation for available endpoints',
    availableEndpoints: {
      auth: [
        'POST /api/auth/login',
        'POST /api/auth/register',
        'GET /api/auth/me',
        'POST /api/auth/logout'
      ],
      resumes: [
        'GET /api/resumes',
        'POST /api/resumes/upload',
        'GET /api/resumes/:id'
      ],
      jobs: [
        'GET /api/jobs',
        'POST /api/jobs',
        'GET /api/jobs/:id'
      ],
      assistant: [
        'POST /api/assistant/chat',
        'POST /api/assistant/analyze-resume',
        'POST /api/assistant/analyze-job-match',
        'GET /api/assistant/health'
      ],
      recruiters: [
        'GET /api/recruiters/search',
        'GET /api/recruiters/filters',
        'GET /api/recruiters/:id',
        'POST /api/recruiters/outreach',
        'GET /api/recruiters/outreach',
        'POST /api/recruiters/generate-message',
        'GET /api/recruiters/analytics'
      ],
      search: [
        'GET /api/search?query={query}&category={category}',
        'GET /api/search/suggestions?query={query}',
        'GET /api/search/popular'
      ],
      settings: [ // NEW: Settings endpoints
        'GET /api/settings/profile',
        'PUT /api/settings/profile',
        'PUT /api/settings/change-password',
        'DELETE /api/settings/delete-account',
        'POST /api/settings/send-verification-email',
        'GET /api/settings/verify-email/:token'
      ]
    }
  });
});

// Global error handling middleware
app.use((err, req, res, next) => {
  console.error('Global error handler triggered:', {
    message: err.message,
    stack: process.env.NODE_ENV !== 'production' ? err.stack : undefined,
    url: req.originalUrl,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  // OpenAI API error handling
  if (err.message && err.message.includes('OpenAI')) {
    return res.status(503).json({
      success: false,
      error: 'AI service temporarily unavailable',
      details: process.env.NODE_ENV !== 'production' ? err.message : undefined
    });
  }
  
  // PostgreSQL error handling
  if (err.code && err.code.startsWith('23')) { // PostgreSQL constraint violations
    return res.status(400).json({
      success: false,
      error: 'Database constraint violation',
      details: process.env.NODE_ENV !== 'production' ? err.message : undefined
    });
  }
  
  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(val => val.message);
    return res.status(400).json({
      success: false,
      error: 'Validation Error',
      details: errors
    });
  }
  
  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue || {})[0] || 'field';
    return res.status(400).json({
      success: false,
      error: `${field} already exists`
    });
  }
  
  // JWT error
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
  
  // MongoDB connection error
  if (err.name === 'MongoNetworkError') {
    return res.status(503).json({
      success: false,
      error: 'Database connection error'
    });
  }
  
  // Default error response
  res.status(err.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal Server Error' 
      : err.message,
    ...(process.env.NODE_ENV !== 'production' && { 
      stack: err.stack,
      timestamp: new Date().toISOString()
    })
  });
});

// Start the server
const PORT = process.env.PORT || 5000;
const server = app.listen(PORT, () => {
  console.log(`ðŸš€ Server running successfully on port ${PORT}`);
  console.log(`ðŸ“ Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`ðŸŒ CORS enabled for: ${process.env.NODE_ENV === 'production' ? 'production domain' : 'http://localhost:3000'}`);
  console.log(`ðŸ“Š Health check available at: http://localhost:${PORT}/api/health`);
  console.log(`ðŸ”— API documentation: http://localhost:${PORT}/`);
  console.log(`ðŸ¤– AI Assistant: ${process.env.OPENAI_API_KEY ? 'âœ… Configured' : 'âŒ Not configured - add OPENAI_API_KEY to .env'}`);
  console.log(`ðŸŽ¯ Recruiter API: âœ… Configured with PostgreSQL database`);
  console.log(`ðŸ” Global Search: âœ… Configured with cross-platform search`);
  console.log(`âš™ï¸ Settings API: âœ… Configured with profile & security management`); // NEW
});

// Graceful shutdown handlers
process.on('SIGTERM', () => {
  console.log('ðŸ›‘ SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    console.log('âœ… HTTP server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('ðŸ›‘ SIGINT received. Shutting down gracefully...');
  server.close(() => {
    console.log('âœ… HTTP server closed');
    process.exit(0);
  });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err, promise) => {
  console.error('ðŸ”¥ UNHANDLED REJECTION:', {
    message: err.message,
    stack: err.stack,
    promise: promise
  });
  
  if (process.env.NODE_ENV === 'production') {
    console.log('ðŸ›‘ Shutting down server due to unhandled promise rejection');
    server.close(() => {
      process.exit(1);
    });
  }
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('ðŸ”¥ UNCAUGHT EXCEPTION:', {
    message: err.message,
    stack: err.stack
  });
  
  console.log('ðŸ›‘ Shutting down server due to uncaught exception');
  process.exit(1);
});

================
File: services/assistant.service.js
================
// src/utils/assistantService.js - ENHANCED WITH MEMORY & CONVERSATIONS
import api from './axios';

const assistantService = {
  // ===================================================================
  // ENHANCED CHAT WITH CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Send message to AI Assistant with enhanced context and conversation management
   */
  sendMessage: async (requestData) => {
    try {
      const {
        message,
        context = {},
        conversationId,
        newConversation = false,
        conversationHistory = []
      } = requestData;

      const response = await api.post('/assistant/chat', {
        message,
        context: {
          page: context.page || 'unknown',
          currentResume: context.currentResume || null,
          currentJob: context.currentJob || null,
          resumeCount: context.resumeCount || 0,
          jobCount: context.jobCount || 0,
          userProfile: context.userProfile || null
        },
        conversationId,
        newConversation,
        conversationHistory: conversationHistory.slice(-10) // Last 10 messages
      });

      return {
        message: response.data.message,
        suggestions: response.data.suggestions || [],
        actions: response.data.actions || [],
        confidence: response.data.confidence || 0.8,
        conversationId: response.data.conversationId,
        conversationTitle: response.data.conversationTitle,
        memoryInsights: response.data.memoryInsights || [],
        usage: response.data.usage || {}
      };

    } catch (error) {
      console.error('Enhanced AI Assistant Service Error:', error);
      
      // Enhanced fallback responses based on context
      const fallbackResponse = this.getContextualFallback(requestData.message, requestData.context);
      
      if (error.response?.status === 503) {
        throw new Error('AI service temporarily unavailable. Please try again in a moment.');
      } else if (error.response?.status === 429) {
        throw new Error('Rate limit exceeded. Please wait before sending another message.');
      } else {
        throw new Error(fallbackResponse.error || 'AI service temporarily unavailable');
      }
    }
  },

  // ===================================================================
  // CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Get user's conversations
   */
  getConversations: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.category) params.append('category', options.category);
      if (options.tags && options.tags.length > 0) params.append('tags', options.tags.join(','));
      if (options.search) params.append('search', options.search);
      if (options.pinned !== undefined) params.append('pinned', options.pinned);
      if (options.starred !== undefined) params.append('starred', options.starred);
      if (options.limit) params.append('limit', options.limit);
      if (options.offset) params.append('offset', options.offset);
      if (options.sortBy) params.append('sortBy', options.sortBy);

      const response = await api.get(`/assistant/conversations?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching conversations:', error);
      throw error;
    }
  },

  /**
   * Get specific conversation
   */
  getConversation: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}`);
      return response.data.conversation;
    } catch (error) {
      console.error('Error fetching conversation:', error);
      throw error;
    }
  },

  /**
   * Create new conversation
   */
  createConversation: async (conversationData) => {
    try {
      const response = await api.post('/assistant/conversations', conversationData);
      return response.data.conversation;
    } catch (error) {
      console.error('Error creating conversation:', error);
      throw error;
    }
  },

  /**
   * Update conversation
   */
  updateConversation: async (conversationId, updates) => {
    try {
      const response = await api.put(`/assistant/conversations/${conversationId}`, updates);
      return response.data.conversation;
    } catch (error) {
      console.error('Error updating conversation:', error);
      throw error;
    }
  },

  /**
   * Delete conversation
   */
  deleteConversation: async (conversationId, permanent = false) => {
    try {
      const params = permanent ? '?permanent=true' : '';
      const response = await api.delete(`/assistant/conversations/${conversationId}${params}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting conversation:', error);
      throw error;
    }
  },

  /**
   * Generate conversation summary
   */
  generateSummary: async (conversationId) => {
    try {
      const response = await api.post(`/assistant/conversations/${conversationId}/summary`);
      return response.data.summary;
    } catch (error) {
      console.error('Error generating summary:', error);
      throw error;
    }
  },

  /**
   * Get conversation insights
   */
  getConversationInsights: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/insights`);
      return response.data.insights;
    } catch (error) {
      console.error('Error getting insights:', error);
      throw error;
    }
  },

  /**
   * Export conversation
   */
  exportConversation: async (conversationId, format = 'json') => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/export?format=${format}`);
      return response.data.export;
    } catch (error) {
      console.error('Error exporting conversation:', error);
      throw error;
    }
  },

  /**
   * Bulk update conversations
   */
  bulkUpdateConversations: async (conversationIds, updates) => {
    try {
      const response = await api.post('/assistant/conversations/bulk-update', {
        conversationIds,
        updates
      });
      return response.data.result;
    } catch (error) {
      console.error('Error bulk updating conversations:', error);
      throw error;
    }
  },

  // ===================================================================
  // MEMORY MANAGEMENT
  // ===================================================================

  /**
   * Get user memories
   */
  getMemories: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.type) params.append('type', options.type);
      if (options.category) params.append('category', options.category);
      if (options.search) params.append('search', options.search);
      if (options.minConfidence) params.append('minConfidence', options.minConfidence);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/memories?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching memories:', error);
      throw error;
    }
  },

  /**
   * Add or update memory
   */
  updateMemory: async (memoryData) => {
    try {
      const response = await api.post('/assistant/memories', { memoryData });
      return response.data;
    } catch (error) {
      console.error('Error updating memory:', error);
      throw error;
    }
  },

  /**
   * Delete memory
   */
  deleteMemory: async (memoryId) => {
    try {
      const response = await api.delete(`/assistant/memories/${memoryId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting memory:', error);
      throw error;
    }
  },

  /**
   * Get memory insights
   */
  getMemoryInsights: async () => {
    try {
      const response = await api.get('/assistant/memory-insights');
      return response.data;
    } catch (error) {
      console.error('Error getting memory insights:', error);
      throw error;
    }
  },

  /**
   * Perform memory maintenance
   */
  performMemoryMaintenance: async () => {
    try {
      const response = await api.post('/assistant/memory-maintenance');
      return response.data.maintenance;
    } catch (error) {
      console.error('Error performing memory maintenance:', error);
      throw error;
    }
  },

  // ===================================================================
  // SEARCH & ANALYTICS
  // ===================================================================

  /**
   * Search across conversations and memories
   */
  search: async (query, options = {}) => {
    try {
      const params = new URLSearchParams();
      params.append('query', query);
      
      if (options.searchType) params.append('searchType', options.searchType);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/search?${params}`);
      return response.data.results;

    } catch (error) {
      console.error('Error searching:', error);
      return { conversations: [], memories: [] };
    }
  },

  /**
   * Get analytics
   */
  getAnalytics: async (timeframe = '30d') => {
    try {
      const response = await api.get(`/assistant/analytics?timeframe=${timeframe}`);
      return response.data.analytics;
    } catch (error) {
      console.error('Error getting analytics:', error);
      throw error;
    }
  },

  // ===================================================================
  // ENHANCED RESUME OPERATIONS
  // ===================================================================

  /**
   * Analyze resume with memory context
   */
  analyzeResume: async (resumeId, analysisType = 'comprehensive') => {
    try {
      const response = await api.post('/assistant/analyze-resume', {
        resumeId,
        analysisType,
        includeImprovements: true,
        includeKeywords: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing resume:', error);
      throw error;
    }
  },

  /**
   * Apply resume changes suggested by AI
   */
  applyResumeChanges: async (changes) => {
    try {
      const response = await api.post('/assistant/apply-resume-changes', {
        resumeId: changes.resumeId,
        changes: changes.modifications,
        changeType: changes.type || 'enhancement'
      });

      return response.data;

    } catch (error) {
      console.error('Error applying resume changes:', error);
      throw error;
    }
  },

  /**
   * Optimize resume for ATS
   */
  optimizeForATS: async (resumeId, jobId = null) => {
    try {
      const response = await api.post('/assistant/optimize-ats', {
        resumeId,
        targetJobId: jobId,
        optimizationLevel: 'aggressive',
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error optimizing for ATS:', error);
      throw error;
    }
  },

  // ===================================================================
  // JOB MATCHING & CAREER GUIDANCE
  // ===================================================================

  /**
   * Get job matching insights with memory context
   */
  analyzeJobMatch: async (resumeId, jobId) => {
    try {
      const response = await api.post('/assistant/analyze-job-match', {
        resumeId,
        jobId,
        includeImprovements: true,
        includeTailoringAdvice: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing job match:', error);
      throw error;
    }
  },

/**
   * Generate personalized cover letter
   */
  generateCoverLetter: async (resumeId, jobId, style = 'professional') => {
    try {
      const response = await api.post('/assistant/generate-cover-letter', {
        resumeId,
        jobId,
        style,
        customization: 'high',
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error generating cover letter:', error);
      throw error;
    }
  },

  /**
   * Get career advice and guidance with memory context
   */
  getCareerAdvice: async (userProfile, specificQuestion = null) => {
    try {
      const response = await api.post('/assistant/career-advice', {
        userProfile,
        question: specificQuestion,
        includeJobSuggestions: true,
        includeSkillGaps: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error getting career advice:', error);
      throw error;
    }
  },

  /**
   * Get contextual suggestions for current page
   */
  getContextualSuggestions: async (page, contextData = {}) => {
    try {
      const response = await api.post('/assistant/contextual-suggestions', {
        page,
        contextData,
        maxSuggestions: 5,
        useMemoryContext: true
      });

      return response.data.suggestions || [];

    } catch (error) {
      console.error('Error getting contextual suggestions:', error);
      return this.getFallbackSuggestions(page, contextData);
    }
  },

  /**
   * Get personalized tips based on user profile and memory
   */
  getPersonalizedTips: async (category = 'general') => {
    try {
      const response = await api.post('/assistant/personalized-tips', {
        category,
        includeActions: true,
        useMemoryContext: true
      });

      return response.data.tips || [];

    } catch (error) {
      console.error('Error getting personalized tips:', error);
      return this.getFallbackTips(category);
    }
  },

  // ===================================================================
  // SYSTEM & HEALTH
  // ===================================================================

  /**
   * Get AI Assistant capabilities and status
   */
  getCapabilities: async () => {
    try {
      const response = await api.get('/assistant/capabilities');
      return response.data;
    } catch (error) {
      console.error('Error getting AI capabilities:', error);
      return {
        available: false,
        features: ['basic_chat', 'contextual_suggestions'],
        limitations: ['Full AI features unavailable in test mode'],
        memory_features: {
          available: false
        }
      };
    }
  },

  /**
   * Check AI Assistant health
   */
  checkHealth: async () => {
    try {
      const response = await api.get('/assistant/health');
      return response.data;
    } catch (error) {
      console.error('Health check failed:', error);
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  },

  /**
   * Get user's AI usage statistics
   */
  getUsageStats: async () => {
    try {
      const response = await api.get('/assistant/usage-stats');
      return response.data;
    } catch (error) {
      console.error('Error getting usage stats:', error);
      return {
        messagesThisMonth: 0,
        resumeAnalyses: 0,
        jobMatches: 0,
        careerAdviceRequests: 0,
        conversationsCreated: 0,
        memoriesStored: 0
      };
    }
  },

  /**
   * Track user interaction
   */
  trackInteraction: async (interactionType, data) => {
    try {
      await api.post('/assistant/track-interaction', {
        type: interactionType,
        data,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      // Non-critical, just log
      console.warn('Failed to track interaction:', error);
    }
  },

  /**
   * Reset AI conversation context
   */
  resetContext: async () => {
    try {
      await api.post('/assistant/reset-context');
      return { success: true };
    } catch (error) {
      console.error('Error resetting context:', error);
      return { success: false };
    }
  },

  // ===================================================================
  // CONVERSATION UTILITIES
  // ===================================================================

  /**
   * Auto-generate conversation title based on content
   */
  generateConversationTitle: async (messages, context = {}) => {
    try {
      if (!messages || messages.length === 0) return 'New Conversation';

      // Use the first user message to generate title
      const firstUserMessage = messages.find(m => m.type === 'user');
      if (!firstUserMessage) return 'New Conversation';

      // Simple client-side title generation for immediate feedback
      const content = firstUserMessage.content.toLowerCase();
      
      if (content.includes('resume')) return 'Resume Assistance';
      if (content.includes('job') || content.includes('application')) return 'Job Search Help';
      if (content.includes('interview')) return 'Interview Preparation';
      if (content.includes('career')) return 'Career Guidance';
      if (content.includes('skill')) return 'Skill Development';
      
      // Fallback based on context
      const contextTitles = {
        'resumes': 'Resume Help',
        'jobs': 'Job Search',
        'dashboard': 'Career Planning'
      };
      
      return contextTitles[context.page] || 'Career Assistance';

    } catch (error) {
      console.error('Error generating conversation title:', error);
      return 'New Conversation';
    }
  },

  /**
   * Format conversation for display
   */
  formatConversation: (conversation) => {
    if (!conversation) return null;

    return {
      ...conversation,
      formattedDate: new Date(conversation.createdAt).toLocaleDateString(),
      formattedTime: new Date(conversation.lastActiveAt).toLocaleTimeString(),
      preview: conversation.messages && conversation.messages.length > 0
        ? conversation.messages[conversation.messages.length - 1].content.substring(0, 100) + '...'
        : conversation.description || 'No messages yet',
      messageCount: conversation.messages ? conversation.messages.length : 0,
      isRecent: Date.now() - new Date(conversation.lastActiveAt).getTime() < 24 * 60 * 60 * 1000
    };
  },

  /**
   * Format memory for display
   */
  formatMemory: (memory) => {
    if (!memory) return null;

    return {
      ...memory,
      formattedDate: new Date(memory.createdAt).toLocaleDateString(),
      confidencePercentage: Math.round(memory.confidence * 100),
      isHighConfidence: memory.confidence >= 0.8,
      isRecentlyAccessed: memory.usage?.lastAccessedAt && 
        Date.now() - new Date(memory.usage.lastAccessedAt).getTime() < 7 * 24 * 60 * 60 * 1000,
      typeLabel: this.getMemoryTypeLabel(memory.type),
      categoryLabel: this.getCategoryLabel(memory.category)
    };
  },

  /**
   * Get human-readable memory type labels
   */
  getMemoryTypeLabel: (type) => {
    const labels = {
      'preference': 'Preference',
      'skill': 'Skill',
      'career_goal': 'Career Goal',
      'experience': 'Experience',
      'achievement': 'Achievement',
      'challenge': 'Challenge',
      'personality_trait': 'Personality',
      'communication_style': 'Communication Style',
      'work_style': 'Work Style',
      'industry_knowledge': 'Industry Knowledge',
      'tool_preference': 'Tool Preference',
      'feedback_pattern': 'Feedback Pattern'
    };
    return labels[type] || type;
  },

  /**
   * Get human-readable category labels
   */
  getCategoryLabel: (category) => {
    const labels = {
      'personal': 'Personal',
      'professional': 'Professional',
      'technical': 'Technical',
      'behavioral': 'Behavioral',
      'contextual': 'Contextual'
    };
    return labels[category] || category;
  },

  // ===================================================================
  // ENHANCED FALLBACK RESPONSES
  // ===================================================================

  /**
   * Enhanced fallback responses based on context
   */
  getContextualFallback: (message, context) => {
    const lowercaseMessage = message.toLowerCase();

    // Resume-related queries
    if (lowercaseMessage.includes('resume') || lowercaseMessage.includes('cv')) {
      if (context?.page === 'resumes' && context?.currentResume) {
        return {
          message: `I can see you're working on "${context.currentResume.name}". While I can't access my full AI capabilities right now, I suggest focusing on: quantifying achievements with metrics, using action verbs, and ensuring ATS compatibility. I remember our previous discussions about your career goals and can provide personalized suggestions once I'm back online.`,
          suggestions: [
            'Help improve work experience section',
            'Suggest better action verbs',
            'Check ATS compatibility',
            'Add missing skills based on your profile'
          ]
        };
      }
      return {
        message: "I'd love to help improve your resume! I remember our previous conversations about your career goals and preferences. Common improvements include quantifying achievements, using strong action verbs, optimizing for ATS systems, and tailoring to specific jobs. Which resume would you like to work on?",
        suggestions: [
          'Analyze my best resume',
          'Create new resume',
          'Compare my resumes',
          'ATS optimization tips'
        ]
      };
    }

    // Job-related queries
    if (lowercaseMessage.includes('job') || lowercaseMessage.includes('application') || lowercaseMessage.includes('interview')) {
      if (context?.page === 'jobs' && context?.currentJob) {
        return {
          message: `Looking at "${context.currentJob.title}" at ${context.currentJob.company}. Based on what I remember about your background and preferences, I can help you understand how well your resume matches this position and suggest improvements to increase your chances.`,
          suggestions: [
            'Match my best resume to this job',
            'What skills am I missing?',
            'Help tailor my resume',
            'Write a personalized cover letter'
          ]
        };
      }
      return {
        message: "I can help you with job searching, application optimization, and interview preparation! I remember your career goals and can provide personalized advice. What specific aspect would you like assistance with?",
        suggestions: [
          'Find matching jobs for my profile',
          'Improve application materials',
          'Interview preparation tips',
          'Salary negotiation advice'
        ]
      };
    }

    // Career guidance queries
    if (lowercaseMessage.includes('career') || lowercaseMessage.includes('advice') || lowercaseMessage.includes('guidance')) {
      return {
        message: "I'm here to provide personalized career guidance! I remember our previous conversations about your goals and challenges. I can help with career planning, skill development, industry insights, and strategic job search approaches. What's your biggest career challenge right now?",
        suggestions: [
          'Plan my next career move',
          'Identify skill gaps for my goals',
          'Industry insights for my field',
          'Job search strategy review'
        ]
      };
    }

    // Memory-related queries
    if (lowercaseMessage.includes('remember') || lowercaseMessage.includes('memory') || lowercaseMessage.includes('previous')) {
      return {
        message: "I maintain a memory of our conversations to provide better assistance! I remember your preferences, goals, and career journey. While I'm currently in test mode, I can still access some of our conversation history and provide personalized advice.",
        suggestions: [
          'Show my conversation history',
          'What do you remember about me?',
          'Review my career progress',
          'Update my preferences'
        ]
      };
    }

    // Default fallback
    return {
      message: "I'm currently running in test mode while my full AI capabilities are being set up, but I can still access our conversation history and provide personalized career advice. I remember your goals and preferences from our previous discussions. What would you like to explore?",
      suggestions: [
        'Review my career progress',
        'Resume improvement tips',
        'Job search strategy',
        'Show conversation history'
      ],
      error: 'AI service temporarily in test mode'
    };
  },

  /**
   * Get fallback suggestions based on page context
   */
  getFallbackSuggestions: (page, contextData) => {
    const suggestions = {
      dashboard: [
        'Review my career progress',
        'What should I focus on today?',
        'Find new job opportunities',
        'Show my conversation history'
      ],
      resumes: [
        'Improve this resume with memory context',
        'Check ATS compatibility',
        'Compare with other resumes',
        'Add missing keywords for my goals'
      ],
      jobs: [
        'Match resume to this job',
        'Find similar positions for my profile',
        'Improve match score',
        'Create tailored resume version'
      ],
      'ai-searches': [
        'Optimize search criteria for my goals',
        'Review found opportunities',
        'Adjust search parameters',
        'Set up new automated searches'
      ]
    };

    return suggestions[page] || [
      'Help with resume using my profile',
      'Find job opportunities that match me',
      'Career guidance based on my goals',
      'Review my conversation history'
    ];
  },

  /**
   * Get fallback tips based on category
   */
  getFallbackTips: (category) => {
    const fallbackTips = {
      resume: [
        'Use action verbs to start each bullet point',
        'Quantify achievements with specific numbers',
        'Tailor keywords to match job descriptions',
        'Keep formatting clean and ATS-friendly',
        'Highlight achievements relevant to your career goals'
      ],
      job_search: [
        'Apply to jobs within 24-48 hours of posting',
        'Customize your resume for each application',
        'Research company culture before applying',
        'Follow up professionally after 1-2 weeks',
        'Leverage your network for referrals'
      ],
      career: [
        'Set SMART career goals every quarter',
        'Build your professional network consistently',
        'Stay updated with industry trends',
        'Invest in learning new skills regularly',
        'Seek feedback and mentorship opportunities'
      ],
      interview: [
        'Practice common interview questions',
        'Research the company and role thoroughly',
        'Prepare specific examples using STAR method',
        'Ask thoughtful questions about the role',
        'Follow up with a thank-you message'
      ],
      general: [
        'Keep your LinkedIn profile updated',
        'Track your job applications systematically',
        'Practice interviewing regularly',
        'Maintain a professional online presence',
        'Document your achievements for future reference'
      ]
    };

    return fallbackTips[category] || fallbackTips.general;
  },

  // ===================================================================
  // VALIDATION & UTILITIES
  // ===================================================================

  /**
   * Validate message content before sending
   */
  validateMessage: (message) => {
    if (!message || typeof message !== 'string') {
      return { valid: false, error: 'Message must be a non-empty string' };
    }

    if (message.trim().length === 0) {
      return { valid: false, error: 'Message cannot be empty' };
    }

    if (message.length > 3000) {
      return { valid: false, error: 'Message too long (max 3000 characters)' };
    }

    // Check for potential harmful content
    const harmfulPatterns = [
      /password/i,
      /credit card/i,
      /social security/i,
      /ssn/i
    ];

    for (const pattern of harmfulPatterns) {
      if (pattern.test(message)) {
        return { 
          valid: false, 
          error: 'Please avoid sharing sensitive personal information' 
        };
      }
    }

    return { valid: true };
  },

  /**
   * Format AI response for display
   */
  formatResponse: (response) => {
    if (!response || typeof response !== 'string') {
      return 'I encountered an issue processing that request. Please try again.';
    }

    // Clean up common AI response artifacts
    let formatted = response
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove markdown bold
      .replace(/\*(.*?)\*/g, '$1')     // Remove markdown italic
      .replace(/\n\n+/g, '\n\n')      // Normalize line breaks
      .trim();

    // Ensure proper sentence structure
    if (formatted && !formatted.endsWith('.') && !formatted.endsWith('!') && !formatted.endsWith('?')) {
      formatted += '.';
    }

    return formatted;
  },

  /**
   * Check if AI service is available
   */
  isAvailable: async () => {
    try {
      const response = await api.get('/assistant/health');
      return response.data.status === 'healthy';
    } catch (error) {
      console.warn('AI Assistant service unavailable:', error.message);
      return false;
    }
  },

  /**
   * Get conversation statistics
   */
  getConversationStats: async () => {
    try {
      const analytics = await this.getAnalytics('30d');
      return {
        totalConversations: analytics.totalConversations || 0,
        totalMessages: analytics.totalMessages || 0,
        avgEngagement: analytics.avgEngagement || 0,
        mostActiveCategory: analytics.categoryDistribution ? 
          Object.keys(analytics.categoryDistribution)[0] : 'general'
      };
    } catch (error) {
      console.error('Error getting conversation stats:', error);
      return {
        totalConversations: 0,
        totalMessages: 0,
        avgEngagement: 0,
        mostActiveCategory: 'general'
      };
    }
  },

  /**
   * Estimate tokens for message
   */
  estimateTokens: (text) => {
    // Rough estimation: ~4 characters per token
    return Math.ceil(text.length / 4);
  },

  /**
   * Calculate estimated cost
   */
  estimateCost: (tokens) => {
    // GPT-4 Turbo pricing estimate
    const inputCost = 0.01 / 1000;
    const outputCost = 0.03 / 1000;
    return ((tokens * 0.5 * inputCost) + (tokens * 0.5 * outputCost)).toFixed(4);
  }
};

export default assistantService;

================
File: services/conversationService.js
================
// backend/services/conversationService.js
const Conversation = require('../models/mongodb/conversation.model');
const MemoryService = require('./memoryService');
const { openai } = require('../config/openai');

class ConversationService {
  /**
   * Create a new conversation
   */
  static async createConversation(userId, conversationData) {
    try {
      const conversation = new Conversation({
        userId,
        title: conversationData.title || 'New Conversation',
        description: conversationData.description || '',
        category: conversationData.category || 'general',
        tags: conversationData.tags || [],
        context: conversationData.context || {},
        settings: {
          memoryEnabled: true,
          autoSummarize: true,
          ...conversationData.settings
        }
      });

      await conversation.save();

      // Add initial system message if provided
      if (conversationData.initialMessage) {
        await this.addMessage(conversation._id, {
          type: 'system',
          content: conversationData.initialMessage,
          metadata: {
            context: conversationData.context
          }
        });
      }

      return conversation;

    } catch (error) {
      console.error('Create conversation error:', error);
      throw error;
    }
  }

  /**
   * Get user's conversations with filtering and pagination
   */
  static async getUserConversations(userId, options = {}) {
    try {
      const {
        category,
        tags,
        search,
        pinned,
        starred,
        status = 'active',
        limit = 20,
        offset = 0,
        sortBy = 'lastActiveAt',
        sortOrder = 'desc'
      } = options;

      let query = { userId, status };

      // Apply filters
      if (category) query.category = category;
      if (tags && tags.length > 0) query.tags = { $in: tags };
      if (pinned !== undefined) query.pinned = pinned;
      if (starred !== undefined) query.starred = starred;

      // Handle search
      if (search) {
        query.$or = [
          { title: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } },
          { tags: { $regex: search, $options: 'i' } },
          { 'summary.keyTopics': { $regex: search, $options: 'i' } }
        ];
      }

      const sortOptions = {};
      sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;

      const conversations = await Conversation.find(query)
        .sort(sortOptions)
        .limit(limit)
        .skip(offset)
        .populate('context.primaryResumeId', 'name analysis.overallScore')
        .populate('context.relatedJobIds', 'title company')
        .lean();

      // Add computed fields
      const enrichedConversations = conversations.map(conv => ({
        ...conv,
        messageCount: conv.messages ? conv.messages.length : 0,
        lastMessage: conv.messages && conv.messages.length > 0 
          ? conv.messages[conv.messages.length - 1] 
          : null,
        unreadCount: this.calculateUnreadCount(conv.messages),
        preview: this.generatePreview(conv)
      }));

      return {
        conversations: enrichedConversations,
        total: await Conversation.countDocuments(query),
        hasMore: (offset + limit) < await Conversation.countDocuments(query)
      };

    } catch (error) {
      console.error('Get user conversations error:', error);
      throw error;
    }
  }

  /**
   * Get a specific conversation with full message history
   */
  static async getConversation(conversationId, userId) {
    try {
      const conversation = await Conversation.findOne({
        _id: conversationId,
        userId,
        status: { $ne: 'deleted' }
      })
      .populate('context.primaryResumeId', 'name analysis.overallScore parsedData.skills')
      .populate('context.relatedJobIds', 'title company parsedData.keySkills');

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      // Update last active time
      conversation.lastActiveAt = new Date();
      await conversation.save();

      return conversation;

    } catch (error) {
      console.error('Get conversation error:', error);
      throw error;
    }
  }

  /**
   * Add a message to a conversation
   */
  static async addMessage(conversationId, messageData) {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) {
        throw new Error('Conversation not found');
      }

      const message = conversation.addMessage(messageData);
      await conversation.save();

      // Extract memories from user messages
      if (messageData.type === 'user' && conversation.settings.memoryEnabled) {
        try {
          await MemoryService.extractMemoriesFromMessage(
            conversation.userId,
            messageData.content,
            {
              conversationId: conversationId,
              messageId: message.id,
              page: messageData.metadata?.context?.page,
              category: conversation.category,
              tags: conversation.tags
            }
          );
        } catch (memoryError) {
          console.warn('Memory extraction failed:', memoryError);
          // Don't fail the message addition if memory extraction fails
        }
      }

      // Auto-summarize if needed
      if (conversation.settings.autoSummarize && 
          conversation.messages.length % 20 === 0) {
        try {
          await MemoryService.generateConversationSummary(conversationId);
        } catch (summaryError) {
          console.warn('Auto-summarization failed:', summaryError);
        }
      }

      return message;

    } catch (error) {
      console.error('Add message error:', error);
      throw error;
    }
  }

  /**
   * Update conversation metadata
   */
  static async updateConversation(conversationId, userId, updates) {
    try {
      const allowedUpdates = [
        'title', 'description', 'category', 'tags', 'pinned', 'starred', 'settings'
      ];
      
      const filteredUpdates = {};
      Object.keys(updates).forEach(key => {
        if (allowedUpdates.includes(key)) {
          filteredUpdates[key] = updates[key];
        }
      });

      const conversation = await Conversation.findOneAndUpdate(
        { _id: conversationId, userId },
        { $set: filteredUpdates },
        { new: true, runValidators: true }
      );

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      return conversation;

    } catch (error) {
      console.error('Update conversation error:', error);
      throw error;
    }
  }

  /**
   * Delete or archive a conversation
   */
  static async deleteConversation(conversationId, userId, permanent = false) {
    try {
      const update = permanent ? 
        { status: 'deleted' } : 
        { status: 'archived' };

      const conversation = await Conversation.findOneAndUpdate(
        { _id: conversationId, userId },
        { $set: update },
        { new: true }
      );

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      return conversation;

    } catch (error) {
      console.error('Delete conversation error:', error);
      throw error;
    }
  }

  /**
   * Generate intelligent conversation title
   */
  static async generateConversationTitle(messages, context = {}) {
    try {
      if (!messages || messages.length === 0) {
        return 'New Conversation';
      }

      const recentMessages = messages.slice(0, 5); // First 5 messages
      const messageText = recentMessages
        .map(m => `${m.type}: ${m.content}`)
        .join('\n');

      const systemPrompt = `Generate a concise, descriptive title for this conversation. The title should:
1. Be 3-6 words long
2. Capture the main topic or purpose
3. Be specific and actionable
4. Use professional language

Context: This is a career assistance conversation on page "${context.page || 'unknown'}"

Return only the title, nothing else.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: messageText }
        ],
        temperature: 0.5,
        max_tokens: 50
      });

      const title = response.choices[0].message.content.trim();
      return title || 'Career Assistance';

    } catch (error) {
      console.error('Generate conversation title error:', error);
      
      // Fallback titles based on context
      const fallbackTitles = {
        'resumes': 'Resume Assistance',
        'jobs': 'Job Search Help',
        'career': 'Career Guidance',
        'interview': 'Interview Preparation'
      };

      return fallbackTitles[context.page] || 'Career Assistance';
    }
  }

/**
   * Get conversation analytics
   */
  static async getConversationAnalytics(userId, timeframe = '30d') {
    try {
      const dateThreshold = new Date();
      if (timeframe === '7d') {
        dateThreshold.setDate(dateThreshold.getDate() - 7);
      } else if (timeframe === '30d') {
        dateThreshold.setDate(dateThreshold.getDate() - 30);
      } else if (timeframe === '90d') {
        dateThreshold.setDate(dateThreshold.getDate() - 90);
      }

      const analytics = await Conversation.aggregate([
        {
          $match: {
            userId: mongoose.Types.ObjectId(userId),
            status: { $ne: 'deleted' },
            createdAt: { $gte: dateThreshold }
          }
        },
        {
          $group: {
            _id: null,
            totalConversations: { $sum: 1 },
            totalMessages: { $sum: '$analytics.messageCount' },
            totalTokens: { $sum: '$analytics.tokensUsed' },
            avgEngagement: { $avg: '$analytics.engagementScore' },
            pinnedCount: {
              $sum: { $cond: [{ $eq: ['$pinned', true] }, 1, 0] }
            },
            starredCount: {
              $sum: { $cond: [{ $eq: ['$starred', true] }, 1, 0] }
            },
            categoryCounts: { $push: '$category' }
          }
        },
        {
          $project: {
            totalConversations: 1,
            totalMessages: 1,
            totalTokens: 1,
            avgEngagement: { $round: ['$avgEngagement', 1] },
            pinnedCount: 1,
            starredCount: 1,
            categoryCounts: 1
          }
        }
      ]);

      const result = analytics[0] || {
        totalConversations: 0,
        totalMessages: 0,
        totalTokens: 0,
        avgEngagement: 0,
        pinnedCount: 0,
        starredCount: 0,
        categoryCounts: []
      };

      // Calculate category distribution
      const categoryDistribution = result.categoryCounts.reduce((acc, category) => {
        acc[category] = (acc[category] || 0) + 1;
        return acc;
      }, {});

      // Get most active conversations
      const mostActiveConversations = await Conversation.find({
        userId,
        status: { $ne: 'deleted' },
        createdAt: { $gte: dateThreshold }
      })
      .sort({ 'analytics.messageCount': -1 })
      .limit(5)
      .select('title analytics.messageCount analytics.engagementScore lastActiveAt')
      .lean();

      return {
        ...result,
        categoryDistribution,
        mostActiveConversations,
        timeframe
      };

    } catch (error) {
      console.error('Get conversation analytics error:', error);
      throw error;
    }
  }

  /**
   * Search across all user conversations
   */
  static async searchAllConversations(userId, query, options = {}) {
    try {
      const {
        limit = 20,
        includeMessages = false,
        categories = [],
        dateRange = null
      } = options;

      let matchQuery = {
        userId,
        status: { $ne: 'deleted' },
        $text: { $search: query }
      };

      if (categories.length > 0) {
        matchQuery.category = { $in: categories };
      }

      if (dateRange) {
        matchQuery.createdAt = {
          $gte: new Date(dateRange.from),
          $lte: new Date(dateRange.to)
        };
      }

      const pipeline = [
        { $match: matchQuery },
        { $addFields: { score: { $meta: 'textScore' } } },
        { $sort: { score: { $meta: 'textScore' }, lastActiveAt: -1 } },
        { $limit: limit }
      ];

      if (!includeMessages) {
        pipeline.push({
          $project: {
            messages: 0
          }
        });
      }

      const results = await Conversation.aggregate(pipeline);

      // Highlight matching content
      const enrichedResults = await Promise.all(
        results.map(async (conv) => {
          const highlights = await this.findQueryHighlights(conv, query);
          return {
            ...conv,
            highlights,
            preview: this.generateSearchPreview(conv, query)
          };
        })
      );

      return enrichedResults;

    } catch (error) {
      console.error('Search all conversations error:', error);
      throw error;
    }
  }

  /**
   * Get conversation insights using AI
   */
  static async getConversationInsights(conversationId) {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) {
        throw new Error('Conversation not found');
      }

      const messages = conversation.messages.slice(-30); // Last 30 messages
      const messageText = messages
        .map(m => `${m.type.toUpperCase()}: ${m.content}`)
        .join('\n');

      const systemPrompt = `Analyze this conversation and provide insights about:
1. User's communication patterns
2. Progress made toward their goals
3. Areas where they need more help
4. Suggestions for improvement
5. Key topics and themes

Format as JSON:
{
  "communicationPatterns": ["pattern1", "pattern2"],
  "progressMade": ["achievement1", "achievement2"],
  "areasNeedingHelp": ["area1", "area2"],
  "suggestions": ["suggestion1", "suggestion2"],
  "keyThemes": ["theme1", "theme2"],
  "sentiment": "positive|neutral|negative",
  "engagementLevel": "high|medium|low",
  "nextSteps": ["step1", "step2"]
}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: messageText }
        ],
        temperature: 0.3,
        max_tokens: 800,
        response_format: { type: 'json_object' }
      });

      const insights = JSON.parse(response.choices[0].message.content);

      // Store insights in conversation
      conversation.analytics.insights = {
        ...insights,
        generatedAt: new Date()
      };

      await conversation.save();

      return insights;

    } catch (error) {
      console.error('Get conversation insights error:', error);
      throw error;
    }
  }

  /**
   * Export conversation data
   */
  static async exportConversation(conversationId, userId, format = 'json') {
    try {
      const conversation = await Conversation.findOne({
        _id: conversationId,
        userId,
        status: { $ne: 'deleted' }
      })
      .populate('context.primaryResumeId', 'name')
      .populate('context.relatedJobIds', 'title company')
      .lean();

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      if (format === 'json') {
        return {
          conversation: conversation,
          exportedAt: new Date(),
          format: 'json'
        };
      }

      if (format === 'markdown') {
        return this.convertToMarkdown(conversation);
      }

      if (format === 'txt') {
        return this.convertToPlainText(conversation);
      }

      throw new Error('Unsupported export format');

    } catch (error) {
      console.error('Export conversation error:', error);
      throw error;
    }
  }

  /**
   * Bulk operations on conversations
   */
  static async bulkUpdateConversations(userId, conversationIds, updates) {
    try {
      const allowedUpdates = ['category', 'tags', 'pinned', 'starred', 'status'];
      const filteredUpdates = {};

      Object.keys(updates).forEach(key => {
        if (allowedUpdates.includes(key)) {
          filteredUpdates[key] = updates[key];
        }
      });

      const result = await Conversation.updateMany(
        {
          _id: { $in: conversationIds },
          userId,
          status: { $ne: 'deleted' }
        },
        { $set: filteredUpdates }
      );

      return {
        modifiedCount: result.modifiedCount,
        matchedCount: result.matchedCount
      };

    } catch (error) {
      console.error('Bulk update conversations error:', error);
      throw error;
    }
  }

  // ===================================================================
  // PRIVATE HELPER METHODS
  // ===================================================================

  /**
   * Calculate unread count for a conversation
   */
  static calculateUnreadCount(messages) {
    if (!messages || messages.length === 0) return 0;

    // Simple implementation - in real app, track read status
    const lastMessage = messages[messages.length - 1];
    return lastMessage && lastMessage.type === 'ai' ? 1 : 0;
  }

  /**
   * Generate conversation preview
   */
  static generatePreview(conversation) {
    if (conversation.summary && conversation.summary.content) {
      return conversation.summary.content.substring(0, 100) + '...';
    }

    if (conversation.messages && conversation.messages.length > 0) {
      const lastMessage = conversation.messages[conversation.messages.length - 1];
      return lastMessage.content.substring(0, 100) + '...';
    }

    return conversation.description || 'No content yet';
  }

  /**
   * Find query highlights in conversation content
   */
  static async findQueryHighlights(conversation, query) {
    const highlights = [];
    const queryLower = query.toLowerCase();

    // Check title
    if (conversation.title.toLowerCase().includes(queryLower)) {
      highlights.push({
        type: 'title',
        text: conversation.title,
        position: conversation.title.toLowerCase().indexOf(queryLower)
      });
    }

    // Check summary
    if (conversation.summary && conversation.summary.content) {
      const summaryLower = conversation.summary.content.toLowerCase();
      if (summaryLower.includes(queryLower)) {
        const position = summaryLower.indexOf(queryLower);
        const start = Math.max(0, position - 50);
        const end = Math.min(conversation.summary.content.length, position + 100);
        
        highlights.push({
          type: 'summary',
          text: conversation.summary.content.substring(start, end),
          position: position
        });
      }
    }

    // Check recent messages
    if (conversation.messages) {
      conversation.messages.slice(-10).forEach((message, index) => {
        const contentLower = message.content.toLowerCase();
        if (contentLower.includes(queryLower)) {
          const position = contentLower.indexOf(queryLower);
          const start = Math.max(0, position - 30);
          const end = Math.min(message.content.length, position + 70);
          
          highlights.push({
            type: 'message',
            text: message.content.substring(start, end),
            messageType: message.type,
            position: position,
            messageIndex: index
          });
        }
      });
    }

    return highlights.slice(0, 3); // Limit to 3 highlights
  }

  /**
   * Generate search preview with highlighted terms
   */
  static generateSearchPreview(conversation, query) {
    const queryLower = query.toLowerCase();
    
    // Try summary first
    if (conversation.summary && conversation.summary.content) {
      const content = conversation.summary.content;
      const contentLower = content.toLowerCase();
      
      if (contentLower.includes(queryLower)) {
        const position = contentLower.indexOf(queryLower);
        const start = Math.max(0, position - 50);
        const end = Math.min(content.length, position + 100);
        
        return content.substring(start, end) + (end < content.length ? '...' : '');
      }
    }

    // Try last message
    if (conversation.messages && conversation.messages.length > 0) {
      const lastMessage = conversation.messages[conversation.messages.length - 1];
      const content = lastMessage.content;
      const contentLower = content.toLowerCase();
      
      if (contentLower.includes(queryLower)) {
        const position = contentLower.indexOf(queryLower);
        const start = Math.max(0, position - 50);
        const end = Math.min(content.length, position + 100);
        
        return content.substring(start, end) + (end < content.length ? '...' : '');
      }
      
      // Fallback to beginning of last message
      return content.substring(0, 100) + (content.length > 100 ? '...' : '');
    }

    return conversation.description || 'No preview available';
  }

  /**
   * Convert conversation to Markdown format
   */
  static convertToMarkdown(conversation) {
    let markdown = `# ${conversation.title}\n\n`;
    
    if (conversation.description) {
      markdown += `**Description:** ${conversation.description}\n\n`;
    }

    markdown += `**Created:** ${conversation.createdAt.toISOString()}\n`;
    markdown += `**Category:** ${conversation.category}\n`;
    
    if (conversation.tags && conversation.tags.length > 0) {
      markdown += `**Tags:** ${conversation.tags.join(', ')}\n`;
    }

    markdown += `\n---\n\n`;

    if (conversation.summary && conversation.summary.content) {
      markdown += `## Summary\n\n${conversation.summary.content}\n\n`;
      
      if (conversation.summary.keyTopics && conversation.summary.keyTopics.length > 0) {
        markdown += `**Key Topics:** ${conversation.summary.keyTopics.join(', ')}\n\n`;
      }
      
      markdown += `---\n\n`;
    }

    markdown += `## Messages\n\n`;

    if (conversation.messages && conversation.messages.length > 0) {
      conversation.messages.forEach((message, index) => {
        const timestamp = message.createdAt ? 
          new Date(message.createdAt).toLocaleString() : 
          'Unknown time';
        
        markdown += `### ${message.type.toUpperCase()} (${timestamp})\n\n`;
        markdown += `${message.content}\n\n`;
        
        if (message.metadata && message.metadata.suggestions && message.metadata.suggestions.length > 0) {
          markdown += `**Suggestions:** ${message.metadata.suggestions.join(', ')}\n\n`;
        }
        
        markdown += `---\n\n`;
      });
    }

    return {
      content: markdown,
      filename: `conversation_${conversation._id}.md`,
      exportedAt: new Date(),
      format: 'markdown'
    };
  }

  /**
   * Convert conversation to plain text format
   */
  static convertToPlainText(conversation) {
    let text = `${conversation.title}\n${'='.repeat(conversation.title.length)}\n\n`;
    
    if (conversation.description) {
      text += `Description: ${conversation.description}\n\n`;
    }

    text += `Created: ${conversation.createdAt.toISOString()}\n`;
    text += `Category: ${conversation.category}\n`;
    
    if (conversation.tags && conversation.tags.length > 0) {
      text += `Tags: ${conversation.tags.join(', ')}\n`;
    }

    text += `\n${'-'.repeat(50)}\n\n`;

    if (conversation.summary && conversation.summary.content) {
      text += `SUMMARY\n${conversation.summary.content}\n\n`;
      
      if (conversation.summary.keyTopics && conversation.summary.keyTopics.length > 0) {
        text += `Key Topics: ${conversation.summary.keyTopics.join(', ')}\n\n`;
      }
      
      text += `${'-'.repeat(50)}\n\n`;
    }

    text += `MESSAGES\n\n`;

    if (conversation.messages && conversation.messages.length > 0) {
      conversation.messages.forEach((message, index) => {
        const timestamp = message.createdAt ? 
          new Date(message.createdAt).toLocaleString() : 
          'Unknown time';
        
        text += `[${message.type.toUpperCase()}] ${timestamp}\n`;
        text += `${message.content}\n`;
        
        if (message.metadata && message.metadata.suggestions && message.metadata.suggestions.length > 0) {
          text += `Suggestions: ${message.metadata.suggestions.join(', ')}\n`;
        }
        
        text += `\n${'-'.repeat(30)}\n\n`;
      });
    }

    return {
      content: text,
      filename: `conversation_${conversation._id}.txt`,
      exportedAt: new Date(),
      format: 'text'
    };
  }
}

module.exports = ConversationService;

================
File: services/jobAnalysis.service.js
================
// services/jobAnalysis.service.js - HYBRID APPROACH WITH BATCH ANALYSIS
const { openai } = require('../config/openai');

/**
 * Enhanced job analysis with hybrid model selection + NEW BATCH ANALYSIS
 * - GPT-4o for manual jobs (quality-critical, low volume)
 * - GPT-4o for AI discovery (now same quality as manual!)
 * - Batch processing for efficiency
 * 
 * @param {string} jobDescription - Raw job description text
 * @param {Object} jobMetadata - Additional job metadata (title, company, etc.)
 * @param {Object} options - Analysis options
 * @param {boolean} options.isAiDiscovery - Whether this is from AI discovery (now uses GPT-4o!)
 * @param {boolean} options.prioritizeCost - Force use of Mini model (deprecated)
 * @returns {Object} Parsed job data with detailed analysis
 */
exports.analyzeJob = async (jobDescription, jobMetadata = {}, options = {}) => {
  try {
    // NEW: Use GPT-4o for both manual and AI discovery for consistent quality
    const model = "gpt-4o";
    const maxTokens = 3500;
    
    console.log(`Starting premium job analysis with ${model} (same quality for all jobs)...`);
    
    if (!jobDescription || jobDescription.trim().length < 50) {
      throw new Error('Job description is too short for meaningful analysis');
    }

    const prompt = createPromptForModel(jobDescription, jobMetadata, false); // Always use premium prompt

    // Call OpenAI API with GPT-4o
    const response = await openai.chat.completions.create({
      model: model,
      messages: [
        {
          role: "system",
          content: createSystemPromptForModel(false) // Always use premium system prompt
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Low for consistent extraction
      max_tokens: maxTokens,
    });

    const content = response.choices[0].message.content.trim();
    console.log(`Job analysis response received from ${model}, parsing...`);

    let parsedData;
    try {
      // Clean up the response to extract JSON
      let jsonStr = content;
      
      // Remove any markdown code blocks
      if (content.includes('```')) {
        const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          jsonStr = jsonMatch[1];
        }
      }
      
      // Clean up and ensure valid JSON structure
      jsonStr = jsonStr.trim();
      if (!jsonStr.startsWith('{')) {
        const startIndex = jsonStr.indexOf('{');
        if (startIndex !== -1) {
          jsonStr = jsonStr.substring(startIndex);
        }
      }
      if (!jsonStr.endsWith('}')) {
        const endIndex = jsonStr.lastIndexOf('}');
        if (endIndex !== -1) {
          jsonStr = jsonStr.substring(0, endIndex + 1);
        }
      }

      parsedData = JSON.parse(jsonStr);
      
      // Validate and enhance the parsed data
      parsedData = validateAndEnhanceJobData(parsedData, jobDescription, false); // Always use premium validation
      
      console.log(`Job analysis completed successfully with ${model}. Found ${parsedData.keySkills?.length || 0} skills.`);
      
    } catch (parseError) {
      console.error(`Error parsing job analysis response from ${model}:`, parseError);
      console.log('Raw response:', content);
      throw new Error(`Failed to parse job analysis response from ${model}`);
    }

    // Add analysis metadata
    parsedData.analysisMetadata = {
      analyzedAt: new Date(),
      algorithmVersion: options.isAiDiscovery ? '3.0-ai-discovery-premium' : '3.0-manual-premium',
      model: model,
      originalLength: jobDescription.length,
      extractedSkillsCount: parsedData.keySkills?.length || 0,
      costOptimized: false, // Now using premium for all
      analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium',
      estimatedCost: '$0.01-0.02',
      qualityLevel: 'premium'
    };

    return parsedData;

  } catch (error) {
    console.error('Error in premium job analysis:', error);
    
    // Intelligent fallback analysis
    return generateJobAnalysisFallback(jobDescription, jobMetadata, error, options);
  }
};

/**
 * NEW: Batch job analysis for AI discovery efficiency
 * Analyzes multiple jobs in a single API call for cost efficiency
 * 
 * @param {Array} jobBatch - Array of job objects with title, company, fullContent
 * @returns {Array} Array of analysis results matching input order
 */
exports.analyzeBatchJobs = async (jobBatch) => {
  try {
    console.log(`ðŸ”¬ Starting batch analysis of ${jobBatch.length} jobs with GPT-4o...`);
    
    if (!jobBatch || jobBatch.length === 0) {
      return [];
    }
    
    // Limit batch size to prevent token overflow
    const maxBatchSize = 3;
    if (jobBatch.length > maxBatchSize) {
      console.log(`Batch size ${jobBatch.length} exceeds maximum ${maxBatchSize}, processing in chunks...`);
      
      const results = [];
      for (let i = 0; i < jobBatch.length; i += maxBatchSize) {
        const chunk = jobBatch.slice(i, i + maxBatchSize);
        const chunkResults = await this.analyzeBatchJobs(chunk);
        results.push(...chunkResults);
      }
      return results;
    }
    
    // Prepare batch content for analysis
    const batchContent = jobBatch.map((job, index) => 
      `JOB ${index + 1}:
Title: ${job.title}
Company: ${job.company}
Location: ${job.location || 'Not specified'}
Content: ${(job.fullContent || job.description || '').substring(0, 2500)}
---`
    ).join('\n\n');
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert job analyst providing premium batch analysis. Analyze multiple job postings and return detailed structured data for each. Focus on extracting comprehensive requirements, responsibilities, and skills with high accuracy. Return valid JSON array with exactly ${jobBatch.length} objects.`
        },
        {
          role: "user",
          content: `Analyze these ${jobBatch.length} job postings and return detailed analysis for each:

${batchContent}

Return JSON array with exactly ${jobBatch.length} objects in this EXACT format:
[
  {
    "requirements": ["Specific requirement 1", "Specific requirement 2"],
    "responsibilities": ["Key responsibility 1", "Key responsibility 2"],
    "qualifications": {
      "required": ["Must-have qualification 1", "Must-have qualification 2"],
      "preferred": ["Nice-to-have qualification 1", "Nice-to-have qualification 2"]
    },
    "keySkills": [
      {
        "name": "Python",
        "importance": 9,
        "category": "technical",
        "skillType": "programming"
      },
      {
        "name": "Leadership",
        "importance": 7,
        "category": "soft",
        "skillType": "management"
      }
    ],
    "experienceLevel": "mid/senior/lead",
    "yearsOfExperience": {
      "minimum": 3,
      "preferred": 5
    },
    "educationRequirements": ["Bachelor's degree in relevant field"],
    "benefits": ["Health insurance", "401k", "Remote work"],
    "salary": {
      "min": 120000,
      "max": 150000,
      "currency": "USD"
    },
    "workArrangement": "remote/hybrid/onsite",
    "industryContext": "technology/finance/healthcare",
    "roleCategory": "software-engineering/product-management",
    "technicalComplexity": "high/medium/low",
    "leadershipRequired": true/false,
    "companyStage": "startup/growth/enterprise"
  }
]

CRITICAL REQUIREMENTS:
- Skills importance: 9-10=critical, 7-8=very important, 5-6=important, 3-4=nice to have
- Extract comprehensive information from each job posting
- Maintain high accuracy and detail level
- Return exactly ${jobBatch.length} analysis objects in the same order
- Each analysis must be complete and detailed`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    let jsonStr = content;
    
    // Clean JSON extraction
    if (content.includes('```')) {
      const jsonMatch = content.match(/```(?:json)?\s*(\[[\s\S]*?\])\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    const analyses = JSON.parse(jsonStr);
    
    // Ensure we have the right number of analyses
    if (!Array.isArray(analyses)) {
      throw new Error('Response is not an array');
    }
    
    if (analyses.length !== jobBatch.length) {
      console.warn(`Expected ${jobBatch.length} analyses, got ${analyses.length}. Padding or trimming...`);
      
      // Pad with fallback analyses if too few
      while (analyses.length < jobBatch.length) {
        analyses.push(createFallbackSingleAnalysis());
      }
      
      // Trim if too many
      if (analyses.length > jobBatch.length) {
        analyses.splice(jobBatch.length);
      }
    }
    
    // Enhance analyses with metadata
    const enhancedAnalyses = analyses.map((analysis, index) => ({
      ...analysis,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-batch-premium',
        model: 'gpt-4o',
        analysisType: 'ai_discovery_batch_premium',
        qualityLevel: 'premium',
        batchIndex: index,
        batchSize: jobBatch.length
      }
    }));
    
    console.log(`âœ… Batch analysis completed: ${enhancedAnalyses.length} jobs analyzed with GPT-4o`);
    return enhancedAnalyses;
    
  } catch (error) {
    console.error('Error in batch job analysis:', error);
    
    // Return fallback analyses for all jobs in batch
    return jobBatch.map((job, index) => ({
      ...createFallbackSingleAnalysis(),
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-batch-fallback',
        model: 'gpt-4o-fallback',
        analysisType: 'ai_discovery_batch_fallback',
        error: error.message,
        batchIndex: index,
        batchSize: jobBatch.length
      }
    }));
  }
};

/**
 * Content analysis with premium quality
 * @param {string} jobContent - Raw job content from URL
 * @param {Object} jobInfo - Job metadata
 * @param {boolean} isAiDiscovery - Whether this is from AI discovery (now uses GPT-4o regardless)
 * @returns {Object} Analyzed job content
 */
exports.analyzeJobContent = async (jobContent, jobInfo, isAiDiscovery = false) => {
  if (!jobContent) return null;
  
  try {
    // NEW: Always use GPT-4o for consistent premium quality
    const model = "gpt-4o";
    const maxTokens = 2000;
    
    console.log(`ðŸ¤– Analyzing job content with premium ${model}: "${jobInfo.title}"`);
    
    // Create optimized prompt
    const prompt = createContentAnalysisPrompt(jobContent, jobInfo, false); // Always use premium prompt

    const response = await openai.chat.completions.create({
      model: model,
      messages: [
        {
          role: "system",
          content: "You are an expert job analyst. Extract comprehensive job data and return valid JSON only."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0,
      max_tokens: maxTokens
    });

    const analysisText = response.choices[0].message.content.trim();
    let jsonStr = analysisText;
    
    // Clean JSON extraction
    if (analysisText.includes('```')) {
      const jsonMatch = analysisText.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    const analysis = JSON.parse(jsonStr);
    
    // Validate work arrangement
    if (analysis.workArrangement) {
      analysis.workArrangement = normalizeWorkArrangement(analysis.workArrangement);
    }
    
    // Add metadata
    analysis.analysisMetadata = {
      model: model,
      analysisType: isAiDiscovery ? 'ai_discovery_content_premium' : 'manual_content_premium',
      qualityLevel: 'premium',
      analyzedAt: new Date()
    };
    
    console.log(`âœ… Premium content analysis completed with ${model} for "${jobInfo.title}"`);
    return analysis;
    
  } catch (error) {
    console.error(`Error analyzing job content with premium approach:`, error);
    return generateBasicContentAnalysis(jobContent, jobInfo, isAiDiscovery);
  }
};

/**
 * Create model-specific prompts (now always premium)
 */
function createPromptForModel(jobDescription, jobMetadata, useMinimModel) {
  // Always use comprehensive prompt for premium quality
  const contentLength = 4000;
  const truncatedDescription = jobDescription.length > contentLength ? 
    jobDescription.substring(0, contentLength) + '...' : jobDescription;

  return `
    Analyze this job posting and extract detailed information. Be thorough and accurate in your analysis.

    **JOB POSTING:**
    ${truncatedDescription}

    **ADDITIONAL CONTEXT:**
    ${jobMetadata.title ? `Title: ${jobMetadata.title}` : ''}
    ${jobMetadata.company ? `Company: ${jobMetadata.company}` : ''}
    ${jobMetadata.location ? `Location: ${JSON.stringify(jobMetadata.location)}` : ''}

    Extract and categorize information into this EXACT JSON structure:

    {
      "requirements": [
        "specific requirement 1",
        "specific requirement 2"
      ],
      "responsibilities": [
        "key responsibility 1",
        "key responsibility 2"
      ],
      "qualifications": {
        "required": [
          "must-have qualification 1",
          "must-have qualification 2"
        ],
        "preferred": [
          "nice-to-have qualification 1",
          "nice-to-have qualification 2"
        ]
      },
      "keySkills": [
        {
          "name": "Python",
          "importance": 9,
          "category": "technical",
          "skillType": "programming"
        },
        {
          "name": "Project Management",
          "importance": 7,
          "category": "soft",
          "skillType": "management"
        }
      ],
      "experienceLevel": "mid-senior",
      "yearsOfExperience": {
        "minimum": 3,
        "preferred": 5
      },
      "educationRequirements": [
        "Bachelor's degree in Computer Science or related field",
        "Master's degree preferred"
      ],
      "benefits": [
        "Health insurance",
        "401k matching",
        "Remote work options"
      ],
      "industryContext": "technology",
      "roleCategory": "product-management",
      "seniorityLevel": "mid",
      "technicalComplexity": "high",
      "leadershipRequired": true,
      "certifications": [
        "PMP certification preferred",
        "Agile certification a plus"
      ],
      "softSkills": [
        "Communication",
        "Leadership",
        "Problem-solving"
      ],
      "technicalSkills": [
        "SQL",
        "Python",
        "Data Analysis"
      ],
      "toolsAndTechnologies": [
        "Jira",
        "Confluence",
        "Tableau"
      ],
      "companySize": "medium",
      "workArrangement": "hybrid"
    }

    **EXTRACTION GUIDELINES:**

    1. **Skills Importance Scale (1-10):**
       - 9-10: Critical/Must-have (mentioned multiple times, essential)
       - 7-8: Very Important (clearly stated as required)
       - 5-6: Important (mentioned in requirements)
       - 3-4: Nice to have (preferred qualifications)
       - 1-2: Bonus (mentioned casually)

    2. **Experience Level Mapping:**
       - "entry": 0-2 years
       - "junior": 1-3 years
       - "mid": 3-6 years
       - "senior": 5-10 years
       - "lead": 7-12 years
       - "principal": 10+ years
       - "executive": 12+ years

    3. **Work Arrangement (use exact values):**
       - "remote": Fully remote work
       - "hybrid": Mix of remote and office work
       - "onsite": Must work from office/physical location
       - "unknown": Work arrangement not specified

    **IMPORTANT:** Extract only information explicitly mentioned in the job posting. Don't infer or add generic requirements.

    Return ONLY the JSON object without any markdown formatting or explanations.
    `;
}

/**
 * Create model-specific system prompts (now always premium)
 */
function createSystemPromptForModel(useMinimModel) {
  return "You are an expert HR technology analyst specializing in job posting analysis. You extract precise, detailed information from job descriptions without adding assumptions. You return only valid JSON without markdown formatting. For workArrangement field, use ONLY these exact values: 'remote', 'hybrid', 'onsite', or 'unknown'.";
}

/**
 * Create content analysis prompt (now always premium)
 */
function createContentAnalysisPrompt(jobContent, jobInfo, isAiDiscovery) {
  const contentLength = 3000;
  const truncatedContent = jobContent.length > contentLength ? 
    jobContent.substring(0, contentLength) + '...' : jobContent;

  return `
    Analyze this job content and extract structured data:

    Job: ${jobInfo.title} at ${jobInfo.company}
    Content: ${truncatedContent}

    Return JSON:
    {
      "requirements": ["Required skill 1", "Required skill 2"],
      "responsibilities": ["Responsibility 1", "Responsibility 2"],
      "qualifications": {
        "required": ["Must have 1", "Must have 2"],
        "preferred": ["Nice to have 1", "Nice to have 2"]
      },
      "salary": {
        "min": 120000,
        "max": 150000,
        "currency": "USD"
      },
      "benefits": ["Benefit 1", "Benefit 2"],
      "jobType": "FULL_TIME",
      "experienceLevel": "mid/senior/lead",
      "workArrangement": "remote/hybrid/onsite/unknown"
    }

    Extract comprehensive information. Be thorough with requirements and qualifications.
    `;
}

/**
 * Enhanced validation for premium quality
 */
function validateAndEnhanceJobData(parsedData, originalDescription, useMinimModel) {
  // Ensure required fields exist
  if (!parsedData.requirements) parsedData.requirements = [];
  if (!parsedData.responsibilities) parsedData.responsibilities = [];
  if (!parsedData.qualifications) {
    parsedData.qualifications = { required: [], preferred: [] };
  }
  if (!parsedData.keySkills) parsedData.keySkills = [];
  if (!parsedData.benefits) parsedData.benefits = [];
  if (!parsedData.educationRequirements) parsedData.educationRequirements = [];

  // Validate and normalize skill importance scores
  if (parsedData.keySkills && Array.isArray(parsedData.keySkills)) {
    parsedData.keySkills = parsedData.keySkills.map(skill => {
      if (typeof skill === 'string') {
        return {
          name: skill,
          importance: 5,
          category: 'technical',
          skillType: 'general'
        };
      }
      
      // Validate importance score
      if (!skill.importance || skill.importance < 1 || skill.importance > 10) {
        skill.importance = 5;
      }
      
      // Ensure required fields
      if (!skill.category) skill.category = 'technical';
      if (!skill.skillType) skill.skillType = 'general';
      
      return skill;
    });
  }

  // Enhanced skill extraction (now always comprehensive)
  const skillLimit = 15; // Increased for premium quality
  const additionalSkills = extractSkillsFromText(originalDescription);
  const existingSkillNames = parsedData.keySkills.map(s => s.name.toLowerCase());
  
  additionalSkills.slice(0, skillLimit).forEach(skill => {
    if (!existingSkillNames.includes(skill.toLowerCase())) {
      parsedData.keySkills.push({
        name: skill,
        importance: 4,
        category: 'technical',
        skillType: 'extracted'
      });
    }
  });

  // Apply standard validations
  const validExperienceLevels = ['entry', 'junior', 'mid', 'senior', 'lead', 'principal', 'executive'];
  if (!parsedData.experienceLevel || !validExperienceLevels.includes(parsedData.experienceLevel)) {
    parsedData.experienceLevel = inferExperienceLevel(originalDescription);
  }

  if (!parsedData.yearsOfExperience) {
    parsedData.yearsOfExperience = inferYearsOfExperience(originalDescription, parsedData.experienceLevel);
  }

  if (!parsedData.industryContext) {
    parsedData.industryContext = inferIndustryContext(originalDescription);
  }

  if (!parsedData.roleCategory) {
    parsedData.roleCategory = inferRoleCategory(originalDescription, parsedData.keySkills);
  }

  // Normalize workArrangement
  if (parsedData.workArrangement) {
    parsedData.workArrangement = normalizeWorkArrangement(parsedData.workArrangement);
  } else {
    parsedData.workArrangement = inferWorkArrangement(originalDescription);
  }

  return parsedData;
}

/**
 * Create fallback single analysis for batch processing
 */
function createFallbackSingleAnalysis() {
  return {
    requirements: ['Relevant experience in the field'],
    responsibilities: ['Perform assigned duties effectively'],
    qualifications: {
      required: ['Relevant education or experience'],
      preferred: ['Additional qualifications preferred']
    },
    keySkills: [
      {
        name: 'Communication',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      },
      {
        name: 'Problem Solving',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      }
    ],
    experienceLevel: 'mid',
    yearsOfExperience: { minimum: 3, preferred: 5 },
    educationRequirements: ['Bachelor\'s degree preferred'],
    benefits: ['Competitive benefits package'],
    workArrangement: 'unknown',
    industryContext: 'general',
    roleCategory: 'general',
    technicalComplexity: 'medium',
    leadershipRequired: false,
    companyStage: 'unknown'
  };
}

/**
 * Generate fallback analysis with premium approach awareness
 */
function generateJobAnalysisFallback(jobDescription, jobMetadata, error, options = {}) {
  console.log('Generating premium fallback job analysis...');
  
  try {
    const extractedSkills = extractSkillsFromText(jobDescription);
    const experienceLevel = inferExperienceLevel(jobDescription);
    const workArrangement = inferWorkArrangement(jobDescription);
    
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      keySkills: extractedSkills.map(skill => ({
        name: skill,
        importance: 5,
        category: 'technical',
        skillType: 'extracted'
      })),
      experienceLevel,
      yearsOfExperience: inferYearsOfExperience(jobDescription, experienceLevel),
      educationRequirements: [],
      benefits: [],
      industryContext: inferIndustryContext(jobDescription),
      roleCategory: inferRoleCategory(jobDescription, extractedSkills),
      seniorityLevel: experienceLevel,
      technicalComplexity: 'medium',
      leadershipRequired: jobDescription.toLowerCase().includes('lead'),
      certifications: [],
      softSkills: ['Communication', 'Problem-solving'],
      technicalSkills: extractedSkills,
      toolsAndTechnologies: [],
      companySize: 'unknown',
      workArrangement: workArrangement,
      fallbackReason: error.message,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-premium-fallback',
        model: 'gpt-4o-fallback',
        originalLength: jobDescription.length,
        extractedSkillsCount: extractedSkills.length,
        fallback: true,
        analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium'
      }
    };
    
  } catch (fallbackError) {
    console.error('Error in premium fallback analysis:', fallbackError);
    
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      keySkills: [],
      experienceLevel: 'mid',
      yearsOfExperience: { minimum: 3, preferred: 5 },
      educationRequirements: [],
      benefits: [],
      industryContext: 'general',
      roleCategory: 'general',
      workArrangement: 'unknown',
      errorDetails: error.message,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-premium-error',
        model: 'error-fallback-premium',
        originalLength: jobDescription.length,
        error: true,
        analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium'
      }
    };
  }
}

/**
 * Generate basic content analysis with premium awareness
 */
function generateBasicContentAnalysis(jobContent, jobInfo, isAiDiscovery = false) {
  console.log('Generating premium content analysis fallback...');
  
  try {
    const lowerContent = jobContent.toLowerCase();
    
    // Basic salary extraction
    const salaryMatch = jobContent.match(/\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*-?\s*\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)?/);
    let salary = {};
    if (salaryMatch) {
      salary.min = parseInt(salaryMatch[1].replace(/,/g, ''));
      if (salaryMatch[2]) {
        salary.max = parseInt(salaryMatch[2].replace(/,/g, ''));
      }
      salary.currency = 'USD';
    }
    
    // Basic work arrangement detection
    let workArrangement = 'unknown';
    if (lowerContent.includes('remote')) {
      workArrangement = lowerContent.includes('hybrid') ? 'hybrid' : 'remote';
    } else if (lowerContent.includes('onsite') || lowerContent.includes('on-site')) {
      workArrangement = 'onsite';
    }
    
    return {
      requirements: ['Experience in relevant field'],
      responsibilities: ['Perform job duties as assigned'],
      qualifications: {
        required: ['Relevant experience'],
        preferred: []
      },
      salary: Object.keys(salary).length > 0 ? salary : null,
      benefits: [],
      jobType: 'FULL_TIME',
      experienceLevel: 'mid',
      workArrangement: workArrangement,
      fallbackReason: 'Premium model analysis failed',
      analysisMetadata: {
        model: 'gpt-4o-basic-fallback',
        analysisType: isAiDiscovery ? 'ai_discovery_premium' : 'manual_content_premium',
        qualityLevel: 'basic_fallback'
      }
    };
    
  } catch (error) {
    console.error('Error in basic premium content analysis:', error);
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      salary: null,
      benefits: [],
      jobType: 'FULL_TIME',
      experienceLevel: 'mid',
      workArrangement: 'unknown',
      error: true,
      analysisMetadata: {
        model: 'error-premium',
        analysisType: isAiDiscovery ? 'ai_discovery_premium' : 'manual_content_premium',
        qualityLevel: 'error_fallback'
      }
    };
  }
}

// Keep all existing helper functions unchanged
function normalizeWorkArrangement(workArrangement) {
  if (!workArrangement || typeof workArrangement !== 'string') {
    return 'unknown';
  }
  
  const normalized = workArrangement.toLowerCase().trim();
  
  const mappings = {
    'remote': 'remote',
    'fully remote': 'remote',
    'work from home': 'remote',
    'wfh': 'remote',
    '100% remote': 'remote',
    
    'hybrid': 'hybrid',
    'flex': 'hybrid',
    'flexible': 'hybrid',
    'mix': 'hybrid',
    'part remote': 'hybrid',
    'partial remote': 'hybrid',
    
    'onsite': 'onsite',
    'on-site': 'onsite',
    'on site': 'onsite',
    'office': 'onsite',
    'in-office': 'onsite',
    'in office': 'onsite',
    'on-premise': 'onsite',
    'on premise': 'onsite',
    'physical location': 'onsite',
    'in-person': 'onsite',
    'in person': 'onsite'
  };
  
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  
  for (const [key, value] of Object.entries(mappings)) {
    if (normalized.includes(key)) {
      return value;
    }
  }
  
  return 'unknown';
}

function extractSkillsFromText(description) {
  const commonSkills = [
    'JavaScript', 'Python', 'Java', 'C++', 'C#', 'PHP', 'Ruby', 'Go', 'Rust', 'Swift',
    'TypeScript', 'Kotlin', 'Scala', 'R', 'MATLAB', 'Perl', 'Shell', 'PowerShell',
    'React', 'Vue.js', 'Angular', 'Node.js', 'Express', 'Django', 'Flask', 'Spring',
    'Laravel', 'Rails', 'ASP.NET', 'HTML', 'CSS', 'SASS', 'LESS', 'Bootstrap',
    'SQL', 'MySQL', 'PostgreSQL', 'MongoDB', 'Redis', 'Elasticsearch', 'Oracle',
    'AWS', 'Azure', 'GCP', 'Docker', 'Kubernetes', 'Jenkins', 'GitLab CI', 'CircleCI',
    'Git', 'GitHub', 'GitLab', 'Bitbucket', 'Jira', 'Confluence', 'Slack',
    'Machine Learning', 'Data Analysis', 'Tableau', 'Power BI', 'Excel', 'Pandas',
    'Figma', 'Sketch', 'Adobe XD', 'Photoshop', 'Illustrator',
    'Agile', 'Scrum', 'Kanban', 'Waterfall', 'PMP', 'PRINCE2',
    'Project Management', 'Leadership', 'Communication', 'Problem Solving'
  ];
  
  const foundSkills = [];
  const lowerDescription = description.toLowerCase();
  
  commonSkills.forEach(skill => {
    const skillVariations = [
      skill.toLowerCase(),
      skill.toLowerCase().replace(/\./g, ''),
      skill.toLowerCase().replace(/\s+/g, ''),
      skill.toLowerCase().replace(/-/g, ''),
      skill.toLowerCase().replace(/\//g, ' ')
    ];
    
    if (skillVariations.some(variation => lowerDescription.includes(variation))) {
      foundSkills.push(skill);
    }
  });
  
  return foundSkills;
}

function inferExperienceLevel(description) {
  const lowerDesc = description.toLowerCase();
  
  if (lowerDesc.includes('entry level') || lowerDesc.includes('0-2 years') || 
      lowerDesc.includes('new grad') || lowerDesc.includes('graduate') ||
      lowerDesc.includes('junior developer') || lowerDesc.includes('associate')) {
    return 'entry';
  }
  
  if (lowerDesc.includes('junior') && !lowerDesc.includes('senior')) {
    return 'junior';
  }
  
  if (lowerDesc.includes('3-5 years') || lowerDesc.includes('mid level') ||
      lowerDesc.includes('3+ years') || lowerDesc.includes('4+ years')) {
    return 'mid';
  }
  
  if (lowerDesc.includes('senior') || lowerDesc.includes('5+ years') ||
      lowerDesc.includes('6+ years') || lowerDesc.includes('7+ years')) {
    return 'senior';
  }
  
  if (lowerDesc.includes('lead') || lowerDesc.includes('tech lead') ||
      lowerDesc.includes('team lead') || lowerDesc.includes('8+ years')) {
    return 'lead';
  }
  
  if (lowerDesc.includes('principal') || lowerDesc.includes('10+ years') ||
      lowerDesc.includes('architect') || lowerDesc.includes('staff')) {
    return 'principal';
  }
  
  if (lowerDesc.includes('director') || lowerDesc.includes('vp') ||
      lowerDesc.includes('executive') || lowerDesc.includes('15+ years') ||
      lowerDesc.includes('chief')) {
    return 'executive';
  }
  
  if (lowerDesc.includes('manage') || lowerDesc.includes('supervise') ||
      lowerDesc.includes('oversee')) {
    return 'senior';
  }
  
  return 'mid'; // Default fallback
}

function inferYearsOfExperience(description, experienceLevel) {
  // Try to extract explicit years mentioned
  const yearMatches = description.match(/(\d+)[\s\-\+]*years?/gi);
  if (yearMatches && yearMatches.length > 0) {
    const years = yearMatches.map(match => parseInt(match.match(/\d+/)[0]));
    const maxYears = Math.max(...years);
    const minYears = Math.min(...years);
    
    return {
      minimum: minYears,
      preferred: maxYears > minYears ? maxYears : minYears + 2
    };
  }
  
  // Fall back to level-based inference
  const levelMappings = {
    'entry': { minimum: 0, preferred: 2 },
    'junior': { minimum: 1, preferred: 3 },
    'mid': { minimum: 3, preferred: 5 },
    'senior': { minimum: 5, preferred: 8 },
    'lead': { minimum: 7, preferred: 10 },
    'principal': { minimum: 10, preferred: 15 },
    'executive': { minimum: 12, preferred: 20 }
  };
  
  return levelMappings[experienceLevel] || { minimum: 3, preferred: 5 };
}

function inferWorkArrangement(description) {
  const lowerDesc = description.toLowerCase();
  
  if (lowerDesc.includes('remote') || lowerDesc.includes('work from home') || 
      lowerDesc.includes('wfh') || lowerDesc.includes('telecommute') ||
      lowerDesc.includes('distributed team')) {
    
    if (lowerDesc.includes('office') || lowerDesc.includes('hybrid') || 
        lowerDesc.includes('flexible') || lowerDesc.includes('mix')) {
      return 'hybrid';
    }
    
    return 'remote';
  }
  
  if (lowerDesc.includes('hybrid') || lowerDesc.includes('flexible') || 
      lowerDesc.includes('mix of remote') || lowerDesc.includes('part remote')) {
    return 'hybrid';
  }
  
  if (lowerDesc.includes('on-site') || lowerDesc.includes('onsite') || 
      lowerDesc.includes('on site') || lowerDesc.includes('in office') ||
      lowerDesc.includes('office location') || lowerDesc.includes('headquarters') ||
      lowerDesc.includes('in-person') || lowerDesc.includes('physical presence')) {
    return 'onsite';
  }
  
  return 'unknown';
}

function inferIndustryContext(description) {
  const lowerDesc = description.toLowerCase();
  
  const industryKeywords = {
    'technology': ['software', 'tech', 'startup', 'saas', 'platform', 'api', 'cloud', 'digital'],
    'finance': ['financial', 'bank', 'investment', 'trading', 'fintech', 'insurance', 'credit'],
    'healthcare': ['health', 'medical', 'hospital', 'pharmaceutical', 'biotech', 'clinical'],
    'retail': ['retail', 'ecommerce', 'e-commerce', 'shopping', 'consumer', 'marketplace'],
    'education': ['education', 'university', 'school', 'learning', 'training', 'academic'],
    'manufacturing': ['manufacturing', 'production', 'factory', 'industrial', 'automotive'],
    'consulting': ['consulting', 'advisory', 'professional services', 'strategy'],
    'media': ['media', 'entertainment', 'publishing', 'content', 'journalism', 'broadcasting'],
    'government': ['government', 'public sector', 'federal', 'state', 'municipal'],
    'nonprofit': ['nonprofit', 'ngo', 'foundation', 'charity', 'social impact']
  };
  
  for (const [industry, keywords] of Object.entries(industryKeywords)) {
    if (keywords.some(keyword => lowerDesc.includes(keyword))) {
      return industry;
    }
  }
  
  return 'general';
}

function inferRoleCategory(description, skills) {
  const lowerDesc = description.toLowerCase();
  const skillNames = skills.map(s => s.name ? s.name.toLowerCase() : s.toLowerCase());
  
  // Direct role mentions
  if (lowerDesc.includes('software engineer') || lowerDesc.includes('developer') ||
      lowerDesc.includes('programmer')) {
    return 'software-engineering';
  }
  
  if (lowerDesc.includes('product manager') || lowerDesc.includes('product owner')) {
    return 'product-management';
  }
  
  if (lowerDesc.includes('data scientist') || lowerDesc.includes('data analyst') ||
      lowerDesc.includes('machine learning')) {
    return 'data-science';
  }
  
  if (lowerDesc.includes('designer') || lowerDesc.includes('ux') || lowerDesc.includes('ui')) {
    return 'design';
  }
  
  if (lowerDesc.includes('marketing') || lowerDesc.includes('growth')) {
    return 'marketing';
  }
  
  if (lowerDesc.includes('sales') || lowerDesc.includes('account executive')) {
    return 'sales';
  }
  
  // Infer from skills
  const techSkills = ['javascript', 'python', 'java', 'react', 'node.js'];
  const dataSkills = ['sql', 'tableau', 'python', 'r', 'machine learning'];
  const designSkills = ['figma', 'sketch', 'photoshop', 'prototyping'];
  
  if (techSkills.some(skill => skillNames.includes(skill))) {
    return 'software-engineering';
  }
  
  if (dataSkills.some(skill => skillNames.includes(skill))) {
    return 'data-science';
  }
  
  if (designSkills.some(skill => skillNames.includes(skill))) {
    return 'design';
  }
  
  return 'general';
}

/**
 * Re-analyze a job with updated algorithm (always premium now)
 * @param {string} jobId - Job ID to re-analyze
 * @returns {Object} Updated job analysis
 */
exports.reAnalyzeJob = async (jobId) => {
  try {
    const Job = require('../models/mongodb/job.model');
    const job = await Job.findById(jobId);
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    console.log(`Re-analyzing job with premium quality: ${job.title} at ${job.company}`);
    
    // Re-analyze with premium GPT-4o for all re-analysis
    const updatedAnalysis = await this.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location
    }, { 
      isAiDiscovery: false,  // Use premium approach for all re-analysis
      prioritizeCost: false 
    });
    
    // Update the job with new analysis
    job.parsedData = updatedAnalysis;
    job.updatedAt = new Date();
    await job.save();
    
    console.log('Premium job re-analysis completed successfully');
    return updatedAnalysis;
    
  } catch (error) {
    console.error('Error re-analyzing job:', error);
    throw error;
  }
};

/**
 * Batch analyze multiple jobs with premium quality
 * @param {Array} jobIds - Array of job IDs to analyze
 * @param {boolean} isAiDiscovery - Whether this is AI discovery (now uses premium regardless)
 * @returns {Object} Batch analysis results
 */
exports.batchAnalyzeJobs = async (jobIds, isAiDiscovery = false) => {
  const results = {
    successful: [],
    failed: [],
    total: jobIds.length,
    modelUsed: 'gpt-4o', // Always premium now
    qualityLevel: 'premium',
    estimatedCost: '$0.01-0.02 per job'
  };
  
  console.log(`Starting premium batch analysis of ${jobIds.length} jobs with ${results.modelUsed}...`);
  
  for (const jobId of jobIds) {
    try {
      const Job = require('../models/mongodb/job.model');
      const job = await Job.findById(jobId);
      
      if (!job) {
        throw new Error('Job not found');
      }
      
      const analysis = await this.analyzeJob(job.description, {
        title: job.title,
        company: job.company,
        location: job.location
      }, { 
        isAiDiscovery: isAiDiscovery,
        prioritizeCost: false  // Always premium quality
      });
      
      job.parsedData = analysis;
      job.updatedAt = new Date();
      await job.save();
      
      results.successful.push({ jobId, analysis });
      
    } catch (error) {
      console.error(`Failed to analyze job ${jobId}:`, error);
      results.failed.push({ jobId, error: error.message });
    }
  }
  
  console.log(`Premium batch analysis completed: ${results.successful.length} successful, ${results.failed.length} failed`);
  return results;
};

================
File: services/jobMatching.service.js
================
// services/jobMatching.service.js - UPDATED TO AUTO-SELECT BEST RESUME
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');

/**
 * Find the best resume for a user to match against a job
 * @param {string} userId - User ID
 * @param {string} jobId - Job ID (optional, for tailored resume detection)
 * @returns {Object} Best resume for matching
 */
async function findBestResumeForMatching(userId, jobId = null) {
  try {
    // Get all user's resumes
    const allResumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    
    if (!allResumes || allResumes.length === 0) {
      throw new Error('No resumes found for user');
    }
    
    // First, check if there's a tailored resume specifically for this job
    if (jobId) {
      const tailoredResume = allResumes.find(resume => 
        resume.isTailored && 
        resume.tailoredForJob?.jobId && 
        resume.tailoredForJob.jobId.toString() === jobId.toString()
      );
      
      if (tailoredResume) {
        console.log(`Found tailored resume for job ${jobId}:`, {
          resumeId: tailoredResume._id,
          name: tailoredResume.name,
          overallScore: tailoredResume.analysis?.overallScore
        });
        return tailoredResume;
      }
    }
    
    // If no job-specific tailored resume, find the highest scoring resume
    const resumesWithScores = allResumes
      .filter(resume => resume.analysis && resume.analysis.overallScore)
      .sort((a, b) => b.analysis.overallScore - a.analysis.overallScore);
    
    if (resumesWithScores.length > 0) {
      const bestResume = resumesWithScores[0];
      console.log(`Selected best resume by score:`, {
        resumeId: bestResume._id,
        name: bestResume.name,
        overallScore: bestResume.analysis.overallScore,
        isTailored: bestResume.isTailored
      });
      return bestResume;
    }
    
    // Fallback to most recent resume
    const fallbackResume = allResumes[0];
    console.log(`Fallback to most recent resume:`, {
      resumeId: fallbackResume._id,
      name: fallbackResume.name
    });
    return fallbackResume;
    
  } catch (error) {
    console.error('Error finding best resume for matching:', error);
    throw error;
  }
}

/**
 * Enhanced job matching with automatic best resume selection
 * @param {string} jobId - MongoDB ID of the job
 * @param {string} resumeId - MongoDB ID of the resume (optional - will auto-select if not provided)
 * @param {string} userId - User ID (for auto-selection)
 * @returns {Object} Match analysis results with accurate scoring
 */
exports.matchJobWithBestResume = async (jobId, userId, specificResumeId = null) => {
  try {
    console.log(`Starting intelligent job matching for job ${jobId}, user ${userId}`);
    
    // Get the job
    const job = await Job.findById(jobId);
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Find the best resume to use for matching
    let resume;
    if (specificResumeId) {
      // Use specific resume if provided
      resume = await Resume.findOne({ _id: specificResumeId, userId });
      if (!resume) {
        throw new Error('Specified resume not found');
      }
      console.log(`Using specified resume: ${resume.name}`);
    } else {
      // Auto-select best resume
      resume = await findBestResumeForMatching(userId, jobId);
    }
    
    console.log(`Starting enhanced matching for job "${job.title}" with resume "${resume.name}"`);
    
    // Perform the actual matching
    const matchAnalysis = await this.matchResumeWithJob(resume._id, jobId);
    
    // Update the job with the new match analysis
    job.matchAnalysis = {
      ...matchAnalysis,
      resumeId: resume._id,
      lastAnalyzed: new Date(),
      analysisVersion: '2.0-auto-best'
    };
    
    await job.save();
    
    console.log(`Job match updated with best resume. Score: ${matchAnalysis.overallScore}%`);
    
    return {
      matchAnalysis,
      usedResume: {
        id: resume._id,
        name: resume.name,
        isTailored: resume.isTailored,
        overallScore: resume.analysis?.overallScore
      }
    };
    
  } catch (error) {
    console.error('Error in enhanced job matching:', error);
    throw error;
  }
};

/**
 * Enhanced job matching with more intelligent scoring
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @returns {Object} Match analysis results with accurate scoring
 */
exports.matchResumeWithJob = async (resumeId, jobId) => {
  try {
    console.log(`Starting enhanced matching for resume ${resumeId} with job ${jobId}`);
    
    // Get the resume and job from the database
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Check if parsed data is available for both
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      throw new Error('Resume parsing data not available for matching');
    }
    
    if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
      throw new Error('Job analysis data not available for matching');
    }
    
    console.log('Performing intelligent job-resume matching with OpenAI...');
    
    // Create detailed prompts for more accurate analysis
    const resumeSkills = extractSkillsFromResume(resume.parsedData);
    const jobSkills = extractSkillsFromJob(job.parsedData);
    const resumeExperience = extractExperienceFromResume(resume.parsedData);
    const jobRequirements = extractRequirementsFromJob(job.parsedData);
    
    // Check if this is a tailored resume for bonus consideration
    const isTailoredForThisJob = resume.isTailored && 
      resume.tailoredForJob?.jobId && 
      resume.tailoredForJob.jobId.toString() === jobId.toString();
    
    // Enhanced prompt for more precise matching
    const prompt = `
    You are an expert ATS (Applicant Tracking System) and recruitment analyst. Perform a detailed match analysis between this resume and job posting.

    IMPORTANT: Provide realistic and accurate scores based on actual content matching. ${isTailoredForThisJob ? 'This resume has been AI-tailored specifically for this job, so it should score higher than a generic resume.' : 'Avoid giving inflated scores.'}

    **JOB POSTING:**
    Title: ${job.title}
    Company: ${job.company}
    Description: ${job.description}
    
    **JOB REQUIREMENTS ANALYSIS:**
    Required Skills: ${JSON.stringify(jobSkills.required)}
    Preferred Skills: ${JSON.stringify(jobSkills.preferred)}
    Experience Level: ${job.parsedData.experienceLevel || 'Not specified'}
    Education Requirements: ${JSON.stringify(job.parsedData.educationRequirements)}
    Key Requirements: ${JSON.stringify(jobRequirements)}

    **CANDIDATE RESUME:**
    Summary: ${resume.parsedData.summary || 'No summary provided'}
    Skills: ${JSON.stringify(resumeSkills)}
    Experience: ${JSON.stringify(resumeExperience)}
    Education: ${JSON.stringify(resume.parsedData.education)}
    ${isTailoredForThisJob ? 'NOTE: This resume has been specifically tailored for this job posting.' : ''}

    **MATCHING CRITERIA:**
    1. **Skills Match (40% weight)**: Compare required vs candidate skills
    2. **Experience Match (35% weight)**: Evaluate relevant experience depth and breadth
    3. **Education Match (25% weight)**: Check education requirements vs candidate background

    **SCORING GUIDELINES:**
    - 95-100%: Perfect match, candidate exceeds all requirements ${isTailoredForThisJob ? '(expected for tailored resumes)' : ''}
    - 85-94%: Excellent match, candidate meets all core requirements with strong alignment
    - 75-84%: Very good match, candidate meets most requirements
    - 65-74%: Good match, candidate meets core requirements with some gaps
    - 55-64%: Moderate match, candidate has potential but significant gaps
    - Below 55%: Poor match, major misalignment

    ${isTailoredForThisJob ? 'TAILORED RESUME BONUS: This resume should score 10-15 points higher than the original due to optimization.' : ''}

    Provide analysis in this EXACT JSON format:
    {
      "overallScore": <realistic number 0-100>,
      "categoryScores": {
        "skills": <realistic number 0-100>,
        "experience": <realistic number 0-100>,
        "education": <realistic number 0-100>
      },
      "matchedSkills": [
        {
          "skill": "exact skill name from job",
          "found": true/false,
          "importance": <1-10 scale>,
          "matchQuality": "exact|partial|related|none",
          "resumeEvidence": "where found in resume or null"
        }
      ],
      "missingSkills": [
        {
          "skill": "missing skill name",
          "importance": <1-10 scale>,
          "category": "required|preferred",
          "suggestionToAdd": "specific advice"
        }
      ],
      "experienceAnalysis": {
        "totalYearsExperience": <number>,
        "relevantYearsExperience": <number>,
        "seniorityMatch": "junior|mid|senior|executive",
        "industryAlignment": "high|medium|low",
        "roleAlignment": "high|medium|low"
      },
      "educationAnalysis": {
        "degreeMatch": "exceeds|meets|partial|none",
        "fieldAlignment": "high|medium|low",
        "certificationBonus": true/false
      },
      "improvementSuggestions": [
        "specific actionable suggestion 1",
        "specific actionable suggestion 2",
        "specific actionable suggestion 3"
      ],
      "strengthsHighlight": [
        "key strength 1",
        "key strength 2",
        "key strength 3"
      ]
    }

    **IMPORTANT**: ${isTailoredForThisJob ? 'This is a tailored resume - expect scores in the 85-95% range due to optimization.' : 'Base scores on actual content analysis, not generic assumptions. Be critical and realistic in scoring.'}
    `;

    // Call OpenAI API with enhanced model settings
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: `You are an expert ATS system and senior recruitment analyst with 15+ years of experience. You provide realistic, accurate match scores based on detailed analysis. ${isTailoredForThisJob ? 'You recognize when resumes have been optimized for specific jobs and score them appropriately higher.' : 'You never inflate scores and always provide evidence-based assessments.'} Return ONLY valid JSON without markdown formatting.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Lower temperature for more consistent scoring
      max_tokens: 4000,
    });

    // Parse and validate the response
    const content = response.choices[0].message.content.trim();
    console.log('OpenAI Response received, parsing...');
    
    let matchAnalysis;
    try {
      // Clean up the response to extract JSON
      let jsonStr = content;
      
      // Remove any markdown code blocks
      if (content.includes('```')) {
        const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          jsonStr = jsonMatch[1];
        }
      }
      
      // Clean up and ensure valid JSON structure
      jsonStr = jsonStr.trim();
      if (!jsonStr.startsWith('{')) {
        const startIndex = jsonStr.indexOf('{');
        if (startIndex !== -1) {
          jsonStr = jsonStr.substring(startIndex);
        }
      }
      if (!jsonStr.endsWith('}')) {
        const endIndex = jsonStr.lastIndexOf('}');
        if (endIndex !== -1) {
          jsonStr = jsonStr.substring(0, endIndex + 1);
        }
      }
      
      matchAnalysis = JSON.parse(jsonStr);
      
      // Validate and ensure realistic scoring
      matchAnalysis = validateAndNormalizeScores(matchAnalysis);
      
      console.log(`Enhanced matching completed - Overall Score: ${matchAnalysis.overallScore}%`);
      
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.log('Raw response:', content);
      throw new Error('Failed to parse AI response');
    }

    // Add additional metadata
    matchAnalysis.analysisMetadata = {
      resumeId,
      jobId,
      analyzedAt: new Date(),
      algorithmVersion: '2.0',
      isTailoredResume: isTailoredForThisJob
    };

    return matchAnalysis;
    
  } catch (error) {
    console.error('Error in enhanced job matching:', error);
    
    // More intelligent fallback based on available data
    return generateIntelligentFallback(resume, job, error);
  }
};

/**
 * Extract skills from resume data
 */
function extractSkillsFromResume(parsedData) {
  const skills = [];
  
  // From skills section
  if (parsedData.skills && Array.isArray(parsedData.skills)) {
    parsedData.skills.forEach(skill => {
      if (typeof skill === 'string') {
        skills.push(skill);
      } else if (skill && skill.name) {
        skills.push(skill.name);
      }
    });
  }
  
  // From experience highlights
  if (parsedData.experience && Array.isArray(parsedData.experience)) {
    parsedData.experience.forEach(exp => {
      if (exp.skills && Array.isArray(exp.skills)) {
        skills.push(...exp.skills);
      }
    });
  }
  
  return [...new Set(skills)]; // Remove duplicates
}

/**
 * Extract skills from job data
 */
function extractSkillsFromJob(parsedData) {
  const required = [];
  const preferred = [];
  
  // From key skills
  if (parsedData.keySkills && Array.isArray(parsedData.keySkills)) {
    parsedData.keySkills.forEach(skill => {
      if (typeof skill === 'string') {
        required.push(skill);
      } else if (skill && skill.name) {
        const importance = skill.importance || 5;
        if (importance >= 7) {
          required.push(skill.name);
        } else {
          preferred.push(skill.name);
        }
      }
    });
  }
  
  // From qualifications
  if (parsedData.qualifications) {
    if (parsedData.qualifications.required) {
      required.push(...parsedData.qualifications.required);
    }
    if (parsedData.qualifications.preferred) {
      preferred.push(...parsedData.qualifications.preferred);
    }
  }
  
  return {
    required: [...new Set(required)],
    preferred: [...new Set(preferred)]
  };
}

/**
 * Extract experience from resume
 */
function extractExperienceFromResume(parsedData) {
  if (!parsedData.experience || !Array.isArray(parsedData.experience)) {
    return [];
  }
  
  return parsedData.experience.map(exp => ({
    company: exp.company,
    title: exp.title,
    duration: calculateDuration(exp.startDate, exp.endDate),
    description: exp.description,
    highlights: exp.highlights || []
  }));
}

/**
 * Extract requirements from job
 */
function extractRequirementsFromJob(parsedData) {
  const requirements = [];
  
  if (parsedData.requirements && Array.isArray(parsedData.requirements)) {
    requirements.push(...parsedData.requirements);
  }
  
  if (parsedData.responsibilities && Array.isArray(parsedData.responsibilities)) {
    requirements.push(...parsedData.responsibilities);
  }
  
  return requirements;
}

/**
 * Calculate duration between two dates
 */
function calculateDuration(startDate, endDate) {
  if (!startDate) return 0;
  
  const start = new Date(startDate);
  const end = endDate ? new Date(endDate) : new Date();
  
  const diffTime = Math.abs(end - start);
  const diffMonths = Math.ceil(diffTime / (1000 * 60 * 60 * 24 * 30));
  
  return diffMonths;
}

/**
 * Validate and normalize scores to ensure realistic ranges
 */
function validateAndNormalizeScores(analysis) {
  // Ensure overall score is reasonable based on category scores
  if (analysis.categoryScores) {
    const { skills, experience, education } = analysis.categoryScores;
    
    // Weighted average: Skills 40%, Experience 35%, Education 25%
    const calculatedOverall = Math.round((skills * 0.4) + (experience * 0.35) + (education * 0.25));
    
    // If provided overall score is significantly different, use calculated
    if (Math.abs(analysis.overallScore - calculatedOverall) > 10) {
      analysis.overallScore = calculatedOverall;
    }
  }
  
  // Ensure scores are within valid range
  analysis.overallScore = Math.max(0, Math.min(100, analysis.overallScore));
  if (analysis.categoryScores) {
    analysis.categoryScores.skills = Math.max(0, Math.min(100, analysis.categoryScores.skills));
    analysis.categoryScores.experience = Math.max(0, Math.min(100, analysis.categoryScores.experience));
    analysis.categoryScores.education = Math.max(0, Math.min(100, analysis.categoryScores.education));
  }
  
  return analysis;
}

/**
 * Generate intelligent fallback when AI analysis fails
 */
function generateIntelligentFallback(resume, job, error) {
  console.log('Generating intelligent fallback analysis...');
  
  try {
    // Basic skills matching
    const resumeSkills = extractSkillsFromResume(resume.parsedData);
    const jobSkills = extractSkillsFromJob(job.parsedData);
    
    // Calculate basic skill match percentage
    const allJobSkills = [...jobSkills.required, ...jobSkills.preferred];
    const matchedSkills = resumeSkills.filter(skill => 
      allJobSkills.some(jobSkill => 
        skill.toLowerCase().includes(jobSkill.toLowerCase()) ||
        jobSkill.toLowerCase().includes(skill.toLowerCase())
      )
    );
    
    const skillsScore = allJobSkills.length > 0 ? 
      Math.round((matchedSkills.length / allJobSkills.length) * 100) : 50;
    
    // Basic experience scoring
    const experienceYears = resume.parsedData.experience ? 
      resume.parsedData.experience.length * 2 : 0; // Rough estimate
    
    let experienceScore = 40;
    if (experienceYears >= 5) experienceScore = 75;
    if (experienceYears >= 8) experienceScore = 85;
    if (experienceYears >= 12) experienceScore = 95;
    
    // Basic education scoring
    const hasEducation = resume.parsedData.education && 
      resume.parsedData.education.length > 0;
    const educationScore = hasEducation ? 70 : 40;
    
    // Calculate weighted overall score
    const overallScore = Math.round(
      (skillsScore * 0.4) + (experienceScore * 0.35) + (educationScore * 0.25)
    );
    
    return {
      overallScore,
      categoryScores: {
        skills: skillsScore,
        experience: experienceScore,
        education: educationScore
      },
      matchedSkills: matchedSkills.map(skill => ({
        skill,
        found: true,
        importance: 5,
        matchQuality: 'partial',
        resumeEvidence: 'Skills section'
      })),
      missingSkills: allJobSkills
        .filter(skill => !matchedSkills.includes(skill))
        .slice(0, 5)
        .map(skill => ({
          skill,
          importance: 6,
          category: 'required',
          suggestionToAdd: `Consider highlighting experience with ${skill} if you have it`
        })),
      improvementSuggestions: [
        'Analysis temporarily unavailable - basic matching performed',
        'Consider highlighting relevant skills mentioned in the job posting',
        'Quantify your achievements with specific metrics and results'
      ],
      strengthsHighlight: [
        'Resume structure is well-organized',
        'Relevant work experience present',
        'Skills section is comprehensive'
      ],
      fallbackReason: error.message,
      analysisMetadata: {
        resumeId: resume._id,
        jobId: job._id,
        analyzedAt: new Date(),
        algorithmVersion: '2.0-fallback'
      }
    };
    
  } catch (fallbackError) {
    console.error('Error in fallback analysis:', fallbackError);
    
    // Final fallback with very basic scores
    return {
      overallScore: 45,
      categoryScores: {
        skills: 40,
        experience: 50,
        education: 45
      },
      matchedSkills: [],
      missingSkills: [],
      improvementSuggestions: [
        'Unable to complete detailed analysis at this time',
        'Please ensure your resume includes relevant skills for this position',
        'Try the analysis again later for more detailed insights'
      ],
      strengthsHighlight: [
        'Resume uploaded successfully',
        'Basic profile information captured'
      ],
      errorDetails: error.message,
      analysisMetadata: {
        resumeId: resume._id,
        jobId: job._id,
        analyzedAt: new Date(),
        algorithmVersion: '2.0-error-fallback'
      }
    };
  }
}

================
File: services/jobSearch.service.js
================
// services/jobSearch.service.js - ENHANCED WITH CLAUDE WEB SEARCH LIKE GENERAL CHAT
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const AiJobSearch = require('../models/mongodb/aiJobSearch.model');
const { anthropic } = require('../config/anthropic');
const { openai } = require('../config/openai');
const jobAnalysisService = require('./jobAnalysis.service');

/**
 * ENHANCED 3-Phase AI Job Search - Now with Claude Web Search like General Chat
 * Phase 1: Career Analysis ($0.05) - GPT-4 Turbo
 * Phase 2: ENHANCED Job Discovery & Extraction ($0.30-0.50) - Claude 3.5 Sonnet with web search API
 * Phase 3: Premium Job Analysis ($0.01-0.02) - GPT-4o batch processing
 * 
 * Uses Claude's web search API exactly like the general chat example
 * Total Cost: $0.36-0.57 per search
 */
exports.findJobsWithAi = async (userId, resumeId) => {
  try {
    console.log(`ðŸš€ Starting ENHANCED 3-Phase AI job search with Claude web search API for user ${userId}`);
    
    const resume = await Resume.findById(resumeId);
    if (!resume || !resume.parsedData) {
      throw new Error('Resume not found or not parsed');
    }
    
    // Create search record with CORRECT enum values
    const aiJobSearch = new AiJobSearch({
      userId,
      resumeId,
      resumeName: resume.name,
      searchCriteria: extractSearchCriteria(resume.parsedData),
      status: 'running',
      dailyLimit: 10,
      jobsFoundToday: 0,
      totalJobsFound: 0,
      searchApproach: '3-phase-intelligent-claude-web-search',  // FIXED: Use correct enum value
      approachVersion: '3.2-claude-web-search-api',
      qualityLevel: 'claude-web-search'  // FIXED: Use correct enum value
    });
    
    await aiJobSearch.save();
    
    // Add initialization reasoning log
    await aiJobSearch.addReasoningLog(
      'initialization',
      `ENHANCED 3-Phase AI job search with Claude web search API initialized for resume "${resume.name}"`,
      {
        searchCriteria: aiJobSearch.searchCriteria,
        dailyLimit: aiJobSearch.dailyLimit,
        enhancedApproach: '3-Phase: Career Analysis â†’ Claude Web Search Discovery â†’ Premium Analysis',
        webSearchMethod: 'Claude web search API (same as general chat)',
        qualityImprovement: 'Real job URLs found and content extracted like general chat',
        costEstimate: '$0.36-0.57 per search',
        phases: [
          'Phase 1: Career Analysis (GPT-4 Turbo)',
          'Phase 2: ENHANCED Job Discovery (Claude Web Search API)',
          'Phase 3: Premium Job Analysis (GPT-4o batch)'
        ]
      }
    );
    
    // Start background search
    performEnhancedJobSearch(aiJobSearch._id, userId, resume).catch(error => {
      console.error('Enhanced job search error:', error);
      updateSearchStatus(aiJobSearch._id, 'failed', error.message);
    });
    
    return {
      success: true,
      message: 'ENHANCED AI job search with Claude web search API started successfully',
      searchId: aiJobSearch._id,
      searchMethod: 'Claude web search API (same as general chat)'
    };
    
  } catch (error) {
    console.error('Error initiating enhanced job search:', error);
    throw error;
  }
};

async function addSearchError(search, errorType, message, phase = 'general', context = '') {
  // Map old error types to new enum values if needed
  const errorTypeMapping = {
    'intelligent_discovery_failed': 'web_search_failed',
    'job_search_failed': 'job_discovery_failed',
    'content_extraction_failed': 'content_extraction_failed'
  };
  
  const mappedErrorType = errorTypeMapping[errorType] || errorType;
  
  await search.addError(mappedErrorType, message, phase, context);
}

/**
 * ENHANCED 3-Phase Job Search with Claude Web Search API
 */
async function performEnhancedJobSearch(searchId, userId, resume) {
  const searchStartTime = Date.now();
  let search;
  
  try {
    search = await AiJobSearch.findById(searchId);
    if (!search || search.status !== 'running') return;
    
    // Check daily limits
    if (await isDailyLimitReached(search)) {
      await search.addReasoningLog(
        'completion',
        `Daily limit of ${search.dailyLimit} jobs reached. Search paused until tomorrow.`,
        { 
          dailyLimit: search.dailyLimit, 
          jobsFoundToday: search.jobsFoundToday,
          reason: 'daily_limit_reached'
        }
      );
      await updateSearchStatus(searchId, 'paused', 'Daily limit reached');
      return;
    }
    
    // PHASE 1: Career Analysis (Unchanged - GPT-4 Turbo)
    console.log(`ðŸ“Š Phase 1: Career Analysis...`);
    const phase1Start = Date.now();
    
    await search.addReasoningLog(
      'career_analysis',
      'Starting enhanced career trajectory analysis using GPT-4 Turbo for optimal job targeting',
      { 
        phase: 'career_analysis_start',
        model: 'gpt-4-turbo',
        costEstimate: '$0.05'
      }
    );
    
    const careerProfile = await analyzeCareerTrajectoryEnhanced(resume.parsedData);
    const phase1Duration = Date.now() - phase1Start;
    
    await search.addReasoningLog(
      'career_analysis',
      `Career analysis completed. Generated ${careerProfile.targetJobTitles?.length || 0} target job titles and ${careerProfile.targetKeywords?.length || 0} search keywords.`,
      {
        phase: 'career_analysis_complete',
        targetJobTitles: careerProfile.targetJobTitles || [],
        targetKeywords: careerProfile.targetKeywords || [],
        experienceLevel: careerProfile.experienceLevel,
        preferredLocations: careerProfile.preferredLocations || [],
        model: 'gpt-4-turbo',
        duration: phase1Duration
      },
      true,
      phase1Duration
    );
    
    if (!careerProfile.targetJobTitles || careerProfile.targetJobTitles.length === 0) {
      await search.addReasoningLog(
        'error',
        'Career analysis failed to identify target job titles. Cannot proceed with job search.',
        { 
          phase: 'career_analysis_failed',
          suggestion: 'Resume may need more detailed experience information'
        },
        false,
        phase1Duration
      );
      await updateSearchStatus(searchId, 'completed', 'Career analysis insufficient');
      return;
    }
    
    // PHASE 2: ENHANCED Job Discovery & Extraction (CLAUDE WEB SEARCH API)
    console.log(`ðŸŽ¯ Phase 2: ENHANCED Job Discovery with Claude Web Search API...`);
    const phase2Start = Date.now();
    
    await search.addReasoningLog(
      'intelligent_discovery',
      'Starting ENHANCED job discovery using Claude web search API (same method as general chat)',
      { 
        phase: 'enhanced_job_discovery_start',
        model: 'claude-3.5-sonnet',
        approach: 'Step 1: Find job URLs with web search â†’ Step 2: Extract content from URLs',
        webSearchMethod: 'Claude web search API (same as general chat)',
        costEstimate: '$0.30-0.50'
      }
    );
    
    const discoveredJobs = await performRealJobBoardDiscovery(careerProfile, search);
    const phase2Duration = Date.now() - phase2Start;
    
    if (discoveredJobs.length === 0) {
      await search.addReasoningLog(
        'completion',
        'Enhanced job discovery found no matching opportunities using Claude web search API. Search criteria may need adjustment.',
        { 
          phase: 'enhanced_discovery_no_results',
          searchMethod: 'Claude web search API',
          searchedTitles: careerProfile.targetJobTitles,
          suggestion: 'Try again tomorrow or broaden search criteria'
        },
        false,
        phase2Duration
      );
      await updateSearchStatus(searchId, 'completed', 'No job opportunities found with Claude web search');
      return;
    }
    
    await search.addReasoningLog(
      'intelligent_discovery',
      `Enhanced job discovery completed successfully. Found ${discoveredJobs.length} high-quality job opportunities using Claude web search API.`,
      {
        phase: 'enhanced_job_discovery_complete',
        totalJobsFound: discoveredJobs.length,
        searchMethod: 'Claude web search API',
        platformsFound: [...new Set(discoveredJobs.map(job => job.sourcePlatform))],
        averageContentLength: discoveredJobs.length > 0 ? 
          Math.round(discoveredJobs.reduce((sum, job) => sum + (job.fullContent?.length || 0), 0) / discoveredJobs.length) : 0,
        qualityJobs: discoveredJobs.filter(job => job.contentQuality === 'high').length,
        companiesFound: [...new Set(discoveredJobs.map(job => job.company))].length,
        model: 'claude-3.5-sonnet',
        duration: phase2Duration
      },
      true,
      phase2Duration
    );
    
// PHASE 3: Premium Job Analysis (Unchanged - GPT-4o Quality)
    console.log(`ðŸ”¬ Phase 3: Premium Job Analysis...`);
    const phase3Start = Date.now();
    
    await search.addReasoningLog(
      'premium_analysis',
      'Starting premium job analysis using GPT-4o for same quality as manual job uploads',
      { 
        phase: 'premium_analysis_start',
        jobsToAnalyze: discoveredJobs.length,
        model: 'gpt-4o',
        quality: 'Same as manual job uploads',
        costEstimate: '$0.01-0.02'
      }
    );
    
    const analyzedJobs = await performPremiumJobAnalysis(discoveredJobs, search);
    const phase3Duration = Date.now() - phase3Start;
    
    const successfulAnalyses = analyzedJobs.filter(job => job.analysis && !job.analysisError).length;
    
    await search.addReasoningLog(
      'premium_analysis',
      `Premium job analysis completed. Successfully analyzed ${successfulAnalyses}/${analyzedJobs.length} jobs with GPT-4o quality.`,
      {
        phase: 'premium_analysis_complete',
        totalJobs: analyzedJobs.length,
        successfulAnalyses: successfulAnalyses,
        averageSkillsFound: successfulAnalyses > 0 ? 
          Math.round(analyzedJobs
            .filter(job => job.analysis?.keySkills)
            .reduce((sum, job) => sum + (job.analysis.keySkills.length || 0), 0) / successfulAnalyses) : 0,
        model: 'gpt-4o',
        quality: 'Premium analysis (same as manual)',
        duration: phase3Duration
      },
      successfulAnalyses > 0,
      phase3Duration
    );

    function getPhaseForLogging(originalPhase) {
  const phaseMapping = {
    'intelligent_discovery': 'web_search_discovery',
    'content_extraction': 'content_extraction',
    'job_search': 'web_search_discovery'
  };
  
  return phaseMapping[originalPhase] || originalPhase;
}

    
    // Save Jobs with Enhanced Metadata
    console.log(`ðŸ’¾ Saving ${analyzedJobs.length} analyzed jobs from Claude web search...`);
    const saveStart = Date.now();
    
    await search.addReasoningLog(
      'job_saving',
      `Saving ${analyzedJobs.length} premium-analyzed jobs from Claude web search with enhanced metadata and deduplication`,
      { 
        phase: 'job_saving_start',
        jobsToSave: analyzedJobs.length,
        discoveryMethod: 'Claude web search API'
      }
    );
    
    const savedCount = await saveJobsWithEnhancedMetadata(analyzedJobs, userId, searchId, search);
    const saveDuration = Date.now() - saveStart;
    
    await search.addReasoningLog(
      'job_saving',
      `Job saving completed. Saved ${savedCount} new premium jobs from Claude web search, skipped ${analyzedJobs.length - savedCount} duplicates.`,
      {
        phase: 'job_saving_complete',
        savedJobs: savedCount,
        duplicatesSkipped: analyzedJobs.length - savedCount,
        discoveryMethod: 'Claude web search API',
        duration: saveDuration
      },
      savedCount > 0,
      saveDuration
    );
    
    // Final completion with Claude web search summary
    const totalDuration = Date.now() - searchStartTime;
    const searchSummary = {
      phase1: 'GPT-4 Turbo - $0.05',
      phase2: 'Claude 3.5 Sonnet + Web Search API - $0.30-0.50', 
      phase3: 'GPT-4o Premium Analysis - $0.01-0.02',
      totalCost: '$0.36-0.57',
      qualityLevel: 'Real job postings found via Claude web search API',
      searchMethod: 'Same as Claude general chat',
      enhancement: 'Claude web search API + Premium analysis'
    };
    
    await search.addReasoningLog(
      'completion',
      `ENHANCED 3-Phase AI job search with Claude web search API completed in ${Math.round(totalDuration / 1000)}s. Found ${savedCount} premium jobs using the same method as general chat.`,
      {
        phase: 'search_complete',
        totalDuration: totalDuration,
        jobsSaved: savedCount,
        searchSummary: searchSummary,
        webSearchMethod: 'Claude web search API (same as general chat)',
        intelligence: 'Claude for job discovery + GPT-4o for analysis',
        nextRun: 'Will continue tomorrow with fresh opportunities via Claude web search'
      }
    );
    
    await updateSearchStatus(searchId, savedCount > 0 ? 'running' : 'completed', 
      `Found ${savedCount} premium jobs via Claude web search API`);
    console.log(`âœ… ENHANCED 3-Phase AI job search complete: ${savedCount} jobs saved via Claude web search, cost: $0.36-0.57`);
    
  } catch (error) {
    console.error('Error in enhanced Claude web search:', error);
    
    if (search) {
      await search.addReasoningLog(
        'error',
        `Enhanced job search failed: ${error.message}`,
        { 
          phase: 'search_error',
          errorType: error.name,
          errorMessage: error.message,
          searchMethod: 'Claude web search API',
          suggestion: 'Try running the search again'
        },
        false
      );
    }
    
    await updateSearchStatus(searchId, 'failed', error.message);
  }
}

async function updateAiUsageForPhase(search, phase, type, tokens = 0, cost = 0) {
  // Map phases to match new enum values
  const phaseMapping = {
    'intelligent_discovery': 'web_search_discovery',
    'job_search': 'web_search_discovery',
    'content_extraction': 'web_search_discovery'
  };
  
  const mappedPhase = phaseMapping[phase] || phase;
  await search.updateAiUsage(mappedPhase, type, tokens, cost);
}

/**
 * ENHANCED PHASE 2: Real Job Board Discovery & Extraction
 * Uses Claude's web search API exactly like the general chat example
 */
async function performRealJobBoardDiscovery(careerProfile, search) {
  try {
    console.log(`ðŸŽ¯ Starting ENHANCED job discovery using Claude web search for ${careerProfile.targetJobTitles?.length || 0} target roles...`);
    
    // Step 1: Find job URLs using web search (like your general chat example)
    const jobUrls = await findJobUrlsWithWebSearch(careerProfile, search);
    
    if (jobUrls.length === 0) {
      await search.addReasoningLog(
        'web_search_discovery',
        'No job URLs found with Claude web search. May need to adjust search criteria.',
        { 
          searchTargets: careerProfile.targetJobTitles,
          searchKeywords: careerProfile.targetKeywords,
          searchMethod: 'Claude web search API'
        },
        false
      );
      return [];
    }
    
    // Step 2: Extract content from each job URL (like your URL extraction example)
const discoveredJobs = await extractJobContentFromUrls(jobUrls, search, careerProfile);
    
    await search.addReasoningLog(
      'web_search_discovery',
      `Enhanced job discovery completed. Found ${discoveredJobs.length} high-quality jobs using Claude web search API.`,
      {
        jobUrlsFound: jobUrls.length,
        successfulExtractions: discoveredJobs.length,
        jobBoards: [...new Set(discoveredJobs.map(job => job.sourcePlatform))],
        averageContentLength: discoveredJobs.length > 0 ? 
          Math.round(discoveredJobs.reduce((sum, job) => sum + (job.fullContent?.length || 0), 0) / discoveredJobs.length) : 0,
        searchMethod: 'Claude web search API (same as general chat)'
      }
    );
    
    return discoveredJobs;
    
  } catch (error) {
    console.error('Error in enhanced job discovery:', error);
    await search.addReasoningLog(
      'web_search_discovery',
      `Enhanced job discovery failed: ${error.message}`,
      { error: error.message, searchMethod: 'Claude web search API' },
      false
    );
    return [];
  }
}


/**
 * Step 1: Find Job URLs using Claude Web Search
 * Mimics the approach from your general chat example
 */
async function findJobUrlsWithWebSearch(careerProfile, search) {
  try {
    await search.addReasoningLog(
      'web_search_discovery',  // FIXED: Use correct phase enum
      'Starting job URL discovery using Claude web search API',
      { 
        targetTitles: careerProfile.targetJobTitles,
        searchApproach: 'Claude web search like general chat',
        webSearchMethod: 'claude_web_search_api'
      }
    );
    
    const response = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 4000,
      temperature: 0.2,
      messages: [
        {
          role: "user",
          content: `I am looking for ${careerProfile.experienceLevel || 'mid-level'} ${careerProfile.targetJobTitles?.[0] || 'Software Engineer'} jobs at companies that are hiring. 

TARGET PROFILE:
- Job Titles: ${careerProfile.targetJobTitles?.join(', ')}
- Experience Level: ${careerProfile.experienceLevel}
- Preferred Skills: ${careerProfile.targetKeywords?.join(', ')}
- Work Arrangement: ${careerProfile.workArrangement || 'remote/hybrid'}
- Salary Range: $${careerProfile.salaryExpectation?.min || 100000}-${careerProfile.salaryExpectation?.max || 150000}

Please find 8-12 current job openings that match this profile. For each job, I need:
1. The company name and job title
2. The direct job application URL (especially from Greenhouse, Lever, Indeed, or company career pages)
3. Brief description of why it's a good match

Focus on:
- Direct company postings (not recruiters)
- Jobs posted in the last 30 days
- Companies with good reputations
- Remote/hybrid opportunities when possible
- Jobs from well-known ATS systems (Greenhouse, Lever, etc.)

Return the results in this format:
JOB 1: [Job Title] at [Company Name]
URL: [Direct job application URL]
Match Reason: [Why this is a good fit]

JOB 2: [Job Title] at [Company Name]  
URL: [Direct job application URL]
Match Reason: [Why this is a good fit]

etc.`
        }
      ],
      tools: [
        {
          type: "web_search_20250305",
          name: "web_search"
        }
      ],
      tool_choice: { type: "any" }
    });

    const jobUrls = [];
    
    // Process Claude's response to extract job URLs
    for (const content of response.content) {
      if (content.type === 'text') {
        const text = content.text;
        
        // Extract URLs from the response
        const urlMatches = text.match(/URL:\s*(https?:\/\/[^\s\n]+)/gi);
        
        if (urlMatches) {
          urlMatches.forEach(match => {
            const url = match.replace(/^URL:\s*/i, '').trim();
            
            // Extract job info from the surrounding text
            const lines = text.split('\n');
            const urlLineIndex = lines.findIndex(line => line.includes(url));
            
            if (urlLineIndex > 0) {
              const jobLine = lines[urlLineIndex - 1] || '';
              const matchReasonLine = lines[urlLineIndex + 1] || '';
              
              // Parse job title and company
              const jobMatch = jobLine.match(/JOB\s+\d+:\s*(.+?)\s+at\s+(.+?)$/i);
              let title = 'Unknown Title';
              let company = 'Unknown Company';
              
              if (jobMatch) {
                title = jobMatch[1].trim();
                company = jobMatch[2].trim();
              }
              
              // Extract match reason
              const matchReason = matchReasonLine.replace(/^Match Reason:\s*/i, '').trim();
              
              // Determine source platform from URL
              const sourcePlatform = determineSourcePlatform(url);
              
              if (isValidJobUrl(url)) {
                jobUrls.push({
                  url: url,
                  title: title,
                  company: company,
                  matchReason: matchReason,
                  sourcePlatform: sourcePlatform,
                  foundAt: new Date()
                });
              }
            }
          });
        }
      }
    }
    
    await search.addReasoningLog(
      'web_search_discovery',  // FIXED: Use correct phase enum
      `Found ${jobUrls.length} job URLs using Claude web search API`,
      {
        totalUrls: jobUrls.length,
        platforms: [...new Set(jobUrls.map(job => job.sourcePlatform))],
        companies: [...new Set(jobUrls.map(job => job.company))],
        searchMethod: 'claude_web_search_api',
        webSearchMethod: 'claude_web_search_api'
      }
    );
    
    console.log(`âœ… Found ${jobUrls.length} job URLs using Claude web search API`);
    return jobUrls;
    
  } catch (error) {
    console.error('Error finding job URLs with web search:', error);
    
    // Add error with correct enum
    await search.addError('web_search_failed', error.message, 'web_search_discovery', 'URL discovery failed');
    throw error;
  }
}


/**
 * Step 2: Extract Job Content from URLs
 * Mimics the URL content extraction from your example
 */
async function extractJobContentFromUrls(jobUrls, search, careerProfile) {
  const discoveredJobs = [];
  
  console.log(`ðŸ“„ Extracting content from ${jobUrls.length} job URLs with detailed debugging...`);
  
  for (const jobUrl of jobUrls) {
    try {
      console.log(`\nðŸ” === EXTRACTION DEBUG FOR: ${jobUrl.title} at ${jobUrl.company} ===`);
      console.log(`ðŸ”— URL: ${jobUrl.url}`);
      console.log(`ðŸ¢ Platform: ${jobUrl.sourcePlatform}`);
      console.log(`ðŸ’¡ Match Reason: ${jobUrl.matchReason}`);
      
      await search.addReasoningLog(
        'content_extraction',
        `Starting content extraction from ${jobUrl.title} at ${jobUrl.company}`,
        {
          url: jobUrl.url,
          platform: jobUrl.sourcePlatform,
          extractionMethod: 'claude_web_fetch_debug'
        }
      );
      
      const response = await anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 4000,
        temperature: 0.1,
        messages: [
          {
            role: "user",
            content: `Please visit this job posting URL and extract the complete content: ${jobUrl.url}

Extract all job details including:
- Complete job description and overview
- Key responsibilities and duties  
- Required qualifications and skills
- Preferred qualifications
- Salary/compensation information
- Benefits and perks
- Work location and arrangement (remote/hybrid/onsite)
- Company information and culture
- Application process

Provide the comprehensive job posting content exactly as it appears on the page.`
          }
        ],
        tools: [
          {
            type: "web_search_20250305",
            name: "web_search"
          }
        ],
        tool_choice: { type: "any" }
      });

      console.log(`ðŸ“¡ Claude API Response Structure:`);
      console.log(`- Response content array length: ${response.content?.length || 0}`);
      
      let fullContent = '';
      let hasTextContent = false;
      let hasToolResults = false;
      let allTextFragments = []; // NEW: Collect all text fragments
      
      // FIXED: Examine the full response structure and collect ALL text content
      for (let i = 0; i < response.content.length; i++) {
        const content = response.content[i];
        console.log(`- Content[${i}] type: ${content.type}`);
        
        if (content.type === 'text') {
          hasTextContent = true;
          allTextFragments.push(content.text); // COLLECT each text fragment
          console.log(`- Text content length: ${content.text.length} characters`);
          console.log(`- Text preview: "${content.text.substring(0, 100)}..."`);
        } else if (content.type === 'tool_use') {
          hasToolResults = true;
          console.log(`- Tool use detected: ${content.name}`);
        } else if (content.type === 'tool_result') {
          console.log(`- Tool result detected`);
        }
      }
      
      // FIXED: Concatenate ALL text fragments into one complete content
      fullContent = allTextFragments.join('').trim();
      
      console.log(`ðŸ“Š Content Analysis:`);
      console.log(`- Has text content: ${hasTextContent}`);
      console.log(`- Has tool results: ${hasToolResults}`);
      console.log(`- Number of text fragments: ${allTextFragments.length}`);
      console.log(`- Total concatenated content length: ${fullContent.length}`);
      console.log(`- Full content preview: "${fullContent.substring(0, 300)}..."`);
      
      // More detailed content analysis
      if (fullContent.length > 0) {
        const lowerContent = fullContent.toLowerCase();
        const hasJobKeywords = /job|position|role|career|responsibilities|qualifications|requirements/i.test(fullContent);
        const hasCompanyInfo = /company|organization|team|culture/i.test(fullContent);
        const hasSalaryInfo = /salary|compensation|\$|pay|benefits/i.test(fullContent);
        
        console.log(`ðŸ“‹ Content Quality Check:`);
        console.log(`- Has job keywords: ${hasJobKeywords}`);
        console.log(`- Has company info: ${hasCompanyInfo}`);
        console.log(`- Has salary info: ${hasSalaryInfo}`);
        
        // Check if content looks like an error message
        const isErrorContent = /error|not found|404|access denied|blocked|unavailable/i.test(fullContent);
        console.log(`- Is error content: ${isErrorContent}`);
        
        if (isErrorContent) {
          console.log(`âŒ ERROR: Content appears to be an error message`);
          console.log(`Error content preview: "${fullContent.substring(0, 300)}"`);
        }
      }
      
      // Only proceed if we have substantial, valid content
      if (fullContent && fullContent.length > 300 && !/error|not found|404|access denied/i.test(fullContent)) {
        console.log(`âœ… EXTRACTION SUCCESSFUL - Processing content...`);
        
        // Extract structured data from the content
        const extractedData = parseJobContent(fullContent, jobUrl, careerProfile);
        
        const job = {
          title: extractedData.title || jobUrl.title,
          company: extractedData.company || jobUrl.company,
          location: extractedData.location || 'Not specified',
          salary: extractedData.salary || {},
          jobUrl: jobUrl.url,
          sourcePlatform: jobUrl.sourcePlatform,
          fullContent: fullContent,
          postedDate: extractedData.postedDate || new Date().toISOString().split('T')[0],
          workArrangement: extractedData.workArrangement || 'unknown',
          matchReason: jobUrl.matchReason,
          experienceLevel: extractedData.experienceLevel || careerProfile.experienceLevel,
          keyRequirements: extractedData.keyRequirements || [],
          department: extractedData.department || 'Not specified',
          companySize: extractedData.companySize || 'Not specified',
          industry: extractedData.industry || 'Technology',
          benefits: extractedData.benefits || [],
          techStack: extractedData.techStack || [],
          extractionMethod: 'claude_web_content_extraction',
          extractedAt: new Date(),
          matchScore: calculateEnhancedMatchScore(extractedData, careerProfile),
          contentQuality: assessContentQuality(fullContent),
          metadata: {
            discoveryMethod: 'claude_web_search_and_extract',
            platform: jobUrl.sourcePlatform,
            extractedAt: new Date(),
            contentLength: fullContent.length,
            urlValidated: true,
            directCompanyPosting: true
          }
        };
        
        discoveredJobs.push(job);
        
        await search.addReasoningLog(
          'content_extraction',
          `Successfully extracted ${fullContent.length} characters from ${job.title} at ${job.company}`,
          {
            contentLength: fullContent.length,
            qualityScore: job.contentQuality,
            matchScore: job.matchScore,
            extractionSuccess: true
          },
          true
        );
        
        console.log(`âœ… JOB CREATED: ${job.title} at ${job.company} (${fullContent.length} chars)`);
        
      } else {
        console.log(`âŒ EXTRACTION FAILED: Insufficient or invalid content`);
        console.log(`- Content length: ${fullContent.length}`);
        console.log(`- Content preview: "${fullContent.substring(0, 200)}"`);
        
        await search.addReasoningLog(
          'content_extraction',
          `Failed to extract sufficient content from ${jobUrl.title} at ${jobUrl.company}`,
          {
            url: jobUrl.url,
            contentLength: fullContent.length,
            extractionSuccess: false,
            failureReason: fullContent.length === 0 ? 'No content returned' : 'Content too short or invalid'
          },
          false
        );
      }
      
      console.log(`=== END EXTRACTION DEBUG ===\n`);
      
      // Delay between extractions
      await new Promise(resolve => setTimeout(resolve, 3000));
      
    } catch (error) {
      console.error(`âŒ EXTRACTION ERROR for ${jobUrl.url}:`, error);
      console.error(`Error details:`, {
        name: error.name,
        message: error.message,
        stack: error.stack?.split('\n')[0]
      });
      
      await search.addReasoningLog(
        'content_extraction',
        `Error extracting content from ${jobUrl.title}: ${error.message}`,
        {
          url: jobUrl.url,
          error: error.message,
          extractionSuccess: false
        },
        false
      );
    }
  }
  
  console.log(`\nðŸ“Š FINAL EXTRACTION RESULTS:`);
  console.log(`- URLs processed: ${jobUrls.length}`);
  console.log(`- Jobs successfully created: ${discoveredJobs.length}`);
  console.log(`- Success rate: ${Math.round((discoveredJobs.length / jobUrls.length) * 100)}%`);
  
  return discoveredJobs;
}

/**
 * Helper Functions
 */

function determineSourcePlatform(url) {
  const lowerUrl = url.toLowerCase();
  
  if (lowerUrl.includes('greenhouse.io')) return 'Greenhouse';
  if (lowerUrl.includes('lever.co')) return 'Lever';
  if (lowerUrl.includes('indeed.com')) return 'Indeed';
  if (lowerUrl.includes('linkedin.com')) return 'LinkedIn';
  if (lowerUrl.includes('workday.com')) return 'Workday';
  if (lowerUrl.includes('careers.') || lowerUrl.includes('/careers/')) return 'Company Career Page';
  if (lowerUrl.includes('bamboohr.com')) return 'BambooHR';
  if (lowerUrl.includes('smartrecruiters.com')) return 'SmartRecruiters';
  if (lowerUrl.includes('jobvite.com')) return 'Jobvite';
  
  return 'Other';
}

function isValidJobUrl(url) {
  if (!url || typeof url !== 'string') return false;
  
  const lowerUrl = url.toLowerCase();
  
  // Check if it's a valid HTTP/HTTPS URL
  if (!lowerUrl.startsWith('http://') && !lowerUrl.startsWith('https://')) return false;
  
  // Check if it contains job-related keywords
  const jobKeywords = [
    'job', 'jobs', 'career', 'careers', 'apply', 'position', 'opening',
    'greenhouse.io', 'lever.co', 'indeed.com', 'linkedin.com/jobs'
  ];
  
  return jobKeywords.some(keyword => lowerUrl.includes(keyword));
}

function parseJobContent(content, jobUrl, careerProfile) {
  console.log(`ðŸ”§ Parsing job content for: ${jobUrl.title}`);
  
  const data = {
    title: jobUrl.title,
    company: jobUrl.company
  };
  
  try {
    const lowerContent = content.toLowerCase();
    
    // Extract salary with better patterns
    const salaryPatterns = [
      /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*-?\s*\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)?/g,
      /(\d{1,3}(?:,\d{3})*)\s*-\s*(\d{1,3}(?:,\d{3})*)\s*(?:per year|annually|\/year)/gi,
      /salary.*?(\d{1,3}(?:,\d{3})*)/gi
    ];
    
    for (const pattern of salaryPatterns) {
      const salaryMatches = content.match(pattern);
      if (salaryMatches && salaryMatches.length > 0) {
        const salaryMatch = salaryMatches[0].match(/(\d{1,3}(?:,\d{3})*)/g);
        if (salaryMatch) {
          data.salary = {
            min: parseInt(salaryMatch[0].replace(/,/g, '')),
            max: salaryMatch[1] ? parseInt(salaryMatch[1].replace(/,/g, '')) : undefined,
            currency: 'USD'
          };
          console.log(`ðŸ’° Found salary: $${data.salary.min}${data.salary.max ? `-$${data.salary.max}` : ''}`);
          break;
        }
      }
    }
    
    // Extract work arrangement with more patterns
    const workPatterns = [
      { pattern: /remote.*?first|fully remote|100%\s*remote/i, arrangement: 'remote' },
      { pattern: /hybrid|flexible|mix of remote/i, arrangement: 'hybrid' },
      { pattern: /on-?site|in-?office|office-?based/i, arrangement: 'onsite' }
    ];
    
    for (const wp of workPatterns) {
      if (wp.pattern.test(content)) {
        data.workArrangement = wp.arrangement;
        console.log(`ðŸ  Found work arrangement: ${data.workArrangement}`);
        break;
      }
    }
    
    // Extract experience level
    const expPatterns = [
      { pattern: /senior|sr\.|lead/i, level: 'senior' },
      { pattern: /principal|staff|architect/i, level: 'lead' },
      { pattern: /junior|jr\.|entry|associate/i, level: 'junior' },
      { pattern: /director|vp|head of/i, level: 'executive' }
    ];
    
    for (const ep of expPatterns) {
      if (ep.pattern.test(content)) {
        data.experienceLevel = ep.level;
        console.log(`ðŸ“ˆ Found experience level: ${data.experienceLevel}`);
        break;
      }
    }
    
    // Extract requirements with better keyword matching
    const skillKeywords = [
      'product management', 'product strategy', 'roadmap', 'analytics', 'data analysis',
      'ai', 'machine learning', 'artificial intelligence', 'python', 'sql', 'tableau',
      'javascript', 'react', 'node.js', 'aws', 'typescript', 'java', 'kubernetes',
      'agile', 'scrum', 'jira', 'figma', 'sketch', 'user research', 'a/b testing'
    ];
    
    data.keyRequirements = skillKeywords.filter(skill => 
      lowerContent.includes(skill.toLowerCase())
    );
    console.log(`ðŸŽ¯ Found ${data.keyRequirements.length} skill requirements`);
    
    // Extract benefits
    const benefitKeywords = [
      'health insurance', 'dental', 'vision', '401k', 'pto', 'vacation', 
      'equity', 'stock options', 'bonus', 'flexible hours', 'remote work'
    ];
    
    data.benefits = benefitKeywords.filter(benefit => 
      lowerContent.includes(benefit.toLowerCase())
    );
    console.log(`ðŸŽ Found ${data.benefits.length} benefits`);
    
    // Extract location from content
    const locationPatterns = [
      /location:?\s*([^\n]+)/i,
      /based in:?\s*([^\n]+)/i,
      /office:?\s*([^\n]+)/i
    ];
    
    for (const pattern of locationPatterns) {
      const locationMatch = content.match(pattern);
      if (locationMatch) {
        data.location = locationMatch[1].trim();
        console.log(`ðŸ“ Found location: ${data.location}`);
        break;
      }
    }
    
    console.log(`âœ… Content parsing completed for: ${jobUrl.title}`);
    
  } catch (error) {
    console.error(`âŒ Error parsing job content for ${jobUrl.title}:`, error);
  }
  
  return data;
}


function calculateEnhancedMatchScore(jobData, careerProfile) {
  let score = 70; // Base score for Claude-discovered jobs
  
  // Title matching
  const jobTitle = (jobData.title || '').toLowerCase();
  const titleMatches = careerProfile.targetJobTitles?.some(target => 
    jobTitle.includes(target.toLowerCase()) || target.toLowerCase().includes(jobTitle)
  );
  if (titleMatches) score += 20;
  
  // Keyword matching
  const content = (jobData.fullContent || '').toLowerCase();
  const keywordMatches = careerProfile.targetKeywords?.filter(keyword => 
    content.includes(keyword.toLowerCase())
  ).length || 0;
  score += Math.min(keywordMatches * 3, 15);
  
  // Experience level matching
  if (jobData.experienceLevel && jobData.experienceLevel.toLowerCase() === careerProfile.experienceLevel?.toLowerCase()) {
    score += 10;
  }
  
  // Salary matching
  if (jobData.salary?.min && careerProfile.salaryExpectation?.min) {
    if (jobData.salary.min >= careerProfile.salaryExpectation.min * 0.8) {
      score += 10;
    }
  }
  
  // Work arrangement preference
  if (jobData.workArrangement && careerProfile.workArrangement) {
    if (jobData.workArrangement === careerProfile.workArrangement || 
        (careerProfile.workArrangement === 'remote' && jobData.workArrangement === 'hybrid')) {
      score += 5;
    }
  }
  
  return Math.min(Math.max(score, 0), 100);
}

function assessContentQuality(content) {
  if (!content) return 'low';
  
  const length = content.length;
  const hasRequirements = /requirements?|qualifications?|skills?/i.test(content);
  const hasResponsibilities = /responsibilit|duties|role|job description/i.test(content);
  const hasBenefits = /benefits?|perks|compensation|salary/i.test(content);
  const hasCompanyInfo = /company|about us|culture|mission/i.test(content);
  const hasWorkArrangement = /remote|hybrid|onsite|office|location/i.test(content);
  const hasApplyInfo = /apply|application|submit|contact/i.test(content);
  
  let qualityScore = 0;
  
  // Length scoring
  if (length > 3000) qualityScore += 4;
  else if (length > 2000) qualityScore += 3;
  else if (length > 1000) qualityScore += 2;
  else if (length > 500) qualityScore += 1;
  
  // Content sections scoring
  if (hasRequirements) qualityScore += 2;
  if (hasResponsibilities) qualityScore += 2;
  if (hasBenefits) qualityScore += 1;
  if (hasCompanyInfo) qualityScore += 1;
  if (hasWorkArrangement) qualityScore += 1;
  if (hasApplyInfo) qualityScore += 1;
  
  console.log(`ðŸ“Š Content quality score: ${qualityScore}/12`);
  
  if (qualityScore >= 8) return 'high';
  else if (qualityScore >= 5) return 'medium';
  else return 'low';
}

/**
 * Enhanced save jobs function with Claude web search metadata
 */
async function saveJobsWithEnhancedMetadata(analyzedJobs, userId, searchId, search) {
  let savedCount = 0;
  
  for (const jobData of analyzedJobs) {
    try {
      // Enhanced duplicate checking
      const existing = await Job.findOne({
        userId,
        $or: [
          { sourceUrl: jobData.jobUrl },
          { 
            title: jobData.title, 
            company: jobData.company,
            sourcePlatform: { $regex: jobData.sourcePlatform, $options: 'i' }
          }
        ]
      });
      
      if (existing) {
        await search.addReasoningLog(
          'job_saving',
          `Skipped duplicate: "${jobData.title}" at ${jobData.company} (${jobData.sourcePlatform})`,
          { 
            reason: 'duplicate_prevention',
            originalPlatform: jobData.sourcePlatform 
          }
        );
        continue;
      }
      
      // Fix the sourcePlatform enum issue
      let sourcePlatform = `AI_FOUND_INTELLIGENT`;
      if (jobData.sourcePlatform && jobData.sourcePlatform.toLowerCase().includes('greenhouse')) {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      } else if (jobData.sourcePlatform && jobData.sourcePlatform.toLowerCase().includes('lever')) {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      } else if (jobData.sourcePlatform && jobData.sourcePlatform.toLowerCase().includes('indeed')) {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      } else {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      }
      
      // Create enhanced job record with Claude web search data
      const job = new Job({
        userId,
        title: jobData.title,
        company: jobData.company,
        location: parseLocationEnhanced(jobData.location),
        description: jobData.fullContent,
        sourceUrl: jobData.jobUrl,
        sourcePlatform: sourcePlatform,
        isAiGenerated: true,
        applicationStatus: 'NOT_APPLIED',
        aiSearchId: searchId,
        salary: jobData.salary || {},
        jobType: jobData.jobType || 'FULL_TIME',
        
        // FIXED: Add proper analysis status to prevent infinite analysis loop
        analysisStatus: {
          status: 'completed',
          progress: 100,
          message: `Premium analysis complete! Found ${jobData.analysis?.keySkills?.length || 0} key skills via Claude web search.`,
          updatedAt: new Date(),
          completedAt: new Date(),
          canViewJob: true,
          skillsFound: jobData.analysis?.keySkills?.length || 0,
          experienceLevel: jobData.analysis?.experienceLevel,
          modelUsed: 'gpt-4o',
          analysisType: 'claude_web_search_discovery_premium',
          searchApproach: '3-phase-intelligent-claude-web-search',
          qualityLevel: 'premium'
        },
        
        // Enhanced parsed data (premium quality)
        parsedData: {
          requirements: jobData.analysis?.requirements || [],
          responsibilities: jobData.analysis?.responsibilities || [],
          qualifications: jobData.analysis?.qualifications || { required: [], preferred: [] },
          benefits: jobData.analysis?.benefits || jobData.benefits || [],
          keySkills: jobData.analysis?.keySkills || [],
          experienceLevel: jobData.analysis?.experienceLevel || jobData.experienceLevel || 'Mid',
          yearsOfExperience: jobData.analysis?.yearsOfExperience || { minimum: 3, preferred: 5 },
          educationRequirements: jobData.analysis?.educationRequirements || [],
          workArrangement: jobData.analysis?.workArrangement || jobData.workArrangement || 'unknown',
          industryContext: jobData.analysis?.industryContext || jobData.industry || 'technology',
          roleCategory: jobData.analysis?.roleCategory || 'general',
          technicalComplexity: jobData.analysis?.technicalComplexity || 'medium',
          leadershipRequired: jobData.analysis?.leadershipRequired || false,
          companyStage: jobData.analysis?.companyStage || jobData.companySize || 'unknown',
          extractedAt: new Date(),
          extractionMethod: 'claude_web_search_premium',
          // Enhanced Claude web search specific data
          claudeWebSearchData: {
            platform: jobData.sourcePlatform,
            originalUrl: jobData.jobUrl,
            postedDate: jobData.postedDate,
            matchReason: jobData.matchReason,
            techStack: jobData.techStack || [],
            department: jobData.department,
            directCompanyPosting: true,
            discoveryMethod: 'claude_web_search_api'
          },
          analysisMetadata: jobData.analysis?.analysisMetadata || {
            analyzedAt: new Date(),
            algorithmVersion: '3.2-claude-web-search-premium',
            model: 'gpt-4o',
            analysisType: 'claude_web_search_discovery_premium',
            qualityLevel: 'same_as_manual',
            discoveryPlatform: jobData.sourcePlatform
          }
        },
        
        // Enhanced AI search metadata for Claude web search
        aiSearchMetadata: {
          searchScore: jobData.matchScore || 85,
          discoveryMethod: 'claude_web_search_discovery',
          extractionSuccess: !jobData.analysisError,
          contentQuality: jobData.contentQuality || 'high',
          premiumAnalysis: jobData.premiumAnalysis || true,
          intelligentDiscovery: true,
          claudeWebSearchDiscovery: true,
          phase: '3-phase-intelligent-claude-web-search',
          originalPlatform: jobData.sourcePlatform,
          postedDate: jobData.postedDate,
          workArrangement: jobData.workArrangement,
          experienceLevel: jobData.experienceLevel,
          department: jobData.department,
          companySize: jobData.companySize,
          industry: jobData.industry,
          keyRequirements: jobData.keyRequirements || [],
          matchReason: jobData.matchReason,
          benefits: jobData.benefits || [],
          techStack: jobData.techStack || [],
          claudeWebSearchMetadata: {
            discoveryMethod: 'claude_web_search_api',
            extractionMethod: 'claude_web_content_extraction',
            searchQuery: jobData.searchQuery,
            foundAt: jobData.foundAt
          }
        }
      });
      
      await job.save();
      savedCount++;
      
      // Update search progress with Claude web search info
      await AiJobSearch.findByIdAndUpdate(searchId, {
        $inc: { jobsFoundToday: 1, totalJobsFound: 1 },
        $push: {
          jobsFound: {
            jobId: job._id,
            title: job.title,
            company: job.company,
            foundAt: new Date(),
            extractionMethod: 'claude_web_search_discovery',
            contentQuality: jobData.contentQuality,
            matchScore: jobData.matchScore,
            premiumAnalysis: true,
            sourcePlatform: jobData.sourcePlatform,
            directCompanyPosting: true
          }
        }
      });
      
      console.log(`âœ… Saved: ${job.title} at ${job.company} (${jobData.sourcePlatform} - Claude web search discovery)`);
      
    } catch (error) {
      console.error(`Error saving job ${jobData.title}:`, error);
    }
  }
  
  return savedCount;
}
/**
 * Enhanced Phase 3: Premium Job Analysis (unchanged but with Claude web search context)
 */
async function performPremiumJobAnalysis(discoveredJobs, search) {
  const analyzedJobs = [];
  
  console.log(`ðŸ”¬ Starting premium analysis of ${discoveredJobs.length} jobs from Claude web search with GPT-4o...`);
  
  // Process jobs in batches of 3 for efficiency
  const batchSize = 3;
  for (let i = 0; i < discoveredJobs.length; i += batchSize) {
    const batch = discoveredJobs.slice(i, i + batchSize);
    
    try {
      console.log(`  ðŸ“Š Analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(discoveredJobs.length/batchSize)}...`);
      
      await search.addReasoningLog(
        'premium_analysis',
        `Analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}: ${batch.map(job => `"${job.title}" at ${job.company} (${job.sourcePlatform})`).join(', ')}`,
        {
          batchNumber: Math.floor(i/batchSize) + 1,
          jobsInBatch: batch.length,
          model: 'gpt-4o',
          discoveryMethod: 'Claude web search API',
          sourcePlatforms: [...new Set(batch.map(job => job.sourcePlatform))]
        }
      );
      
      const batchResults = await analyzeBatchWithGPT4o(batch);
      
      // Process batch results
      for (let j = 0; j < batch.length; j++) {
        const job = batch[j];
        const analysis = batchResults[j];
        
        const hasGoodAnalysis = analysis && 
          (analysis.requirements?.length > 0 || analysis.responsibilities?.length > 0) &&
          analysis.keySkills?.length > 0;
        
        analyzedJobs.push({
          ...job,
          analysis: analysis,
          analysisError: !hasGoodAnalysis ? 'Analysis incomplete' : null,
          premiumAnalysis: true,
          analysisQuality: 'premium',
          claudeWebSearchDiscovery: true
        });
        
        await search.addReasoningLog(
          'content_extraction',
          `"${job.title}" at ${job.company} (${job.sourcePlatform}) - ${hasGoodAnalysis ? 'Premium analysis successful' : 'Analysis incomplete'}`,
          {
            jobTitle: job.title,
            companyName: job.company,
            discoveryPlatform: job.sourcePlatform,
            contentLength: job.fullContent?.length || 0,
            skillsFound: analysis?.keySkills?.length || 0,
            hasRequirements: !!(analysis?.requirements?.length > 0),
            hasResponsibilities: !!(analysis?.responsibilities?.length > 0),
            experienceLevel: analysis?.experienceLevel,
            model: 'gpt-4o',
            quality: 'premium',
            discoveryMethod: 'Claude web search'
          },
          hasGoodAnalysis
        );
      }
      
      // Small delay between batches to be respectful
      if (i + batchSize < discoveredJobs.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
    } catch (error) {
      console.error(`Error analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}:`, error);
      
      // Add failed jobs with error
      batch.forEach(job => {
        analyzedJobs.push({
          ...job,
          analysis: null,
          analysisError: error.message,
          premiumAnalysis: false,
          claudeWebSearchDiscovery: true
        });
      });
    }
  }
  
  return analyzedJobs;
}

/**
 * Batch analysis with GPT-4o specifically for Claude web search content
 */
async function analyzeBatchWithGPT4o(jobBatch) {
  try {
    // Prepare batch content for analysis with Claude web search context
    const batchContent = jobBatch.map((job, index) => 
      `JOB ${index + 1} (${job.sourcePlatform}):
Title: ${job.title}
Company: ${job.company}
Source: ${job.sourcePlatform} (Found via Claude Web Search)
Location: ${job.location || 'Not specified'}
Tech Stack: ${job.techStack ? job.techStack.join(', ') : 'Not specified'}
Match Reason: ${job.matchReason || 'Not specified'}
Content: ${job.fullContent.substring(0, 2000)}...
---`
    ).join('\n\n');
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert job analyst providing premium analysis for jobs discovered via Claude's web search API. These are real job postings found through intelligent web search, similar to how jobs are found in general chat. Analyze multiple job postings and return detailed structured data for each. Focus on extracting comprehensive requirements, responsibilities, and skills with high accuracy. Return valid JSON array.`
        },
        {
          role: "user",
          content: `Analyze these ${jobBatch.length} job postings discovered via Claude web search and return detailed analysis for each:

${batchContent}

These jobs were discovered using Claude's web search API (same method as general chat), so they should have high-quality, comprehensive content from real job postings.

Return JSON array with ${jobBatch.length} objects in this EXACT format:
[
  {
    "requirements": ["Specific requirement 1", "Specific requirement 2"],
    "responsibilities": ["Key responsibility 1", "Key responsibility 2"],
    "qualifications": {
      "required": ["Must-have qualification 1", "Must-have qualification 2"],
      "preferred": ["Nice-to-have qualification 1", "Nice-to-have qualification 2"]
    },
    "keySkills": [
      {
        "name": "Python",
        "importance": 9,
        "category": "technical",
        "skillType": "programming"
      },
      {
        "name": "Leadership",
        "importance": 7,
        "category": "soft",
        "skillType": "management"
      }
    ],
    "experienceLevel": "mid/senior/lead",
    "yearsOfExperience": {
      "minimum": 3,
      "preferred": 5
    },
    "educationRequirements": ["Bachelor's degree in relevant field"],
    "benefits": ["Health insurance", "401k", "Remote work"],
    "salary": {
      "min": 120000,
      "max": 150000,
      "currency": "USD"
    },
    "workArrangement": "remote/hybrid/onsite",
    "industryContext": "technology/finance/healthcare",
    "roleCategory": "software-engineering/product-management",
    "technicalComplexity": "high/medium/low",
    "leadershipRequired": true/false,
    "companyStage": "startup/growth/enterprise"
  }
]

IMPORTANT:
- Skills importance: 9-10=critical, 7-8=very important, 5-6=important, 3-4=nice to have
- Extract comprehensive information from each job posting discovered via Claude web search
- These are high-quality job postings so expect detailed content
- Maintain high accuracy and detail level
- Return exactly ${jobBatch.length} analysis objects`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    
    if (jsonMatch) {
      const analyses = JSON.parse(jsonMatch[0]);
      
      // Ensure we have the right number of analyses
      if (analyses.length === jobBatch.length) {
        return analyses.map((analysis, index) => ({
          ...analysis,
          analysisMetadata: {
            analyzedAt: new Date(),
            algorithmVersion: '3.2-claude-web-search-premium',
            model: 'gpt-4o',
            analysisType: 'claude_web_search_discovery_premium',
            qualityLevel: 'same_as_manual',
            discoveryPlatform: jobBatch[index].sourcePlatform,
            claudeWebSearchDiscovery: true
          }
        }));
      }
    }
    
    // Fallback: return individual analyses
    return jobBatch.map((job) => createFallbackSingleAnalysis(job.sourcePlatform));
    
  } catch (error) {
    console.error('Error in GPT-4o batch analysis for Claude web search jobs:', error);
    return jobBatch.map((job) => createFallbackSingleAnalysis(job.sourcePlatform));
  }
}

/**
 * Create fallback single analysis for Claude web search
 */
function createFallbackSingleAnalysis(sourcePlatform = 'Unknown') {
  return {
    requirements: ['Relevant experience in the field'],
    responsibilities: ['Perform assigned duties effectively'],
    qualifications: {
      required: ['Relevant education or experience'],
      preferred: ['Additional qualifications preferred']
    },
    keySkills: [
      {
        name: 'Communication',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      },
      {
        name: 'Problem Solving',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      }
    ],
    experienceLevel: 'mid',
    yearsOfExperience: { minimum: 3, preferred: 5 },
    educationRequirements: ['Bachelor\'s degree preferred'],
    benefits: ['Competitive benefits package'],
    workArrangement: 'unknown',
    industryContext: 'general',
    roleCategory: 'general',
    technicalComplexity: 'medium',
    leadershipRequired: false,
    companyStage: 'unknown',
    analysisMetadata: {
      analyzedAt: new Date(),
      algorithmVersion: '3.2-claude-web-search-fallback',
      model: 'gpt-4o-fallback',
      analysisType: 'claude_web_search_discovery_fallback',
      discoveryPlatform: sourcePlatform,
      claudeWebSearchDiscovery: true
    }
  };
}

/**
 * Enhanced career analysis for Claude web search targeting
 */
async function analyzeCareerTrajectoryEnhanced(resumeData) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert career strategist. Analyze resume data to create targeted job search criteria for AI job discovery using Claude's web search API. Focus on generating specific, searchable job titles and keywords that will find the best opportunities through web search. Return only valid JSON.`
        },
        {
          role: "user",
          content: `Analyze this career data and create targeted search criteria for Claude web search job discovery:

Experience: ${JSON.stringify(resumeData.experience?.slice(0, 3), null, 2)}
Skills: ${JSON.stringify(resumeData.skills?.slice(0, 15), null, 2)}
Education: ${JSON.stringify(resumeData.education?.slice(0, 2), null, 2)}

Create targeted search criteria in this EXACT JSON format for Claude web search:
{
  "targetJobTitles": [
    "Primary Target Title",
    "Alternative Title 1", 
    "Alternative Title 2",
    "Growth Opportunity Title"
  ],
  "targetKeywords": [
    "keyword1", "keyword2", "keyword3"
  ],
  "experienceLevel": "Mid/Senior/Lead",
  "industries": ["Industry 1", "Industry 2"],
  "preferredLocations": ["Remote", "Major City"],
  "salaryExpectation": {
    "min": 120000,
    "max": 180000,
    "currency": "USD"
  },
  "mustHaveSkills": ["Critical Skill 1", "Critical Skill 2"],
  "niceToHaveSkills": ["Bonus Skill 1", "Bonus Skill 2"],
  "avoidKeywords": ["keyword to avoid"],
  "workArrangement": "remote/hybrid/onsite",
  "careerDirection": "Brief description of career goals",
  "targetCompanyTypes": ["Startup", "Scale-up", "Enterprise"],
  "webSearchPreferences": {
    "focus": "Direct company postings and reputable job boards",
    "avoid": "Recruitment agencies and low-quality job aggregators",
    "prioritize": "Greenhouse, Lever, Indeed, LinkedIn, company career pages"
  }
}

Focus on:
1. Specific job titles that match experience level and are commonly searched
2. Keywords that companies actually use in job postings
3. Realistic salary expectations based on current market
4. Skills that are in high demand
5. Company types and job boards that typically have quality postings
6. Avoiding overqualified or underqualified positions`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    
    return createEnhancedFallbackCareerProfile(resumeData);
    
  } catch (error) {
    console.error('Error in enhanced career trajectory analysis:', error);
    return createEnhancedFallbackCareerProfile(resumeData);
  }
}

/**
 * Enhanced fallback career profile for Claude web search
 */
function createEnhancedFallbackCareerProfile(resumeData) {
  return {
    targetJobTitles: [
      resumeData.experience?.[0]?.title || 'Software Engineer',
      'Senior Software Engineer',
      'Software Developer',
      'Full Stack Developer'
    ],
    targetKeywords: [
      'software development',
      'programming',
      'engineering',
      'technology'
    ],
    experienceLevel: calculateExperienceLevel(resumeData.experience),
    industries: ['Technology', 'Software', 'SaaS'],
    preferredLocations: ['Remote', 'San Francisco', 'New York', 'Austin'],
    salaryExpectation: {
      min: 100000,
      max: 150000,
      currency: 'USD'
    },
    mustHaveSkills: resumeData.skills?.slice(0, 3).map(s => typeof s === 'string' ? s : s.name) || [],
    niceToHaveSkills: resumeData.skills?.slice(3, 6).map(s => typeof s === 'string' ? s : s.name) || [],
    workArrangement: 'remote',
    careerDirection: 'Software engineering role with growth opportunities',
    targetCompanyTypes: ['Startup', 'Scale-up', 'Enterprise'],
    webSearchPreferences: {
      focus: 'Direct company postings and reputable job boards',
      avoid: 'Recruitment agencies and low-quality job aggregators',
      prioritize: 'Greenhouse, Lever, Indeed, LinkedIn, company career pages'
    }
  };
}

function parseLocationEnhanced(locationString) {
  if (!locationString) return { remote: true };
  
  const lower = locationString.toLowerCase();
  const remote = lower.includes('remote') || lower.includes('anywhere');
  
  if (remote) {
    return {
      remote: true,
      city: lower.includes('remote') ? null : extractCity(locationString),
      country: 'USA'
    };
  }
  
  const parts = locationString.split(',').map(p => p.trim());
  return {
    city: parts[0] || null,
    state: parts[1] || null,
    country: parts[2] || 'USA',
    remote: false
  };
}

function extractCity(locationString) {
  const parts = locationString.split(',').map(p => p.trim());
  return parts.find(part => !part.toLowerCase().includes('remote')) || null;
}

// Keep all existing utility functions
function extractSearchCriteria(resumeData) {
  return {
    jobTitle: resumeData.experience?.[0]?.title || 'Software Engineer',
    skills: resumeData.skills?.slice(0, 10).map(s => typeof s === 'string' ? s : s.name) || [],
    location: resumeData.contactInfo?.location || 'Remote',
    experienceLevel: calculateExperienceLevel(resumeData.experience)
  };
}

function calculateExperienceLevel(experiences) {
  const years = calculateYearsOfExperience(experiences);
  if (years < 2) return 'Entry';
  if (years < 5) return 'Mid';
  if (years < 10) return 'Senior';
  return 'Lead';
}

function calculateYearsOfExperience(experiences) {
  if (!experiences?.length) return 0;
  
  const sorted = experiences
    .filter(exp => exp.startDate)
    .sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
  
  if (!sorted.length) return 0;
  
  const first = new Date(sorted[0].startDate);
  const last = sorted[sorted.length - 1].endDate 
    ? new Date(sorted[sorted.length - 1].endDate)
    : new Date();
  
  return Math.round((last - first) / (1000 * 60 * 60 * 24 * 365));
}

async function isDailyLimitReached(search) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  if (!search.lastSearchDate || search.lastSearchDate < today) {
    search.jobsFoundToday = 0;
    search.lastSearchDate = today;
    await search.save();
    return false;
  }
  
  return search.jobsFoundToday >= search.dailyLimit;
}

async function updateSearchStatus(searchId, status, message) {
  await AiJobSearch.findByIdAndUpdate(searchId, {
    status,
    lastUpdateMessage: message,
    lastUpdated: new Date()
  });
  console.log(`Search ${searchId}: ${status} - ${message}`);
}

// Export existing functions for compatibility
exports.getUserAiSearches = async (userId) => {
  return await AiJobSearch.find({ userId }).sort({ createdAt: -1 });
};

exports.pauseAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Claude web search paused by user request',
    { phase: 'user_pause', pausedAt: new Date() }
  );
  
  search.status = 'paused';
  search.lastUpdateMessage = 'Paused by user';
  await search.save();
  
  return { message: 'Claude web search paused successfully' };
};

exports.resumeAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'initialization',
    'Claude web search resumed by user - continuing with ENHANCED 3-Phase approach using Claude web search API',
    { 
      phase: 'user_resume', 
      resumedAt: new Date(),
      searchMethod: 'Claude web search API (same as general chat)'
    }
  );
  
  search.status = 'running';
  search.lastUpdateMessage = 'Resumed by user - Claude web search';
  await search.save();
  
  const resume = await Resume.findById(search.resumeId);
  if (resume) {
    performEnhancedJobSearch(searchId, userId, resume).catch(error => {
      console.error('Error resuming Claude web search:', error);
    });
  }
  
  return { message: 'Claude web search resumed successfully with enhanced approach' };
};

exports.deleteAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Claude web search cancelled by user request',
    { 
      phase: 'user_cancellation', 
      cancelledAt: new Date(),
      searchMethod: 'Claude web search API'
    }
  );
  
  search.status = 'cancelled';
  search.lastUpdateMessage = 'Cancelled by user';
  await search.save();
  
  return { message: 'Claude web search cancelled successfully' };
};

================
File: services/memoryService.js
================
// backend/services/memoryService.js
const { openai } = require('../config/openai');
const UserMemory = require('../models/mongodb/userMemory.model');
const Conversation = require('../models/mongodb/conversation.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');

class MemoryService {
  /**
   * Extract memories from a conversation message using AI
   */
  static async extractMemoriesFromMessage(userId, message, conversationContext = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId) || 
                        await UserMemory.createForUser(userId);

      // Get existing memories for context
      const existingMemories = userMemory.getRelevantMemories({
        types: ['preference', 'skill', 'career_goal', 'personality_trait'],
        tags: conversationContext.tags || []
      }, 5);

      const systemPrompt = this.buildMemoryExtractionPrompt(existingMemories, conversationContext);
      
      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: message }
        ],
        temperature: 0.3,
        max_tokens: 800,
        response_format: { type: 'json_object' }
      });

      const extractedData = JSON.parse(response.choices[0].message.content);
      const memories = [];

      // Process extracted memories
      if (extractedData.memories && extractedData.memories.length > 0) {
        for (const memoryData of extractedData.memories) {
          const memory = await this.addMemoryToUser(userId, {
            ...memoryData,
            source: {
              conversationId: conversationContext.conversationId,
              messageId: conversationContext.messageId,
              extractionMethod: 'ai_extracted',
              model: 'gpt-4-turbo-preview'
            },
            context: conversationContext
          });
          memories.push(memory);
        }
      }

      return {
        memories,
        insights: extractedData.insights || [],
        profileUpdates: extractedData.profileUpdates || {}
      };

    } catch (error) {
      console.error('Memory extraction error:', error);
      return { memories: [], insights: [], profileUpdates: {} };
    }
  }

  /**
   * Add a memory to user's memory system
   */
  static async addMemoryToUser(userId, memoryData) {
    try {
      let userMemory = await UserMemory.findByUserId(userId);
      
      if (!userMemory) {
        userMemory = await UserMemory.createForUser(userId);
      }

      const memory = userMemory.addMemory(memoryData);
      await userMemory.save();

      return memory;

    } catch (error) {
      console.error('Add memory error:', error);
      throw error;
    }
  }

  /**
   * Get relevant memories for AI context
   */
  static async getRelevantMemoriesForContext(userId, context) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return [];

      const relevantMemories = userMemory.getRelevantMemories(context, 15);
      
      // Update access count for retrieved memories
      relevantMemories.forEach(memory => {
        memory.usage.accessCount += 1;
        memory.usage.lastAccessedAt = new Date();
      });

      await userMemory.save();

      return relevantMemories;

    } catch (error) {
      console.error('Get relevant memories error:', error);
      return [];
    }
  }

  /**
   * Build context for AI assistant using memories
   */
  static async buildAIContext(userId, currentContext = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return '';

      // Get different types of relevant memories
      const personalityMemories = userMemory.getMemoriesByType('personality_trait', { 
        minConfidence: 0.6, 
        sortBy: 'confidence' 
      }).slice(0, 3);

      const preferenceMemories = userMemory.getMemoriesByType('preference', { 
        minConfidence: 0.6, 
        sortBy: 'recent' 
      }).slice(0, 5);

      const skillMemories = userMemory.getMemoriesByType('skill', { 
        minConfidence: 0.7, 
        sortBy: 'confidence' 
      }).slice(0, 5);

      const goalMemories = userMemory.getMemoriesByType('career_goal', { 
        minConfidence: 0.6, 
        sortBy: 'recent' 
      }).slice(0, 3);

      // Build context string
      let context = '\n=== USER MEMORY CONTEXT ===\n';

      if (personalityMemories.length > 0) {
        context += '\nPersonality & Communication Style:\n';
        personalityMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (preferenceMemories.length > 0) {
        context += '\nPreferences & Work Style:\n';
        preferenceMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (skillMemories.length > 0) {
        context += '\nSkills & Experience:\n';
        skillMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (goalMemories.length > 0) {
        context += '\nCareer Goals & Aspirations:\n';
        goalMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      // Add profile insights
      if (userMemory.profile && Object.keys(userMemory.profile).length > 0) {
        context += '\nUser Profile Insights:\n';
        
        if (userMemory.profile.careerStage) {
          context += `- Career Stage: ${userMemory.profile.careerStage}\n`;
        }
        
        if (userMemory.profile.communicationStyle) {
          const style = userMemory.profile.communicationStyle;
          context += `- Communication Preference: ${style.formality || 'neutral'} formality, ${style.detail_preference || 'moderate'} detail level\n`;
        }
      }

      context += '\n=== END MEMORY CONTEXT ===\n\n';
      context += 'IMPORTANT: Use this memory context to personalize your responses, but don\'t explicitly mention that you\'re using memory unless directly asked about it.\n';

      return context;

    } catch (error) {
      console.error('Build AI context error:', error);
      return '';
    }
  }

  /**
   * Update user profile based on conversation patterns
   */
  static async updateUserProfile(userId, conversationData) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return;

      // Analyze conversation patterns
      const analysis = await this.analyzeConversationPatterns(conversationData);
      
      // Update profile based on analysis
      if (analysis.communicationStyle) {
        userMemory.profile.communicationStyle = {
          ...userMemory.profile.communicationStyle,
          ...analysis.communicationStyle
        };
      }

      if (analysis.skills && analysis.skills.length > 0) {
        userMemory.profile.skills = userMemory.profile.skills || [];
        analysis.skills.forEach(skill => {
          const existingSkill = userMemory.profile.skills.find(s => s.name === skill.name);
          if (existingSkill) {
            existingSkill.confidence = Math.max(existingSkill.confidence, skill.confidence);
            existingSkill.lastMentioned = new Date();
          } else {
            userMemory.profile.skills.push({
              ...skill,
              lastMentioned: new Date()
            });
          }
        });
      }

      await userMemory.save();

    } catch (error) {
      console.error('Update user profile error:', error);
    }
  }

  /**
   * Generate conversation summary with memory extraction
   */
  static async generateConversationSummary(conversationId) {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) throw new Error('Conversation not found');

      const messages = conversation.messages.slice(-20); // Last 20 messages
      const messageText = messages.map(m => `${m.type.toUpperCase()}: ${m.content}`).join('\n');

      const systemPrompt = `You are an AI assistant that creates intelligent conversation summaries with memory extraction.

Analyze this conversation and provide:
1. A concise summary of what was discussed
2. Key topics covered
3. Action items or outcomes
4. Important memories that should be retained about the user
5. User preferences or patterns observed

Format your response as JSON:
{
  "summary": "Brief summary of the conversation",
  "keyTopics": ["topic1", "topic2", "topic3"],
  "actionItems": ["action1", "action2"],
  "outcomes": ["outcome1", "outcome2"],
  "memories": [
    {
      "type": "preference|skill|career_goal|personality_trait|etc",
      "category": "personal|professional|technical|behavioral|contextual",
      "content": "What you learned about the user",
      "confidence": 0.8,
      "importance": "low|medium|high|critical",
      "tags": ["tag1", "tag2"]
    }
  ],
  "insights": ["insight1", "insight2"]
}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: messageText }
        ],
        temperature: 0.3,
        max_tokens: 1000,
        response_format: { type: 'json_object' }
      });

      const summaryData = JSON.parse(response.choices[0].message.content);

      // Update conversation with summary
      conversation.updateSummary({
        content: summaryData.summary,
        keyTopics: summaryData.keyTopics || [],
        actionItems: summaryData.actionItems || [],
        outcomes: summaryData.outcomes || []
      });

      await conversation.save();

      // Extract and store memories
      if (summaryData.memories && summaryData.memories.length > 0) {
        for (const memoryData of summaryData.memories) {
          await this.addMemoryToUser(conversation.userId, {
            ...memoryData,
            source: {
              conversationId: conversationId,
              extractionMethod: 'summary_extracted',
              model: 'gpt-4-turbo-preview'
            }
          });
        }
      }

      return summaryData;

    } catch (error) {
      console.error('Generate conversation summary error:', error);
      throw error;
    }
  }

  /**
   * Search memories with intelligent ranking
   */
  static async searchMemories(userId, query, options = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return [];

      // First, do a basic text search
      let memories = userMemory.searchMemories(query, options);

      // If we have few results, use AI for semantic search
      if (memories.length < 5) {
        const semanticMemories = await this.semanticMemorySearch(userMemory, query);
        memories = [...memories, ...semanticMemories];
        
        // Remove duplicates
        memories = memories.filter((memory, index, self) => 
          index === self.findIndex(m => m.id === memory.id)
        );
      }

      // Rank memories by relevance
      return memories.sort((a, b) => {
        const aScore = this.calculateSearchRelevance(a, query);
        const bScore = this.calculateSearchRelevance(b, query);
        return bScore - aScore;
      });

    } catch (error) {
      console.error('Search memories error:', error);
      return [];
    }
  }

  /**
   * Perform memory cleanup and optimization
   */
  static async performMemoryMaintenance(userId) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return;

      // Decay old memories
      const decayedCount = userMemory.decayMemories();

      // Merge similar memories
      const mergedCount = await this.mergeSimilarMemories(userMemory);

      // Update profile
      userMemory.updateProfile();

      await userMemory.save();

      return {
        decayedMemories: decayedCount,
        mergedMemories: mergedCount,
        totalMemories: userMemory.analytics.totalMemories
      };

    } catch (error) {
      console.error('Memory maintenance error:', error);
      return null;
    }
  }

  // ===================================================================
  // PRIVATE HELPER METHODS
  // ===================================================================

  /**
   * Build system prompt for memory extraction
   */
  static buildMemoryExtractionPrompt(existingMemories, context) {
    let prompt = `You are an AI memory extraction system. Analyze user messages to extract meaningful memories about their preferences, skills, goals, personality, and work style.

EXISTING MEMORIES (to avoid duplicates):
${existingMemories.map(m => `- ${m.type}: ${m.content}`).join('\n')}

CONTEXT:
- Page: ${context.page || 'unknown'}
- Category: ${context.category || 'general'}

Extract memories in this JSON format:
{
  "memories": [
    {
      "type": "preference|skill|career_goal|experience|achievement|challenge|personality_trait|communication_style|work_style|industry_knowledge|tool_preference|feedback_pattern",
      "category": "personal|professional|technical|behavioral|contextual",
      "content": "Clear, specific statement about the user",
      "confidence": 0.1-1.0,
      "importance": "low|medium|high|critical",
      "tags": ["relevant", "tags"]
    }
  ],
  "insights": ["Observable patterns or insights about the user"],
  "profileUpdates": {
    "communicationStyle": {
      "formality": "very_formal|formal|neutral|casual|very_casual",
      "detail_preference": "brief|moderate|detailed|comprehensive"
    }
  }
}

Only extract memories that are:
1. Specific and actionable
2. Likely to be useful for future conversations
3. Not duplicating existing memories
4. Expressed with reasonable confidence

IMPORTANT: Only extract memories if the user message contains clear, specific information. Don't infer too much from brief responses.`;

    return prompt;
  }

  /**
   * Analyze conversation patterns
   */
  static async analyzeConversationPatterns(conversationData) {
    try {
      // Simple pattern analysis - can be enhanced with ML
      const analysis = {
        communicationStyle: {},
        skills: [],
        preferences: []
      };

      // Analyze message length patterns
      const avgMessageLength = conversationData.userMessages?.reduce((sum, msg) => 
        sum + msg.content.length, 0) / (conversationData.userMessages?.length || 1);

      if (avgMessageLength < 50) {
        analysis.communicationStyle.detail_preference = 'brief';
      } else if (avgMessageLength > 200) {
        analysis.communicationStyle.detail_preference = 'detailed';
      } else {
        analysis.communicationStyle.detail_preference = 'moderate';
      }

      // Analyze formality
      const formalWords = ['please', 'thank you', 'would you', 'could you'];
      const casualWords = ['hey', 'thanks', 'cool', 'awesome'];
      
      let formalCount = 0;
      let casualCount = 0;

      conversationData.userMessages?.forEach(msg => {
        const content = msg.content.toLowerCase();
        formalWords.forEach(word => {
          if (content.includes(word)) formalCount++;
        });
        casualWords.forEach(word => {
          if (content.includes(word)) casualCount++;
        });
      });

      if (formalCount > casualCount) {
        analysis.communicationStyle.formality = 'formal';
      } else if (casualCount > formalCount) {
        analysis.communicationStyle.formality = 'casual';
      } else {
        analysis.communicationStyle.formality = 'neutral';
      }

      return analysis;

    } catch (error) {
      console.error('Analyze conversation patterns error:', error);
      return {};
    }
  }

/**
 * Semantic memory search using AI - FIXED VERSION
 */
static async semanticMemorySearch(userMemory, query) {
  try {
    const allMemories = userMemory.memories.filter(m => m.isActive);
    if (allMemories.length === 0) {
      return [];
    }

    const memoryContents = allMemories.map(m => `${m.id}: ${m.content}`).join('\n');

    const systemPrompt = `Find memories that are semantically related to the user's query, even if they don't contain exact keywords.

MEMORIES:
${memoryContents}

USER QUERY: ${query}

Return ONLY a JSON array of memory IDs that are relevant: ["memory_id_1", "memory_id_2"]
If no memories are relevant, return an empty array: []`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: query }
      ],
      temperature: 0.3,
      max_tokens: 200,
      response_format: { type: 'json_object' }
    });

    console.log('ðŸ” Semantic search response:', response.choices[0].message.content);

    // FIXED: Proper JSON parsing and validation
    let parsedResponse;
    try {
      parsedResponse = JSON.parse(response.choices[0].message.content);
    } catch (parseError) {
      console.warn('Failed to parse semantic search response:', parseError);
      return [];
    }

    // FIXED: Handle different response formats
    let relevantIds = [];
    if (Array.isArray(parsedResponse)) {
      relevantIds = parsedResponse;
    } else if (parsedResponse.ids && Array.isArray(parsedResponse.ids)) {
      relevantIds = parsedResponse.ids;
    } else if (parsedResponse.results && Array.isArray(parsedResponse.results)) {
      relevantIds = parsedResponse.results;
    } else if (parsedResponse.relevant_memories && Array.isArray(parsedResponse.relevant_memories)) {
      // FIXED: Handle the actual response format the AI is using
      relevantIds = parsedResponse.relevant_memories;
    } else {
      console.warn('Unexpected semantic search response format:', parsedResponse);
      return [];
    }

    // FIXED: Ensure relevantIds is an array before using includes
    if (!Array.isArray(relevantIds)) {
      console.warn('relevantIds is not an array:', relevantIds);
      return [];
    }

    console.log('âœ… Found relevant memory IDs:', relevantIds);
    const foundMemories = allMemories.filter(m => relevantIds.includes(m.id));
    console.log('âœ… Returning', foundMemories.length, 'relevant memories');
    
    return foundMemories;

  } catch (error) {
    console.error('Semantic memory search error:', error);
    return [];
  }
}

  /**
   * Calculate search relevance score
   */
  static calculateSearchRelevance(memory, query) {
    const queryLower = query.toLowerCase();
    const contentLower = memory.content.toLowerCase();
    
    let score = memory.confidence;

    // Exact phrase match
    if (contentLower.includes(queryLower)) {
      score += 0.5;
    }

    // Word matches
    const queryWords = queryLower.split(' ');
    const contentWords = contentLower.split(' ');
    const matchedWords = queryWords.filter(word => contentWords.includes(word));
    score += (matchedWords.length / queryWords.length) * 0.3;

    // Tag matches
    const tagMatches = memory.tags.filter(tag => 
      tag.includes(queryLower) || queryLower.includes(tag)
    );
    score += tagMatches.length * 0.2;

    // Importance boost
    const importanceBoost = {
      'critical': 0.3,
      'high': 0.2,
      'medium': 0.1,
      'low': 0
    };
    score += importanceBoost[memory.importance] || 0;

    return Math.min(score, 1);
  }

  /**
   * Merge similar memories to reduce redundancy
   */
  static async mergeSimilarMemories(userMemory) {
    let mergedCount = 0;
    const memoriesToRemove = [];

    for (let i = 0; i < userMemory.memories.length; i++) {
      for (let j = i + 1; j < userMemory.memories.length; j++) {
        const memory1 = userMemory.memories[i];
        const memory2 = userMemory.memories[j];

        if (memory1.type === memory2.type && 
            memory1.category === memory2.category &&
            userMemory.calculateSimilarity(memory1.content, memory2.content) > 0.85) {
          
          // Merge the memories
          const strongerMemory = memory1.confidence >= memory2.confidence ? memory1 : memory2;
          const weakerMemory = memory1.confidence < memory2.confidence ? memory1 : memory2;

          strongerMemory.confidence = Math.min(1, strongerMemory.confidence + 0.1);
          strongerMemory.decay.reinforcementCount += weakerMemory.decay.reinforcementCount;
          strongerMemory.tags = [...new Set([...strongerMemory.tags, ...weakerMemory.tags])];

          memoriesToRemove.push(weakerMemory.id);
          mergedCount++;
        }
      }
    }

    // Remove merged memories
    userMemory.memories = userMemory.memories.filter(m => !memoriesToRemove.includes(m.id));

    return mergedCount;
  }
}

module.exports = MemoryService;

================
File: services/realJobBoard.service.js
================
// services/realJobBoard.service.js - REAL JOB BOARD INTEGRATION UTILITIES
const { anthropic } = require('../config/anthropic');

/**
 * Real Job Board Integration Service
 * Handles validation, URL extraction, and platform-specific logic
 * for Greenhouse, Lever, and Indeed integrations
 */

/**
 * Validate if a URL is from a supported real job board
 */
exports.validateJobBoardUrl = (url, expectedPlatform = null) => {
  if (!url || typeof url !== 'string') return false;
  
  const lowerUrl = url.toLowerCase();
  const validPlatforms = {
    greenhouse: [
      'greenhouse.io/jobs',
      'greenhouse.io/job',
      'boards.greenhouse.io'
    ],
    lever: [
      'jobs.lever.co',
      'lever.co/jobs'
    ],
    indeed: [
      'indeed.com/viewjob',
      'indeed.com/jobs',
      'indeed.com/job'
    ]
  };
  
  if (expectedPlatform) {
    const patterns = validPlatforms[expectedPlatform.toLowerCase()];
    return patterns ? patterns.some(pattern => lowerUrl.includes(pattern)) : false;
  }
  
  // Check all platforms
  return Object.values(validPlatforms).flat().some(pattern => lowerUrl.includes(pattern));
};

/**
 * Extract job board platform from URL
 */
exports.extractJobBoardPlatform = (url) => {
  if (!url) return null;
  
  const lowerUrl = url.toLowerCase();
  
  if (lowerUrl.includes('greenhouse.io')) return 'Greenhouse';
  if (lowerUrl.includes('lever.co')) return 'Lever';
  if (lowerUrl.includes('indeed.com')) return 'Indeed';
  
  return null;
};

/**
 * Extract platform-specific job identifiers
 */
exports.extractJobIdentifiers = (url, platform) => {
  if (!url || !platform) return {};
  
  const lowerUrl = url.toLowerCase();
  const identifiers = {};
  
  try {
    switch (platform.toLowerCase()) {
      case 'greenhouse':
        // Extract Greenhouse job ID
        const greenhouseMatch = url.match(/\/jobs\/(\d+)/i);
        if (greenhouseMatch) {
          identifiers.greenhouseJobId = greenhouseMatch[1];
        }
        
        // Extract office ID if present
        const officeMatch = url.match(/office_id=(\d+)/i);
        if (officeMatch) {
          identifiers.greenhouseOfficeId = officeMatch[1];
        }
        break;
        
      case 'lever':
        // Extract Lever posting ID
        const leverMatch = url.match(/jobs\.lever\.co\/([^\/]+)\/([^\/\?]+)/i);
        if (leverMatch) {
          identifiers.leverCompany = leverMatch[1];
          identifiers.leverPostingId = leverMatch[2];
        }
        break;
        
      case 'indeed':
        // Extract Indeed job key
        const indeedMatch = url.match(/jk=([^&]+)/i);
        if (indeedMatch) {
          identifiers.indeedJobKey = indeedMatch[1];
        }
        
        // Extract company ID if present
        const companyMatch = url.match(/cmp=([^&]+)/i);
        if (companyMatch) {
          identifiers.indeedCompanyId = companyMatch[1];
        }
        break;
    }
  } catch (error) {
    console.error('Error extracting job identifiers:', error);
  }
  
  return identifiers;
};

/**
 * Generate platform-specific search queries for Claude
 */
exports.generatePlatformSearchQueries = (careerProfile) => {
  const { targetJobTitles, targetKeywords, preferredLocations, experienceLevel } = careerProfile;
  
  const baseQueries = targetJobTitles.map(title => ({
    jobTitle: title,
    keywords: targetKeywords.slice(0, 5),
    locations: preferredLocations.slice(0, 3),
    experienceLevel
  }));
  
  return {
    greenhouse: baseQueries.map(query => ({
      ...query,
      platform: 'Greenhouse',
      searchContext: 'Tech startups and scale-ups with comprehensive job details',
      urlPattern: 'company.greenhouse.io/jobs',
      focusAreas: ['startups', 'tech companies', 'scale-ups', 'venture-backed companies']
    })),
    
    lever: baseQueries.map(query => ({
      ...query,
      platform: 'Lever',
      searchContext: 'Growth-stage companies with detailed role information',
      urlPattern: 'jobs.lever.co/company',
      focusAreas: ['growth companies', 'series A-C companies', 'expanding teams']
    })),
    
    indeed: baseQueries.map(query => ({
      ...query,
      platform: 'Indeed',
      searchContext: 'Established companies with verified direct postings',
      urlPattern: 'indeed.com/viewjob',
      focusAreas: ['established companies', 'direct postings', 'verified employers']
    }))
  };
};

/**
 * Enhanced Claude prompt for real job board discovery
 */
exports.createRealJobBoardSearchPrompt = (careerProfile) => {
  const searchQueries = this.generatePlatformSearchQueries(careerProfile);
  
  return `You are an expert job hunter with access to web search. Find 8-12 high-quality job opportunities from REAL company job boards.

TARGET PROFILE:
- Job Titles: ${careerProfile.targetJobTitles?.join(', ')}
- Keywords: ${careerProfile.targetKeywords?.join(', ')}
- Experience Level: ${careerProfile.experienceLevel}
- Industries: ${careerProfile.industries?.join(', ')}
- Locations: ${careerProfile.preferredLocations?.join(', ')}
- Salary Range: $${careerProfile.salaryExpectation?.min || 100000}-${careerProfile.salaryExpectation?.max || 150000}

SEARCH STRATEGY - TARGET THESE SPECIFIC PLATFORMS:

ðŸŒ± **GREENHOUSE JOBS** (Priority: Tech Startups & Scale-ups)
- Search for: [company].greenhouse.io/jobs URLs
- Target: VC-backed startups, tech scale-ups, innovative companies
- Look for: Comprehensive job descriptions, team info, tech stacks
- Focus companies: Well-funded startups, Series A-C companies

âš¡ **LEVER JOBS** (Priority: Growth Companies)  
- Search for: jobs.lever.co/[company] URLs
- Target: Fast-growing companies, expanding teams
- Look for: Detailed role descriptions, hiring manager info
- Focus companies: Scale-ups, growth-stage companies

ðŸ” **INDEED** (Priority: Direct Company Postings ONLY)
- Search for: indeed.com/viewjob URLs from direct company postings
- Target: Established companies posting directly (NOT recruiters)
- Avoid: Staffing agencies, third-party recruiters
- Focus: Verified company accounts, direct employer postings

SEARCH PROCESS:
1. **Search each platform systematically** for the target job titles
2. **Verify URL authenticity** - ensure URLs match the expected patterns
3. **Extract comprehensive job content** from actual job posting pages
4. **Prioritize quality over quantity** - focus on complete, detailed postings
5. **Validate company legitimacy** - check for real companies with good reputations

CONTENT REQUIREMENTS:
- Each job MUST have substantial content (minimum 400 words)
- Include tech stack, team information when available
- Extract salary information if posted
- Capture application deadlines and hiring manager details
- Verify the job posting is recent (within 30 days)

Return JSON array with 8-12 verified jobs:
[
  {
    "title": "Senior Software Engineer",
    "company": "TechStartup Inc",
    "location": "San Francisco, CA (Remote OK)",
    "salary": {
      "min": 140000,
      "max": 190000,
      "currency": "USD"
    },
    "jobUrl": "https://techstartup.greenhouse.io/jobs/4567890",
    "sourcePlatform": "Greenhouse",
    "fullContent": "Complete job description extracted from the actual Greenhouse posting page...",
    "postedDate": "2024-01-15",
    "workArrangement": "hybrid",
    "experienceLevel": "Senior",
    "department": "Engineering",
    "techStack": ["Python", "React", "PostgreSQL", "AWS", "Docker"],
    "hiringManager": "Jane Smith, Engineering Manager",
    "teamSize": "12-person engineering team",
    "benefits": ["Equity", "Health insurance", "Unlimited PTO"],
    "applicationDeadline": "2024-02-15",
    "companySize": "Series B (50-100 employees)",
    "industry": "SaaS",
    "matchReason": "Perfect match for Python/React experience and senior level"
  }
]

CRITICAL VALIDATION:
- âœ… URL must match platform patterns exactly
- âœ… Content must be from actual job posting page
- âœ… Company must be legitimate (verify with web search if needed)
- âœ… Job must be recent and active
- âœ… Extract comprehensive details including tech stack
- âœ… Prioritize direct company postings over recruiter posts

PLATFORM-SPECIFIC NOTES:
- **Greenhouse**: Look for detailed engineering roles with team/culture info
- **Lever**: Focus on growth companies with clear role progression
- **Indeed**: ONLY direct company postings, avoid staffing agencies

Quality over quantity - return fewer jobs if needed to ensure all are high-quality, verified company postings.`;
};

/**
 * Assess job content quality from real job boards
 */
exports.assessRealJobBoardContentQuality = (jobData) => {
  if (!jobData || !jobData.fullContent) return { quality: 'low', score: 0, issues: ['No content'] };
  
  const content = jobData.fullContent;
  const issues = [];
  let score = 0;
  
  // Length assessment
  if (content.length < 200) {
    issues.push('Content too short');
  } else if (content.length >= 400) {
    score += 25;
  } else if (content.length >= 200) {
    score += 15;
  }
  
  // Section completeness
  const hasRequirements = /requirements?|qualifications?|must have/i.test(content);
  const hasResponsibilities = /responsibilit|duties|role|what you.ll do/i.test(content);
  const hasBenefits = /benefits?|perks|compensation|offer/i.test(content);
  const hasTechStack = /technologies?|tools|stack|languages?|frameworks?/i.test(content);
  const hasTeamInfo = /team|manager|reports|colleagues|hiring manager/i.test(content);
  const hasCompanyInfo = /company|about us|our mission|culture/i.test(content);
  
  if (hasRequirements) score += 15;
  else issues.push('Missing requirements section');
  
  if (hasResponsibilities) score += 15;
  else issues.push('Missing responsibilities section');
  
  if (hasBenefits) score += 10;
  if (hasTechStack) score += 15;
  if (hasTeamInfo) score += 10;
  if (hasCompanyInfo) score += 10;
  
  // Platform-specific bonuses
  if (jobData.sourcePlatform === 'Greenhouse' && (hasTechStack && hasTeamInfo)) {
    score += 5; // Greenhouse typically has good tech details
  }
  
  if (jobData.sourcePlatform === 'Lever' && hasTeamInfo) {
    score += 5; // Lever often includes good team context
  }
  
  // URL validation bonus
  if (this.validateJobBoardUrl(jobData.jobUrl, jobData.sourcePlatform)) {
    score += 5;
  } else {
    issues.push('Invalid URL for platform');
  }
  
  // Recent posting bonus
  if (jobData.postedDate) {
    const postDate = new Date(jobData.postedDate);
    const now = new Date();
    const daysDiff = (now - postDate) / (1000 * 60 * 60 * 24);
    
    if (daysDiff <= 7) score += 10;
    else if (daysDiff <= 30) score += 5;
    else issues.push('Job posting is old');
  }
  
  // Determine quality level
  let quality = 'low';
  if (score >= 85) quality = 'high';
  else if (score >= 60) quality = 'medium';
  
  return {
    quality,
    score: Math.min(score, 100),
    issues,
    strengths: [
      hasRequirements && 'Clear requirements',
      hasResponsibilities && 'Detailed responsibilities', 
      hasTechStack && 'Tech stack included',
      hasTeamInfo && 'Team information',
      hasBenefits && 'Benefits listed',
      hasCompanyInfo && 'Company details'
    ].filter(Boolean)
  };
};

/**
 * Extract enhanced metadata from real job board postings
 */
exports.extractJobBoardMetadata = (jobData) => {
  const metadata = {
    platform: jobData.sourcePlatform,
    urlValidated: this.validateJobBoardUrl(jobData.jobUrl, jobData.sourcePlatform),
    contentLength: jobData.fullContent?.length || 0,
    hasComprehensiveDetails: false,
    hasTechStack: false,
    hasTeamInfo: false,
    hasApplicationDeadline: !!jobData.applicationDeadline,
    verifiedCompanyPosting: true, // Assume verified if from target platforms
    extractedAt: new Date()
  };
  
  if (jobData.fullContent) {
    const content = jobData.fullContent.toLowerCase();
    
    // Check for comprehensive details
    const hasMultipleSections = [
      /requirements?|qualifications?/,
      /responsibilit|duties/,
      /benefits?|perks/,
      /about|company|culture/
    ].filter(regex => regex.test(content)).length >= 3;
    
    metadata.hasComprehensiveDetails = hasMultipleSections;
    metadata.hasTechStack = /tech|stack|languages?|frameworks?|tools/i.test(content);
    metadata.hasTeamInfo = /team|manager|reports|colleagues/i.test(content);
  }
  
  // Platform-specific metadata
  const platformIdentifiers = this.extractJobIdentifiers(jobData.jobUrl, jobData.sourcePlatform);
  
  return {
    ...metadata,
    platformIdentifiers,
    qualityAssessment: this.assessRealJobBoardContentQuality(jobData)
  };
};

/**
 * Generate job board specific search parameters
 */
exports.generateJobBoardSearchParams = (careerProfile, platform) => {
  const baseParams = {
    jobTitles: careerProfile.targetJobTitles?.slice(0, 3) || [],
    keywords: careerProfile.targetKeywords?.slice(0, 5) || [],
    locations: careerProfile.preferredLocations?.slice(0, 2) || ['Remote'],
    experienceLevel: careerProfile.experienceLevel || 'Mid'
  };
  
  switch (platform.toLowerCase()) {
    case 'greenhouse':
      return {
        ...baseParams,
        platformFocus: 'tech startups and scale-ups',
        companyTypes: ['startup', 'scale-up', 'venture-backed'],
        searchModifiers: ['site:greenhouse.io', 'inurl:jobs'],
        expectedFeatures: ['comprehensive job descriptions', 'team culture info', 'tech stack details']
      };
      
    case 'lever':
      return {
        ...baseParams,
        platformFocus: 'growth-stage companies',
        companyTypes: ['growth-stage', 'expanding teams', 'series A-C'],
        searchModifiers: ['site:lever.co', 'inurl:jobs'],
        expectedFeatures: ['detailed role descriptions', 'career progression', 'team structure']
      };
      
    case 'indeed':
      return {
        ...baseParams,
        platformFocus: 'established companies with direct postings',
        companyTypes: ['established', 'direct employer', 'verified company'],
        searchModifiers: ['site:indeed.com', 'inurl:viewjob', '-recruiter', '-staffing'],
        expectedFeatures: ['direct company posting', 'verified employer', 'complete job details']
      };
      
    default:
      return baseParams;
  }
};

/**
 * Validate job posting freshness
 */
exports.validateJobFreshness = (postedDate, maxDaysOld = 30) => {
  if (!postedDate) return { isValid: false, reason: 'No posted date' };
  
  const postDate = new Date(postedDate);
  const now = new Date();
  const daysDiff = (now - postDate) / (1000 * 60 * 60 * 24);
  
  if (isNaN(daysDiff)) {
    return { isValid: false, reason: 'Invalid date format' };
  }
  
  if (daysDiff > maxDaysOld) {
    return { 
      isValid: false, 
      reason: `Job is ${Math.round(daysDiff)} days old (max: ${maxDaysOld})` 
    };
  }
  
  return {
    isValid: true,
    daysOld: Math.round(daysDiff),
    freshness: daysDiff <= 7 ? 'very fresh' : 
               daysDiff <= 14 ? 'fresh' : 
               daysDiff <= 30 ? 'recent' : 'old'
  };
};

/**
 * Enhanced job matching score calculation for real job board postings
 */
exports.calculateRealJobBoardMatchScore = (jobData, careerProfile) => {
  let score = 60; // Higher base score for real job board postings
  
  // Title matching (25 points)
  const jobTitle = (jobData.title || '').toLowerCase();
  const titleMatches = careerProfile.targetJobTitles?.some(target => 
    jobTitle.includes(target.toLowerCase()) || target.toLowerCase().includes(jobTitle)
  );
  if (titleMatches) score += 25;
  
  // Content quality bonus for real job boards (10 points)
  const contentQuality = this.assessRealJobBoardContentQuality(jobData);
  if (contentQuality.quality === 'high') score += 10;
  else if (contentQuality.quality === 'medium') score += 5;
  
  // Keyword matching (20 points max)
  const content = (jobData.fullContent || '').toLowerCase();
  const keywordMatches = careerProfile.targetKeywords?.filter(keyword => 
    content.includes(keyword.toLowerCase())
  ).length || 0;
  score += Math.min(keywordMatches * 4, 20);
  
  // Experience level matching (15 points)
  if (jobData.experienceLevel && 
      jobData.experienceLevel.toLowerCase() === careerProfile.experienceLevel?.toLowerCase()) {
    score += 15;
  }
  
  // Salary matching (10 points)
  if (jobData.salary?.min && careerProfile.salaryExpectation?.min) {
    if (jobData.salary.min >= careerProfile.salaryExpectation.min * 0.8) {
      score += 10;
    }
  }
  
  // Real job board platform bonus (5 points)
  if (['Greenhouse', 'Lever'].includes(jobData.sourcePlatform)) {
    score += 5; // These typically have higher quality postings
  }
  
  // Tech stack matching bonus (15 points max)
  if (jobData.techStack && Array.isArray(jobData.techStack)) {
    const techMatches = jobData.techStack.filter(tech => 
      careerProfile.mustHaveSkills?.some(skill => 
        skill.toLowerCase().includes(tech.toLowerCase()) || 
        tech.toLowerCase().includes(skill.toLowerCase())
      )
    ).length;
    score += Math.min(techMatches * 5, 15);
  }
  
  // Comprehensive details bonus (5 points)
  if (contentQuality.strengths?.length >= 4) {
    score += 5;
  }
  
  // Recent posting bonus (5 points)
  const freshnessCheck = this.validateJobFreshness(jobData.postedDate);
  if (freshnessCheck.isValid && freshnessCheck.daysOld <= 7) {
    score += 5;
  }
  
  return Math.min(Math.max(score, 0), 100);
};

/**
 * Generate job board discovery statistics
 */
exports.generateJobBoardStats = (discoveredJobs) => {
  const stats = {
    total: discoveredJobs.length,
    byPlatform: {
      greenhouse: 0,
      lever: 0,
      indeed: 0
    },
    qualityDistribution: {
      high: 0,
      medium: 0,
      low: 0
    },
    averageMatchScore: 0,
    averageContentLength: 0,
    featuresFound: {
      techStack: 0,
      teamInfo: 0,
      salary: 0,
      benefits: 0,
      applicationDeadline: 0
    }
  };
  
  if (discoveredJobs.length === 0) return stats;
  
  let totalMatchScore = 0;
  let totalContentLength = 0;
  
  discoveredJobs.forEach(job => {
    // Platform distribution
    const platform = job.sourcePlatform?.toLowerCase();
    if (stats.byPlatform.hasOwnProperty(platform)) {
      stats.byPlatform[platform]++;
    }
    
    // Quality assessment
    const quality = this.assessRealJobBoardContentQuality(job);
    stats.qualityDistribution[quality.quality]++;
    
    // Match scores
    totalMatchScore += job.matchScore || 0;
    
    // Content length
    totalContentLength += job.fullContent?.length || 0;
    
    // Features tracking
    if (job.techStack?.length > 0) stats.featuresFound.techStack++;
    if (job.hiringManager) stats.featuresFound.teamInfo++;
    if (job.salary?.min || job.salary?.max) stats.featuresFound.salary++;
    if (job.benefits?.length > 0) stats.featuresFound.benefits++;
    if (job.applicationDeadline) stats.featuresFound.applicationDeadline++;
  });
  
  stats.averageMatchScore = Math.round(totalMatchScore / discoveredJobs.length);
  stats.averageContentLength = Math.round(totalContentLength / discoveredJobs.length);
  
  return stats;
};

/**
 * Create job board specific error messages
 */
exports.createJobBoardErrorMessage = (platform, error) => {
  const platformMessages = {
    greenhouse: 'Failed to search Greenhouse job boards. This may be due to rate limiting or access restrictions.',
    lever: 'Failed to search Lever job boards. The platform may be temporarily unavailable.',
    indeed: 'Failed to search Indeed for direct company postings. Try again later.',
    general: 'Failed to search real job boards. This may be a temporary issue.'
  };
  
  const baseMessage = platformMessages[platform?.toLowerCase()] || platformMessages.general;
  
  return {
    message: baseMessage,
    suggestion: 'The search will retry automatically. You can also try running a new search.',
    platform: platform,
    timestamp: new Date(),
    errorDetails: error.message
  };
};

/**
 * Validate complete job board discovery result
 */
exports.validateJobBoardDiscoveryResult = (discoveredJobs) => {
  const validation = {
    isValid: true,
    errors: [],
    warnings: [],
    stats: this.generateJobBoardStats(discoveredJobs),
    recommendations: []
  };
  
  if (discoveredJobs.length === 0) {
    validation.isValid = false;
    validation.errors.push('No jobs discovered from any job board');
    validation.recommendations.push('Try broadening search criteria or running search at different time');
  }
  
  // Check for platform diversity
  const platformCount = Object.values(validation.stats.byPlatform).filter(count => count > 0).length;
  if (platformCount < 2) {
    validation.warnings.push('Jobs found from only one platform - may indicate limited search scope');
    validation.recommendations.push('Ensure all target job boards (Greenhouse, Lever, Indeed) are accessible');
  }
  
  // Check quality distribution
  const highQualityPercentage = (validation.stats.qualityDistribution.high / discoveredJobs.length) * 100;
  if (highQualityPercentage < 50) {
    validation.warnings.push('Less than 50% of jobs are high quality');
    validation.recommendations.push('Consider adjusting search criteria to target higher quality postings');
  }
  
  // Check for comprehensive job details
  const withTechStack = validation.stats.featuresFound.techStack;
  if (withTechStack < discoveredJobs.length * 0.3) {
    validation.warnings.push('Few jobs include tech stack information');
  }
  
  return validation;
};

module.exports = exports;

================
File: services/recruiterImport.service.js
================
// backend/services/recruiterImport.service.js - OPTIMIZED VERSION
const csv = require('csv-parser');
const fs = require('fs');
const db = require('../config/postgresql');

class RecruiterImportService {
  static async importFromCSV(filePath) {
    const companies = new Map();
    const recruiters = [];
    let processedCount = 0;
    let errorCount = 0;

    console.log('ðŸš€ Starting recruiter import from CSV...');

    return new Promise((resolve, reject) => {
      fs.createReadStream(filePath)
        .pipe(csv())
        .on('data', (row) => {
          try {
            // Process company data
            const companyData = this.extractCompanyData(row);
            const companyKey = `${companyData.name}_${companyData.website || 'no-website'}`;
            
            if (!companies.has(companyKey) && companyData.name) {
              companies.set(companyKey, companyData);
            }

            // Process recruiter data
            const recruiterData = this.extractRecruiterData(row, companyKey);
            if (recruiterData.firstName && recruiterData.lastName) {
              recruiters.push(recruiterData);
            }
            
            processedCount++;
            
            if (processedCount % 1000 === 0) {
              console.log(`ðŸ“Š Processed ${processedCount} records...`);
            }
          } catch (error) {
            console.error(`âŒ Error processing row ${processedCount}:`, error.message);
            errorCount++;
          }
        })
        .on('end', async () => {
          try {
            console.log(`ðŸ“¥ CSV parsing complete. Processing ${companies.size} companies and ${recruiters.length} recruiters...`);
            
            // Import to database
            const result = await this.bulkInsertData(Array.from(companies.values()), recruiters);
            
            resolve({
              companiesImported: result.companiesImported,
              recruitersImported: result.recruitersImported,
              totalProcessed: processedCount,
              errors: errorCount
            });
          } catch (error) {
            reject(error);
          }
        })
        .on('error', reject);
    });
  }

  static extractCompanyData(row) {
    return {
      name: row['Company Name'] || '',
      website: row['Website'] || '',
      foundedYear: this.parseInteger(row['Founded Year']),
      phone: row['Company HQ Phone'] || '',
      fax: row['Fax'] || '',
      stockTicker: row['Ticker'] || '',
      revenueRange: row['Revenue Range (in USD)'] || '',
      revenueUsdThousands: this.parseInteger(row['Revenue (in 000s USD)']),
      employeeCount: this.parseInteger(row['Employees']),
      employeeRange: row['Employee Range'] || '',
      ownershipType: row['Ownership Type'] || '',
      businessModel: row['Business Model'] || '',
      primaryIndustry: row['Primary Industry'] || '',
      subIndustry: row['Primary Sub-Industry'] || '',
      allIndustries: this.parseArray(row['All Industries']),
      allSubIndustries: this.parseArray(row['All Sub-Industries']),
      sicCodes: this.parseArray(row['SIC Codes']),
      naicsCodes: this.parseArray(row['NAICS Codes']),
      linkedinUrl: row['LinkedIn Company Profile URL'] || '',
      facebookUrl: row['Facebook Company Profile URL'] || '',
      twitterUrl: row['Twitter Company Profile URL'] || '',
      zoominfoUrl: row['ZoomInfo Company Profile URL'] || '',
      zoominfoId: row['ZoomInfo Company ID'] || '',
      alexaRank: this.parseInteger(row['Alexa Rank']),
      locationCount: this.parseInteger(row['Number of Locations']),
      fundingTotalUsdThousands: this.parseInteger(row['Total Funding Amount (in 000s USD)']),
      recentFundingUsdThousands: this.parseInteger(row['Recent Funding Amount (in 000s USD)']),
      recentFundingRound: row['Recent Funding Round'] || '',
      recentFundingDate: this.parseDate(row['Recent Funding Date']),
      recentInvestors: this.parseArray(row['Recent Investors']),
      allInvestors: this.parseArray(row['All Investors']),
      isCertifiedActive: row['Certified Active Company'] === 'Yes',
      certificationDate: this.parseDate(row['Certification Date'])
    };
  }

  static extractRecruiterData(row, companyKey) {
    return {
      firstName: row['First Name'] || '',
      lastName: row['Last Name'] || '',
      middleName: row['Middle Name'] || '',
      salutation: row['Salutation'] || '',
      suffix: row['Suffix'] || '',
      email: row['Email Address'] || '',
      emailDomain: row['Email Domain'] || '',
      supplementalEmail: row['Supplemental Email'] || '',
      mobilePhone: row['Mobile phone'] || '',
      directPhone: row['Direct Phone Number'] || '',
      title: row['Job Title'] || '',
      jobTitleHierarchyLevel: this.parseInteger(row['Job Title Hierarchy Level']),
      managementLevel: row['Management Level'] || '',
      jobStartDate: this.parseDate(row['Job Start Date']),
      jobFunction: row['Job Function'] || '',
      department: row['Department'] || '',
      companyDivision: row['Company Division Name'] || '',
      companyKey: companyKey,
      highestEducation: row['Highest Level of Education'] || '',
      contactAccuracyScore: this.parseInteger(row['Contact Accuracy Score']),
      contactAccuracyGrade: row['Contact Accuracy Grade'] || '',
      zoominfoProfileUrl: row['ZoomInfo Contact Profile URL'] || '',
      linkedinProfileUrl: row['LinkedIn Contact Profile URL'] || '',
      noticeProvidedDate: this.parseDate(row['Notice Provided Date']),
      personStreet: row['Person Street'] || '',
      personCity: row['Person City'] || '',
      personState: row['Person State'] || '',
      personZipCode: row['Person Zip Code'] || '',
      personCountry: row['Country'] || ''
    };
  }

  static async bulkInsertData(companies, recruiters) {
    let companiesImported = 0;
    let recruitersImported = 0;

    try {
      // First, insert/find industries in batch
      console.log('ðŸ“¥ Processing industries...');
      const industryMap = new Map();
      const uniqueIndustries = [...new Set(companies.map(c => c.primaryIndustry).filter(Boolean))];
      
      // Batch insert industries
      if (uniqueIndustries.length > 0) {
        const industryValues = uniqueIndustries.map((name, index) => 
          `($${index + 1}, $${index + 1})`
        ).join(', ');
        
        const industryQuery = `
          INSERT INTO industries (name, primary_category) 
          VALUES ${industryValues}
          ON CONFLICT (name) DO UPDATE SET updated_at = NOW()
          RETURNING id, name
        `;
        
        const result = await db.query(industryQuery, uniqueIndustries);
        result.rows.forEach(row => {
          industryMap.set(row.name, row.id);
        });
        
        console.log(`âœ… Processed ${uniqueIndustries.length} industries`);
      }

      // Insert companies in batches
      console.log('ðŸ“¥ Importing companies in batches...');
      const companyMap = new Map();
      const batchSize = 100; // Reduced batch size for stability
      
      for (let i = 0; i < companies.length; i += batchSize) {
        const batch = companies.slice(i, i + batchSize);
        
        try {
          // Build batch insert query
          const values = [];
          const placeholders = [];
          let paramCount = 0;
          
          for (const company of batch) {
            const industryId = industryMap.get(company.primaryIndustry);
            const emailDomain = company.website ? 
              company.website.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] : 
              null;

            const companyValues = [
              company.name, company.website, company.foundedYear, company.phone,
              company.fax, company.stockTicker, company.revenueRange, company.revenueUsdThousands,
              company.employeeCount, company.employeeRange, company.ownershipType,
              company.businessModel, emailDomain, company.sicCodes, company.naicsCodes, 
              company.linkedinUrl, company.facebookUrl, company.twitterUrl, company.zoominfoUrl,
              company.zoominfoId, company.alexaRank, company.fundingTotalUsdThousands,
              company.recentFundingUsdThousands, company.recentFundingRound,
              company.recentFundingDate, company.recentInvestors, company.allInvestors,
              company.locationCount, company.isCertifiedActive, company.certificationDate,
              industryId
            ];

            values.push(...companyValues);
            
            const startParam = paramCount + 1;
            paramCount += companyValues.length;
            const endParam = paramCount;
            
            const placeholder = `($${Array.from({length: companyValues.length}, (_, j) => startParam + j).join(', $')})`;
            placeholders.push(placeholder);
          }

          const batchQuery = `
            INSERT INTO companies (
              name, website, founded_year, phone, fax, stock_ticker, revenue_range,
              revenue_usd_thousands, employee_count, employee_range, ownership_type,
              business_model, email_domain, sic_codes, naics_codes, linkedin_url,
              facebook_url, twitter_url, zoominfo_url, zoominfo_id, alexa_rank,
              funding_total_usd_thousands, recent_funding_usd_thousands, 
              recent_funding_round, recent_funding_date, recent_investors, 
              all_investors, location_count, is_certified_active, 
              certification_date, industry_id
            ) VALUES ${placeholders.join(', ')}
            ON CONFLICT (name, website) DO UPDATE SET 
              updated_at = NOW(),
              industry_id = EXCLUDED.industry_id,
              employee_count = EXCLUDED.employee_count,
              revenue_usd_thousands = EXCLUDED.revenue_usd_thousands
            RETURNING id, name, website
          `;

          const result = await db.query(batchQuery, values);
          
          // Map results back to company keys
          for (let j = 0; j < batch.length; j++) {
            const company = batch[j];
            const resultRow = result.rows[j];
            if (resultRow) {
              const companyKey = `${company.name}_${company.website || 'no-website'}`;
              companyMap.set(companyKey, resultRow.id);
              companiesImported++;
            }
          }

          console.log(`ðŸ“Š Imported ${Math.min(i + batchSize, companies.length)} / ${companies.length} companies`);
          
        } catch (error) {
          console.error(`Error in company batch ${i}-${i + batchSize}:`, error.message);
          // Try individual inserts for this batch
          for (const company of batch) {
            try {
              const industryId = industryMap.get(company.primaryIndustry);
              const emailDomain = company.website ? 
                company.website.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] : 
                null;

              const query = `
                INSERT INTO companies (
                  name, website, founded_year, phone, fax, stock_ticker, revenue_range,
                  revenue_usd_thousands, employee_count, employee_range, ownership_type,
                  business_model, email_domain, sic_codes, naics_codes, linkedin_url,
                  facebook_url, twitter_url, zoominfo_url, zoominfo_id, alexa_rank,
                  funding_total_usd_thousands, recent_funding_usd_thousands, 
                  recent_funding_round, recent_funding_date, recent_investors, 
                  all_investors, location_count, is_certified_active, 
                  certification_date, industry_id
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31)
                ON CONFLICT (name, website) DO UPDATE SET 
                  updated_at = NOW(),
                  industry_id = EXCLUDED.industry_id,
                  employee_count = EXCLUDED.employee_count,
                  revenue_usd_thousands = EXCLUDED.revenue_usd_thousands
                RETURNING id
              `;

              const values = [
                company.name, company.website, company.foundedYear, company.phone,
                company.fax, company.stockTicker, company.revenueRange, company.revenueUsdThousands,
                company.employeeCount, company.employeeRange, company.ownershipType,
                company.businessModel, emailDomain, company.sicCodes, company.naicsCodes, 
                company.linkedinUrl, company.facebookUrl, company.twitterUrl, company.zoominfoUrl,
                company.zoominfoId, company.alexaRank, company.fundingTotalUsdThousands,
                company.recentFundingUsdThousands, company.recentFundingRound,
                company.recentFundingDate, company.recentInvestors, company.allInvestors,
                company.locationCount, company.isCertifiedActive, company.certificationDate,
                industryId
              ];

              const result = await db.query(query, values);
              const companyKey = `${company.name}_${company.website || 'no-website'}`;
              companyMap.set(companyKey, result.rows[0].id);
              companiesImported++;

            } catch (individualError) {
              // Skip this company
              console.log(`Skipping company ${company.name}: ${individualError.message}`);
            }
          }
        }
      }

      // Insert recruiters in batches
      console.log('ðŸ“¥ Importing recruiters in batches...');
      const recruiterBatchSize = 500;
      
      for (let i = 0; i < recruiters.length; i += recruiterBatchSize) {
        const batch = recruiters.slice(i, i + recruiterBatchSize);
        
        for (const recruiter of batch) {
          try {
            const companyId = companyMap.get(recruiter.companyKey);
            
            const query = `
              INSERT INTO recruiters (
                first_name, last_name, middle_name, salutation, suffix,
                email, email_domain, supplemental_email, mobile_phone,
                direct_phone, title, job_title_hierarchy_level,
                management_level, job_start_date, job_function, department,
                company_division, current_company_id, highest_education,
                contact_accuracy_score, contact_accuracy_grade,
                zoominfo_profile_url, linkedin_profile_url,
                notice_provided_date, person_street, person_city, person_state,
                person_zip_code, person_country
              ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29)
              ON CONFLICT (email) DO UPDATE SET 
                title = EXCLUDED.title,
                current_company_id = EXCLUDED.current_company_id,
                updated_at = NOW()
            `;

            const values = [
              recruiter.firstName, recruiter.lastName, recruiter.middleName,
              recruiter.salutation, recruiter.suffix, recruiter.email,
              recruiter.emailDomain, recruiter.supplementalEmail,
              recruiter.mobilePhone, recruiter.directPhone, recruiter.title,
              recruiter.jobTitleHierarchyLevel, recruiter.managementLevel,
              recruiter.jobStartDate, recruiter.jobFunction, recruiter.department,
              recruiter.companyDivision, companyId, recruiter.highestEducation,
              recruiter.contactAccuracyScore, recruiter.contactAccuracyGrade,
              recruiter.zoominfoProfileUrl, recruiter.linkedinProfileUrl,
              recruiter.noticeProvidedDate, recruiter.personStreet,
              recruiter.personCity, recruiter.personState, recruiter.personZipCode,
              recruiter.personCountry
            ];

            await db.query(query, values);
            recruitersImported++;

          } catch (error) {
            // Skip duplicates and other errors
            if (!error.message.includes('duplicate key')) {
              console.error(`Error inserting recruiter ${recruiter.firstName} ${recruiter.lastName}:`, error.message);
            }
          }
        }

        console.log(`ðŸ“Š Imported ${Math.min(i + recruiterBatchSize, recruiters.length)} / ${recruiters.length} recruiters`);
      }

      console.log('âœ… Import completed successfully');
      return { companiesImported, recruitersImported };

    } catch (error) {
      console.error('âŒ Import failed:', error);
      throw error;
    }
  }

  // Helper methods
  static parseInteger(value) {
    if (!value || value === '') return null;
    const parsed = parseInt(value.toString().replace(/[^\d]/g, ''));
    return isNaN(parsed) ? null : parsed;
  }

  static parseDate(value) {
    if (!value || value === '') return null;
    const date = new Date(value);
    return isNaN(date.getTime()) ? null : date;
  }

  static parseArray(value) {
    if (!value || value === '') return [];
    return value.split(';').map(item => item.trim()).filter(item => item !== '');
  }
}

module.exports = RecruiterImportService;

================
File: services/resumeAnalysis.service.js
================
// services/resumeAnalysis.service.js - FIXED REALISTIC SCORING
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');

/**
 * Analyze a resume using OpenAI with strict, realistic scoring criteria
 * @param {string} resumeId - MongoDB ID of the resume to analyze
 * @returns {Object} Analysis results
 */
exports.analyzeResume = async (resumeId) => {
  try {
    console.log(`Analyzing resume: ${resumeId}`);
    
    // Get the resume from the database
    const resume = await Resume.findById(resumeId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    // Check if parsed data is available
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      throw new Error('Resume parsing data not available for analysis');
    }
    
    console.log('Parsed data found, proceeding with OpenAI analysis');
    
    // Check if this is a tailored resume for enhanced analysis
    const isTailoredResume = resume.isTailored || false;
    const tailoredContext = isTailoredResume ? 
      `This is an AI-tailored resume optimized for ${resume.tailoredForJob?.jobTitle || 'a specific role'} at ${resume.tailoredForJob?.company || 'a target company'}. ` : '';
    
    // Convert parsed data to string for OpenAI
    const resumeData = JSON.stringify(resume.parsedData, null, 2);
    
    // FIXED: Much stricter and more realistic scoring prompt
    const prompt = `
    You are a STRICT resume analyst and ATS expert with 15+ years of experience. You are known for being tough but fair in your evaluations. Most resumes are mediocre and should score between 50-75.

    ${tailoredContext}Analyze this resume with STRICT professional standards. Be realistic and tough in your scoring.

    CRITICAL INSTRUCTIONS FOR REALISTIC SCORING:

    **PLACEHOLDER CONTENT DETECTION:**
    - If you find placeholder text like "Bullet 1", "Bullet 2", "Generic content", etc., this is a MAJOR red flag
    - Automatically deduct 20-30 points for placeholder content
    - These resumes should score 40-60 maximum regardless of format

    **CONTENT QUALITY REQUIREMENTS:**
    - Achievements MUST have specific numbers, percentages, or metrics
    - Generic statements like "Managed projects" or "Worked with teams" are weak
    - Strong content requires: specific metrics, technologies, business impact, team sizes, revenue figures

    Provide the analysis in JSON format:
    {
      "overallScore": 0-100,
      "atsCompatibility": 0-100,
      "profileSummary": {
        "currentRole": "",
        "careerLevel": "",
        "industries": [],
        "suggestedJobTitles": [],
        "suggestedIndustries": []
      },
      "strengths": ["strength1", "strength2", "strength3"],
      "weaknesses": ["weakness1", "weakness2", "weakness3"],
      "keywordsSuggestions": ["keyword1", "keyword2", "keyword3", "keyword4", "keyword5"],
      "improvementAreas": [
        {
          "section": "section name",
          "suggestions": ["suggestion1", "suggestion2"],
          "improvedSnippets": [
            {
              "original": "original text from resume",
              "improved": "AI-enhanced version"
            }
          ]
        }
      ]
    }
    
    **STRICT SCORING GUIDELINES - BE REALISTIC:**
    
    Overall Score (0-100):
    - 90-100: EXCEPTIONAL resume with quantified achievements, perfect keyword optimization, industry leadership examples, specific metrics throughout
    - 80-89: STRONG resume with good quantification, solid keyword presence, clear career progression, some metrics
    - 70-79: DECENT resume with basic quantification, acceptable structure, some achievements shown
    - 60-69: BELOW AVERAGE resume with weak content, generic statements, poor quantification
    - 50-59: POOR resume with placeholder content, no metrics, generic bullet points
    - Below 50: TERRIBLE resume with major content/format issues
    
    ATS Compatibility (0-100):
    - 90-100: Perfect ATS format with extensive industry keywords, optimized headers, strong keyword density (8-12%)
    - 80-89: Good ATS compatibility with solid keyword presence (6-8%), proper formatting
    - 70-79: Acceptable ATS compatibility with basic keywords (4-6%), standard formatting
    - 60-69: Poor ATS compatibility with few keywords (2-4%), weak optimization
    - Below 60: Very poor ATS compatibility with minimal keywords (<2%), bad formatting

    **CONTENT QUALITY CHECKLIST - DEDUCT POINTS FOR:**
    1. PLACEHOLDER CONTENT: "Bullet 1", "Bullet 2", generic placeholders (-25 points)
    2. NO QUANTIFICATION: Lack of numbers, percentages, metrics (-15 points)
    3. GENERIC STATEMENTS: "Responsible for...", "Worked on..." without specifics (-10 points)
    4. WEAK ACHIEVEMENTS: No business impact or measurable outcomes (-10 points)
    5. POOR KEYWORD DENSITY: Less than 3% relevant keywords for the field (-10 points)
    6. FORMATTING ISSUES: Poor structure, inconsistent formatting (-5 points)

    **KEYWORD DENSITY CALCULATION:**
    - Count industry-specific terms, technologies, methodologies
    - Calculate as percentage of total words
    - Product Management: "roadmap", "stakeholder", "KPI", "user research", "product strategy"
    - Technical: "API", "cloud", "agile", "scrum", "data analysis"

    **ACHIEVEMENT QUALITY EXAMPLES:**
    - WEAK: "Managed projects" 
    - STRONG: "Led 3 cross-functional teams to deliver $2M revenue-generating product ahead of schedule"
    
    - WEAK: "Worked with customers"
    - STRONG: "Increased customer satisfaction by 40% through data-driven UX improvements affecting 50k+ users"

    IMPORTANT: 
    - Be STRICT and REALISTIC in scoring
    - Most resumes should score 50-75, not 85-95
    - Only truly exceptional resumes with perfect content and optimization should score above 85
    - Placeholder content automatically caps scores at 60 maximum

    Return ONLY the JSON object without any markdown formatting or code blocks.
    
    Resume Data:
    ${resumeData}
    `;
    
    // Call OpenAI API with enhanced parameters for stricter analysis
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: `You are a STRICT professional resume analyst with 15+ years of experience. You are known for tough, realistic evaluations. Most resumes are mediocre (50-75 range). Only exceptional resumes with perfect quantified achievements and optimization score above 85. You automatically detect and heavily penalize placeholder content like "Bullet 1, Bullet 2". You require specific metrics, technologies, and business impact for high scores. Return ONLY valid JSON without markdown.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Lower temperature for more consistent, strict scoring
      max_tokens: 3000,
    });
    
    // Get the response content
    const responseContent = response.choices[0].message.content.trim();
    
    // Clean up the response - remove any markdown code block syntax
    let cleanedResponse = responseContent;
    
    if (responseContent.startsWith('```json') || responseContent.startsWith('```')) {
      const startIndex = responseContent.indexOf('{');
      const endIndex = responseContent.lastIndexOf('}');
      
      if (startIndex !== -1 && endIndex !== -1) {
        cleanedResponse = responseContent.substring(startIndex, endIndex + 1);
      }
    }
    
    console.log('Cleaned response for parsing:', cleanedResponse.substring(0, 200) + '...');
    
    // Parse the response
    const analysisData = JSON.parse(cleanedResponse);
    console.log('Resume analysis with OpenAI completed successfully');
    
    // ENHANCED: Additional validation and scoring adjustments
    let sanitizedAnalysis = {
      overallScore: Math.max(0, Math.min(100, analysisData.overallScore || 0)),
      atsCompatibility: Math.max(0, Math.min(100, analysisData.atsCompatibility || 0)),
      profileSummary: {
        currentRole: analysisData.profileSummary?.currentRole || "Not specified",
        careerLevel: analysisData.profileSummary?.careerLevel || "Mid-level",
        industries: Array.isArray(analysisData.profileSummary?.industries) ? analysisData.profileSummary.industries : ["Technology"],
        suggestedJobTitles: Array.isArray(analysisData.profileSummary?.suggestedJobTitles) ? analysisData.profileSummary.suggestedJobTitles : ["Product Manager", "Project Manager"],
        suggestedIndustries: Array.isArray(analysisData.profileSummary?.suggestedIndustries) ? analysisData.profileSummary.suggestedIndustries : ["Technology", "Software"]
      },
      strengths: Array.isArray(analysisData.strengths) ? analysisData.strengths : [
        "Resume has a clear structure",
        "Contact information is included",
        "Work experience is detailed"
      ],
      weaknesses: Array.isArray(analysisData.weaknesses) ? analysisData.weaknesses : [
        "Could benefit from more quantifiable achievements",
        "Skills section could be more comprehensive",
        "Summary could be more impactful"
      ],
      keywordsSuggestions: Array.isArray(analysisData.keywordsSuggestions) ? analysisData.keywordsSuggestions : [
        "leadership",
        "communication",
        "problem-solving",
        "teamwork",
        "analytical"
      ],
      improvementAreas: Array.isArray(analysisData.improvementAreas) ? analysisData.improvementAreas : [
        {
          section: "Experience",
          suggestions: [
            "Add more quantifiable achievements",
            "Use more action verbs"
          ],
          improvedSnippets: [
            {
              original: "Generic bullet points need improvement",
              improved: "Specific, quantified achievements with business impact"
            }
          ]
        }
      ]
    };
    
    // CRITICAL: Detect and penalize placeholder content
    const resumeText = JSON.stringify(resume.parsedData).toLowerCase();
    const placeholderPatterns = [
      'bullet 1', 'bullet 2', 'bullet 3', 'bullet 4', 'bullet 5',
      'bullet point', 'add content', 'placeholder', 'lorem ipsum',
      'example text', 'sample text', 'generic content'
    ];
    
    let hasPlaceholders = false;
    let placeholderCount = 0;
    
    placeholderPatterns.forEach(pattern => {
      if (resumeText.includes(pattern)) {
        hasPlaceholders = true;
        placeholderCount++;
      }
    });
    
    if (hasPlaceholders) {
      console.log(`ðŸš¨ PLACEHOLDER CONTENT DETECTED: Found ${placeholderCount} placeholder patterns`);
      
      // Apply severe penalty for placeholder content
      const penalty = Math.min(30, placeholderCount * 8); // Up to 30 point penalty
      sanitizedAnalysis.overallScore = Math.max(20, sanitizedAnalysis.overallScore - penalty);
      sanitizedAnalysis.atsCompatibility = Math.max(25, sanitizedAnalysis.atsCompatibility - (penalty * 0.8));
      
      // Add to weaknesses
      sanitizedAnalysis.weaknesses.unshift("Contains placeholder content that needs to be replaced with specific achievements");
      
      // Cap maximum scores for placeholder content
      sanitizedAnalysis.overallScore = Math.min(60, sanitizedAnalysis.overallScore);
      sanitizedAnalysis.atsCompatibility = Math.min(65, sanitizedAnalysis.atsCompatibility);
      
      console.log(`Applied ${penalty} point penalty for placeholder content. New scores: ${sanitizedAnalysis.overallScore}/${sanitizedAnalysis.atsCompatibility}`);
    }
    
    // Additional content quality checks
    const experienceText = JSON.stringify(resume.parsedData.experience || []);
    
    // Check for quantification
    const hasNumbers = /\d+/.test(experienceText);
    const hasPercentages = /%/.test(experienceText);
    const hasMetrics = /\$|revenue|million|thousand|increase|decrease|improve/i.test(experienceText);
    
    if (!hasNumbers && !hasPercentages && !hasMetrics) {
      console.log('ðŸš¨ NO QUANTIFICATION DETECTED: Applying penalty');
      sanitizedAnalysis.overallScore = Math.max(30, sanitizedAnalysis.overallScore - 15);
      sanitizedAnalysis.atsCompatibility = Math.max(40, sanitizedAnalysis.atsCompatibility - 10);
      sanitizedAnalysis.weaknesses.unshift("Lacks quantified achievements and specific metrics");
    }
    
    // ENHANCED: Apply tailored resume bonus more carefully
    if (isTailoredResume && !hasPlaceholders) {
      console.log('Applying tailored resume analysis bonus...');
      
      // Check for keyword optimization indicators in the content
      const summaryText = (resume.parsedData.summary || '').toLowerCase();
      const experienceText = JSON.stringify(resume.parsedData.experience || []).toLowerCase();
      
      // Keywords that indicate technical optimization
      const techKeywords = ['api', 'cloud', 'infrastructure', 'developer', 'velocity', 'platform', 'security', 'architecture'];
      const foundKeywords = techKeywords.filter(keyword => 
        summaryText.includes(keyword) || experienceText.includes(keyword)
      );
      
      // Apply bonus based on keyword optimization (only if no placeholders)
      if (foundKeywords.length >= 3) {
        console.log(`Found ${foundKeywords.length} optimization keywords:`, foundKeywords);
        
        // Apply 3-5 point bonus for good optimization (reduced from previous)
        const bonus = Math.min(5, foundKeywords.length);
        sanitizedAnalysis.overallScore = Math.min(100, sanitizedAnalysis.overallScore + bonus);
        sanitizedAnalysis.atsCompatibility = Math.min(100, sanitizedAnalysis.atsCompatibility + bonus);
        
        console.log(`Applied ${bonus} point tailoring bonus. New scores: ${sanitizedAnalysis.overallScore}/${sanitizedAnalysis.atsCompatibility}`);
        
        // Update strengths to reflect optimization
        sanitizedAnalysis.strengths.unshift("Resume is well-optimized with relevant technical keywords");
      }
    }
    
    console.log('Final analysis scores after all adjustments:', {
      overallScore: sanitizedAnalysis.overallScore,
      atsCompatibility: sanitizedAnalysis.atsCompatibility,
      hadPlaceholders: hasPlaceholders,
      placeholderCount: placeholderCount,
      strengthsCount: sanitizedAnalysis.strengths.length,
      weaknessesCount: sanitizedAnalysis.weaknesses.length,
      isTailored: isTailoredResume
    });
    
    return sanitizedAnalysis;
  } catch (error) {
    console.error('Error analyzing resume with OpenAI:', error);
    
    // Fallback to a more realistic default analysis
    return {
      overallScore: 45, // Much lower default score
      atsCompatibility: 55,
      profileSummary: {
        currentRole: "Not identified",
        careerLevel: "Mid-level",
        industries: ["Technology"],
        suggestedJobTitles: ["Product Manager", "Project Manager"],
        suggestedIndustries: ["Technology", "Software"]
      },
      strengths: [
        "Resume has a clear structure",
        "Contact information is included"
      ],
      weaknesses: [
        "Contains placeholder content that needs specific achievements",
        "Lacks quantifiable metrics and business impact",
        "Needs more industry-specific keywords",
        "Bullet points are too generic and need improvement"
      ],
      keywordsSuggestions: [
        "leadership",
        "project management",
        "data analysis",
        "cross-functional collaboration",
        "business impact"
      ],
      improvementAreas: [
        {
          section: "Experience",
          suggestions: [
            "Replace placeholder bullets with specific quantified achievements",
            "Add metrics like percentages, dollar amounts, team sizes",
            "Include specific technologies and methodologies used"
          ],
          improvedSnippets: [
            {
              original: "Bullet 1, Bullet 2, Bullet 3",
              improved: "Led cross-functional team of 12 to deliver $2M revenue product, increasing customer satisfaction by 35% through data-driven feature improvements"
            }
          ]
        }
      ]
    };
  }
};

================
File: services/resumeEditor.service.js
================
// backend/services/resumeEditor.service.js - AI-POWERED RESUME EDITOR
const { openai } = require('../config/openai');
const Resume = require('../models/mongodb/resume.model');
const { PutObjectCommand } = require('@aws-sdk/client-s3');
const { s3Client, S3_BUCKET } = require('../config/s3');
const PDFDocument = require('pdfkit');
const { Document, Packer, Paragraph, TextRun, HeadingLevel } = require('docx');
const uuid = require('uuid').v4;

class ResumeEditorService {
  /**
   * Apply AI-suggested changes to a resume
   */
  static async applyResumeChanges(resumeId, userId, changes) {
    try {
      console.log(`ðŸ¤– AJ: Applying changes to resume ${resumeId}`);
      
      const resume = await Resume.findOne({ _id: resumeId, userId });
      if (!resume) {
        throw new Error('Resume not found');
      }

      // Parse the change request using AI
      const structuredChanges = await this.parseChangeRequest(changes, resume.parsedData);
      
      // Apply changes to resume data
      const updatedResumeData = await this.applyStructuredChanges(resume.parsedData, structuredChanges);
      
      // Update resume in database
      resume.parsedData = updatedResumeData;
      resume.updatedAt = new Date();
      
      // Add version tracking
      const versionNumber = (resume.versions || []).length + 1;
      if (!resume.versions) resume.versions = [];
      
      // Create new version entry
      const newVersion = {
        versionNumber,
        createdAt: new Date(),
        fileUrl: resume.fileUrl, // Will be updated after file generation
        changesDescription: this.summarizeChanges(structuredChanges),
        aiGenerated: true
      };

      resume.versions.push(newVersion);
      await resume.save();

      // Generate updated resume file
      const updatedFileUrl = await this.generateUpdatedResumeFile(resume, updatedResumeData);
      
      // Update the version with new file URL
      resume.versions[resume.versions.length - 1].fileUrl = updatedFileUrl;
      await resume.save();

      console.log(`âœ… AJ: Successfully updated resume with ${structuredChanges.length} changes`);

      return {
        success: true,
        updatedResume: resume,
        changes: structuredChanges,
        newFileUrl: updatedFileUrl,
        changesSummary: this.summarizeChanges(structuredChanges)
      };

    } catch (error) {
      console.error('Resume update error:', error);
      throw error;
    }
  }

  /**
   * Parse natural language change request into structured changes
   */
static async parseChangeRequest(changeRequest, currentResumeData) {
  try {
    const prompt = `You are an expert resume editor. Parse this change request and convert it into structured JSON changes.

CURRENT RESUME DATA:
${JSON.stringify(currentResumeData, null, 2)}

CHANGE REQUEST:
"${changeRequest}"

CRITICAL: When updating work experience highlights/achievements, generate ONE single action that replaces the entire highlights array with 3-5 detailed bullet points.

Return JSON in this EXACT format:
{
  "changes": [
    {
      "section": "experience",
      "action": "enhance",
      "target": "0",
      "field": "highlights",
      "newValue": [
        "Detailed bullet point 1 with specific metrics and technologies",
        "Detailed bullet point 2 showcasing leadership and impact", 
        "Detailed bullet point 3 with quantifiable business results",
        "Detailed bullet point 4 highlighting technical expertise",
        "Detailed bullet point 5 demonstrating strategic thinking"
      ],
      "originalValue": "current highlights array",
      "reason": "Enhanced with multiple detailed achievements"
    }
  ]
}

IMPORTANT RULES:
- Generate EXACTLY ONE change action, not multiple separate ones
- Use action: "enhance" for updating existing experience
- Set field: "highlights" for bullet points
- newValue MUST be an array of 3-5 detailed strings
- Each bullet should be 15-25 words with specific metrics
- Use strong action verbs (Led, Developed, Achieved, Implemented, etc.)
- Include technologies, numbers, percentages, and business impact
- Make bullets relevant to the current role and industry

EXAMPLE - DO THIS:
{
  "changes": [
    {
      "section": "experience",
      "action": "enhance",
      "target": "0",
      "field": "highlights", 
      "newValue": [
        "Led development of AI-powered tax platform serving 10k+ enterprise clients with 40% faster processing",
        "Architected machine learning workflows reducing manual review time by 65% and improving accuracy to 98%",
        "Managed cross-functional team of 15 engineers delivering $3.2M in new AI product revenue",
        "Implemented automated compliance checking system preventing 200+ regulatory violations annually",
        "Drove product strategy for agentic AI features resulting in 85% customer satisfaction increase"
      ],
      "reason": "Enhanced Thomson Reuters role with specific AI achievements and quantifiable impact"
    }
  ]
}

DON'T DO THIS (multiple separate actions):
{
  "changes": [
    {"action": "add", "target": "0/highlights", "newValue": "bullet 1"},
    {"action": "add", "target": "0/highlights", "newValue": "bullet 2"},
    {"action": "add", "target": "0/highlights", "newValue": "bullet 3"}
  ]
}

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: 'You are an expert resume editor. Generate ONE comprehensive change action with an array of detailed bullet points. Return only valid JSON.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 2000
    });

    let parsedChanges;
    try {
      const responseContent = response.choices[0].message.content.trim();
      // Clean up response if it has markdown
      const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
      parsedChanges = JSON.parse(cleanedResponse);
      
      console.log('ðŸ“‹ Parsed changes:', JSON.stringify(parsedChanges, null, 2));
      
      // ðŸ”§ VALIDATION: Ensure we have the right structure for experience updates
      if (parsedChanges.changes) {
        parsedChanges.changes.forEach((change, index) => {
          if (change.section === 'experience' && 
              change.action === 'enhance' && 
              change.field === 'highlights' && 
              Array.isArray(change.newValue)) {
            console.log(`âœ… Valid experience enhancement found with ${change.newValue.length} bullet points`);
          }
        });
      }
      
    } catch (parseError) {
      console.error('Error parsing AI response:', parseError);
      throw new Error('Failed to parse change request');
    }

    return parsedChanges.changes || [];

  } catch (error) {
    console.error('Error parsing change request:', error);
    throw error;
  }
}

  /**
   * Apply structured changes to resume data
   */
  static async applyStructuredChanges(resumeData, changes) {
    const updatedData = JSON.parse(JSON.stringify(resumeData)); // Deep clone

    for (const change of changes) {
      try {
        console.log(`Applying change: ${change.action} to ${change.section}`);
        
        switch (change.section) {
          case 'contactInfo':
            this.updateContactInfo(updatedData, change);
            break;
          case 'summary':
            this.updateSummary(updatedData, change);
            break;
          case 'experience':
            this.updateExperience(updatedData, change);
            break;
          case 'education':
            this.updateEducation(updatedData, change);
            break;
          case 'skills':
            this.updateSkills(updatedData, change);
            break;
          case 'certifications':
            this.updateCertifications(updatedData, change);
            break;
          case 'projects':
            this.updateProjects(updatedData, change);
            break;
          case 'languages':
            this.updateLanguages(updatedData, change);
            break;
          default:
            console.warn(`Unknown section: ${change.section}`);
        }
      } catch (error) {
        console.error(`Error applying change to ${change.section}:`, error);
      }
    }

    return updatedData;
  }

  // Section-specific update methods
  static updateContactInfo(data, change) {
    if (!data.contactInfo) data.contactInfo = {};
    
    switch (change.action) {
      case 'update':
        if (change.target && change.newValue) {
          data.contactInfo[change.target] = change.newValue;
        }
        break;
      case 'add':
        if (change.target === 'websites' && change.newValue) {
          if (!data.contactInfo.websites) data.contactInfo.websites = [];
          data.contactInfo.websites.push(change.newValue);
        }
        break;
    }
  }

  static updateSummary(data, change) {
    switch (change.action) {
      case 'update':
      case 'rewrite':
      case 'enhance':
        data.summary = change.newValue;
        break;
      case 'add':
        if (!data.summary) {
          data.summary = change.newValue;
        }
        break;
    }
  }

static updateExperience(data, change) {
  if (!data.experience) data.experience = [];

  console.log(`ðŸ”§ Updating experience - Action: ${change.action}, Target: ${change.target}, Field: ${change.field}`);
  console.log(`ðŸ”§ NewValue type: ${Array.isArray(change.newValue) ? 'array' : typeof change.newValue}`);
  console.log(`ðŸ”§ NewValue content:`, change.newValue);

  switch (change.action) {
    case 'add':
      // ðŸŽ¯ FIXED: Handle adding new experience vs adding to existing experience
      if (change.target && change.target.includes('/')) {
        // Adding to existing experience (e.g., "0/highlights")
        const [indexStr, field] = change.target.split('/');
        const index = parseInt(indexStr);
        
        if (data.experience[index]) {
          if (field === 'highlights') {
            // Initialize highlights array if it doesn't exist
            if (!data.experience[index].highlights) {
              data.experience[index].highlights = [];
            }
            
            if (Array.isArray(change.newValue)) {
              // ðŸ”§ FIXED: Replace entire highlights array with new content
              console.log(`ðŸŽ¯ Replacing highlights array with ${change.newValue.length} items`);
              data.experience[index].highlights = change.newValue;
            } else if (typeof change.newValue === 'string') {
              // Add single highlight
              console.log(`ðŸŽ¯ Adding single highlight: ${change.newValue}`);
              data.experience[index].highlights.push(change.newValue);
            }
            console.log(`âœ… Updated experience[${index}].highlights - now has ${data.experience[index].highlights.length} items`);
          } else {
            // Add to other fields
            data.experience[index][field] = change.newValue;
            console.log(`âœ… Added to experience[${index}].${field}`);
          }
        } else {
          console.warn(`âŒ Experience index ${index} not found`);
        }
      } else if (change.newValue && typeof change.newValue === 'object') {
        // Adding entirely new experience entry
        data.experience.push(change.newValue);
        console.log('âœ… Added new experience entry');
      }
      break;
      
    case 'update':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        if (data.experience[index]) {
          // Update specific field or entire experience entry
          if (change.field) {
            data.experience[index][change.field] = change.newValue;
            console.log(`âœ… Updated experience[${index}].${change.field}`);
          } else {
            data.experience[index] = { ...data.experience[index], ...change.newValue };
            console.log(`âœ… Updated entire experience[${index}]`);
          }
        } else {
          console.warn(`âŒ Experience index ${index} not found`);
        }
      }
      break;
      
    case 'delete':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        data.experience.splice(index, 1);
        console.log(`âœ… Deleted experience[${index}]`);
      }
      break;
      
    case 'enhance':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        if (data.experience[index]) {
          
          // ðŸŽ¯ ENHANCED: Handle highlights field specifically
          if (change.field === 'highlights' && Array.isArray(change.newValue)) {
            console.log(`ðŸŽ¯ Setting experience[${index}].highlights with ${change.newValue.length} bullet points`);
            data.experience[index].highlights = change.newValue;
            console.log(`âœ… Enhanced experience[${index}].highlights:`, data.experience[index].highlights);
            
          } else if (change.field === 'description') {
            data.experience[index].description = change.newValue;
            console.log(`âœ… Enhanced experience[${index}].description`);
            
          } else if (change.field && change.newValue) {
            // Handle other specific fields
            data.experience[index][change.field] = change.newValue;
            console.log(`âœ… Enhanced experience[${index}].${change.field}`);
            
          } else if (!change.field && Array.isArray(change.newValue)) {
            // ðŸ”§ FIXED: Default to highlights when no field specified but array provided
            console.log('ðŸŽ¯ No field specified, defaulting to highlights for array data');
            data.experience[index].highlights = change.newValue;
            console.log(`âœ… Set experience[${index}].highlights with ${change.newValue.length} items`);
            
          } else if (!change.field && typeof change.newValue === 'object') {
            // Handle object updates
            Object.keys(change.newValue).forEach(key => {
              data.experience[index][key] = change.newValue[key];
              console.log(`âœ… Updated experience[${index}].${key}`);
            });
            
          } else {
            console.warn(`âŒ Cannot enhance experience[${index}] - invalid field/value combination`);
            console.warn(`Field: ${change.field}, NewValue: ${JSON.stringify(change.newValue)}`);
          }
        } else {
          console.warn(`âŒ Experience index ${index} not found for enhancement`);
        }
      } else {
        console.warn('âŒ No target specified for enhance action');
      }
      break;
      
    default:
      console.warn(`âŒ Unknown action: ${change.action}`);
  }
}

  static updateEducation(data, change) {
    if (!data.education) data.education = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.education.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.education[index]) {
            if (change.field) {
              data.education[index][change.field] = change.newValue;
            } else {
              data.education[index] = { ...data.education[index], ...change.newValue };
            }
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.education.splice(index, 1);
        }
        break;
    }
  }

  static updateSkills(data, change) {
    if (!data.skills) data.skills = [];

    switch (change.action) {
      case 'add':
        if (change.newValue) {
          // Handle both string and object skills
          if (typeof change.newValue === 'string') {
            data.skills.push({ name: change.newValue, level: 'Intermediate' });
          } else {
            data.skills.push(change.newValue);
          }
        }
        break;
      case 'update':
        if (change.target) {
          const skillIndex = data.skills.findIndex(skill => 
            (typeof skill === 'string' ? skill : skill.name) === change.target
          );
          if (skillIndex !== -1) {
            if (typeof change.newValue === 'string') {
              data.skills[skillIndex] = { name: change.newValue, level: 'Intermediate' };
            } else {
              data.skills[skillIndex] = change.newValue;
            }
          }
        }
        break;
      case 'delete':
        if (change.target) {
          data.skills = data.skills.filter(skill => 
            (typeof skill === 'string' ? skill : skill.name) !== change.target
          );
        }
        break;
    }
  }

  static updateCertifications(data, change) {
    if (!data.certifications) data.certifications = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.certifications.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.certifications[index]) {
            data.certifications[index] = { ...data.certifications[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.certifications.splice(index, 1);
        }
        break;
    }
  }

  static updateProjects(data, change) {
    if (!data.projects) data.projects = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.projects.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.projects[index]) {
            data.projects[index] = { ...data.projects[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.projects.splice(index, 1);
        }
        break;
    }
  }

  static updateLanguages(data, change) {
    if (!data.languages) data.languages = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.languages.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.languages[index]) {
            data.languages[index] = { ...data.languages[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.languages.splice(index, 1);
        }
        break;
    }
  }

  /**
   * Generate updated resume file (PDF/DOCX)
   */
  static async generateUpdatedResumeFile(resume, updatedData) {
    try {
      const fileType = resume.fileType;
      let buffer;
      let contentType;
      let extension;

      if (fileType === 'PDF') {
        buffer = await this.generatePDF(updatedData);
        contentType = 'application/pdf';
        extension = '.pdf';
      } else if (fileType === 'DOCX') {
        buffer = await this.generateDOCX(updatedData);
        contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        extension = '.docx';
      } else {
        throw new Error(`Unsupported file type: ${fileType}`);
      }

      // Upload to S3
      const s3Key = `resumes/${resume.userId}/updated_${uuid()}${extension}`;
      
      const uploadParams = {
        Bucket: S3_BUCKET,
        Key: s3Key,
        Body: buffer,
        ContentType: contentType
      };

      await s3Client.send(new PutObjectCommand(uploadParams));
      
      console.log(`âœ… Generated updated resume file: ${s3Key}`);
      return s3Key;

    } catch (error) {
      console.error('Error generating updated resume file:', error);
      throw error;
    }
  }

/**
 * Send progress update to connected SSE clients
 */
static sendProgressUpdate(resumeId, userId, stage, percentage, message) {
  try {
    if (global.progressClients) {
      const progressData = {
        type: 'progress',
        resumeId,
        stage,
        percentage,
        message,
        timestamp: new Date().toISOString()
      };
      
      // Send to all clients for this user/resume
      global.progressClients.forEach((res, clientId) => {
        if (clientId.includes(`${userId}_${resumeId}`)) {
          try {
            res.write(`data: ${JSON.stringify(progressData)}\n\n`);
            console.log(`ðŸ“¡ Sent progress: ${percentage}% - ${message}`);
          } catch (error) {
            console.error('Error sending SSE progress:', error);
            global.progressClients.delete(clientId);
          }
        }
      });
    }
  } catch (error) {
    console.error('Error in sendProgressUpdate:', error);
  }
}

  /**
   * Generate PDF from resume data
   */
  static async generatePDF(resumeData) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Header
        doc.fontSize(20).text(resumeData.contactInfo?.name || 'Resume', { align: 'center' });
        doc.fontSize(12);
        
        if (resumeData.contactInfo?.email) {
          doc.text(`Email: ${resumeData.contactInfo.email}`);
        }
        if (resumeData.contactInfo?.phone) {
          doc.text(`Phone: ${resumeData.contactInfo.phone}`);
        }
        if (resumeData.contactInfo?.location) {
          doc.text(`Location: ${resumeData.contactInfo.location}`);
        }

        doc.moveDown();

        // Summary
        if (resumeData.summary) {
          doc.fontSize(14).text('Professional Summary', { underline: true });
          doc.fontSize(11).text(resumeData.summary);
          doc.moveDown();
        }

        // Experience
        if (resumeData.experience && resumeData.experience.length > 0) {
          doc.fontSize(14).text('Work Experience', { underline: true });
          resumeData.experience.forEach(exp => {
            doc.fontSize(12).text(`${exp.title} at ${exp.company}`, { bold: true });
            if (exp.startDate || exp.endDate) {
              doc.fontSize(10).text(`${exp.startDate || ''} - ${exp.endDate || 'Present'}`);
            }
            if (exp.description) {
              doc.fontSize(11).text(exp.description);
            }
            if (exp.highlights && exp.highlights.length > 0) {
              exp.highlights.forEach(highlight => {
                doc.text(`â€¢ ${highlight}`);
              });
            }
            doc.moveDown();
          });
        }

        // Education
        if (resumeData.education && resumeData.education.length > 0) {
          doc.fontSize(14).text('Education', { underline: true });
          resumeData.education.forEach(edu => {
            doc.fontSize(12).text(`${edu.degree} in ${edu.field || ''}`);
            doc.fontSize(11).text(edu.institution);
            if (edu.startDate || edu.endDate) {
              doc.fontSize(10).text(`${edu.startDate || ''} - ${edu.endDate || ''}`);
            }
            doc.moveDown();
          });
        }

        // Skills
        if (resumeData.skills && resumeData.skills.length > 0) {
          doc.fontSize(14).text('Skills', { underline: true });
          const skillsText = resumeData.skills.map(skill => 
            typeof skill === 'string' ? skill : `${skill.name} (${skill.level || ''})`
          ).join(', ');
          doc.fontSize(11).text(skillsText);
          doc.moveDown();
        }

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Generate DOCX from resume data
   */
  static async generateDOCX(resumeData) {
    try {
      const children = [];

      // Header
      children.push(
        new Paragraph({
          text: resumeData.contactInfo?.name || 'Resume',
          heading: HeadingLevel.TITLE,
          alignment: 'center'
        })
      );

      if (resumeData.contactInfo?.email) {
        children.push(new Paragraph({ text: `Email: ${resumeData.contactInfo.email}` }));
      }
      if (resumeData.contactInfo?.phone) {
        children.push(new Paragraph({ text: `Phone: ${resumeData.contactInfo.phone}` }));
      }
      if (resumeData.contactInfo?.location) {
        children.push(new Paragraph({ text: `Location: ${resumeData.contactInfo.location}` }));
      }

      // Summary
      if (resumeData.summary) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Professional Summary',
            heading: HeadingLevel.HEADING_1
          }),
          new Paragraph({ text: resumeData.summary })
        );
      }

      // Experience
      if (resumeData.experience && resumeData.experience.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Work Experience',
            heading: HeadingLevel.HEADING_1
          })
        );

        resumeData.experience.forEach(exp => {
          children.push(
            new Paragraph({
              children: [
                new TextRun({ text: `${exp.title} at ${exp.company}`, bold: true })
              ]
            })
          );
          
          if (exp.startDate || exp.endDate) {
            children.push(
              new Paragraph({ text: `${exp.startDate || ''} - ${exp.endDate || 'Present'}` })
            );
          }
          
          if (exp.description) {
            children.push(new Paragraph({ text: exp.description }));
          }
          
          if (exp.highlights && exp.highlights.length > 0) {
            exp.highlights.forEach(highlight => {
              children.push(new Paragraph({ text: `â€¢ ${highlight}` }));
            });
          }
        });
      }

      // Education, Skills, etc. (similar pattern)
      if (resumeData.education && resumeData.education.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Education',
            heading: HeadingLevel.HEADING_1
          })
        );

        resumeData.education.forEach(edu => {
          children.push(
            new Paragraph({ text: `${edu.degree} in ${edu.field || ''}` }),
            new Paragraph({ text: edu.institution })
          );
        });
      }

      if (resumeData.skills && resumeData.skills.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Skills',
            heading: HeadingLevel.HEADING_1
          })
        );

        const skillsText = resumeData.skills.map(skill => 
          typeof skill === 'string' ? skill : `${skill.name} (${skill.level || ''})`
        ).join(', ');
        
        children.push(new Paragraph({ text: skillsText }));
      }

      const doc = new Document({
        sections: [{
          properties: {},
          children: children
        }]
      });

      return await Packer.toBuffer(doc);
    } catch (error) {
      console.error('Error generating DOCX:', error);
      throw error;
    }
  }

  /**
   * Summarize changes for version tracking
   */
  static summarizeChanges(changes) {
    if (!changes || changes.length === 0) return 'No changes applied';

    const summary = changes.map(change => {
      const action = change.action.charAt(0).toUpperCase() + change.action.slice(1);
      return `${action} ${change.section}${change.target ? ` (${change.target})` : ''}`;
    }).join(', ');

    return `AI Updates: ${summary}`;
  }

/**
 * Optimize resume for ATS with real progress tracking
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData, progressCallback = null) {
  const startTime = Date.now();
  const stages = [];
  
  const reportProgress = (stage, percentage, message) => {
    stages.push({ stage, percentage, message, timestamp: Date.now() - startTime });
    
    // Send real-time update via SSE
    this.sendProgressUpdate(resumeId, userId, stage, percentage, message);
    
    // Also call the callback if provided
    if (progressCallback) {
      progressCallback(stage, percentage, message);
    }
    
    console.log(`ðŸ“Š Real Progress: ${percentage}% - ${message}`);
  };

  try {
    console.log(`ðŸ¤– AJ: Optimizing resume ${resumeId} for ATS with real progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    reportProgress('analyzing', 20, 'Analyzing resume for ATS optimizations...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Realistic delay
    
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress) 
    reportProgress('applying', 40, 'Generating enhancement suggestions...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    reportProgress('applying', 60, 'Applying ATS optimizations to resume...');
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    reportProgress('analyzing', 80, 'Re-analyzing optimized resume...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    reportProgress('comparing', 90, 'Generating before/after comparison...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;
    const processingTime = Date.now() - startTime;

    // Step 5: Complete (100% progress)
    reportProgress('complete', 100, `Optimization complete! ATS score improved from ${previousScore}% to ${newATSScore}%`);

    console.log(`âœ… Real Progress: 100% - ATS optimization complete. Score: ${previousScore}% â†’ ${newATSScore}% (${processingTime}ms)`);

    // Send completion message via SSE
    this.sendProgressUpdate(resumeId, userId, 'complete', 100, 'Optimization completed successfully!');

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison,
      processingTime: processingTime,
      stages: stages
    };

  } catch (error) {
    console.error('ATS optimization with real progress error:', error);
    
    // Send error via SSE
    this.sendProgressUpdate(resumeId, userId, 'error', 0, `Optimization failed: ${error.message}`);
    
    throw error;
  }
}

/**
 * Optimize resume for ATS with progress tracking and before/after comparison
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData) {
  try {
    console.log(`ðŸ¤– AJ: Optimizing resume ${resumeId} for ATS with progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    console.log(`ðŸ“Š Progress: 20% - Analyzing resume for ATS optimizations...`);
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress)
    console.log(`ðŸ“Š Progress: 60% - Applying ATS optimizations...`);
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    console.log(`ðŸ“Š Progress: 80% - Re-analyzing optimized resume...`);
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    console.log(`ðŸ“Š Progress: 90% - Generating before/after comparison...`);
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;

    console.log(`âœ… Progress: 100% - ATS optimization complete. Score: ${previousScore}% â†’ ${newATSScore}%`);

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison
    };

  } catch (error) {
    console.error('ATS optimization with progress error:', error);
    throw error;
  }
}

/**
 * Send progress update to connected SSE clients
 */
static sendProgressUpdate(resumeId, userId, stage, percentage, message) {
  try {
    if (global.progressClients) {
      const progressData = {
        type: 'progress',
        resumeId,
        stage,
        percentage,
        message,
        timestamp: new Date().toISOString()
      };
      
      // Send to all clients for this user/resume
      global.progressClients.forEach((res, clientId) => {
        if (clientId.includes(`${userId}_${resumeId}`)) {
          try {
            res.write(`data: ${JSON.stringify(progressData)}\n\n`);
            console.log(`ðŸ“¡ Sent progress: ${percentage}% - ${message}`);
          } catch (error) {
            console.error('Error sending SSE progress:', error);
            global.progressClients.delete(clientId);
          }
        }
      });
    } else {
      console.log('âš ï¸ No progress clients connected for SSE updates');
    }
  } catch (error) {
    console.error('Error in sendProgressUpdate:', error);
  }
}

/**
 * Optimize resume for ATS with real progress tracking
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData, progressCallback = null) {
  const startTime = Date.now();
  const stages = [];
  
  const reportProgress = (stage, percentage, message) => {
    stages.push({ stage, percentage, message, timestamp: Date.now() - startTime });
    
    // Send real-time update via SSE
    this.sendProgressUpdate(resumeId, userId, stage, percentage, message);
    
    // Also call the callback if provided
    if (progressCallback) {
      progressCallback(stage, percentage, message);
    }
    
    console.log(`ðŸ“Š Real Progress: ${percentage}% - ${message}`);
  };

  try {
    console.log(`ðŸ¤– AJ: Optimizing resume ${resumeId} for ATS with real progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    reportProgress('analyzing', 20, 'Analyzing resume for ATS optimizations...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Realistic delay
    
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress) 
    reportProgress('applying', 40, 'Generating enhancement suggestions...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    reportProgress('applying', 60, 'Applying ATS optimizations to resume...');
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    reportProgress('analyzing', 80, 'Re-analyzing optimized resume...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    reportProgress('comparing', 90, 'Generating before/after comparison...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;
    const processingTime = Date.now() - startTime;

    // Step 5: Complete (100% progress)
    reportProgress('complete', 100, `Optimization complete! ATS score: ${previousScore}% â†’ ${newATSScore}%`);

    console.log(`âœ… Real Progress: 100% - ATS optimization complete. Score: ${previousScore}% â†’ ${newATSScore}% (${processingTime}ms)`);

    // Send completion message via SSE
    this.sendProgressUpdate(resumeId, userId, 'complete', 100, 'Optimization completed successfully!');

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison,
      processingTime: processingTime,
      stages: stages
    };

  } catch (error) {
    console.error('ATS optimization with real progress error:', error);
    
    // Send error via SSE
    this.sendProgressUpdate(resumeId, userId, 'error', 0, `Optimization failed: ${error.message}`);
    
    throw error;
  }
}

/**
 * Generate detailed before/after comparison
 */
static generateBeforeAfterComparison(originalData, updatedData) {
  const comparison = {
    scores: {
      before: {
        overallScore: originalData.analysis?.overallScore || 0,
        atsCompatibility: originalData.analysis?.atsCompatibility || 0
      },
      after: {
        overallScore: updatedData.analysis?.overallScore || 0,
        atsCompatibility: updatedData.analysis?.atsCompatibility || 0
      }
    },
    changes: [],
    summary: {
      sectionsModified: 0,
      improvementsCount: 0,
      keywordsAdded: 0
    }
  };

  // Compare experience section
  const originalExp = originalData.parsedData?.experience || [];
  const updatedExp = updatedData.parsedData?.experience || [];

  originalExp.forEach((origJob, index) => {
    if (updatedExp[index]) {
      const updatedJob = updatedExp[index];
      
      // Compare highlights
      if (JSON.stringify(origJob.highlights) !== JSON.stringify(updatedJob.highlights)) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'highlights',
          before: origJob.highlights || [],
          after: updatedJob.highlights || [],
          changeType: 'enhanced',
          impact: 'Improved quantification and ATS keywords'
        });
        comparison.summary.sectionsModified++;
      }

      // Compare description
      if (origJob.description !== updatedJob.description) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'description',
          before: origJob.description || '',
          after: updatedJob.description || '',
          changeType: 'optimized',
          impact: 'Enhanced for ATS compatibility'
        });
      }
    }
  });

  // Compare skills section
  const originalSkills = originalData.parsedData?.skills || [];
  const updatedSkills = updatedData.parsedData?.skills || [];
  
  if (JSON.stringify(originalSkills) !== JSON.stringify(updatedSkills)) {
    comparison.changes.push({
      section: 'skills',
      field: 'skills',
      before: originalSkills,
      after: updatedSkills,
      changeType: 'expanded',
      impact: 'Added relevant keywords and skills'
    });
    comparison.summary.sectionsModified++;
  }

  // Calculate improvement metrics
  comparison.summary.improvementsCount = comparison.changes.length;
  comparison.summary.keywordsAdded = this.countNewKeywords(originalData, updatedData);

  // Generate summary text
  const scoreImprovement = comparison.scores.after.atsCompatibility - comparison.scores.before.atsCompatibility;
  comparison.summaryText = `Enhanced ${comparison.summary.sectionsModified} section${comparison.summary.sectionsModified !== 1 ? 's' : ''} with ${comparison.summary.improvementsCount} improvement${comparison.summary.improvementsCount !== 1 ? 's' : ''}${scoreImprovement > 0 ? `, boosting ATS score by ${scoreImprovement}%` : ''}`;

  return comparison;
}

/**
 * Count new keywords added during optimization
 */
static countNewKeywords(originalData, updatedData) {
  const originalText = JSON.stringify(originalData.parsedData).toLowerCase();
  const updatedText = JSON.stringify(updatedData.parsedData).toLowerCase();
  
  // Simple keyword counting - could be enhanced with more sophisticated analysis
  const commonKeywords = ['api', 'cloud', 'agile', 'leadership', 'development', 'management', 'strategy', 'security'];
  
  let newKeywords = 0;
  commonKeywords.forEach(keyword => {
    const originalCount = (originalText.match(new RegExp(keyword, 'g')) || []).length;
    const updatedCount = (updatedText.match(new RegExp(keyword, 'g')) || []).length;
    if (updatedCount > originalCount) {
      newKeywords += (updatedCount - originalCount);
    }
  });
  
  return newKeywords;
}

/**
 * Generate detailed before/after comparison
 */
static generateBeforeAfterComparison(originalData, updatedData) {
  const comparison = {
    scores: {
      before: {
        overallScore: originalData.analysis?.overallScore || 0,
        atsCompatibility: originalData.analysis?.atsCompatibility || 0
      },
      after: {
        overallScore: updatedData.analysis?.overallScore || 0,
        atsCompatibility: updatedData.analysis?.atsCompatibility || 0
      }
    },
    changes: [],
    summary: {
      sectionsModified: 0,
      improvementsCount: 0,
      keywordsAdded: 0
    }
  };

  // Compare experience section
  const originalExp = originalData.parsedData?.experience || [];
  const updatedExp = updatedData.parsedData?.experience || [];

  originalExp.forEach((origJob, index) => {
    if (updatedExp[index]) {
      const updatedJob = updatedExp[index];
      
      // Compare highlights
      if (JSON.stringify(origJob.highlights) !== JSON.stringify(updatedJob.highlights)) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'highlights',
          before: origJob.highlights || [],
          after: updatedJob.highlights || [],
          changeType: 'enhanced',
          impact: 'Improved quantification and ATS keywords'
        });
        comparison.summary.sectionsModified++;
      }

      // Compare description
      if (origJob.description !== updatedJob.description) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'description',
          before: origJob.description || '',
          after: updatedJob.description || '',
          changeType: 'optimized',
          impact: 'Enhanced for ATS compatibility'
        });
      }
    }
  });

  // Compare skills section
  const originalSkills = originalData.parsedData?.skills || [];
  const updatedSkills = updatedData.parsedData?.skills || [];
  
  if (JSON.stringify(originalSkills) !== JSON.stringify(updatedSkills)) {
    comparison.changes.push({
      section: 'skills',
      field: 'skills',
      before: originalSkills,
      after: updatedSkills,
      changeType: 'expanded',
      impact: 'Added relevant keywords and skills'
    });
    comparison.summary.sectionsModified++;
  }

  // Calculate improvement metrics
  comparison.summary.improvementsCount = comparison.changes.length;
  comparison.summary.keywordsAdded = this.countNewKeywords(originalData, updatedData);

  // Generate summary text
  const scoreImprovement = comparison.scores.after.atsCompatibility - comparison.scores.before.atsCompatibility;
  comparison.summaryText = `Enhanced ${comparison.summary.sectionsModified} section${comparison.summary.sectionsModified !== 1 ? 's' : ''} with ${comparison.summary.improvementsCount} improvement${comparison.summary.improvementsCount !== 1 ? 's' : ''}${scoreImprovement > 0 ? `, boosting ATS score by ${scoreImprovement}%` : ''}`;

  return comparison;
}

/**
 * Count new keywords added during optimization
 */
static countNewKeywords(originalData, updatedData) {
  const originalText = JSON.stringify(originalData.parsedData).toLowerCase();
  const updatedText = JSON.stringify(updatedData.parsedData).toLowerCase();
  
  // Simple keyword counting - could be enhanced with more sophisticated analysis
  const commonKeywords = ['api', 'cloud', 'agile', 'leadership', 'development', 'management', 'strategy', 'security'];
  
  let newKeywords = 0;
  commonKeywords.forEach(keyword => {
    const originalCount = (originalText.match(new RegExp(keyword, 'g')) || []).length;
    const updatedCount = (updatedText.match(new RegExp(keyword, 'g')) || []).length;
    if (updatedCount > originalCount) {
      newKeywords += (updatedCount - originalCount);
    }
  });
  
  return newKeywords;
}

  /**
   * Generate ATS optimization suggestions
   */
  static async generateATSOptimizations(resumeData, targetJob) {
    try {
      let prompt = `You are an ATS (Applicant Tracking System) optimization expert. Analyze this resume and provide specific optimizations to improve ATS compatibility.

CURRENT RESUME DATA:
${JSON.stringify(resumeData, null, 2)}`;

      if (targetJob) {
        prompt += `\n\nTARGET JOB:
Title: ${targetJob.title}
Company: ${targetJob.company}
Description: ${targetJob.description}`;
      }

      prompt += `

Provide ATS optimizations in this JSON format:
{
  "optimizations": [
    {
      "section": "summary|experience|skills|education|etc",
      "type": "keyword_addition|format_improvement|section_enhancement|ats_formatting",
      "change": "specific change to make",
      "reason": "why this improves ATS score",
      "keywords": ["relevant", "keywords", "to", "add"],
      "priority": "high|medium|low"
    }
  ],
  "atsImprovements": {
    "keywordDensity": "improvements needed",
    "formatting": "formatting changes",
    "structure": "structural improvements",
    "content": "content enhancements"
  }
}

Focus on:
1. Adding relevant keywords naturally
2. Improving section headers for ATS parsing
3. Optimizing bullet point structure
4. Enhancing skill descriptions
5. Ensuring proper formatting for ATS scanning

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          {
            role: 'system',
            content: 'You are an ATS optimization expert. Provide specific, actionable suggestions to improve resume ATS compatibility. Return only valid JSON.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 1500
      });

      const responseContent = response.choices[0].message.content.trim();
      const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
      const optimizations = JSON.parse(cleanedResponse);

      return optimizations.optimizations || [];

    } catch (error) {
      console.error('Error generating ATS optimizations:', error);
      throw error;
    }
  }
}

module.exports = ResumeEditorService;

================
File: services/resumeParser.service.js
================
// services/resumeParser.service.js
const { GetObjectCommand } = require('@aws-sdk/client-s3');
const { s3Client, S3_BUCKET } = require('../config/s3');
const { openai } = require('../config/openai');
const pdf = require('pdf-parse');
const mammoth = require('mammoth');

/**
 * Parse a resume file and extract structured data using OpenAI
 * @param {string} fileUrl - S3 key for the resume file
 * @param {string} fileType - Type of file (PDF, DOCX, DOC)
 * @returns {Object} Parsed resume data
 */
exports.parseResume = async (fileUrl, fileType) => {
  try {
    console.log(`Parsing resume file: ${fileUrl}, type: ${fileType}`);
    
    // Debug check for S3 bucket configuration
    console.log('S3 bucket config check:', { bucket: S3_BUCKET });
    
    if (!S3_BUCKET) {
      throw new Error('S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.');
    }
    
    // Get file from S3
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: fileUrl
    };
    
    console.log('Getting file from S3:', { bucket: S3_BUCKET, key: fileUrl });
    
    const { Body } = await s3Client.send(new GetObjectCommand(getObjectParams));
    
    // Convert readable stream to buffer
    const chunks = [];
    for await (const chunk of Body) {
      chunks.push(chunk);
    }
    const buffer = Buffer.concat(chunks);
    
    console.log(`File retrieved from S3, size: ${buffer.length} bytes`);
    
    // Extract text based on file type
    let text = '';
    if (fileType === 'PDF') {
      console.log('Parsing PDF file...');
      const pdfData = await pdf(buffer);
      text = pdfData.text;
    } else if (fileType === 'DOCX') {
      console.log('Parsing DOCX file...');
      const result = await mammoth.extractRawText({ buffer });
      text = result.value;
    } else if (fileType === 'DOC') {
      // For DOC files, we would need a different parser
      // This is a placeholder for now
      console.log('DOC parsing not fully implemented');
      text = 'DOC parsing not fully implemented';
    } else {
      throw new Error(`Unsupported file type: ${fileType}`);
    }
    
    console.log(`Text extracted, length: ${text.length} characters`);
    
    // Process the text using OpenAI to extract structured information
    return await processWithOpenAI(text);
  } catch (error) {
    console.error('Error parsing resume:', error);
    throw error;
  }
};

/**
 * Process resume text with OpenAI to extract structured data
 * @param {string} text - Extracted text from resume
 * @returns {Object} Structured resume data
 */
async function processWithOpenAI(text) {
  try {
    console.log('Processing resume text with OpenAI...');
    
    // Check if text is too long for the API
    const maxTokens = 8000; // GPT-4 can handle ~8000 tokens
    // Rough estimation: 1 token ~= 4 characters in English
    if (text.length > maxTokens * 4) {
      console.log('Text is too long, truncating...');
      text = text.substring(0, maxTokens * 4);
    }
    
    // Prompt for OpenAI to extract structured data from the resume
    const prompt = `
    Extract structured information from the following resume text. 
    Provide the information in JSON format with the following structure:
    {
      "contactInfo": {
        "name": "",
        "email": "",
        "phone": "",
        "location": "",
        "websites": []
      },
      "summary": "",
      "experience": [
        {
          "company": "",
          "title": "",
          "location": "",
          "startDate": "",
          "endDate": "",
          "description": "",
          "highlights": [],
          "skills": []
        }
      ],
      "education": [
        {
          "institution": "",
          "degree": "",
          "field": "",
          "startDate": "",
          "endDate": "",
          "gpa": null,
          "highlights": []
        }
      ],
      "skills": [
        {
          "name": "",
          "level": "",
          "yearsOfExperience": null
        }
      ],
      "certifications": [
        {
          "name": "",
          "issuer": "",
          "dateObtained": "",
          "validUntil": ""
        }
      ],
      "languages": [
        {
          "language": "",
          "proficiency": ""
        }
      ],
      "projects": [
        {
          "name": "",
          "description": "",
          "url": "",
          "startDate": "",
          "endDate": "",
          "skills": []
        }
      ]
    }

    Extract all the information accurately from the resume. For dates, use the format YYYY-MM-DD when possible. 
    If information is not available or empty, leave it as an empty string or null. 
    For arrays, if no elements are present, return an empty array [].
    Make sure to include all skills mentioned in each work experience and project.
    For skill levels, use one of: "Beginner", "Intermediate", "Advanced", or "Expert".
    
    IMPORTANT: Return ONLY the JSON object without any markdown formatting, code blocks, or additional text.

    Resume Text:
    ${text}
    `;

    // Call OpenAI API
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: "You are an expert resume parser that extracts structured information from resume text. Be precise and thorough. Return ONLY valid JSON without any markdown formatting or code blocks."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.2,
      max_tokens: 3000,
    });

    // Get the response content
    const responseContent = response.choices[0].message.content.trim();
    
    // Clean up the response - remove any markdown code block syntax
    let cleanedResponse = responseContent;
    
    // If response starts with ```json or ``` and ends with ```, remove these markers
    if (responseContent.startsWith('```json') || responseContent.startsWith('```')) {
      const startIndex = responseContent.indexOf('{');
      const endIndex = responseContent.lastIndexOf('}');
      
      if (startIndex !== -1 && endIndex !== -1) {
        cleanedResponse = responseContent.substring(startIndex, endIndex + 1);
      }
    }
    
    console.log('Cleaned response for parsing:', cleanedResponse.substring(0, 100) + '...');
    
    // Parse the response
    const parsedData = JSON.parse(cleanedResponse);
    console.log('Resume parsing with OpenAI completed successfully');
    
    return parsedData;
  } catch (error) {
    console.error('Error processing with OpenAI:', error);
    
    // Fallback to a simplified parsed data structure
    return {
      contactInfo: {
        name: 'Parsing Error',
        email: '',
        phone: '',
        location: '',
        websites: []
      },
      summary: 'Error parsing resume. Please try again or contact support.',
      experience: [],
      education: [],
      skills: [],
      certifications: [],
      languages: [],
      projects: []
    };
  }
}

================
File: services/resumeTailoring.service.js
================
// services/resumeTailoring.service.js - FIXED FRESH ANALYSIS ISSUE
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');
const { PutObjectCommand, GetObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const { s3Client, S3_BUCKET } = require('../config/s3');
const path = require('path');
const uuid = require('uuid').v4;
const resumeAnalysisService = require('./resumeAnalysis.service');
const PDFDocument = require('pdfkit');

/**
 * Get tailoring recommendations for a resume based on a job
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @returns {Object} Tailoring recommendations
 */
exports.getTailoringRecommendations = async (resumeId, jobId) => {
  try {
    console.log(`Generating tailoring recommendations for resume ${resumeId} to job ${jobId}`);
    
    // Get the resume, job, and any existing match analysis
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Get the match analysis if it exists
    const matchAnalysis = job.matchAnalysis && job.matchAnalysis.resumeId && 
                          job.matchAnalysis.resumeId.toString() === resumeId ? 
                          job.matchAnalysis : null;
    
    console.log('Generating tailoring recommendations with OpenAI');
    
    // Convert data to strings for OpenAI
    const resumeData = JSON.stringify(resume.parsedData, null, 2);
    const jobData = JSON.stringify(job.parsedData, null, 2);
    const matchData = matchAnalysis ? JSON.stringify(matchAnalysis, null, 2) : 'No match analysis available';
    
    // Prompt for OpenAI to generate tailoring recommendations
    const prompt = `
    Generate detailed recommendations for tailoring the following resume to better match the job description.

    Provide the recommendations in JSON format with the following structure:
    {
      "summary": {
        "original": "original summary text",
        "tailored": "tailored summary text"
      },
      "experienceImprovements": [
        {
          "company": "company name",
          "position": "position title",
          "original": ["original bullet point 1", "original bullet point 2"],
          "tailored": ["tailored bullet point 1", "tailored bullet point 2"]
        }
      ],
      "skillsImprovements": {
        "skillsToAdd": ["skill1", "skill2"],
        "skillsToEmphasize": ["skill3", "skill4"]
      },
      "keywordSuggestions": ["keyword1", "keyword2", "keyword3"],
      "formatSuggestions": ["format suggestion 1", "format suggestion 2"],
      "generalAdvice": "General advice for tailoring this resume to this job"
    }

    Return ONLY the JSON without any markdown formatting, code blocks, or additional explanation.
    Focus on tailoring content to highlight experience and skills that are most relevant to the job.
    The tailored content should be truthful and based on the original resume - no fabrication.
    Use relevant keywords and phrases from the job description naturally.
    Prioritize the most important skills and requirements from the job description.
    Keep the tailored version concise, impactful, and achievement-oriented.

    Resume Data:
    ${resumeData}

    Job Data:
    ${jobData}

    Match Analysis:
    ${matchData}
    `;
    
    // Call OpenAI API
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: "You are an expert resume writer specializing in tailoring resumes to specific job descriptions. Return ONLY JSON without markdown formatting or code blocks."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.4,
      max_tokens: 3000,
    });
    
    // Parse the response
    const content = response.choices[0].message.content;
    
    // Extract JSON from the response if it's wrapped in markdown
    let jsonStr = content;
    
    // Handle potential markdown code blocks
    if (content.includes('```')) {
      const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    // Clean up any extra whitespace or newlines
    jsonStr = jsonStr.trim();
    
    // Ensure it's a valid JSON object
    if (!jsonStr.startsWith('{')) {
      jsonStr = '{' + jsonStr.substring(jsonStr.indexOf('"'));
    }
    if (!jsonStr.endsWith('}')) {
      jsonStr = jsonStr.substring(0, jsonStr.lastIndexOf('}') + 1);
    }
    
    // Parse the cleaned JSON
    const recommendations = JSON.parse(jsonStr);
    console.log('Resume tailoring recommendations with OpenAI completed successfully');
    
    return recommendations;
  } catch (error) {
    console.error('Error generating tailoring recommendations with OpenAI:', error);
    
    // Fallback to a simplified recommendations structure
    return {
      summary: {
        original: "Could not retrieve original summary.",
        tailored: "Could not generate tailored summary. Please try again later."
      },
      experienceImprovements: [],
      skillsImprovements: {
        skillsToAdd: ["Technical error occurred while generating recommendations."],
        skillsToEmphasize: []
      },
      keywordSuggestions: ["Please try again later."],
      formatSuggestions: ["Ensure your resume is clear and concise."],
      generalAdvice: "Focus on highlighting relevant experience and skills that match the job requirements."
    };
  }
};

/**
 * Generate a proper PDF from resume data
 * @param {Object} resumeData - The tailored resume data
 * @param {string} resumeName - Name of the resume
 * @param {Object} jobInfo - Job information for context
 * @returns {Buffer} PDF buffer
 */
function generateResumePDF(resumeData, resumeName, jobInfo) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: 'A4'
      });
      
      const buffers = [];
      
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });
      
      // Helper function to add styled text
      const addText = (text, options = {}) => {
        const defaultOptions = {
          fontSize: 11,
          lineGap: 2
        };
        doc.text(text, { ...defaultOptions, ...options });
      };
      
      // Header with contact info
      if (resumeData.contactInfo) {
        doc.fontSize(18).font('Helvetica-Bold')
           .text(resumeData.contactInfo.name || 'Professional Resume', { align: 'center' });
        
        doc.fontSize(10).font('Helvetica')
           .text([
             resumeData.contactInfo.email,
             resumeData.contactInfo.phone,
             resumeData.contactInfo.location
           ].filter(Boolean).join(' | '), { align: 'center' });
        
        doc.moveDown(1);
      }
      
      // Professional Summary
      if (resumeData.summary) {
        doc.fontSize(14).font('Helvetica-Bold').text('PROFESSIONAL SUMMARY');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        doc.fontSize(11).font('Helvetica').text(resumeData.summary, {
          align: 'justify',
          lineGap: 2
        });
        doc.moveDown(1);
      }
      
      // Work Experience
      if (resumeData.experience && resumeData.experience.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('WORK EXPERIENCE');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.experience.forEach((exp, index) => {
          // Job title and company
          doc.fontSize(12).font('Helvetica-Bold')
             .text(`${exp.title || 'Position'} | ${exp.company || 'Company'}`, { continued: false });
          
          // Dates and location
          const dateStr = exp.startDate && exp.endDate 
            ? `${new Date(exp.startDate).toLocaleDateString()} - ${exp.endDate ? new Date(exp.endDate).toLocaleDateString() : 'Present'}`
            : exp.startDate 
              ? `From ${new Date(exp.startDate).toLocaleDateString()}`
              : 'Date not specified';
          
          doc.fontSize(10).font('Helvetica').fillColor('gray')
             .text(`${dateStr}${exp.location ? ' | ' + exp.location : ''}`, { align: 'right' });
          
          doc.fillColor('black').moveDown(0.3);
          
          // Description
          if (exp.description) {
            doc.fontSize(11).font('Helvetica').text(exp.description, { lineGap: 2 });
            doc.moveDown(0.3);
          }
          
          // Highlights/Achievements
          if (exp.highlights && exp.highlights.length > 0) {
            exp.highlights.forEach(highlight => {
              doc.fontSize(11).font('Helvetica')
                 .text(`â€¢ ${highlight}`, { 
                   indent: 15,
                   lineGap: 2,
                   paragraphGap: 2
                 });
            });
          }
          
          // Skills used
          if (exp.skills && exp.skills.length > 0) {
            doc.moveDown(0.3);
            doc.fontSize(10).font('Helvetica-Oblique').fillColor('gray')
               .text(`Technologies: ${exp.skills.join(', ')}`, { lineGap: 2 });
            doc.fillColor('black');
          }
          
          if (index < resumeData.experience.length - 1) {
            doc.moveDown(0.8);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Education
      if (resumeData.education && resumeData.education.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('EDUCATION');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.education.forEach((edu, index) => {
          doc.fontSize(12).font('Helvetica-Bold')
             .text(`${edu.degree || 'Degree'} ${edu.field ? 'in ' + edu.field : ''}`);
          
          doc.fontSize(11).font('Helvetica')
             .text(edu.institution || 'Institution');
          
          if (edu.startDate || edu.endDate) {
            const dateStr = edu.startDate && edu.endDate 
              ? `${new Date(edu.startDate).getFullYear()} - ${new Date(edu.endDate).getFullYear()}`
              : edu.endDate 
                ? new Date(edu.endDate).getFullYear().toString()
                : 'Current';
            
            doc.fontSize(10).font('Helvetica').fillColor('gray')
               .text(dateStr);
            doc.fillColor('black');
          }
          
          if (edu.gpa) {
            doc.fontSize(10).text(`GPA: ${edu.gpa}`);
          }
          
          if (index < resumeData.education.length - 1) {
            doc.moveDown(0.5);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Skills
      if (resumeData.skills && resumeData.skills.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('SKILLS & TECHNOLOGIES');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        const skillsText = resumeData.skills.map(skill => {
          if (typeof skill === 'object' && skill.name) {
            return skill.level ? `${skill.name} (${skill.level})` : skill.name;
          }
          return skill;
        }).join(' â€¢ ');
        
        doc.fontSize(11).font('Helvetica').text(skillsText, { lineGap: 2 });
        doc.moveDown(1);
      }
      
      // Certifications
      if (resumeData.certifications && resumeData.certifications.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('CERTIFICATIONS');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.certifications.forEach((cert, index) => {
          doc.fontSize(11).font('Helvetica-Bold').text(cert.name || 'Certification');
          doc.fontSize(10).font('Helvetica').text(cert.issuer || 'Issuer');
          
          if (cert.dateObtained) {
            doc.fontSize(10).fillColor('gray')
               .text(`Obtained: ${new Date(cert.dateObtained).toLocaleDateString()}`);
            doc.fillColor('black');
          }
          
          if (index < resumeData.certifications.length - 1) {
            doc.moveDown(0.5);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Footer note about tailoring
      doc.fontSize(8).font('Helvetica-Oblique').fillColor('gray')
         .text(`This resume has been AI-tailored for ${jobInfo.title} at ${jobInfo.company}`, {
           align: 'center'
         });
      
      // Finalize PDF
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Create a tailored version of a resume for a job
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @param {Object} tailoringOptions - Options for tailoring
 * @returns {Object} New resume version information
 */
exports.createTailoredResume = async (resumeId, jobId, tailoringOptions) => {
  try {
    console.log(`Creating tailored resume for resumeId: ${resumeId}, jobId: ${jobId}`);
    
    // Get the resume and job
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Get tailoring recommendations if not provided
    const tailoringRecommendations = tailoringOptions?.recommendations || 
                                    await this.getTailoringRecommendations(resumeId, jobId);
    
    // Create a new resume with the tailored data
    const userId = resume.userId;
    
    // Create a unique name for the new resume
    const newResumeName = tailoringOptions?.name || 
                         `[AI Tailored] ${resume.name} for ${job.title} at ${job.company}`;
    
    // Create a deep copy of the original resume's parsed data
    const parsedData = JSON.parse(JSON.stringify(resume.parsedData));
    
    // Apply tailoring recommendations to the parsed data
    // Update summary if available
    if (tailoringRecommendations.summary && 
        tailoringRecommendations.summary.tailored && 
        tailoringRecommendations.summary.tailored !== "Could not generate tailored summary. Please try again later.") {
      parsedData.summary = tailoringRecommendations.summary.tailored;
    }
    
    // Update experience bullet points
    if (tailoringRecommendations.experienceImprovements && 
        tailoringRecommendations.experienceImprovements.length > 0) {
      
      tailoringRecommendations.experienceImprovements.forEach(improvement => {
        // Find the matching experience in the original resume
        const experienceIndex = parsedData.experience.findIndex(exp => 
          exp.company === improvement.company && exp.title === improvement.position);
        
        if (experienceIndex !== -1) {
          // If there are highlights, replace them with the tailored ones
          if (parsedData.experience[experienceIndex].highlights && improvement.tailored) {
            parsedData.experience[experienceIndex].highlights = improvement.tailored;
          }
        }
      });
    }
    
    // Add missing skills
    if (tailoringRecommendations.skillsImprovements && 
        tailoringRecommendations.skillsImprovements.skillsToAdd) {
      
      // Create a set of existing skill names for quick lookup
      const existingSkillNames = new Set(parsedData.skills.map(skill => 
        typeof skill === 'string' ? skill.toLowerCase() : skill.name.toLowerCase()));
      
      // Add new skills that don't already exist
      tailoringRecommendations.skillsImprovements.skillsToAdd.forEach(skill => {
        if (!existingSkillNames.has(skill.toLowerCase())) {
          // If existing skills are objects with name property
          if (parsedData.skills.length > 0 && typeof parsedData.skills[0] === 'object') {
            parsedData.skills.push({
              name: skill,
              level: "Intermediate", // Default level
              yearsOfExperience: null
            });
          } else {
            // If existing skills are just strings
            parsedData.skills.push(skill);
          }
        }
      });
    }
    
    console.log('Generating tailored resume PDF...');
    
    // Generate the tailored resume as a proper PDF
    const pdfBuffer = await generateResumePDF(parsedData, newResumeName, {
      title: job.title,
      company: job.company
    });
    
    // Generate a unique S3 key
    const s3Key = `resumes/${userId}/${uuid()}.pdf`;
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: pdfBuffer,
      ContentType: 'application/pdf'
    };
    
    await s3Client.send(new PutObjectCommand(uploadParams));
    console.log('Tailored resume PDF uploaded to S3:', s3Key);
    
    // Create a new resume document in MongoDB WITHOUT ANALYSIS INITIALLY
    const newResume = new Resume({
      userId,
      name: newResumeName,
      originalFilename: `${newResumeName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`,
      fileUrl: s3Key,
      fileType: 'PDF',
      isActive: false,
      parsedData: parsedData,
      analysis: null, // CRITICAL: Set to null initially to force fresh analysis
      isTailored: true,
      tailoredForJob: {
        jobId: job._id,
        jobTitle: job.title,
        company: job.company,
        originalResumeId: resume._id
      },
      versions: [],
      processingStatus: {
        status: 'analyzing',
        progress: 75,
        message: 'Running fresh AI analysis on tailored resume...',
        updatedAt: new Date()
      }
    });
    
    // CRITICAL: Save the resume FIRST, then run analysis
    await newResume.save();
    console.log('Tailored resume created successfully with ID:', newResume._id);
    
    // CRITICAL: Add a delay to ensure the resume is fully saved before analysis
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // CRITICAL: Run fresh analysis on the tailored resume in a separate process
    console.log('Starting fresh AI analysis for tailored resume...');
    
    try {
      // Force a fresh analysis by calling the service directly
      const analysis = await resumeAnalysisService.analyzeResume(newResume._id);
      
      console.log('Fresh analysis completed:', {
        resumeId: newResume._id,
        overallScore: analysis.overallScore,
        atsCompatibility: analysis.atsCompatibility,
        hasProfileSummary: !!analysis.profileSummary,
        strengthsCount: analysis.strengths?.length || 0
      });
      
      // CRITICAL: Update the resume with the NEW analysis scores
      await Resume.findByIdAndUpdate(newResume._id, {
        $set: {
          analysis: analysis,
          processingStatus: {
            status: 'completed',
            progress: 100,
            message: 'Fresh analysis completed successfully',
            updatedAt: new Date()
          }
        }
      }, { new: true });
      
      console.log('âœ… Fresh analysis saved to database successfully');
      
      // Update the local object for return
      newResume.analysis = analysis;
      newResume.processingStatus = {
        status: 'completed',
        progress: 100,
        message: 'Fresh analysis completed successfully',
        updatedAt: new Date()
      };
      
    } catch (analysisError) {
      console.error('âŒ Error running fresh analysis on tailored resume:', analysisError);
      
      // Update status to show analysis failed
      await Resume.findByIdAndUpdate(newResume._id, {
        $set: {
          analysis: {
            overallScore: 0,
            atsCompatibility: 0,
            profileSummary: { currentRole: "Analysis pending", careerLevel: "Unknown", industries: [], suggestedJobTitles: [], suggestedIndustries: [] },
            strengths: ["Analysis in progress..."],
            weaknesses: ["Analysis in progress..."],
            keywordsSuggestions: ["Analysis in progress..."],
            improvementAreas: []
          },
          processingStatus: {
            status: 'error',
            progress: 50,
            message: 'Fresh analysis failed - please try manual analysis',
            error: analysisError.message,
            updatedAt: new Date()
          }
        }
      });
      
      // Set the error state in the local object
      newResume.analysis = {
        overallScore: 0,
        atsCompatibility: 0,
        profileSummary: { currentRole: "Analysis pending", careerLevel: "Unknown", industries: [], suggestedJobTitles: [], suggestedIndustries: [] },
        strengths: ["Analysis failed - please retry"],
        weaknesses: ["Analysis failed - please retry"],
        keywordsSuggestions: ["Analysis failed - please retry"],
        improvementAreas: []
      };
    }
    
    // AUTOMATIC TRIGGER: Re-match THIS SPECIFIC JOB with the new tailored resume
    console.log('ðŸ”„ Auto-triggering job re-match with new tailored resume...');
    try {
      const jobMatchingService = require('./jobMatching.service');
      
      // Force re-match this specific job with the new tailored resume
      const matchAnalysis = await jobMatchingService.matchResumeWithJob(newResume._id, jobId);
      
      // Update the job's match analysis with the new tailored resume
      job.matchAnalysis = {
        ...matchAnalysis,
        resumeId: newResume._id,
        lastAnalyzed: new Date(),
        analysisVersion: '2.0-tailored-auto',
        tailoredResumeId: newResume._id
      };
      
      await job.save();
      
      console.log('âœ… Job-specific auto re-match completed:', {
        jobId: job._id,
        jobTitle: job.title,
        newScore: `${matchAnalysis.overallScore}%`,
        usedTailoredResume: newResume.name
      });
      
    } catch (rematchError) {
      console.error('âŒ Auto re-match failed (non-critical):', rematchError.message);
      // Still add reference even if re-matching fails
      if (job.matchAnalysis) {
        job.matchAnalysis.tailoredResumeId = newResume._id;
        await job.save();
      }
    }
    
    // Generate a signed URL for downloading
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: s3Key
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
    
    return {
      message: "Tailored resume created successfully with fresh analysis",
      resume: {
        id: newResume._id,
        name: newResume.name,
        originalFilename: newResume.originalFilename,
        fileType: newResume.fileType,
        isTailored: newResume.isTailored,
        downloadUrl: signedUrl,
        analysis: newResume.analysis,
        processingStatus: newResume.processingStatus,
        createdAt: newResume.createdAt
      }
    };
  } catch (error) {
    console.error('Error creating tailored resume:', error);
    throw error;
  }
};

================
File: test-controller.js
================
// backend/test-controller.js - Simple test to verify our controller works
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function testController() {
  try {
    console.log('ðŸ§ª TESTING BACKEND CONTROLLER');
    console.log('==============================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Simulate the exact query from the controller
    const sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
        AND (
          COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $2 OR
          COALESCE(r.title, '') ILIKE $2
        )
      ORDER BY r.first_name ASC
      LIMIT 20 OFFSET 0
    `;

    const queryParams = [userId, `%${query}%`];

    console.log('ðŸ—„ï¸ Testing exact controller query...');
    console.log('ðŸ“ SQL Query:', sqlQuery.replace(/\s+/g, ' ').trim());
    console.log('ðŸ“ Query Params:', queryParams);

    const result = await pool.query(sqlQuery, queryParams);
    
    console.log(`ðŸ“Š Query returned ${result.rows.length} rows`);
    
    if (result.rows.length > 0) {
      console.log('âœ… SUCCESS: Found results!');
      console.log('ðŸ‘¥ Sample results:');
      result.rows.slice(0, 5).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    } else {
      console.log('âŒ PROBLEM: No results found');
    }

    // Test count query
    const countQuery = `
      SELECT COUNT(*) as count FROM recruiters r 
      WHERE r.is_active = true
        AND (
          COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $1 OR
          COALESCE(r.title, '') ILIKE $1
        )
    `;

    const countResult = await pool.query(countQuery, [`%${query}%`]);
    console.log(`ðŸ“Š Count query returned: ${countResult.rows[0].count}`);

    console.log('\nâœ… Test complete!');

  } catch (error) {
    console.error('âŒ Test failed:', error);
  } finally {
    await pool.end();
  }
}

testController();

================
File: test-extraction.js
================
// test-extraction.js - Quick test script for the new extraction methods
const jobBoardAPIsService = require('./services/jobBoardAPIs.service');
const headlessScraperService = require('./services/headlessScraper.service');

// Test configuration
const testCompanies = [
  {
    name: 'Lever Test Company',
    careerUrl: 'https://jobs.lever.co/example',
    industry: 'Technology'
  },
  {
    name: 'Simple Tech Company',
    careerUrl: 'https://example-tech.com/careers',
    industry: 'Technology'
  }
];

const testCareerProfile = {
  jobTitles: ['Software Engineer', 'Frontend Developer', 'Product Manager'],
  industries: ['Technology', 'Software'],
  experienceLevel: 'mid',
  keySkills: ['JavaScript', 'React', 'Node.js']
};

async function testExtractionMethods() {
  console.log('ðŸ§ª Testing extraction methods...\n');
  
  for (const company of testCompanies) {
    console.log(`\nðŸ¢ Testing ${company.name}...`);
    console.log(`URL: ${company.careerUrl}`);
    
    // Test 1: ATS Platform Detection
    console.log('\n1ï¸âƒ£ Testing ATS Platform Detection...');
    try {
      const atsInfo = await jobBoardAPIsService.detectATSPlatform(company.careerUrl);
      console.log('ATS Detection Result:', {
        platform: atsInfo.platform,
        hasAPI: atsInfo.hasAPI,
        slug: atsInfo.slug,
        apiUrl: atsInfo.apiUrl ? atsInfo.apiUrl.substring(0, 100) + '...' : null
      });
    } catch (error) {
      console.error('ATS Detection Error:', error.message);
    }
    
    // Test 2: Free APIs
    console.log('\n2ï¸âƒ£ Testing Free APIs...');
    try {
      const apiResult = await jobBoardAPIsService.tryFreeAPIs(company, testCareerProfile);
      console.log('API Result:', {
        success: apiResult.success,
        method: apiResult.method,
        platform: apiResult.platform,
        jobsFound: apiResult.jobs?.length || 0
      });
      
      if (apiResult.jobs && apiResult.jobs.length > 0) {
        console.log('Sample job:', {
          title: apiResult.jobs[0].title,
          company: apiResult.jobs[0].company,
          location: apiResult.jobs[0].location
        });
      }
    } catch (error) {
      console.error('API Test Error:', error.message);
    }
    
    // Test 3: Pattern Scraping (only test for non-real URLs to avoid hitting real sites)
    if (company.careerUrl.includes('example')) {
      console.log('\n3ï¸âƒ£ Testing Pattern Scraping...');
      try {
        const patternResult = await headlessScraperService.tryPatternScraping(company, testCareerProfile);
        console.log('Pattern Scraping Result:', {
          success: patternResult.success,
          method: patternResult.method,
          jobsFound: patternResult.jobs?.length || 0,
          error: patternResult.error
        });
      } catch (error) {
        console.error('Pattern Scraping Error:', error.message);
      }
    }
    
    console.log('\n' + '='.repeat(50));
  }
  
  // Test 4: Job relevance filtering
  console.log('\n4ï¸âƒ£ Testing Job Relevance Filtering...');
  
  const testJobs = [
    { title: 'Senior Software Engineer', company: 'TestCorp' },
    { title: 'Frontend Developer', company: 'TestCorp' },
    { title: 'Product Manager', company: 'TestCorp' },
    { title: 'Marketing Specialist', company: 'TestCorp' },
    { title: 'Data Scientist', company: 'TestCorp' },
    { title: 'Junior Developer', company: 'TestCorp' }
  ];
  
  console.log('Test jobs:', testJobs.map(j => j.title));
  console.log('Career profile targets:', testCareerProfile.jobTitles);
  
  // Import the filtering function (you'll need to expose this from the service)
  // This is just for testing - in real implementation it's internal
  
  await headlessScraperService.cleanup();
  console.log('\nâœ… Testing completed!');
}

// Helper function to test just ATS detection without hitting APIs
async function quickATSTest() {
  console.log('ðŸ” Quick ATS Detection Test...\n');
  
  const testUrls = [
    'https://boards.greenhouse.io/company',
    'https://jobs.lever.co/company',
    'https://company.myworkdayjobs.com/careers',
    'https://company.bamboohr.com/jobs/',
    'https://regular-company.com/careers'
  ];
  
  for (const url of testUrls) {
    console.log(`Testing: ${url}`);
    try {
      const result = await jobBoardAPIsService.detectATSPlatform(url);
      console.log(`  Platform: ${result.platform}, Has API: ${result.hasAPI}, Slug: ${result.slug}\n`);
    } catch (error) {
      console.log(`  Error: ${error.message}\n`);
    }
  }
}

// Run the appropriate test
if (process.argv.includes('--quick')) {
  quickATSTest().catch(console.error);
} else if (process.argv.includes('--ats-only')) {
  quickATSTest().catch(console.error);
} else {
  testExtractionMethods().catch(console.error);
}

module.exports = { testExtractionMethods, quickATSTest };

================
File: test-s3.js
================
// test-s3.js
const AWS = require('aws-sdk');
const fs = require('fs');
require('dotenv').config();

// Configure AWS SDK
AWS.config.update({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1'
});

const s3 = new AWS.S3();
const bucketName = process.env.AWS_BUCKET_NAME;

// Create a test file
const testFilePath = './test-file.txt';
fs.writeFileSync(testFilePath, 'This is a test file for S3 upload');

// Test bucket connection and file upload
async function testS3() {
  try {
    // Check if bucket exists
    await s3.headBucket({ Bucket: bucketName }).promise();
    console.log(`âœ… Successfully connected to bucket: ${bucketName}`);
    
    // Upload a test file
    const fileContent = fs.readFileSync(testFilePath);
    const params = {
      Bucket: bucketName,
      Key: 'test-file.txt',
      Body: fileContent
    };
    
    const uploadResult = await s3.upload(params).promise();
    console.log(`âœ… Successfully uploaded file to: ${uploadResult.Location}`);
    
    // List files in bucket
    const listResult = await s3.listObjectsV2({ Bucket: bucketName }).promise();
    console.log('Files in bucket:');
    listResult.Contents.forEach(item => {
      console.log(` - ${item.Key} (${item.Size} bytes)`);
    });
    
    // Clean up - delete test file
    await s3.deleteObject({ Bucket: bucketName, Key: 'test-file.txt' }).promise();
    console.log('âœ… Successfully deleted test file');
    
    console.log('All S3 tests passed! Your configuration is working.');
  } catch (error) {
    console.error('âŒ S3 Test Error:', error);
  } finally {
    // Delete local test file
    fs.unlinkSync(testFilePath);
  }
}

testS3();

================
File: tests/test-auth.js
================
// backend/tests/test-auth.js
require('dotenv').config();
const axios = require('axios');
const mongoose = require('mongoose');
const connectMongoDB = require('../config/mongodb');

const API_URL = 'http://localhost:5000/api';

// Helper function to make API requests
const api = axios.create({
  baseURL: API_URL,
  withCredentials: true
});

// Test user details
const testUser = {
  firstName: 'Test',
  lastName: 'User',
  email: `testuser${Date.now()}@example.com`,
  password: 'Test@123456'
};

let token = null;

const runTests = async () => {
  try {
    console.log('Starting authentication tests...');
    
    // Connect to MongoDB
    await connectMongoDB();
    
    // Clean up any previous test users
    await mongoose.connection.collection('users').deleteMany({
      email: { $regex: /testuser.*@example.com/ }
    });
    
    // Test registration
    console.log('\nTesting user registration...');
    const registrationResponse = await api.post('/auth/register', testUser);
    console.log('Registration response status:', registrationResponse.status);
    console.log('Registration data:', registrationResponse.data);
    
    // Save token
    token = registrationResponse.data.token;
    
    // Test get current user
    console.log('\nTesting get current user...');
    const meResponse = await api.get('/auth/me', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    console.log('Get me response status:', meResponse.status);
    console.log('User data:', meResponse.data);
    
    // Test logout
    console.log('\nTesting logout...');
    const logoutResponse = await api.post('/auth/logout', {}, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    console.log('Logout response status:', logoutResponse.status);
    console.log('Logout data:', logoutResponse.data);
    
    // Test login
    console.log('\nTesting login...');
    const loginResponse = await api.post('/auth/login', {
      email: testUser.email,
      password: testUser.password
    });
    console.log('Login response status:', loginResponse.status);
    console.log('Login data:', loginResponse.data);
    
    // Save new token
    token = loginResponse.data.token;
    
    // Test updating user details
    console.log('\nTesting update user details...');
    const updateResponse = await api.put('/auth/update-details', 
      { firstName: 'Updated', lastName: 'User' },
      {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }
    );
    console.log('Update details response status:', updateResponse.status);
    console.log('Updated user data:', updateResponse.data);
    
    // Test updating password
    console.log('\nTesting update password...');
    const updatePasswordResponse = await api.put('/auth/update-password', 
      { 
        currentPassword: testUser.password,
        newPassword: 'NewTest@123456'
      },
      {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }
    );
    console.log('Update password response status:', updatePasswordResponse.status);
    console.log('Update password data:', updatePasswordResponse.data);
    
    // Test login with new password
    console.log('\nTesting login with new password...');
    const newLoginResponse = await api.post('/auth/login', {
      email: testUser.email,
      password: 'NewTest@123456'
    });
    console.log('New login response status:', newLoginResponse.status);
    console.log('New login data:', newLoginResponse.data);
    
    console.log('\nAll authentication tests completed successfully!');
  } catch (error) {
    console.error('Error in authentication tests:', error.message);
    if (error.response) {
      console.error('Response data:', error.response.data);
      console.error('Response status:', error.response.status);
    }
  } finally {
    // Clean up test user
    if (mongoose.connection.readyState === 1) {
      await mongoose.connection.collection('users').deleteMany({
        email: testUser.email
      });
      console.log('\nTest user cleaned up');
      
      // Close the MongoDB connection
      await mongoose.connection.close();
      console.log('MongoDB connection closed');
    }
    
    process.exit(0);
  }
};

runTests();

================
File: tests/test-neon-connection.js
================
// backend/tests/test-neon-connection.js
require('dotenv').config();
const db = require('../config/postgresql');

const testNeonConnection = async () => {
  try {
    // Test basic connection
    const result = await db.query('SELECT NOW() as current_time');
    console.log('Connection successful!');
    console.log('Current server time:', result.rows[0].current_time);
    
    // Test creating a simple table
    await db.query(`
      CREATE TABLE IF NOT EXISTS connection_test (
        id SERIAL PRIMARY KEY,
        test_message TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('Test table created successfully');
    
    // Insert a test record
    const insertResult = await db.query(
      'INSERT INTO connection_test (test_message) VALUES ($1) RETURNING *',
      ['Connection test from job application platform']
    );
    console.log('Test record inserted:', insertResult.rows[0]);
    
    // Query the test record
    const records = await db.query('SELECT * FROM connection_test');
    console.log('All test records:', records.rows);
    
    console.log('Neon PostgreSQL connection test completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('Neon PostgreSQL connection test failed:', error);
    console.error('Error details:', error.message);
    process.exit(1);
  }
};

testNeonConnection();

================
File: utils/email-templates.js
================
// backend/utils/email-templates.js
/**
 * Generate verification email HTML
 * @param {string} firstName User's first name
 * @param {string} verificationUrl Verification URL
 * @returns {string} HTML email content
 */
exports.generateVerificationEmail = (firstName, verificationUrl) => {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Verify Your Email</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .logo {
            text-align: center;
            margin-bottom: 20px;
          }
          .container {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
          }
          .button {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 20px 0;
          }
          .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #777;
            text-align: center;
          }
        </style>
      </head>
      <body>
        <div class="logo">
          <h2>Job Application Platform</h2>
        </div>
        <div class="container">
          <h2>Hello ${firstName},</h2>
          <p>Welcome to the Job Application Platform! Please verify your email address to get started.</p>
          <p>This link will expire in 24 hours.</p>
          <a href="${verificationUrl}" class="button">Verify Email Address</a>
          <p>If you didn't create an account, you can safely ignore this email.</p>
        </div>
        <div class="footer">
          <p>&copy; 2025 Job Application Platform. All rights reserved.</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </body>
      </html>
    `;
  };
  
  /**
   * Generate password reset email HTML
   * @param {string} firstName User's first name
   * @param {string} resetUrl Reset URL
   * @returns {string} HTML email content
   */
  exports.generatePasswordResetEmail = (firstName, resetUrl) => {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Reset Your Password</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .logo {
            text-align: center;
            margin-bottom: 20px;
          }
          .container {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
          }
          .button {
            display: inline-block;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 20px 0;
          }
          .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #777;
            text-align: center;
          }
        </style>
      </head>
      <body>
        <div class="logo">
          <h2>Job Application Platform</h2>
        </div>
        <div class="container">
          <h2>Hello ${firstName},</h2>
          <p>We received a request to reset your password. Click the button below to create a new password.</p>
          <p>This link will expire in 10 minutes.</p>
          <a href="${resetUrl}" class="button">Reset Password</a>
          <p>If you didn't request a password reset, you can safely ignore this email.</p>
        </div>
        <div class="footer">
          <p>&copy; 2025 Job Application Platform. All rights reserved.</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </body>
      </html>
    `;
  };

================
File: utils/jobBoardPatterns.js
================
// utils/jobBoardPatterns.js
/**
 * Pattern-based scraping for career pages
 * Covers ~35% additional companies with predictable patterns
 */

// Common CSS selectors for job listings
const CSS_SELECTORS = {
  jobLinks: [
    'a[href*="/job/"]',
    'a[href*="/jobs/"]',
    'a[href*="/career/"]',
    'a[href*="/careers/"]',
    'a[href*="/position/"]',
    'a[href*="/opening/"]',
    '.job-link a',
    '.job-item a',
    '.position-link a',
    '.career-item a',
    '[data-job-id] a',
    '.job-listing a',
    '.job-card a',
    '.position-card a'
  ],
  
  jobTitles: [
    '.job-title',
    '.position-title',
    '.role-title',
    'h2 a',
    'h3 a',
    '[data-job-title]',
    '.title a',
    '.job-name',
    '.position-name'
  ],
  
  jobDescriptions: [
    '.job-description',
    '.position-description',
    '.job-content',
    '.job-details',
    '.position-details',
    '.description',
    '.content'
  ],
  
  locations: [
    '.job-location',
    '.position-location',
    '.location',
    '[data-location]',
    '.office-location',
    '.work-location'
  ],
  
  departments: [
    '.job-department',
    '.department',
    '.team',
    '[data-department]',
    '.job-category',
    '.category'
  ]
};

// URL patterns for different career page types
const URL_PATTERNS = {
  workday: {
    basePattern: /myworkdayjobs\.com\/([^\/]+)/,
    jobUrlPattern: /myworkdayjobs\.com\/[^\/]+\/job\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://${company}.myworkdayjobs.com/${company}/search`,
    selectors: {
      jobLinks: 'a[data-automation-id="jobTitle"]',
      jobTitles: '[data-automation-id="jobTitle"]',
      locations: '[data-automation-id="locations"]',
      departments: '[data-automation-id="jobCategory"]'
    }
  },
  
  bamboohr: {
    basePattern: /bamboohr\.com\/jobs\/([^\/]+)/,
    jobUrlPattern: /bamboohr\.com\/jobs\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://${company}.bamboohr.com/jobs/`,
    selectors: {
      jobLinks: '.job-board-item a',
      jobTitles: '.job-board-item h3',
      locations: '.job-board-item .location',
      departments: '.job-board-item .department'
    }
  },
  
  smartrecruiters: {
    basePattern: /jobs\.smartrecruiters\.com\/([^\/]+)/,
    jobUrlPattern: /jobs\.smartrecruiters\.com\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://jobs.smartrecruiters.com/${company}`,
    selectors: {
      jobLinks: '.opening-job a',
      jobTitles: '.opening-job h4',
      locations: '.opening-job .location',
      departments: '.opening-job .department'
    }
  },
  
  jobvite: {
    basePattern: /jobs\.jobvite\.com\/([^\/]+)/,
    jobUrlPattern: /jobs\.jobvite\.com\/[^\/]+\/job\/([^\/]+)/,
    searchEndpoint: (company) => `https://jobs.jobvite.com/${company}/search?c=&l=&t=&s=`,
    selectors: {
      jobLinks: '.jv-job-list-item a',
      jobTitles: '.jv-job-list-item h3',
      locations: '.jv-job-list-item .location',
      departments: '.jv-job-list-item .department'
    }
  },
  
  icims: {
    basePattern: /careers\.icims\.com\/jobs\/([^\/]+)/,
    jobUrlPattern: /careers\.icims\.com\/jobs\/\d+\/job/,
    searchEndpoint: (company) => `https://careers.icims.com/jobs/search?ss=1&searchCompany=${company}`,
    selectors: {
      jobLinks: '.iCIMS_JobsTable a',
      jobTitles: '.iCIMS_JobsTable .title',
      locations: '.iCIMS_JobsTable .location',
      departments: '.iCIMS_JobsTable .department'
    }
  },
  
  // Custom corporate career pages
  custom: {
    commonSelectors: CSS_SELECTORS,
    urlIndicators: [
      '/careers',
      '/jobs',
      '/work-with-us',
      '/join-us',
      '/employment',
      '/opportunities'
    ]
  }
};

// Common job title patterns for filtering
const JOB_TITLE_PATTERNS = {
  software: [
    'software engineer',
    'software developer',
    'full stack',
    'frontend',
    'backend',
    'web developer',
    'mobile developer',
    'devops',
    'sre'
  ],
  
  product: [
    'product manager',
    'product owner',
    'product marketing',
    'technical product',
    'senior product'
  ],
  
  data: [
    'data scientist',
    'data engineer',
    'data analyst',
    'machine learning',
    'ai engineer',
    'analytics'
  ],
  
  design: [
    'ux designer',
    'ui designer',
    'product designer',
    'graphic designer',
    'visual designer'
  ],
  
  marketing: [
    'marketing manager',
    'growth marketing',
    'digital marketing',
    'content marketing',
    'marketing specialist'
  ],
  
  sales: [
    'sales manager',
    'account executive',
    'sales development',
    'business development',
    'sales representative'
  ]
};

// Experience level indicators
const EXPERIENCE_INDICATORS = {
  entry: [
    'entry level',
    'junior',
    'associate',
    'new grad',
    'graduate',
    '0-2 years',
    'early career'
  ],
  
  mid: [
    'mid level',
    'intermediate',
    '3-5 years',
    '2-4 years',
    'experienced'
  ],
  
  senior: [
    'senior',
    'sr.',
    'lead',
    'principal',
    '5+ years',
    '7+ years',
    'expert'
  ],
  
  executive: [
    'director',
    'manager',
    'head of',
    'vp',
    'vice president',
    'chief',
    'executive'
  ]
};

/**
 * Detect career page type from URL
 * @param {string} url - Career page URL
 * @returns {Object} { type, pattern, config }
 */
exports.detectCareerPageType = (url) => {
  const lowerUrl = url.toLowerCase();
  
  // Check for known ATS patterns
  for (const [type, config] of Object.entries(URL_PATTERNS)) {
    if (type === 'custom') continue;
    
    if (config.basePattern && config.basePattern.test(url)) {
      return {
        type,
        pattern: config.basePattern,
        config,
        isKnownATS: true
      };
    }
  }
  
  // Check for custom corporate career pages
  const hasCareerIndicator = URL_PATTERNS.custom.urlIndicators.some(
    indicator => lowerUrl.includes(indicator)
  );
  
  if (hasCareerIndicator) {
    return {
      type: 'custom',
      pattern: null,
      config: URL_PATTERNS.custom,
      isKnownATS: false
    };
  }
  
  return {
    type: 'unknown',
    pattern: null,
    config: null,
    isKnownATS: false
  };
};

/**
 * Extract company identifier from URL
 * @param {string} url - Career page URL
 * @param {string} type - Career page type
 * @returns {string} Company identifier
 */
exports.extractCompanyId = (url, type) => {
  const config = URL_PATTERNS[type];
  if (!config || !config.basePattern) {
    return null;
  }
  
  const match = url.match(config.basePattern);
  return match ? match[1] : null;
};

/**
 * Get CSS selectors for a career page type
 * @param {string} type - Career page type
 * @returns {Object} CSS selectors object
 */
exports.getSelectorsForType = (type) => {
  const config = URL_PATTERNS[type];
  if (!config) {
    return CSS_SELECTORS;
  }
  
  return config.selectors || CSS_SELECTORS;
};

/**
 * Generate search endpoint URL for known ATS
 * @param {string} type - ATS type
 * @param {string} companyId - Company identifier
 * @returns {string} Search endpoint URL
 */
exports.generateSearchEndpoint = (type, companyId) => {
  const config = URL_PATTERNS[type];
  if (!config || !config.searchEndpoint) {
    return null;
  }
  
  return config.searchEndpoint(companyId);
};

/**
 * Check if job title matches career profile
 * @param {string} jobTitle - Job title to check
 * @param {Object} careerProfile - User career profile
 * @returns {Object} { isMatch, score, matchedCategory }
 */
exports.isJobTitleRelevant = (jobTitle, careerProfile) => {
  if (!jobTitle || !careerProfile) {
    return { isMatch: false, score: 0, matchedCategory: null };
  }
  
  const lowerTitle = jobTitle.toLowerCase();
  
  // Check against target job titles from career profile
  if (careerProfile.jobTitles) {
    for (const targetTitle of careerProfile.jobTitles) {
      const targetLower = targetTitle.toLowerCase();
      const titleWords = targetLower.split(' ');
      
      // Calculate word overlap
      const matchedWords = titleWords.filter(word => 
        word.length > 2 && lowerTitle.includes(word)
      );
      
      if (matchedWords.length > 0) {
        const score = Math.round((matchedWords.length / titleWords.length) * 100);
        if (score >= 50) { // At least 50% word match
          return { 
            isMatch: true, 
            score, 
            matchedCategory: 'direct_title_match',
            matchedTitle: targetTitle
          };
        }
      }
    }
  }
  
  // Check against job category patterns
  for (const [category, patterns] of Object.entries(JOB_TITLE_PATTERNS)) {
    for (const pattern of patterns) {
      if (lowerTitle.includes(pattern)) {
        // Check if this category aligns with user's experience
        if (careerProfile.industries && 
            careerProfile.industries.some(industry => 
              industry.toLowerCase().includes(category) ||
              category === 'software' && industry.toLowerCase().includes('tech')
            )) {
          return { 
            isMatch: true, 
            score: 70, 
            matchedCategory: category,
            matchedPattern: pattern
          };
        }
      }
    }
  }
  
  return { isMatch: false, score: 0, matchedCategory: null };
};

/**
 * Check if experience level matches career profile
 * @param {string} jobTitle - Job title or description
 * @param {Object} careerProfile - User career profile
 * @returns {boolean} Whether experience level is appropriate
 */
exports.isExperienceLevelAppropriate = (jobTitle, careerProfile) => {
  if (!jobTitle || !careerProfile || !careerProfile.experienceLevel) {
    return true; // Default to include if unclear
  }
  
  const lowerTitle = jobTitle.toLowerCase();
  const userLevel = careerProfile.experienceLevel.toLowerCase();
  
  // Check for experience indicators in job title
  for (const [level, indicators] of Object.entries(EXPERIENCE_INDICATORS)) {
    if (indicators.some(indicator => lowerTitle.includes(indicator))) {
      // Match experience levels appropriately
      if (userLevel === 'entry' && ['mid', 'senior', 'executive'].includes(level)) {
        return false; // Entry level shouldn't see senior roles
      }
      if (userLevel === 'mid' && level === 'executive') {
        return false; // Mid level shouldn't see executive roles
      }
      break;
    }
  }
  
  return true;
};

/**
 * Validate if URL is a direct job posting
 * @param {string} url - URL to validate
 * @returns {boolean} Whether URL points to a specific job
 */
exports.isDirectJobPostingUrl = (url) => {
  if (!url || typeof url !== 'string') {
    return false;
  }
  
  const lowerUrl = url.toLowerCase();
  
  // Invalid patterns (job boards, not specific jobs)
  const invalidPatterns = [
    /\/embed\/job_board/,
    /job_board\?for=/,
    /\/careers\/?$/,
    /\/jobs\/?$/,
    /\/careers\/all/,
    /\/careers\/search/,
    /\/careers\/openings\/?$/
  ];
  
  if (invalidPatterns.some(pattern => pattern.test(url))) {
    return false;
  }
  
  // Valid job posting patterns
  const validPatterns = [
    /\/job\/\d+/,
    /\/jobs\/\d+/,
    /\/careers\/\d+/,
    /\/positions\/\d+/,
    /\/job-description\/?\?.*id=/,
    /\/careers\/job\/[^\/]+/,
    /\/jobs\/[^\/\?]+$/,
    /\/position\/[^\/\?]+$/,
    /\/openings\/[^\/\?]+$/,
    /job-id[=_-]\d+/,
    /position[_-]id[=_-]\d+/,
    /req[_-]?\d+/
  ];
  
  return validPatterns.some(pattern => pattern.test(url));
};

/**
 * Get all supported ATS types
 * @returns {Array} List of supported ATS types
 */
exports.getSupportedATS = () => {
  return Object.keys(URL_PATTERNS).filter(type => type !== 'custom');
};

/**
 * Get job category from title
 * @param {string} jobTitle - Job title
 * @returns {string} Job category
 */
exports.getJobCategory = (jobTitle) => {
  if (!jobTitle) return 'general';
  
  const lowerTitle = jobTitle.toLowerCase();
  
  for (const [category, patterns] of Object.entries(JOB_TITLE_PATTERNS)) {
    if (patterns.some(pattern => lowerTitle.includes(pattern))) {
      return category;
    }
  }
  
  return 'general';
};

/**
 * Extract job metadata from HTML content
 * @param {Object} $ - Cheerio instance
 * @param {Object} selectors - CSS selectors to use
 * @returns {Array} Array of job metadata objects
 */
exports.extractJobMetadata = ($, selectors) => {
  const jobs = [];
  
  try {
    // Find all job links
    const jobElements = $(selectors.jobLinks.join(', '));
    
    jobElements.each((index, element) => {
      const $job = $(element);
      
      // Extract basic information
      const title = extractText($job, selectors.jobTitles, $);
      const location = extractText($job, selectors.locations, $);
      const department = extractText($job, selectors.departments, $);
      const url = $job.attr('href');
      
      if (title && url) {
        jobs.push({
          title: title.trim(),
          location: location ? location.trim() : 'Not specified',
          department: department ? department.trim() : null,
          url: url.startsWith('http') ? url : null,
          relativeUrl: url.startsWith('/') ? url : null,
          extractedAt: new Date()
        });
      }
    });
    
    console.log(`ðŸ“Š Extracted ${jobs.length} job metadata entries`);
    return jobs;
    
  } catch (error) {
    console.error('Error extracting job metadata:', error);
    return [];
  }
};

/**
 * Helper function to extract text using multiple selectors
 * @param {Object} $element - Cheerio element
 * @param {Array} selectors - Array of CSS selectors to try
 * @param {Object} $ - Cheerio instance
 * @returns {string} Extracted text
 */
function extractText($element, selectors, $) {
  // First try within the element itself
  for (const selector of selectors) {
    const text = $element.find(selector).first().text();
    if (text && text.trim()) {
      return text.trim();
    }
  }
  
  // Then try the element's own text if it matches patterns
  const elementText = $element.text();
  if (elementText && elementText.trim()) {
    return elementText.trim();
  }
  
  // Finally try parent elements
  const $parent = $element.parent();
  for (const selector of selectors) {
    const text = $parent.find(selector).first().text();
    if (text && text.trim()) {
      return text.trim();
    }
  }
  
  return null;
}

/**
 * Build absolute URLs from relative URLs
 * @param {string} baseUrl - Base URL of the career page
 * @param {Array} jobs - Array of job objects with relative URLs
 * @returns {Array} Jobs with absolute URLs
 */
exports.buildAbsoluteUrls = (baseUrl, jobs) => {
  const base = new URL(baseUrl);
  
  return jobs.map(job => {
    if (job.url) {
      // Already absolute URL
      return job;
    }
    
    if (job.relativeUrl) {
      try {
        const absoluteUrl = new URL(job.relativeUrl, base).href;
        return {
          ...job,
          url: absoluteUrl,
          directJobUrl: absoluteUrl
        };
      } catch (error) {
        console.error(`Error building absolute URL for ${job.relativeUrl}:`, error);
        return job;
      }
    }
    
    return job;
  });
};

/**
 * Filter jobs by relevance and experience level
 * @param {Array} jobs - Array of job objects
 * @param {Object} careerProfile - User career profile
 * @returns {Array} Filtered jobs
 */
exports.filterJobsByRelevance = (jobs, careerProfile) => {
  if (!jobs || !Array.isArray(jobs)) {
    return [];
  }
  
  return jobs
    .map(job => {
      // Check title relevance
      const titleRelevance = this.isJobTitleRelevant(job.title, careerProfile);
      const experienceAppropriate = this.isExperienceLevelAppropriate(job.title, careerProfile);
      
      return {
        ...job,
        isRelevant: titleRelevance.isMatch && experienceAppropriate,
        matchScore: titleRelevance.score,
        matchReason: titleRelevance.matchedCategory,
        category: this.getJobCategory(job.title)
      };
    })
    .filter(job => job.isRelevant)
    .sort((a, b) => b.matchScore - a.matchScore) // Sort by match score
    .slice(0, 15); // Limit to top 15 matches
};

/**
 * Common patterns for job posting URLs
 */
exports.JOB_URL_PATTERNS = {
  withId: [
    /\/job\/(\d+)/,
    /\/jobs\/(\d+)/,
    /\/position\/(\d+)/,
    /\/careers\/(\d+)/,
    /job-id[=_-](\d+)/,
    /position[_-]id[=_-](\d+)/,
    /req[_-]?(\d+)/
  ],
  
  withSlug: [
    /\/job\/([^\/\?]+)/,
    /\/jobs\/([^\/\?]+)/,
    /\/position\/([^\/\?]+)/,
    /\/careers\/job\/([^\/\?]+)/,
    /\/openings\/([^\/\?]+)/
  ]
};

/**
 * Extract job ID from URL
 * @param {string} url - Job URL
 * @returns {string} Job ID or slug
 */
exports.extractJobId = (url) => {
  if (!url) return null;
  
  // Try ID patterns first
  for (const pattern of this.JOB_URL_PATTERNS.withId) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  
  // Try slug patterns
  for (const pattern of this.JOB_URL_PATTERNS.withSlug) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  
  return null;
};

// Export all patterns for external use
exports.CSS_SELECTORS = CSS_SELECTORS;
exports.URL_PATTERNS = URL_PATTERNS;
exports.JOB_TITLE_PATTERNS = JOB_TITLE_PATTERNS;
exports.EXPERIENCE_INDICATORS = EXPERIENCE_INDICATORS;

================
File: utils/recruiter-importer.js
================
// backend/utils/recruiter-importer.js
const fs = require('fs');
const path = require('path');
const { parse } = require('csv-parse/sync');
const db = require('../config/postgresql');

/**
 * Import recruiters from a CSV/TSV file
 * @param {string} filePath Path to the CSV/TSV file
 * @param {boolean} isHeaderRow Whether the first row is a header row
 * @param {string} delimiter Delimiter used in the file
 */
const importRecruitersFromFile = async (filePath, isHeaderRow = true, delimiter = '\t') => {
  try {
    console.log(`Importing recruiters from ${filePath}...`);
    
    // Read the file
    const fileContent = fs.readFileSync(filePath, 'utf8');
    
    // Parse the CSV/TSV content
    const records = parse(fileContent, {
      delimiter,
      columns: isHeaderRow,
      skip_empty_lines: true,
      trim: true
    });
    
    console.log(`Found ${records.length} records to import`);
    
    // Process each record
    for (const record of records) {
      await processRecruiterRecord(record);
    }
    
    console.log('Recruiter import completed successfully');
  } catch (error) {
    console.error('Error importing recruiters:', error);
    throw error;
  }
};

/**
 * Process a single recruiter record and insert into database
 * @param {Object} record The recruiter record from the CSV/TSV
 */
const processRecruiterRecord = async (record) => {
  try {
    // 1. First, process the company information
    const companyId = await processCompany(record);
    
    // 2. Process the location information
    const locationId = await processLocation(record);
    
    // 3. Process industry information
    const industryId = await processIndustry(record);
    
    // 4. Create or update the recruiter record
    await processRecruiter(record, companyId, locationId, industryId);
    
  } catch (error) {
    console.error(`Error processing recruiter record:`, error);
    console.error('Problematic record:', record);
  }
};

/**
 * Process company data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The company ID
 */
const processCompany = async (record) => {
  try {
    // Check if company already exists
    const companyResult = await db.query(
      'SELECT id FROM companies WHERE name = $1',
      [record['Company Name']]
    );
    
    if (companyResult.rows.length > 0) {
      return companyResult.rows[0].id;
    }
    
    // Insert new company
    const result = await db.query(
      `INSERT INTO companies (
        name, website, employee_count, employee_range, founded_year,
        phone, revenue, revenue_range, ownership_type, business_model,
        stock_ticker, zoominfo_id, zoominfo_url, linkedin_url,
        facebook_url, twitter_url, email_domain
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
      RETURNING id`,
      [
        record['Company Name'] || null,
        record['Website'] || null,
        parseInt(record['Employees']) || null,
        record['Employee Range'] || null,
        parseInt(record['Founded Year']) || null,
        record['Company HQ Phone'] || null,
        parseInt(record['Revenue (in 000s USD)']) || null,
        record['Revenue Range (in USD)'] || null,
        record['Ownership Type'] || null,
        record['Business Model'] || null,
        record['Ticker'] || null,
        record['ZoomInfo Company ID'] || null,
        record['ZoomInfo Company Profile URL'] || null,
        record['LinkedIn Company Profile URL'] || null,
        record['Facebook Company Profile URL'] || null,
        record['Twitter Company Profile URL'] || null,
        record['Email Domain'] || null
      ]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing company:', error);
    throw error;
  }
};

/**
 * Process location data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The location ID
 */
const processLocation = async (record) => {
  try {
    // Check for person location first, then company location
    let street = record['Person Street'] || record['Company Street Address'] || null;
    let city = record['Person City'] || record['Company City'] || null;
    let state = record['Person State'] || record['Company State'] || null;
    let postalCode = record['Person Zip Code'] || record['Company Zip Code'] || null;
    let country = record['Country'] || record['Company Country'] || null;
    
    if (!city && !state && !country) {
      return null;
    }
    
    // Check if location already exists
    const locationResult = await db.query(
      'SELECT id FROM locations WHERE city = $1 AND state = $2 AND country = $3 AND (postal_code = $4 OR $4 IS NULL)',
      [city, state, country, postalCode]
    );
    
    if (locationResult.rows.length > 0) {
      return locationResult.rows[0].id;
    }
    
    // Create full address
    let fullAddress = '';
    if (street) fullAddress += street + ', ';
    if (city) fullAddress += city + ', ';
    if (state) fullAddress += state + ', ';
    if (postalCode) fullAddress += postalCode + ', ';
    if (country) fullAddress += country;
    
    // Insert new location
    const result = await db.query(
      `INSERT INTO locations (
        street_address, city, state, postal_code, country, full_address
      ) VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id`,
      [street, city, state, postalCode, country, fullAddress]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing location:', error);
    throw error;
  }
};

/**
 * Process industry data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The industry ID
 */
const processIndustry = async (record) => {
  try {
    const primaryIndustry = record['Primary Industry'] || null;
    
    if (!primaryIndustry) {
      return null;
    }
    
    // Check if industry already exists
    const industryResult = await db.query(
      'SELECT id FROM industries WHERE name = $1',
      [primaryIndustry]
    );
    
    if (industryResult.rows.length > 0) {
      return industryResult.rows[0].id;
    }
    
    // Parse SIC and NAICS codes
    const sicCodes = [];
    if (record['SIC Code 1']) sicCodes.push(record['SIC Code 1']);
    if (record['SIC Code 2']) sicCodes.push(record['SIC Code 2']);
    if (record['SIC Codes']) {
      const additionalSIC = record['SIC Codes'].split(';').filter(Boolean);
      sicCodes.push(...additionalSIC);
    }
    
    const naicsCodes = [];
    if (record['NAICS Code 1']) naicsCodes.push(record['NAICS Code 1']);
    if (record['NAICS Code 2']) naicsCodes.push(record['NAICS Code 2']);
    if (record['NAICS Codes']) {
      const additionalNAICS = record['NAICS Codes'].split(';').filter(Boolean);
      naicsCodes.push(...additionalNAICS);
    }
    
    // Insert new industry
    const result = await db.query(
      `INSERT INTO industries (
        name, description, primary_category, sub_category, 
        hierarchical_category, sic_codes, naics_codes
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING id`,
      [
        primaryIndustry,
        null,
        record['Primary Industry'] || null,
        record['Primary Sub-Industry'] || null,
        record['Industry Hierarchical Category'] || null,
        sicCodes.length > 0 ? sicCodes : null,
        naicsCodes.length > 0 ? naicsCodes : null
      ]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing industry:', error);
    throw error;
  }
};

/**
 * Process recruiter data from the record
 * @param {Object} record The recruiter record
 * @param {number} companyId The company ID
 * @param {number} locationId The location ID
 * @param {number} industryId The industry ID
 */
const processRecruiter = async (record, companyId, locationId, industryId) => {
  try {
    // Check if recruiter already exists by email
    const email = record['Email Address'] || null;
    
    if (email) {
      const recruiterResult = await db.query(
        'SELECT id FROM recruiters WHERE email = $1',
        [email]
      );
      
      if (recruiterResult.rows.length > 0) {
        const recruiterId = recruiterResult.rows[0].id;
        await updateRecruiter(recruiterId, record, companyId, locationId, industryId);
        return;
      }
    }
    
    // Parse job start date
    let jobStartDate = null;
    if (record['Job Start Date']) {
      try {
        jobStartDate = new Date(record['Job Start Date']);
      } catch (e) {
        console.warn(`Could not parse job start date: ${record['Job Start Date']}`);
      }
    }
    
    // Parse notice provided date
    let noticeProvidedDate = null;
    if (record['Notice Provided Date']) {
      try {
        noticeProvidedDate = new Date(record['Notice Provided Date']);
      } catch (e) {
        console.warn(`Could not parse notice provided date: ${record['Notice Provided Date']}`);
      }
    }
    
    // Insert new recruiter
    const result = await db.query(
      `INSERT INTO recruiters (
        first_name, middle_name, last_name, salutation, suffix,
        email, email_domain, supplemental_email, direct_phone, mobile_phone,
        current_company_id, title, job_title_hierarchy_level, management_level,
        job_start_date, job_function, department, company_division,
        education_level, accuracy_score, accuracy_grade, zoominfo_url,
        linkedin_url, notice_provided_date, location_id, industry_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
        $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
      )
      RETURNING id`,
      [
        record['First Name'] || null,
        record['Middle Name'] || null,
        record['Last Name'] || null,
        record['Salutation'] || null,
        record['Suffix'] || null,
        email,
        record['Email Domain'] || null,
        record['Supplemental Email'] || null,
        record['Direct Phone Number'] || null,
        record['Mobile phone'] || null,
        companyId,
        record['Job Title'] || null,
        parseInt(record['Job Title Hierarchy Level']) || null,
        record['Management Level'] || null,
        jobStartDate,
        record['Job Function'] || null,
        record['Department'] || null,
        record['Company Division Name'] || null,
        record['Highest Level of Education'] || null,
        parseInt(record['Contact Accuracy Score']) || null,
        record['Contact Accuracy Grade'] || null,
        record['ZoomInfo Contact Profile URL'] || null,
        record['LinkedIn Contact Profile URL'] || null,
        noticeProvidedDate,
        locationId,
        industryId
      ]
    );
    
    console.log(`Created recruiter: ${record['First Name']} ${record['Last Name']}`);
  } catch (error) {
    console.error('Error processing recruiter:', error);
    throw error;
  }
};

/**
 * Update an existing recruiter
 * @param {number} recruiterId The recruiter ID
 * @param {Object} record The recruiter record
 * @param {number} companyId The company ID
 * @param {number} locationId The location ID
 * @param {number} industryId The industry ID
 */
const updateRecruiter = async (recruiterId, record, companyId, locationId, industryId) => {
  try {
    // Parse job start date
    let jobStartDate = null;
    if (record['Job Start Date']) {
      try {
        jobStartDate = new Date(record['Job Start Date']);
      } catch (e) {
        console.warn(`Could not parse job start date: ${record['Job Start Date']}`);
      }
    }
    
    // Parse notice provided date
    let noticeProvidedDate = null;
    if (record['Notice Provided Date']) {
      try {
        noticeProvidedDate = new Date(record['Notice Provided Date']);
      } catch (e) {
        console.warn(`Could not parse notice provided date: ${record['Notice Provided Date']}`);
      }
    }
    
    await db.query(
      `UPDATE recruiters SET
        first_name = $1, middle_name = $2, last_name = $3, salutation = $4,
        suffix = $5, email_domain = $6, supplemental_email = $7,
        direct_phone = $8, mobile_phone = $9, current_company_id = $10,
        title = $11, job_title_hierarchy_level = $12, management_level = $13,
        job_start_date = $14, job_function = $15, department = $16,
        company_division = $17, education_level = $18, accuracy_score = $19,
        accuracy_grade = $20, zoominfo_url = $21, linkedin_url = $22,
        notice_provided_date = $23, location_id = $24, industry_id = $25,
        updated_at = NOW()
      WHERE id = $26`,
      [
        record['First Name'] || null,
        record['Middle Name'] || null,
        record['Last Name'] || null,
        record['Salutation'] || null,
        record['Suffix'] || null,
        record['Email Domain'] || null,
        record['Supplemental Email'] || null,
        record['Direct Phone Number'] || null,
        record['Mobile phone'] || null,
        companyId,
        record['Job Title'] || null,
        parseInt(record['Job Title Hierarchy Level']) || null,
        record['Management Level'] || null,
        jobStartDate,
        record['Job Function'] || null,
        record['Department'] || null,
        record['Company Division Name'] || null,
        record['Highest Level of Education'] || null,
        parseInt(record['Contact Accuracy Score']) || null,
        record['Contact Accuracy Grade'] || null,
        record['ZoomInfo Contact Profile URL'] || null,
        record['LinkedIn Contact Profile URL'] || null,
        noticeProvidedDate,
        locationId,
        industryId,
        recruiterId
      ]
    );
    
    console.log(`Updated recruiter: ${record['First Name']} ${record['Last Name']}`);
  } catch (error) {
    console.error('Error updating recruiter:', error);
    throw error;
  }
};

module.exports = { importRecruitersFromFile };

================
File: utils/send-email.js
================
// backend/utils/send-email.js
const nodemailer = require('nodemailer');

/**
 * Send email using nodemailer with Gmail
 * @param {Object} options Email options (to, subject, text, html)
 */
const sendEmail = async (options) => {
  try {
    // Create a transporter using Gmail
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD // App Password, not regular password
      }
    });
    
    // Define mail options
    const mailOptions = {
      from: `${process.env.FROM_NAME} <${process.env.GMAIL_USER}>`,
      to: options.email,
      subject: options.subject,
      html: options.html
    };
    
    // Send mail
    const info = await transporter.sendMail(mailOptions);
    console.log('Email sent: %s', info.messageId);
    return info;
  } catch (error) {
    console.error('Error sending email:', error);
    throw error;
  }
};

module.exports = sendEmail;

================
File: verify-controller.js
================
// backend/verify-controller.js - Test if the controller changes are working
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function verifyControllerFix() {
  try {
    console.log('ðŸ§ª VERIFYING CONTROLLER FIX');
    console.log('=============================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Test the EXACT query from the controller (with COALESCE)
    console.log('\n1ï¸âƒ£ TESTING MAIN QUERY WITH COALESCE:');
    
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    // Add the search filter exactly as it should be in the controller
    sqlQuery += ` AND (
      COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $${paramIndex} OR
      COALESCE(r.title, '') ILIKE $${paramIndex}
    )`;
    queryParams.push(`%${query}%`);
    paramIndex++;

    // Add ordering
    sqlQuery += ` ORDER BY r.first_name ASC`;
    
    // Add pagination
    sqlQuery += ` LIMIT 20 OFFSET 0`;

    console.log('ðŸ“ Executing exact controller query...');
    console.log('ðŸ“‹ Params:', queryParams);
    
    const result = await pool.query(sqlQuery, queryParams);
    console.log(`ðŸ“Š Main query result: ${result.rows.length} rows`);

    if (result.rows.length > 0) {
      console.log('âœ… SUCCESS: Main query found results!');
      result.rows.slice(0, 3).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    } else {
      console.log('âŒ PROBLEM: Main query returned 0 results');
    }

    // Test the count query
    console.log('\n2ï¸âƒ£ TESTING COUNT QUERY:');
    const countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE '%${query}%' OR COALESCE(r.title, '') ILIKE '%${query}%')
    `;

    console.log('ðŸ“ Count query:', countQuery);
    const countResult = await pool.query(countQuery);
    console.log(`ðŸ“Š Count query result: ${countResult.rows[0].count}`);

    // Test without COALESCE to see the difference
    console.log('\n3ï¸âƒ£ TESTING WITHOUT COALESCE (old version):');
    const oldQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE '%${query}%' OR r.title ILIKE '%${query}%')
    `;

    try {
      const oldResult = await pool.query(oldQuery);
      console.log(`ðŸ“Š Old query result: ${oldResult.rows[0].count}`);
    } catch (error) {
      console.log(`âŒ Old query failed: ${error.message}`);
    }

    // Test if there's an issue with the outreach_history join
    console.log('\n4ï¸âƒ£ TESTING WITHOUT OUTREACH JOIN:');
    const noJoinQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE '%${query}%' OR COALESCE(r.title, '') ILIKE '%${query}%')
    `;

    const noJoinResult = await pool.query(noJoinQuery);
    console.log(`ðŸ“Š No join query result: ${noJoinResult.rows[0].count}`);

    console.log('\nâœ… Verification complete!');

  } catch (error) {
    console.error('âŒ Verification failed:', error);
  } finally {
    await pool.end();
  }
}

verifyControllerFix();
