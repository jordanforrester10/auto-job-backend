This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-28T18:33:37.204Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
backend/config/anthropic.js
backend/config/jobBoards.js
backend/config/mongodb.js
backend/config/openai.js
backend/config/postgresql.js
backend/config/s3.js
backend/config/stripe.js
backend/controllers/assistant.controller.js
backend/controllers/auth.controller.js
backend/controllers/job.controller.js
backend/controllers/recruiter.controller.js
backend/controllers/resume.controller.js
backend/controllers/search.controller.js
backend/controllers/settings.controller.js
backend/controllers/subscription.controller.js
backend/debug-controller-params.js
backend/debug-recruiter-search.js
backend/debug-search-query.js
backend/middleware/auth.middleware.js
backend/middleware/subscription.middleware.js
backend/middleware/usage.middleware.js
backend/middleware/validation.middleware.js
backend/models/mongodb/aiAgent.model.js
backend/models/mongodb/aiJobSearch.model.js
backend/models/mongodb/assistantSession.model.js
backend/models/mongodb/conversation.model.js
backend/models/mongodb/job.model.js
backend/models/mongodb/outreach.model.js
backend/models/mongodb/resume.model.js
backend/models/mongodb/user.model.js
backend/models/mongodb/userMemory.model.js
backend/models/postgresql/schema.js
backend/package.json
backend/railway.json
backend/repomix-output.txt
backend/routes/assistant.routes.js
backend/routes/auth.routes.js
backend/routes/job.routes.js
backend/routes/recruiter.routes.js
backend/routes/resume.routes.js
backend/routes/search.routes.js
backend/routes/settings.routes.js
backend/routes/subscription.routes.js
backend/routes/test.routes.js
backend/scripts/fix-missing-columns.js
backend/scripts/fix-outreach-history.js
backend/scripts/import-recruiters.js
backend/scripts/update-recruiter-industries.js
backend/server.js
backend/services/adzunaJobExtractor.service.js
backend/services/assistant.service.js
backend/services/conversationService.js
backend/services/jobAnalysis.service.js
backend/services/jobBoardExtractor.service.js
backend/services/jobMatching.service.js
backend/services/jobSearch.service.js
backend/services/memoryService.js
backend/services/recruiterImport.service.js
backend/services/resumeAnalysis.service.js
backend/services/resumeEditor.service.js
backend/services/resumeParser.service.js
backend/services/resumeTailoring.service.js
backend/services/stripe.service.js
backend/services/subscription.service.js
backend/services/testJobSearch.service.js
backend/services/usage.services.js
backend/test-controller.js
backend/test-s3.js
backend/test-stripe-setup.js
backend/tests/test-auth.js
backend/tests/test-neon-connection.js
backend/utils/email-templates.js
backend/utils/jobBoardPatterns.js
backend/utils/recruiter-importer.js
backend/utils/send-email.js
backend/verify-controller.js
frontend/.env.example
frontend/.prettierignore
frontend/.prettierrc
frontend/jsconfig.json
frontend/package.json
frontend/public/index.html
frontend/public/manifest.json
frontend/public/robots.txt
frontend/README.md
frontend/repomix-output.txt
frontend/src/App.js
frontend/src/components/assistant/AiAssistantWidget.js
frontend/src/components/assistant/GlobalAiAssistant.js
frontend/src/components/auth/EmailVerification.js
frontend/src/components/auth/ForgotPassword.js
frontend/src/components/auth/Login.js
frontend/src/components/auth/ProtectedRoute.js
frontend/src/components/auth/Register.js
frontend/src/components/auth/ResetPassword.js
frontend/src/components/common/AutoJobLogo.js
frontend/src/components/common/GlobalSearch.js
frontend/src/components/common/PageHeader.js
frontend/src/components/Dashboard.js
frontend/src/components/jobs/AiSearchesPage.js
frontend/src/components/jobs/components/AiReasoningLogs.js
frontend/src/components/jobs/components/AiSearchDeleteDialog.js
frontend/src/components/jobs/components/AiSearchDetailsDialog.js
frontend/src/components/jobs/components/AiSearchExpandableRow.js
frontend/src/components/jobs/components/AiSearchSummaryCards.js
frontend/src/components/jobs/components/AiSearchTable.js
frontend/src/components/jobs/components/AiSearchTableRow.js
frontend/src/components/jobs/components/EmptySearchState.js
frontend/src/components/jobs/components/EnhancedCircularProgress.js
frontend/src/components/jobs/components/JobAnalysisStatus.js
frontend/src/components/jobs/components/JobDetailsCard.js
frontend/src/components/jobs/components/JobHeader.js
frontend/src/components/jobs/components/MatchAnalysisCard.js
frontend/src/components/jobs/components/SkillChip.js
frontend/src/components/jobs/FindJobsDialog.js
frontend/src/components/jobs/hooks/useAiSearches.js
frontend/src/components/jobs/hooks/useJobAnalysis.js
frontend/src/components/jobs/JobCreateDialog.js
frontend/src/components/jobs/JobDetail.js
frontend/src/components/jobs/JobsPage.js
frontend/src/components/jobs/ResumeTailoring.js
frontend/src/components/jobs/tabs/AnalysisTab.js
frontend/src/components/jobs/tabs/ContentTab.js
frontend/src/components/jobs/tabs/OverviewTab.js
frontend/src/components/jobs/utils/searchUtils.js
frontend/src/components/layout/Header.js
frontend/src/components/layout/MainLayout.js
frontend/src/components/layout/Sidebar.js
frontend/src/components/recruiters/OutreachComposer.js
frontend/src/components/recruiters/OutreachTracker.js
frontend/src/components/recruiters/RecruiterDetails.js
frontend/src/components/recruiters/RecruiterList.js
frontend/src/components/recruiters/RecruiterPage.js
frontend/src/components/recruiters/RecruiterSearch.js
frontend/src/components/resumes/components/AiEditingToolbar.js
frontend/src/components/resumes/components/BeforeAfterComparison.js
frontend/src/components/resumes/components/ProcessingView.js
frontend/src/components/resumes/components/ScoreDisplay.js
frontend/src/components/resumes/components/TabPanel.js
frontend/src/components/resumes/hooks/useAiIntegration.js
frontend/src/components/resumes/hooks/useResumeData.js
frontend/src/components/resumes/ResumeDetail.js
frontend/src/components/resumes/ResumesPage.js
frontend/src/components/resumes/ResumeUploadDialog.js
frontend/src/components/resumes/ResumeWithAssistant.js
frontend/src/components/resumes/tabs/AnalysisTab.js
frontend/src/components/resumes/tabs/ContentTab.js
frontend/src/components/resumes/tabs/OverviewTab.js
frontend/src/components/resumes/utils/resumeHelpers.js
frontend/src/components/search/SearchPage.js
frontend/src/components/SettingsPage.js
frontend/src/context/AiAssistantContext.js
frontend/src/context/AuthContext.js
frontend/src/hooks/useSearch.js
frontend/src/index.css
frontend/src/index.js
frontend/src/ThemeProvider.js
frontend/src/utils/assistantService.js
frontend/src/utils/axios.js
frontend/src/utils/jobService.js
frontend/src/utils/recruiterService.js
frontend/src/utils/resumeService.js
frontend/src/utils/searchService.js
frontend/src/utils/settingsService.js
package.json
railway.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Dependencies
node_modules/
*/node_modules/
backend/node_modules/
frontend/node_modules/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
backend/.env
frontend/.env

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# Build directories
build/
dist/
frontend/build/
backend/build/

# Cache directories
.cache/
.npm/
.eslintcache
.parcel-cache/

# Temporary folders
tmp/
temp/

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE
.vscode/
.idea/

# Test coverage
.nyc_output

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# Database files
*.db
*.sqlite
*.sqlite3

# CSV files (might contain sensitive data)
*.csv

# Backup files
*.backup
*.bak

# Lock files (keep one type)
package-lock.json
yarn.lock

================
File: backend/config/anthropic.js
================
const Anthropic = require('@anthropic-ai/sdk');

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

module.exports = { anthropic };

================
File: backend/config/jobBoards.js
================
// config/jobBoards.js - REAL JOB BOARD CONFIGURATION
module.exports = {
  // Supported job board platforms
  platforms: {
    greenhouse: {
      name: 'Greenhouse',
      displayName: 'Greenhouse',
      icon: '🌱',
      description: 'Tech startups and scale-ups with comprehensive job details',
      urlPatterns: [
        'greenhouse.io/jobs',
        'greenhouse.io/job',
        'boards.greenhouse.io'
      ],
      searchPriority: 1, // Higher priority for tech roles
      expectedFeatures: [
        'Comprehensive job descriptions',
        'Team and culture information',
        'Tech stack details',
        'Interview process overview'
      ],
      targetCompanyTypes: [
        'Tech startups',
        'Scale-ups',
        'Venture-backed companies',
        'Y Combinator companies',
        'Series A-C companies'
      ],
      averageContentQuality: 'high',
      searchModifiers: ['site:greenhouse.io', 'inurl:jobs'],
      apiEndpoints: {
        // Note: These would be used if we had direct API access
        publicJobs: 'https://boards-api.greenhouse.io/v1/boards/{board_token}/jobs',
        departments: 'https://boards-api.greenhouse.io/v1/boards/{board_token}/departments'
      }
    },
    
    lever: {
      name: 'Lever',
      displayName: 'Lever',
      icon: '⚡',
      description: 'Growth-stage companies with detailed role information',
      urlPatterns: [
        'jobs.lever.co',
        'lever.co/jobs'
      ],
      searchPriority: 2,
      expectedFeatures: [
        'Detailed role descriptions',
        'Career progression paths',
        'Team structure information',
        'Hiring manager details'
      ],
      targetCompanyTypes: [
        'Growth-stage companies',
        'Expanding teams',
        'Series A-D companies',
        'Scale-ups with clear structure'
      ],
      averageContentQuality: 'high',
      searchModifiers: ['site:lever.co', 'inurl:jobs'],
      apiEndpoints: {
        // Note: These would be used if we had direct API access
        postings: 'https://api.lever.co/v0/postings/{company}',
        departments: 'https://api.lever.co/v0/postings/{company}?group=department'
      }
    },
    
    indeed: {
      name: 'Indeed',
      displayName: 'Indeed',
      icon: '🔍',
      description: 'Established companies with verified direct postings',
      urlPatterns: [
        'indeed.com/viewjob',
        'indeed.com/jobs',
        'indeed.com/job'
      ],
      searchPriority: 3, // Lower priority but good for established companies
      expectedFeatures: [
        'Direct company postings',
        'Verified employer accounts',
        'Complete job details',
        'Application instructions'
      ],
      targetCompanyTypes: [
        'Established companies',
        'Enterprise organizations',
        'Public companies',
        'Direct employers'
      ],
      averageContentQuality: 'medium',
      searchModifiers: ['site:indeed.com', 'inurl:viewjob', '-recruiter', '-staffing'],
      exclusionKeywords: [
        'staffing',
        'recruiting',
        'placement',
        'consulting firm',
        'headhunter'
      ]
    }
  },
  
  // Search configuration
  searchConfig: {
    maxJobsPerPlatform: 5,
    maxTotalJobs: 12,
    minContentLength: 400,
    maxPostingAge: 30, // days
    timeoutPerPlatform: 30000, // 30 seconds
    retryAttempts: 2,
    rateLimitDelay: 1000, // 1 second between requests
    
    // Quality thresholds
    qualityThresholds: {
      minQualityScore: 60,
      minMatchScore: 70,
      requiredSections: ['requirements', 'responsibilities'],
      preferredSections: ['benefits', 'tech_stack', 'team_info']
    },
    
    // Search strategy
    searchStrategy: {
      useParallelSearch: false, // Sequential to avoid rate limiting
      prioritizeRecent: true,
      diversifyPlatforms: true,
      maxSearchQueriesPerPlatform: 3
    }
  },
  
  // Content validation rules
  contentValidation: {
    minWordCount: 100,
    maxWordCount: 5000,
    requiredKeywords: {
      jobPosting: ['position', 'role', 'job', 'opportunity'],
      requirements: ['requirement', 'qualification', 'skill', 'experience'],
      company: ['company', 'team', 'organization', 'we are']
    },
    blacklistedKeywords: [
      'this posting has expired',
      'job no longer available',
      'position filled',
      'scam',
      'pyramid scheme'
    ],
    urlValidation: {
      allowedProtocols: ['https'],
      requiredDomains: ['greenhouse.io', 'lever.co', 'indeed.com'],
      blockedDomains: ['spam.com', 'fake-jobs.com']
    }
  },
  
  // Platform-specific extraction rules
  extractionRules: {
    greenhouse: {
      selectors: {
        title: '.app-title, [data-qa="job-title"]',
        description: '.job-post-content, [data-qa="job-description"]',
        requirements: '.requirements, [data-qa="requirements"]',
        team: '.team-info, [data-qa="team"]',
        benefits: '.benefits, [data-qa="benefits"]'
      },
      identifierPatterns: {
        jobId: /\/jobs\/(\d+)/,
        officeId: /office_id=(\d+)/
      }
    },
    
    lever: {
      selectors: {
        title: '.posting-headline, [data-qa="posting-name"]',
        description: '.posting-description, [data-qa="posting-description"]',
        team: '.posting-categories, [data-qa="posting-team"]',
        requirements: '.posting-requirements'
      },
      identifierPatterns: {
        company: /jobs\.lever\.co\/([^\/]+)/,
        postingId: /jobs\.lever\.co\/[^\/]+\/([^\/\?]+)/
      }
    },
    
    indeed: {
      selectors: {
        title: '[data-jk] h1, .jobsearch-JobInfoHeader-title',
        description: '.jobsearch-jobDescriptionText, #jobDescriptionText',
        company: '[data-jk] .jobsearch-CompanyInfoContainer',
        salary: '.jobsearch-JobMetadataHeader-item'
      },
      identifierPatterns: {
        jobKey: /jk=([^&]+)/,
        companyId: /cmp=([^&]+)/
      }
    }
  },
  
  // Error handling configuration
  errorHandling: {
    retryableErrors: [
      'TIMEOUT',
      'RATE_LIMITED',
      'TEMPORARY_FAILURE',
      'NETWORK_ERROR'
    ],
    fatalErrors: [
      'INVALID_CREDENTIALS',
      'BLOCKED_ACCESS',
      'PLATFORM_DISCONTINUED'
    ],
    fallbackStrategies: {
      onPlatformFailure: 'continue_with_other_platforms',
      onAllPlatformFailure: 'return_partial_results',
      onContentExtractionFailure: 'use_fallback_extraction'
    }
  },
  
  // Analytics and monitoring
  analytics: {
    trackSearchPerformance: true,
    trackContentQuality: true,
    trackUserEngagement: true,
    metrics: {
      searchLatency: 'platform_search_duration',
      extractionSuccess: 'content_extraction_rate',
      qualityScore: 'average_content_quality',
      userSatisfaction: 'job_application_rate'
    }
  },
  
  // Rate limiting and respectful scraping
  respectfulScraping: {
    observeRobotsTxt: true,
    respectRateLimits: true,
    userAgent: 'auto-job.ai-bot/1.0 (Job Discovery Service)',
    crawlDelay: 1000, // 1 second between requests
    concurrentRequests: 1, // Sequential processing
    sessionRotation: true
  },
  
  // Legal and compliance
  compliance: {
    respectTermsOfService: true,
    attributeSource: true,
    respectCopyright: true,
    dataRetentionDays: 90,
    anonymizeUserData: true,
    complianceNotes: [
      'All job board searches respect terms of service',
      'Content is used for matching purposes only',
      'No bulk downloading or data resale',
      'Attribution to original job boards maintained'
    ]
  },
  
  // Cost optimization
  costOptimization: {
    claudeSearchCost: 0.35, // Average cost per search with Claude
    gpt4AnalysisCost: 0.02, // Average cost per job analysis
    targetTotalCost: 0.57, // Target cost per complete search
    optimizations: [
      'Batch processing for analysis',
      'Efficient content extraction',
      'Smart retry logic',
      'Quality-based filtering'
    ]
  }
};

================
File: backend/config/mongodb.js
================
const mongoose = require('mongoose');
require('dotenv').config();

const connectMongoDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = connectMongoDB;

================
File: backend/config/openai.js
================
// config/openai.js
const OpenAI = require('openai');
require('dotenv').config();

// Initialize the OpenAI client with your API key
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Log a message to help with debugging
if (!process.env.OPENAI_API_KEY) {
  console.warn('WARNING: OPENAI_API_KEY environment variable is not defined. AI features will not work.');
} else {
  console.log('OpenAI configuration loaded successfully');
}

module.exports = { openai };

================
File: backend/config/postgresql.js
================
// backend/config/postgresql.js
const { Pool } = require('pg');
require('dotenv').config();

// Create a connection pool
const pool = new Pool({
  connectionString: process.env.POSTGRES_URI,
  ssl: {
    rejectUnauthorized: false // Required for Neon and many other cloud PostgreSQL providers
  }
});

// Test connection function
const testConnection = async () => {
  let client;
  try {
    client = await pool.connect();
    console.log('PostgreSQL connected successfully');
    return true;
  } catch (error) {
    console.error('PostgreSQL connection error:', error);
    return false;
  } finally {
    if (client) client.release();
  }
};

// Execute when module is loaded to test the connection
testConnection();

module.exports = {
  query: (text, params) => pool.query(text, params),
  pool,
  testConnection
};

================
File: backend/config/s3.js
================
// config/s3.js
const { S3Client } = require('@aws-sdk/client-s3');
require('dotenv').config();

// Create S3 client with proper configuration
const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-2',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
  }
});

// Export the AWS S3 bucket name as a constant
// Look for either AWS_S3_BUCKET or AWS_BUCKET_NAME to be backward compatible
const S3_BUCKET = process.env.AWS_S3_BUCKET || process.env.AWS_BUCKET_NAME;

// If the bucket name is not defined, log a warning
if (!S3_BUCKET) {
  console.warn('WARNING: AWS_BUCKET_NAME environment variable is not defined. File uploads will fail.');
}

module.exports = { s3Client, S3_BUCKET };

================
File: backend/config/stripe.js
================
// backend/config/stripe.js
require('dotenv').config();

const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

// Validate Stripe configuration
if (!process.env.STRIPE_SECRET_KEY) {
  console.error('❌ STRIPE_SECRET_KEY is not set in environment variables');
  process.exit(1);
}

if (!process.env.STRIPE_WEBHOOK_SECRET) {
  console.warn('⚠️ STRIPE_WEBHOOK_SECRET is not set - webhooks will not work');
}

// Stripe configuration object
const stripeConfig = {
  // API Keys
  secretKey: process.env.STRIPE_SECRET_KEY,
  publishableKey: process.env.STRIPE_PUBLISHABLE_KEY,
  webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,

  // Price IDs for plans (these should be set in your .env file)
  priceIds: {
    casual: {
      monthly: process.env.STRIPE_CASUAL_MONTHLY_PRICE_ID,
      yearly: process.env.STRIPE_CASUAL_YEARLY_PRICE_ID
    },
    hunter: {
      monthly: process.env.STRIPE_HUNTER_MONTHLY_PRICE_ID,
      yearly: process.env.STRIPE_HUNTER_YEARLY_PRICE_ID
    }
  },

  // Default configuration
  defaults: {
    currency: 'usd',
    automaticTax: {
      enabled: true
    },
    billingAddressCollection: 'required',
    shippingAddressCollection: null,
    allowPromotionCodes: true,
    customerCreation: 'always',
    mode: 'subscription',
    successUrl: process.env.FRONTEND_URL + '/subscription/success?session_id={CHECKOUT_SESSION_ID}',
    cancelUrl: process.env.FRONTEND_URL + '/pricing'
  },

  // Webhook events we handle
  webhookEvents: [
    'customer.subscription.created',
    'customer.subscription.updated', 
    'customer.subscription.deleted',
    'customer.subscription.trial_will_end',
    'invoice.payment_succeeded',
    'invoice.payment_failed',
    'invoice.upcoming',
    'checkout.session.completed',
    'checkout.session.expired',
    'customer.created',
    'customer.updated',
    'payment_method.attached'
  ]
};

// Validate price IDs
const validatePriceIds = () => {
  const missing = [];
  
  if (!stripeConfig.priceIds.casual.monthly) {
    missing.push('STRIPE_CASUAL_MONTHLY_PRICE_ID');
  }
  if (!stripeConfig.priceIds.casual.yearly) {
    missing.push('STRIPE_CASUAL_YEARLY_PRICE_ID');
  }
  if (!stripeConfig.priceIds.hunter.monthly) {
    missing.push('STRIPE_HUNTER_MONTHLY_PRICE_ID');
  }
  if (!stripeConfig.priceIds.hunter.yearly) {
    missing.push('STRIPE_HUNTER_YEARLY_PRICE_ID');
  }

  if (missing.length > 0) {
    console.warn('⚠️ Missing Stripe Price IDs in environment variables:');
    missing.forEach(id => console.warn(`   - ${id}`));
    console.warn('   Subscription creation will fail until these are set.');
  }
};

// Initialize Stripe configuration
const initializeStripe = async () => {
  try {
    console.log('🔄 Initializing Stripe configuration...');
    
    // Validate price IDs
    validatePriceIds();
    
    // Test Stripe connection
    await stripe.accounts.retrieve();
    console.log('✅ Stripe connection successful');
    
    // Log configuration status
    console.log('📊 Stripe Configuration Status:');
    console.log(`   - Environment: ${process.env.NODE_ENV || 'development'}`);
    console.log(`   - Secret Key: ${process.env.STRIPE_SECRET_KEY ? '✅ Set' : '❌ Missing'}`);
    console.log(`   - Webhook Secret: ${process.env.STRIPE_WEBHOOK_SECRET ? '✅ Set' : '❌ Missing'}`);
    console.log(`   - Casual Monthly Price: ${stripeConfig.priceIds.casual.monthly ? '✅ Set' : '❌ Missing'}`);
    console.log(`   - Casual Yearly Price: ${stripeConfig.priceIds.casual.yearly ? '✅ Set' : '❌ Missing'}`);
    console.log(`   - Hunter Monthly Price: ${stripeConfig.priceIds.hunter.monthly ? '✅ Set' : '❌ Missing'}`);
    console.log(`   - Hunter Yearly Price: ${stripeConfig.priceIds.hunter.yearly ? '✅ Set' : '❌ Missing'}`);
    
    return true;
  } catch (error) {
    console.error('❌ Stripe initialization failed:', error.message);
    return false;
  }
};

// Export Stripe instance and configuration
module.exports = {
  stripe,
  stripeConfig,
  initializeStripe
};

================
File: backend/controllers/assistant.controller.js
================
// controllers/assistant.controller.js - RAG VERSION WITH NO MEMORY SYSTEM
const { openai } = require('../config/openai');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const User = require('../models/mongodb/user.model');
const Conversation = require('../models/mongodb/conversation.model');
const ConversationService = require('../services/conversationService');

// ===================================================================
// 🆕 RAG: @-MENTION ENDPOINTS
// ===================================================================

/**
 * Get mention suggestions for @-functionality
 */
exports.getMentionSuggestions = async (req, res) => {
  try {
    const userId = req.user._id;
    const { query = '' } = req.query;

    console.log(`🔍 Getting mention suggestions for user ${userId}, query: "${query}"`);

    // Build search filters
    const searchFilter = {};
    if (query && query.trim()) {
      const searchRegex = new RegExp(query.trim(), 'i');
      searchFilter.$or = [
        { name: searchRegex },
        { title: searchRegex },
        { company: searchRegex }
      ];
    }

    // Get user's resumes
    const resumesPromise = Resume.find({
      userId,
      ...searchFilter,
      ...(query ? {} : {}) // Include all if no query
    })
    .select('name analysis.overallScore createdAt')
    .sort({ updatedAt: -1 })
    .limit(10)
    .lean();

    // Get user's jobs  
    const jobsPromise = Job.find({
      userId,
      ...searchFilter,
      ...(query ? {} : {}) // Include all if no query
    })
    .select('title company location createdAt')
    .sort({ updatedAt: -1 })
    .limit(10)
    .lean();

    const [resumes, jobs] = await Promise.all([resumesPromise, jobsPromise]);

    console.log(`✅ Found ${resumes.length} resumes and ${jobs.length} jobs`);

    res.json({
      success: true,
      resumes: resumes || [],
      jobs: jobs || [],
      total: (resumes?.length || 0) + (jobs?.length || 0)
    });

  } catch (error) {
    console.error('Get mention suggestions error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get mention suggestions',
      resumes: [],
      jobs: []
    });
  }
};

/**
 * Get full context data for mentioned item
 */
exports.getContextData = async (req, res) => {
  try {
    const userId = req.user._id;
    const { type, id } = req.params;

    console.log(`📄 Getting context data for ${type}:${id}`);

    let contextData = null;

    if (type === 'resume') {
      contextData = await Resume.findOne({ _id: id, userId })
        .populate('userId', 'firstName lastName email')
        .lean();
      
      if (contextData) {
        // Include relevant resume data for RAG
        contextData.contextType = 'resume';
        contextData.displayName = contextData.name;
        contextData.score = contextData.analysis?.overallScore || 0;
      }
    } else if (type === 'job') {
      contextData = await Job.findOne({ _id: id, userId })
        .populate('userId', 'firstName lastName email')
        .lean();
      
      if (contextData) {
        // Include relevant job data for RAG
        contextData.contextType = 'job';
        contextData.displayName = `${contextData.title} at ${contextData.company}`;
      }
    }

    if (!contextData) {
      return res.status(404).json({
        success: false,
        error: `${type} not found`
      });
    }

    res.json({
      success: true,
      data: contextData
    });

  } catch (error) {
    console.error('Get context data error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get context data'
    });
  }
};

// ===================================================================
// 🆕 ENHANCED RAG CHAT - WITH FULL CONTEXT SUPPORT
// ===================================================================

/**
 * Enhanced chat endpoint with RAG context support
 */
exports.chat = async (req, res) => {
  try {
    const userId = req.user._id;
    const { 
      message, 
      context = {}, 
      conversationId, 
      newConversation = false 
    } = req.body;

    if (!message || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Message is required'
      });
    }

    console.log(`🚀 RAG AI Chat: ${message.substring(0, 50)}... (user: ${userId})`);
    console.log(`📋 Context:`, {
      hasAttachedResumes: context.attachedResumes?.length > 0,
      hasAttachedJobs: context.attachedJobs?.length > 0,
      conversationId: conversationId
    });

    // ================================================================
    // 🆕 RAG: Load full context data for attached items
    // ================================================================
    let fullResumeContext = null;
    let fullJobContext = null;
    
    if (context.attachedResumes?.length > 0) {
      const resumeId = context.attachedResumes[0].id;
      fullResumeContext = await Resume.findOne({ _id: resumeId, userId }).lean();
      console.log(`📄 Loaded resume context: ${fullResumeContext?.name}`);
    }
    
    if (context.attachedJobs?.length > 0) {
      const jobId = context.attachedJobs[0].id;
      fullJobContext = await Job.findOne({ _id: jobId, userId }).lean();
      console.log(`💼 Loaded job context: ${fullJobContext?.title}`);
    }

    // ================================================================
    // 🔧 RAG: Enhanced resume editing detection
    // ================================================================
    const isResumeEditingRequest = fullResumeContext && detectResumeEditingIntent(message);
    
    if (isResumeEditingRequest) {
      console.log(`⚡ RAG resume editing detected for: ${fullResumeContext.name}`);
      return await handleResumeEditingWithContext(
        req, res, userId, message, fullResumeContext, conversationId, newConversation
      );
    }

    // ================================================================
    // 🆕 RAG: Enhanced AI Chat with full context
    // ================================================================
    
    // Get or create conversation
    let conversation = await getOrCreateConversationFast(conversationId, userId, newConversation, message, context);

    // Save user message in background
    setTimeout(async () => {
      try {
        await ConversationService.addMessage(conversation._id, {
          type: 'user',
          content: message,
          metadata: { 
            context,
            attachedResumes: context.attachedResumes || [],
            attachedJobs: context.attachedJobs || []
          }
        });
      } catch (error) {
        console.warn('Background message save failed:', error);
      }
    }, 0);

    // Build RAG-enhanced system prompt
    const systemPrompt = buildRagSystemPrompt(req.user, fullResumeContext, fullJobContext, context);
    
    // Get recent messages
    const recentMessages = conversation.messages ? conversation.messages.slice(-5) : [];
    const messages = buildRagMessages(systemPrompt, recentMessages, message);

    console.log(`🤖 Calling OpenAI with RAG context (${messages.length} messages)...`);

    // Call OpenAI with enhanced context
    const startTime = Date.now();
    const aiResponse = await openai.chat.completions.create({
      model: 'gpt-4', // Use GPT-4 for better RAG processing
      messages: messages,
      temperature: 0.7,
      max_tokens: 1000, // Increased for detailed RAG responses
      presence_penalty: 0.1,
      frequency_penalty: 0.1
    });

    const aiDuration = Date.now() - startTime;
    console.log(`✅ OpenAI responded in ${aiDuration}ms with RAG context`);

    const aiMessage = aiResponse.choices[0].message.content;
    const parsedResponse = parseRagResponse(aiMessage, fullResumeContext, fullJobContext);

    // Save AI response in background
    setTimeout(async () => {
      try {
        await ConversationService.addMessage(conversation._id, {
          type: 'ai',
          content: parsedResponse.message,
          metadata: {
            suggestions: parsedResponse.suggestions,
            actions: parsedResponse.actions,
            confidence: parsedResponse.confidence,
            tokens: aiResponse.usage?.total_tokens || 0,
            duration: aiDuration,
            ragContext: {
              hasResume: !!fullResumeContext,
              hasJob: !!fullJobContext,
              resumeName: fullResumeContext?.name,
              jobTitle: fullJobContext?.title
            }
          }
        });

        await Conversation.findByIdAndUpdate(conversation._id, {
          lastActiveAt: new Date()
        });

        console.log(`💾 Background save completed with RAG metadata`);
      } catch (error) {
        console.warn('Background conversation save failed:', error);
      }
    }, 0);

    const totalDuration = Date.now() - startTime;
    console.log(`🎉 RAG chat completed in ${totalDuration}ms`);

    res.json({
      success: true,
      message: parsedResponse.message,
      suggestions: parsedResponse.suggestions,
      actions: parsedResponse.actions,
      confidence: parsedResponse.confidence,
      conversationId: conversation._id,
      conversationTitle: conversation.title,
      usage: {
        tokens: aiResponse.usage?.total_tokens || 0,
        duration: totalDuration
      },
      performance: {
        openaiDuration: aiDuration,
        totalDuration: totalDuration,
        ragEnabled: true,
        contextUsed: {
          resume: !!fullResumeContext,
          job: !!fullJobContext
        }
      }
    });

  } catch (error) {
    console.error('RAG chat error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to process chat message',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      fallback_message: getRagFallbackResponse(req.body.message, req.body.context)
    });
  }
};

// ===================================================================
// 🆕 RAG RESUME EDITING WITH CONTEXT
// ===================================================================

async function handleResumeEditingWithContext(req, res, userId, message, resumeContext, conversationId, newConversation) {
  try {
    console.log('⚡ Starting RAG resume editing with full context...');
    
    // Get or create conversation
    let conversation = await getOrCreateConversationFast(conversationId, userId, newConversation, message, {});
    
    // Save user message in background
    setTimeout(async () => {
      try {
        await ConversationService.addMessage(conversation._id, {
          type: 'user',
          content: message,
          metadata: { 
            isResumeEdit: true,
            resumeId: resumeContext._id,
            resumeName: resumeContext.name,
            ragContext: true
          }
        });
      } catch (error) {
        console.warn('Background resume edit message save failed:', error);
      }
    }, 0);

    // 🔧 FIXED: Use the existing ResumeEditorService method
    const ResumeEditorService = require('../services/resumeEditor.service');
    
    // Clean the message to remove @-mention syntax for processing
    const cleanedMessage = message.replace(/@\[([^\]]+)\]/g, '$1');
    
    console.log(`🔧 Calling ResumeEditorService.applyResumeChanges with:`, {
      resumeId: resumeContext._id,
      userId: userId,
      message: cleanedMessage
    });

    const editResult = await ResumeEditorService.applyResumeChanges(
      resumeContext._id,
      userId,
      cleanedMessage
    );

    console.log(`✅ RAG resume editing completed successfully:`, {
      success: editResult.success,
      hasChanges: !!editResult.changes,
      hasNewFile: !!editResult.newFileUrl
    });

    // Re-analyze resume in background
    setTimeout(async () => {
      try {
        const resumeAnalysisService = require('../services/resumeAnalysis.service');
        const newAnalysis = await resumeAnalysisService.analyzeResume(resumeContext._id);
        
        const updatedResume = await Resume.findById(resumeContext._id);
        updatedResume.analysis = newAnalysis;
        await updatedResume.save();
        
        console.log(`✅ Background re-analysis completed with RAG context`);
      } catch (analysisError) {
        console.warn('Background analysis failed:', analysisError);
      }
    }, 0);

    // Generate context-aware success response
    const successMessage = `✅ I've successfully updated your resume "${resumeContext.name}"!

${editResult.changesSummary || 'Applied your requested improvements'}

**Changes made based on your resume context:**
• Enhanced content while maintaining your professional background
• Optimized formatting and keyword usage
• Improved readability and ATS compatibility

The updated resume is ready to download. Your score will be recalculated shortly.

What else would you like me to improve?`;

    // Save AI response in background
    setTimeout(async () => {
      try {
        await ConversationService.addMessage(conversation._id, {
          type: 'ai',
          content: successMessage,
          metadata: {
            isResumeEdit: true,
            resumeChanges: editResult.changes,
            newFileUrl: editResult.newFileUrl,
            changesSummary: editResult.changesSummary,
            ragContext: {
              resumeName: resumeContext.name,
              resumeScore: resumeContext.analysis?.overallScore
            },
            suggestions: [
              'Make more improvements',
              'Optimize for ATS', 
              'View updated resume',
              'Download new version',
              'Add more skills'
            ]
          }
        });

        conversation.lastActiveAt = new Date();
        await conversation.save();
      } catch (error) {
        console.warn('Background resume response save failed:', error);
      }
    }, 0);

    return res.json({
      success: true,
      message: successMessage,
      suggestions: [
        'Make more improvements',
        'Optimize for ATS', 
        'View updated resume',
        'Download new version',
        'Add more skills'
      ],
      actions: [],
      confidence: 0.95,
      conversationId: conversation._id,
      conversationTitle: conversation.title,
      resumeUpdated: true,
      resumeChanges: editResult.changes,
      newFileUrl: editResult.newFileUrl,
      changesSummary: editResult.changesSummary,
      usage: {
        tokens: editResult.tokensUsed || 0
      },
      performance: {
        ragEnabled: true,
        resumeContext: true,
        fastTrack: true
      }
    });

  } catch (resumeEditError) {
    console.error('RAG resume editing failed:', resumeEditError);
    
    let conversation = await getOrCreateConversationFast(conversationId, userId, newConversation, message, {});
    
    const errorMessage = `I encountered an issue updating your resume "${resumeContext.name}": ${resumeEditError.message}

Based on your current resume context, here's what I recommend:

**Resume Analysis:**
• Current Score: ${resumeContext.analysis?.overallScore || 'Not analyzed'}%
• Sections Available: ${Object.keys(resumeContext.parsedData || {}).join(', ')}

**Alternative Suggestions:**
• Try a more specific request (e.g., "improve work experience section")
• Focus on one area at a time
• Check if the resume file is accessible
• Consider re-uploading the resume if issues persist

Would you like me to try a different approach or provide general resume advice?`;
    
    // Save error in background
    setTimeout(async () => {
      try {
        await ConversationService.addMessage(conversation._id, {
          type: 'user',
          content: message,
          metadata: { 
            isResumeEdit: true, 
            failed: true,
            resumeContext: {
              name: resumeContext.name,
              score: resumeContext.analysis?.overallScore
            }
          }
        });

        await ConversationService.addMessage(conversation._id, {
          type: 'ai',
          content: errorMessage,
          metadata: {
            isResumeEditError: true,
            error: resumeEditError.message,
            ragContext: true,
            suggestions: [
              'Try a simpler request',
              'Focus on work experience',
              'Update skills section',
              'Improve summary'
            ]
          }
        });

        conversation.lastActiveAt = new Date();
        await conversation.save();
      } catch (bgError) {
        console.warn('Background error save failed:', bgError);
      }
    }, 0);
    
    return res.json({
      success: true,
      message: errorMessage,
      suggestions: [
        'Try a simpler request',
        'Focus on work experience', 
        'Update skills section',
        'Improve summary'
      ],
      conversationId: conversation._id,
      conversationTitle: conversation.title,
      resumeEditError: true,
      error: resumeEditError.message,
      performance: {
        ragEnabled: true,
        resumeContext: true,
        fastTrack: true,
        error: true
      }
    });
  }
}

// ===================================================================
// 🆕 RAG HELPER FUNCTIONS
// ===================================================================

async function getOrCreateConversationFast(conversationId, userId, newConversation, message, context) {
  try {
    if (conversationId && !newConversation) {
      console.log(`📖 Loading existing conversation: ${conversationId}`);
      return await ConversationService.getConversation(conversationId, userId);
    } else {
      const title = generateRagTitle(message, context);
      console.log(`📝 Creating new RAG conversation: ${title}`);
      return await ConversationService.createConversation(userId, {
        title,
        category: detectRagCategory(message, context),
        tags: extractRagTags(message, context)
      });
    }
  } catch (error) {
    console.error('Error handling conversation:', error);
    throw error;
  }
}

function buildRagSystemPrompt(user, resumeContext, jobContext, context) {
  let prompt = `You are AJ, an expert AI career assistant for auto-job.ai with RAG (Retrieval-Augmented Generation) capabilities.

CURRENT USER: ${user.firstName} ${user.lastName}
CURRENT PAGE: ${context.page || 'unknown'}

PERSONALITY & APPROACH:
- Professional, warm, and encouraging
- Provide specific, actionable advice based on available context
- Reference specific details from attached resumes/jobs when relevant
- Keep responses focused and under 300 words
- Always provide relevant follow-up suggestions

CORE CAPABILITIES:
- Resume editing and optimization with full context awareness
- Job analysis and matching with detailed requirements
- Career guidance based on user's actual background
- Interview preparation with role-specific insights`;

  // Add resume context if available
  if (resumeContext) {
    prompt += `\n\n📄 RESUME CONTEXT - "${resumeContext.name}":
Current Score: ${resumeContext.analysis?.overallScore || 'Not analyzed'}%
Experience Level: ${resumeContext.parsedData?.experience?.length || 0} positions
Key Skills: ${resumeContext.parsedData?.skills?.slice(0, 5).map(s => s.name).join(', ') || 'Not parsed'}
Education: ${resumeContext.parsedData?.education?.[0]?.degree || 'Not specified'}
Summary: ${resumeContext.parsedData?.summary?.substring(0, 150) || 'No summary available'}...

You have FULL ACCESS to this resume data and can make direct edits and improvements.`;
  }

  // Add job context if available  
  if (jobContext) {
    prompt += `\n\n💼 JOB CONTEXT - "${jobContext.title}" at ${jobContext.company}:
Location: ${jobContext.location?.city || 'Remote'}
Job Type: ${jobContext.jobType || 'Not specified'}
Key Requirements: ${jobContext.parsedData?.requirements?.slice(0, 3).join(', ') || 'Not parsed'}
Required Skills: ${jobContext.parsedData?.keySkills?.slice(0, 5).map(s => s.name).join(', ') || 'Not parsed'}
Experience Level: ${jobContext.parsedData?.experienceLevel || 'Not specified'}

You can analyze how well the user matches this specific role.`;
  }

  // Add context-specific guidance
  if (resumeContext && jobContext) {
    prompt += `\n\n🎯 MATCHING CONTEXT:
You can now perform detailed matching between the resume and job posting.
Analyze specific skills, experience, and requirements.
Provide tailored advice for this exact combination.`;
  }

  prompt += `\n\nALWAYS provide specific, contextual responses based on the available data.`;

  return prompt;
}

function buildRagMessages(systemPrompt, recentMessages, currentMessage) {
  const messages = [{ role: 'system', content: systemPrompt }];

  // Include more context messages for RAG
  if (recentMessages && recentMessages.length > 0) {
    recentMessages.slice(-4).forEach(msg => {
      messages.push({
        role: msg.type === 'user' ? 'user' : 'assistant',
        content: msg.content
      });
    });
  }

  messages.push({ role: 'user', content: currentMessage });
  return messages;
}

function parseRagResponse(aiMessage, resumeContext, jobContext) {
  const suggestions = [];
  
  // Generate context-aware suggestions
  if (resumeContext && jobContext) {
    suggestions.push(
      'How well do I match this job?',
      'Tailor resume for this role',
      'Generate interview questions',
      'Write cover letter'
    );
  } else if (resumeContext) {
    suggestions.push(
      'Improve this resume',
      'Optimize for ATS',
      'Add missing skills',
      'Update work experience'
    );
  } else if (jobContext) {
    suggestions.push(
      'Analyze job requirements',
      'What skills are needed?',
      'Research the company',
      'Interview preparation'
    );
  } else {
    suggestions.push(
      'Upload a resume for analysis',
      'Find job opportunities',
      'Career guidance',
      'Interview preparation'
    );
  }

  return {
    message: aiMessage,
    suggestions: suggestions.slice(0, 4),
    actions: [],
    confidence: resumeContext || jobContext ? 0.95 : 0.8 // Higher confidence with context
  };
}

function detectResumeEditingIntent(message) {
  const messageLower = message.toLowerCase();
  
  const editingKeywords = [
    'update', 'change', 'edit', 'modify', 'improve', 'enhance', 
    'add', 'remove', 'rewrite', 'fix', 'optimize'
  ];

  const sectionKeywords = [
    'experience', 'work', 'summary', 'skills', 'education', 'resume'
  ];

  const hasEditingKeyword = editingKeywords.some(keyword => messageLower.includes(keyword));
  const hasSectionKeyword = sectionKeywords.some(keyword => messageLower.includes(keyword));

  return hasEditingKeyword && hasSectionKeyword;
}

function generateRagTitle(message, context) {
  const content = message.toLowerCase();
  
  // Check for attached context first
  if (context.attachedResumes?.length > 0 && context.attachedJobs?.length > 0) {
    return `${context.attachedResumes[0].name} vs ${context.attachedJobs[0].title}`;
  }
  
  if (context.attachedResumes?.length > 0) {
    return `Resume: ${context.attachedResumes[0].name}`;
  }
  
  if (context.attachedJobs?.length > 0) {
    return `Job: ${context.attachedJobs[0].title}`;
  }
  
  // Fallback to content-based titles
  if (content.includes('resume')) return 'Resume Help';
  if (content.includes('job')) return 'Job Analysis';
  if (content.includes('interview')) return 'Interview Prep';
  if (content.includes('career')) return 'Career Guidance';
  
  return 'Career Chat';
}

function detectRagCategory(message, context) {
  // Prioritize context over message content
  if (context.attachedResumes?.length > 0 && context.attachedJobs?.length > 0) {
    return 'job_search'; // Valid enum: when both resume and job attached, it's job searching/matching
  }
  
  if (context.attachedResumes?.length > 0) {
    return 'resume_help'; // Valid enum: when resume attached
  }
  
  if (context.attachedJobs?.length > 0) {
    return 'job_search'; // Valid enum: when job attached, use job_search instead of job_analysis
  }
  
  const messageLower = message.toLowerCase();
  
  if (messageLower.includes('resume')) return 'resume_help';
  if (messageLower.includes('job')) return 'job_search'; 
  if (messageLower.includes('interview')) return 'interview_prep';
  if (messageLower.includes('career')) return 'career_advice';
  
  return 'general'; // Default fallback
}

function extractRagTags(message, context) {
  const tags = [];
  
  // Add context-based tags
  if (context.attachedResumes?.length > 0) {
    tags.push('resume_context');
  }
  
  if (context.attachedJobs?.length > 0) {
    tags.push('job_context');
  }
  
  // Add skill-based tags from message
  const messageLower = message.toLowerCase();
  const skillKeywords = ['python', 'javascript', 'react', 'node', 'java', 'aws', 'sql'];
  
  skillKeywords.forEach(skill => {
    if (messageLower.includes(skill)) {
      tags.push(skill);
    }
  });
  
  return tags.slice(0, 5);
}

function getRagFallbackResponse(message, context) {
  if (!message) return "I didn't receive your message. Could you please try again?";
  
  if (context?.attachedResumes?.length > 0) {
    return `I'd be happy to help with your resume "${context.attachedResumes[0].name}"! I can provide detailed analysis and make improvements.`;
  }
  
  if (context?.attachedJobs?.length > 0) {
    return `I can help you with the "${context.attachedJobs[0].title}" position! What would you like me to analyze?`;
  }
  
  if (message.toLowerCase().includes('resume')) {
    return "I can help with your resume! Use @ to select a specific resume for detailed assistance.";
  }
  
  if (message.toLowerCase().includes('job')) {
    return "I can help with job analysis! Use @ to select a specific job posting for detailed insights.";
  }
  
  return "I'm here to help with your career! Use @ to reference specific resumes or jobs for contextual assistance.";
}

// ===================================================================
// EXISTING ENDPOINTS - SIMPLIFIED (NO MEMORY SYSTEM)
// ===================================================================

// Conversation management (keep existing)
exports.getConversations = async (req, res) => {
  try {
    const userId = req.user._id;
    const options = {
      limit: parseInt(req.query.limit) || 20,
      offset: parseInt(req.query.offset) || 0,
      sortBy: req.query.sortBy || 'lastActiveAt'
    };

    const result = await ConversationService.getUserConversations(userId, options);
    res.json({ success: true, ...result });

  } catch (error) {
    console.error('Get conversations error:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch conversations' });
  }
};

exports.getConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    
    const conversation = await ConversationService.getConversation(conversationId, userId);
    res.json({ success: true, conversation, ragEnabled: true });
  } catch (error) {
    console.error('Get conversation error:', error);
    res.status(404).json({ success: false, error: 'Conversation not found' });
  }
};

exports.updateConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const conversation = await ConversationService.updateConversation(conversationId, userId, req.body);
    res.json({ success: true, conversation });
  } catch (error) {
    console.error('Update conversation error:', error);
    res.status(500).json({ success: false, error: 'Failed to update conversation' });
  }
};

exports.deleteConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const { permanent = false } = req.query;
    
    await ConversationService.deleteConversation(conversationId, userId, permanent === 'true');
    res.json({ success: true, message: 'Conversation deleted' });
  } catch (error) {
    console.error('Delete conversation error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete conversation' });
  }
};

// Health check with RAG info
exports.healthCheck = async (req, res) => {
  try {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      openai_status: 'connected',
      ragEnabled: true,
      memorySystem: false, // Removed memory system
      performance_mode: 'rag'
    });
  } catch (error) {
    console.error('Health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
};

// Capabilities with RAG features
exports.getCapabilities = async (req, res) => {
  res.json({
    available: true,
    features: [
      'rag_chat',
      'context_aware_responses',
      'resume_editing_with_context',
      'job_analysis_with_context',
      'conversation_management',
      'mention_suggestions'
    ],
    models: {
      primary: 'gpt-4' // Enhanced model for RAG
    },
    ragSupport: {
      enabled: true,
      supportedTypes: ['resume', 'job'],
      maxContextItems: 2, // 1 resume + 1 job
      contextPersistence: 'conversation_scoped'
    },
    performance: {
      ragOptimized: true,
      memorySystem: false,
      backgroundProcessing: true
    },
    status: process.env.OPENAI_API_KEY ? 'fully_configured' : 'missing_api_key'
  });
};

// Resume operation endpoints (enhanced with context)
exports.analyzeResume = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, context = {} } = req.body;

    if (!resumeId) {
      return res.status(400).json({ success: false, error: 'Resume ID is required' });
    }

    const resumeAnalysisService = require('../services/resumeAnalysis.service');
    const analysis = await resumeAnalysisService.analyzeResumeWithContext(resumeId, context);

    res.json({
      success: true,
      analysis: analysis,
      message: 'Resume analyzed successfully with context',
      ragEnabled: true
    });

  } catch (error) {
    console.error('Resume analysis error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to analyze resume'
    });
  }
};

exports.applyResumeChanges = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, changes, context = {} } = req.body;

    if (!resumeId || !changes) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID and changes are required'
      });
    }

    const ResumeEditorService = require('../services/resumeEditor.service');
    const result = await ResumeEditorService.applyResumeChangesWithContext(resumeId, userId, changes, context);

    res.json({
      success: true,
      message: 'Resume updated successfully with context',
      result: result,
      ragEnabled: true
    });

  } catch (error) {
    console.error('Apply resume changes error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to apply resume changes'
    });
  }
};

exports.optimizeForATS = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, targetJob = null } = req.body;

    if (!resumeId) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID is required'
      });
    }

    const ResumeEditorService = require('../services/resumeEditor.service');
    const result = await ResumeEditorService.optimizeForATSWithContext(resumeId, userId, targetJob);

    res.json({
      success: true,
      message: 'Resume optimized for ATS with job context',
      result: result,
      ragEnabled: true
    });

  } catch (error) {
    console.error('ATS optimization error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to optimize resume for ATS'
    });
  }
};

// Simple search (no memory system)
exports.search = async (req, res) => {
  try {
    const userId = req.user._id;
    const { query, type = 'all' } = req.query;

    if (!query) {
      return res.status(400).json({
        success: false,
        error: 'Search query is required'
      });
    }

    // Search conversations only (no memory search)
    const conversations = await ConversationService.searchAllConversations(
      userId, 
      query, 
      { limit: 10, includeMessages: true }
    );

    res.json({
      success: true,
      results: {
        conversations: conversations,
        total: conversations.length
      },
      ragEnabled: true,
      searchType: 'conversations_only'
    });

  } catch (error) {
    console.error('Search error:', error);
    res.status(500).json({
      success: false,
      error: 'Search failed',
      results: { conversations: [] }
    });
  }
};

// Placeholder implementations for compatibility (removed memory features)
exports.getMemories = async (req, res) => {
  res.json({ 
    success: true, 
    memories: [], 
    message: 'Memory system removed - using RAG context instead' 
  });
};

exports.getMemoryInsights = async (req, res) => {
  res.json({ 
    success: true, 
    insights: [], 
    message: 'Memory system removed - using RAG context for intelligence',
    ragEnabled: true
  });
};

exports.updateMemory = async (req, res) => {
  res.json({ success: true, message: 'Memory system removed - context handled by RAG' });
};

exports.deleteMemory = async (req, res) => {
  res.json({ success: true, message: 'Memory system removed' });
};

exports.performMemoryMaintenance = async (req, res) => {
  res.json({ success: true, message: 'Memory system removed - no maintenance needed' });
};

// Legacy placeholders for compatibility
exports.analyzeJobMatch = async (req, res) => {
  res.json({ success: true, analysis: { matchScore: 85, ragEnabled: true }, message: 'Use RAG context for detailed job matching' });
};

exports.generateCoverLetter = async (req, res) => {
  res.json({ success: true, coverLetter: { content: 'Use RAG context for personalized cover letters' } });
};

exports.getCareerAdvice = async (req, res) => {
  res.json({ success: true, advice: { advice: 'Use RAG context for personalized career advice' } });
};

exports.getContextualSuggestions = async (req, res) => {
  const suggestions = ['Use @ to add context', 'Upload resume for analysis', 'Find jobs to analyze'];
  res.json({ success: true, suggestions, ragEnabled: true });
};

exports.getPersonalizedTips = async (req, res) => {
  const tips = ['Use RAG context for personalized tips', 'Attach resumes and jobs for better insights'];
  res.json({ success: true, tips, ragEnabled: true });
};

exports.getAnalytics = async (req, res) => {
  res.json({ success: true, analytics: { ragEnabled: true, memorySystem: false } });
};

exports.getUsageStats = async (req, res) => {
  res.json({ success: true, stats: { ragEnabled: true } });
};

exports.trackInteraction = async (req, res) => {
  res.json({ success: true, message: 'Interaction tracked' });
};

exports.resetContext = async (req, res) => {
  res.json({ success: true, message: 'Context reset - use @ to add new context' });
};

// Placeholder exports for route compatibility
exports.generateSummary = (req, res) => res.json({ success: true, message: 'Feature replaced by RAG context' });
exports.getConversationInsights = (req, res) => res.json({ success: true, message: 'Feature replaced by RAG context' });
exports.exportConversation = (req, res) => res.json({ success: true, message: 'Feature available' });
exports.bulkUpdateConversations = (req, res) => res.json({ success: true, message: 'Feature available' });

================
File: backend/controllers/auth.controller.js
================
// backend/controllers/auth.controller.js
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const User = require('../models/mongodb/user.model');
const sendEmail = require('../utils/send-email');
const emailTemplates = require('../utils/email-templates');

/**
 * Generate JWT token for a user
 * @param {Object} user User object
 * @returns {String} JWT token
 */
const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, email: user.email, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRE || '30d' }
  );
};

/**
 * Register a new user
 * @route POST /api/auth/register
 * @access Public
 */
exports.register = async (req, res) => {
  try {
    const { email, password, firstName, lastName } = req.body;
    
    // Validate required fields
    if (!email || !password || !firstName || !lastName) {
      return res.status(400).json({
        success: false,
        error: 'All fields are required'
      });
    }
    
    // Check if user already exists
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: 'Email already in use'
      });
    }
    
    // Create the user
    const user = await User.create({
      email: email.toLowerCase(),
      password,
      firstName,
      lastName,
      isEmailVerified: true // TEMPORARILY SET TO TRUE FOR TESTING
    });
    
    // Generate email verification token (but don't require it for now)
    const verificationToken = user.generateEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Create verification URL
    const verificationUrl = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    // Try to send verification email, but don't fail registration if it fails
    try {
      await sendEmail({
        email: user.email,
        subject: 'Email Verification',
        html: emailTemplates.generateVerificationEmail(user.firstName, verificationUrl)
      });
      console.log('Verification email sent successfully');
    } catch (emailError) {
      console.error('Failed to send verification email:', emailError.message);
      // Don't fail registration due to email issues
    }
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    // Remove password from response
    user.password = undefined;
    
    res.status(201).json({
      success: true,
      token,
      data: {
        user,
        message: 'Registration successful'
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      error: 'Registration failed: ' + error.message
    });
  }
};

/**
 * Login user
 * @route POST /api/auth/login
 * @access Public
 */
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Validate email & password
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Please provide email and password'
      });
    }
    
    // Check for user
    const user = await User.findOne({ email: email.toLowerCase() }).select('+password +loginAttempts +lockUntil');
    
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Check if account is locked
    if (user.isLocked()) {
      return res.status(401).json({
        success: false,
        error: 'Account is temporarily locked. Please try again later.'
      });
    }
    
    // Check if password matches
    const isMatch = await user.comparePassword(password);
    
    if (!isMatch) {
      // Increment login attempts
      await user.incrementLoginAttempts();
      
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Reset login attempts on successful login
    await user.resetLoginAttempts();
    
    // Update last login
    user.lastLogin = Date.now();
    await user.save({ validateBeforeSave: false });
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    // Remove password and security fields from response
    user.password = undefined;
    user.loginAttempts = undefined;
    user.lockUntil = undefined;
    
    res.status(200).json({
      success: true,
      token,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      error: 'Login failed: ' + error.message
    });
  }
};

/**
 * Logout user
 * @route POST /api/auth/logout
 * @access Private
 */
exports.logout = (req, res) => {
  res.cookie('token', 'none', {
    expires: new Date(Date.now() + 10 * 1000),
    httpOnly: true
  });
  
  res.status(200).json({
    success: true,
    data: {
      message: 'Logged out successfully'
    }
  });
};

/**
 * Verify email
 * @route GET /api/auth/verify-email/:token
 * @access Public
 */
exports.verifyEmail = async (req, res) => {
  try {
    // Get hashed token
    const hashedToken = crypto
      .createHash('sha256')
      .update(req.params.token)
      .digest('hex');
    
    // Find user by verification token
    const user = await User.findOne({
      emailVerificationToken: hashedToken,
      emailVerificationExpires: { $gt: Date.now() }
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired token'
      });
    }
    
    // Set email as verified
    user.isEmailVerified = true;
    user.emailVerificationToken = undefined;
    user.emailVerificationExpires = undefined;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Email verified successfully'
      }
    });
  } catch (error) {
    console.error('Email verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Email verification failed'
    });
  }
};

/**
 * Resend verification email
 * @route POST /api/auth/resend-verification
 * @access Private
 */
exports.resendVerification = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    if (user.isEmailVerified) {
      return res.status(400).json({
        success: false,
        error: 'Email already verified'
      });
    }
    
    // Generate new verification token
    const verificationToken = user.generateEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Create verification URL
    const verificationUrl = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    try {
      await sendEmail({
        email: user.email,
        subject: 'Email Verification',
        html: emailTemplates.generateVerificationEmail(user.firstName, verificationUrl)
      });
      
      res.status(200).json({
        success: true,
        data: {
          message: 'Verification email sent. Please check your inbox.'
        }
      });
    } catch (error) {
      user.emailVerificationToken = undefined;
      user.emailVerificationExpires = undefined;
      await user.save({ validateBeforeSave: false });
      
      return res.status(500).json({
        success: false,
        error: 'Email could not be sent'
      });
    }
  } catch (error) {
    console.error('Resend verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to resend verification email'
    });
  }
};

/**
 * Forgot password
 * @route POST /api/auth/forgot-password
 * @access Public
 */
exports.forgotPassword = async (req, res) => {
  try {
    const user = await User.findOne({ email: req.body.email?.toLowerCase() });
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'There is no user with this email'
      });
    }
    
    // Generate reset token
    const resetToken = user.generatePasswordResetToken();
    await user.save({ validateBeforeSave: false });
    
    // Create reset URL
    const resetUrl = `${req.protocol}://${req.get('host')}/api/auth/reset-password/${resetToken}`;
    
    try {
      await sendEmail({
        email: user.email,
        subject: 'Password Reset',
        html: emailTemplates.generatePasswordResetEmail(user.firstName, resetUrl)
      });
      
      res.status(200).json({
        success: true,
        data: {
          message: 'Password reset email sent. Please check your inbox.'
        }
      });
    } catch (error) {
      user.passwordResetToken = undefined;
      user.passwordResetExpires = undefined;
      await user.save({ validateBeforeSave: false });
      
      return res.status(500).json({
        success: false,
        error: 'Email could not be sent'
      });
    }
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({
      success: false,
      error: 'Forgot password request failed'
    });
  }
};

/**
 * Reset password
 * @route PUT /api/auth/reset-password/:token
 * @access Public
 */
exports.resetPassword = async (req, res) => {
  try {
    // Get hashed token
    const hashedToken = crypto
      .createHash('sha256')
      .update(req.params.token)
      .digest('hex');
    
    // Find user by reset token
    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() }
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired token'
      });
    }
    
    // Set new password
    user.password = req.body.password;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Password reset successful'
      }
    });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({
      success: false,
      error: 'Password reset failed'
    });
  }
};

/**
 * Get current logged in user
 * @route GET /api/auth/me
 * @access Private
 */
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    res.status(200).json({
      success: true,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Get me error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get user data'
    });
  }
};

/**
 * Update user details
 * @route PUT /api/auth/update-details
 * @access Private
 */
exports.updateDetails = async (req, res) => {
  try {
    const fieldsToUpdate = {
      firstName: req.body.firstName,
      lastName: req.body.lastName,
      phoneNumber: req.body.phoneNumber,
      location: req.body.location,
      socialProfiles: req.body.socialProfiles
    };
    
    // Remove undefined fields
    Object.keys(fieldsToUpdate).forEach(key => 
      fieldsToUpdate[key] === undefined && delete fieldsToUpdate[key]
    );
    
    const user = await User.findByIdAndUpdate(
      req.user.id,
      fieldsToUpdate,
      {
        new: true,
        runValidators: true
      }
    );
    
    res.status(200).json({
      success: true,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Update details error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update user details'
    });
  }
};

/**
 * Update password
 * @route PUT /api/auth/update-password
 * @access Private
 */
exports.updatePassword = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('+password');
    
    // Check current password
    const isMatch = await user.comparePassword(req.body.currentPassword);
    
    if (!isMatch) {
      return res.status(401).json({
        success: false,
        error: 'Current password is incorrect'
      });
    }
    
    // Set new password
    user.password = req.body.newPassword;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Password updated successfully'
      }
    });
  } catch (error) {
    console.error('Update password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update password'
    });
  }
};

/**
 * Delete user account
 * @route DELETE /api/auth/delete-account
 * @access Private
 */
exports.deleteAccount = async (req, res) => {
  try {
    // Soft delete - set active to false
    await User.findByIdAndUpdate(req.user.id, {
      active: false
    });
    
    res.cookie('token', 'none', {
      expires: new Date(Date.now() + 10 * 1000),
      httpOnly: true
    });
    
    res.status(200).json({
      success: true,
      data: {
        message: 'Account deactivated successfully'
      }
    });
  } catch (error) {
    console.error('Delete account error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete account'
    });
  }
};

================
File: backend/controllers/job.controller.js
================
// controllers/job.controller.js - UPDATED FOR REAL JOB BOARD INTEGRATION - FIXED
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const jobAnalysisService = require('../services/jobAnalysis.service');
const jobMatchingService = require('../services/jobMatching.service');
const resumeTailoringService = require('../services/resumeTailoring.service');
const jobSearchService = require('../services/jobSearch.service');
const mongoose = require('mongoose');

// Enhanced background processing for manual jobs (uses premium GPT-4o)
async function processJobInBackground(jobId, jobMetadata = {}) {
  try {
    console.log(`🔍 Starting premium analysis for manually uploaded job: ${jobId}`);
    
    // Get the job from the database
    const job = await Job.findById(jobId);
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Update status: Starting analysis (10%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 10, 'Starting premium job analysis...');
    
    // Add realistic delay to show progress
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Update status: Extracting requirements (40%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 40, 'Extracting job requirements with GPT-4o...');
    
    // Analyze the job using PREMIUM GPT-4o service for manual uploads
    console.log('🤖 Starting premium job analysis with GPT-4o...');
    const parsedData = await jobAnalysisService.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location,
      ...jobMetadata
    }, {
      isAiDiscovery: false,    // Use premium GPT-4o for manual jobs
      prioritizeCost: false    // Prioritize quality for manual uploads
    });
    
    // Update status: Processing results (80%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 80, 'Processing premium analysis results...');
    
    // Add small delay for UX
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Update the job with parsed data
    job.parsedData = parsedData;
    job.updatedAt = new Date();
    
    // Mark analysis as complete with final status
    await updateJobAnalysisStatus(jobId, 'completed', 100, 
      `Premium analysis complete! Found ${parsedData.keySkills?.length || 0} key skills with GPT-4o.`, {
        completedAt: new Date(),
        skillsFound: parsedData.keySkills?.length || 0,
        experienceLevel: parsedData.experienceLevel,
        canViewJob: true,
        modelUsed: parsedData.analysisMetadata?.model || 'gpt-4o',
        analysisType: 'manual_upload_premium'
      });
    
    await job.save();
    
    console.log(`✅ Premium job analysis completed successfully for: ${job.title}`);
    console.log(`📊 Results: ${parsedData.keySkills?.length || 0} skills, model: ${parsedData.analysisMetadata?.model}, cost: ${parsedData.analysisMetadata?.estimatedCost}`);
    
    return true;
  } catch (error) {
    console.error('❌ Error in premium background processing:', error);
    
    // Update job to indicate analysis failed
    await updateJobAnalysisStatus(jobId, 'error', 0, `Premium analysis failed: ${error.message}`, {
      error: error.message,
      canViewJob: true,
      modelUsed: 'error'
    });
    
    throw error;
  }
}

async function updateJobAnalysisStatus(jobId, status, progress, message, additionalData = {}) {
  try {
    const job = await Job.findById(jobId);
    if (!job) {
      console.error(`Job not found for status update: ${jobId}`);
      return false;
    }
    
    job.analysisStatus = {
      status,
      progress,
      message,
      updatedAt: new Date(),
      ...additionalData
    };
    
    if (status === 'completed') {
      job.analysisStatus.completedAt = new Date();
    }
    
    await job.save();
    console.log(`📊 Updated analysis status for ${jobId}: ${status} (${progress}%) - ${message}`);
    return true;
  } catch (err) {
    console.error('Error updating job analysis status:', err);
    return false;
  }
}

// Create a new job with premium analysis
exports.createJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { 
      title, 
      company, 
      location, 
      description, 
      sourceUrl, 
      salary,
      jobType 
    } = req.body;
    
    // Validate required fields
    if (!title || !company || !description) {
      return res.status(400).json({ 
        message: 'Job title, company, and description are required' 
      });
    }
    
    // Create the job with initial analysis status
    const job = new Job({
      userId,
      title,
      company,
      location: location || {},
      description,
      sourceUrl,
      salary: salary || {},
      jobType: jobType || 'FULL_TIME',
      sourcePlatform: 'MANUAL',
      analysisStatus: {
        status: 'pending',
        progress: 0,
        message: 'Premium analysis queued...',
        startedAt: new Date(),
        canViewJob: false,
        estimatedCompletion: new Date(Date.now() + 45000), // 45 seconds for premium analysis
        analysisType: 'manual_upload_premium'
      }
    });
    
    // Save job to database
    await job.save();
    
    console.log(`🔍 Manual job created: ${job.title} at ${job.company} - Starting premium analysis...`);
    
    // Process job in background with premium analysis
    processJobInBackground(job._id, { title, company, location }).catch(err => {
      console.error('Background job processing error:', err);
    });
    
    res.status(201).json({
      message: 'Job created successfully and premium analysis initiated',
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        createdAt: job.createdAt,
        analysisStatus: job.analysisStatus
      }
    });
  } catch (error) {
    console.error('Error creating job:', error);
    res.status(500).json({ message: 'Failed to create job', error: error.message });
  }
};

// Get all user jobs with enhanced analysis status and real job board info
exports.getUserJobs = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobs = await Job.find({ userId }).sort({ createdAt: -1 });
    
    // Enhance jobs with analysis status information and job board approach info
    const enhancedJobs = jobs.map(job => {
      const jobObj = job.toObject();
      
      // Determine analysis status
      let analysisStatus = 'completed';
      let progress = 100;
      let message = 'Analysis complete';
      let canViewJob = true;
      let modelUsed = 'unknown';
      let analysisType = 'unknown';
      let isRealJobBoardDiscovery = false;
      let sourceJobBoard = null;
      
      if (job.analysisStatus) {
        analysisStatus = job.analysisStatus.status;
        progress = job.analysisStatus.progress;
        message = job.analysisStatus.message;
        canViewJob = job.analysisStatus.status === 'completed' || job.analysisStatus.status === 'error';
        modelUsed = job.analysisStatus.modelUsed || 'unknown';
        analysisType = job.analysisStatus.analysisType || 'unknown';
      } else if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
        analysisStatus = 'pending';
        progress = 0;
        message = 'Analysis pending...';
        canViewJob = false;
      } else if (job.parsedData.analysisMetadata) {
        modelUsed = job.parsedData.analysisMetadata.model || 'completed';
        analysisType = job.parsedData.analysisMetadata.analysisType || 'completed';
      }
      
      // Check if this is from real job board discovery
      isRealJobBoardDiscovery = job.sourcePlatform && (
        job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
        job.sourcePlatform.includes('AI_FOUND_LEVER') ||
        job.sourcePlatform.includes('AI_FOUND_INDEED')
      );
      
      // Extract source job board
      if (isRealJobBoardDiscovery) {
        if (job.sourcePlatform.includes('GREENHOUSE')) sourceJobBoard = 'Greenhouse';
        else if (job.sourcePlatform.includes('LEVER')) sourceJobBoard = 'Lever';
        else if (job.sourcePlatform.includes('INDEED')) sourceJobBoard = 'Indeed';
      }
      
      return {
        ...jobObj,
        analysisStatus: {
          status: analysisStatus,
          progress: progress,
          message: message,
          canViewJob: canViewJob,
          skillsFound: job.parsedData?.keySkills?.length || 0,
          experienceLevel: job.parsedData?.experienceLevel,
          modelUsed: modelUsed,
          analysisType: analysisType,
          isAiDiscovery: job.sourcePlatform === 'AI_FOUND' || 
                        job.sourcePlatform === 'AI_FOUND_OPTIMIZED' ||
                        job.sourcePlatform === 'AI_FOUND_INTELLIGENT' ||
                        isRealJobBoardDiscovery,
          isRealJobBoardDiscovery: isRealJobBoardDiscovery,
          sourceJobBoard: sourceJobBoard,
          searchApproach: isRealJobBoardDiscovery ? '3-phase-real-job-boards' : 
                         (job.sourcePlatform?.includes('AI_FOUND') ? 'legacy-ai' : 'manual'),
          qualityLevel: analysisType?.includes('premium') ? 'premium' : 'standard',
          updatedAt: job.analysisStatus?.updatedAt || job.updatedAt,
          realJobBoardData: job.parsedData?.realJobBoardData || null
        }
      };
    });
    
    res.status(200).json({ jobs: enhancedJobs });
  } catch (error) {
    console.error('Error fetching jobs:', error);
    res.status(500).json({ message: 'Failed to fetch jobs', error: error.message });
  }
};

// Get job by ID with real job board context
exports.getJobById = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    res.status(200).json({ job });
  } catch (error) {
    console.error('Error fetching job:', error);
    res.status(500).json({ message: 'Failed to fetch job', error: error.message });
  }
};

// Get job analysis status with real job board information
exports.getJobAnalysisStatus = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId }, 'analysisStatus parsedData title company createdAt sourcePlatform');
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    let status = 'completed';
    let progress = 100;
    let message = 'Analysis complete';
    let canViewJob = true;
    let skillsFound = 0;
    let experienceLevel = null;
    let modelUsed = 'unknown';
    let analysisType = 'unknown';
    let isRealJobBoardDiscovery = false;
    let sourceJobBoard = null;
    
    if (job.analysisStatus && job.analysisStatus.status) {
      status = job.analysisStatus.status;
      progress = job.analysisStatus.progress || 0;
      message = job.analysisStatus.message || 'Processing...';
      canViewJob = job.analysisStatus.canViewJob !== false;
      skillsFound = job.analysisStatus.skillsFound || 0;
      experienceLevel = job.analysisStatus.experienceLevel;
      modelUsed = job.analysisStatus.modelUsed || 'unknown';
      analysisType = job.analysisStatus.analysisType || 'unknown';
    } 
    else if (job.parsedData && Object.keys(job.parsedData).length > 0 && !job.parsedData.analysisError) {
      status = 'completed';
      progress = 100;
      message = `Premium analysis complete! Found ${job.parsedData.keySkills?.length || 0} key skills.`;
      canViewJob = true;
      skillsFound = job.parsedData.keySkills?.length || 0;
      experienceLevel = job.parsedData.experienceLevel;
      modelUsed = job.parsedData.analysisMetadata?.model || 'gpt-4o';
      analysisType = job.parsedData.analysisMetadata?.analysisType || 'premium';
    }
    else if (job.parsedData && job.parsedData.analysisError) {
      status = 'error';
      progress = 0;
      message = 'Analysis failed';
      canViewJob = true;
    }
    else {
      status = 'pending';
      progress = 0;
      message = 'Analysis pending...';
      canViewJob = false;
    }
    
    // Check if this is from real job board discovery
    isRealJobBoardDiscovery = job.sourcePlatform && (
      job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
      job.sourcePlatform.includes('AI_FOUND_LEVER') ||
      job.sourcePlatform.includes('AI_FOUND_INDEED')
    );
    
    // Extract source job board
    if (isRealJobBoardDiscovery) {
      if (job.sourcePlatform.includes('GREENHOUSE')) sourceJobBoard = 'Greenhouse';
      else if (job.sourcePlatform.includes('LEVER')) sourceJobBoard = 'Lever';
      else if (job.sourcePlatform.includes('INDEED')) sourceJobBoard = 'Indeed';
    }
    
    console.log(`📊 Analysis Status for job ${jobId}: ${status} (${progress}%) - ${message}`);
    
    res.status(200).json({ 
      analysisStatus: {
        status,
        progress,
        message,
        updatedAt: job.analysisStatus?.updatedAt || new Date(),
        skillsFound,
        experienceLevel,
        isAnalysisComplete: status === 'completed',
        canViewJob: canViewJob,
        modelUsed: modelUsed,
        analysisType: analysisType,
        isRealJobBoardDiscovery: isRealJobBoardDiscovery,
        sourceJobBoard: sourceJobBoard,
        searchApproach: isRealJobBoardDiscovery ? '3-phase-real-job-boards' : 
                       (job.sourcePlatform?.includes('AI_FOUND') ? 'legacy-ai' : 'manual'),
        qualityLevel: analysisType?.includes('premium') ? 'premium' : 'standard',
        error: job.analysisStatus?.error || job.parsedData?.analysisError
      },
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        createdAt: job.createdAt,
        sourcePlatform: job.sourcePlatform
      },
      realJobBoardInfo: isRealJobBoardDiscovery ? {
        description: 'This job was discovered using our ENHANCED 3-Phase approach with REAL job board integration',
        sourceJobBoard: sourceJobBoard,
        benefits: [
          `Discovered from actual ${sourceJobBoard} company posting`,
          'Real job content from company ATS platform',
          'Premium GPT-4o analysis (same quality as manual jobs)',
          'Enhanced job matching and relevance',
          'Direct company posting verification'
        ],
        jobBoardFeatures: {
          greenhouse: 'Tech startups and scale-ups with comprehensive job details',
          lever: 'Growth-stage companies with detailed role information',
          indeed: 'Established companies with verified direct postings'
        }[sourceJobBoard?.toLowerCase()] || 'High-quality company job posting'
      } : null
    });
  } catch (error) {
    console.error('Error fetching job analysis status:', error);
    res.status(500).json({ message: 'Failed to fetch analysis status', error: error.message });
  }
};

// Update job
exports.updateJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const { 
      title, 
      company, 
      location, 
      description, 
      sourceUrl, 
      salary,
      jobType,
      applicationStatus,
      notes
    } = req.body;
    
    let needsReanalysis = false;
    
    // Update fields if provided
    if (title && title !== job.title) {
      job.title = title;
      needsReanalysis = true;
    }
    if (company && company !== job.company) {
      job.company = company;
      needsReanalysis = true;
    }
    if (location) job.location = location;
    if (description && description !== job.description) {
      job.description = description;
      job.parsedData = {}; // Clear parsedData to trigger re-analysis
      needsReanalysis = true;
    }
    if (sourceUrl) job.sourceUrl = sourceUrl;
    if (salary) job.salary = salary;
    if (jobType) job.jobType = jobType;
    if (applicationStatus) job.applicationStatus = applicationStatus;
    
    // Add a new note if provided
    if (notes && notes.content) {
      job.notes.push({
        content: notes.content,
        createdAt: new Date()
      });
    }
    
    await job.save();
    
    // If significant changes were made, trigger re-analysis with PREMIUM model
    if (needsReanalysis) {
      processJobInBackground(job._id, {
        title: job.title,
        company: job.company,
        location: job.location
      }).catch(err => {
        console.error('Background job processing error after update:', err);
      });
    }
    
    res.status(200).json({
      message: 'Job updated successfully',
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        updatedAt: job.updatedAt
      },
      reanalysisTriggered: needsReanalysis,
      reanalysisNote: needsReanalysis ? 'Premium re-analysis initiated with GPT-4o' : null
    });
  } catch (error) {
    console.error('Error updating job:', error);
    res.status(500).json({ message: 'Failed to update job', error: error.message });
  }
};

// Delete job
exports.deleteJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    await Job.deleteOne({ _id: jobId });
    
    res.status(200).json({ message: 'Job deleted successfully' });
  } catch (error) {
    console.error('Error deleting job:', error);
    res.status(500).json({ message: 'Failed to delete job', error: error.message });
  }
};

// Match resume with job
exports.matchResumeWithJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { jobId, resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(jobId) || !mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid job ID or resume ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Check if the job has been analyzed
    if (!job.parsedData || Object.keys(job.parsedData).length === 0 || job.parsedData.analysisError) {
      console.log('Job analysis missing or failed, attempting re-analysis...');
      try {
        await processJobInBackground(jobId, {
          title: job.title,
          company: job.company,
          location: job.location
        });
        const updatedJob = await Job.findById(jobId);
        if (!updatedJob.parsedData || Object.keys(updatedJob.parsedData).length === 0) {
          throw new Error('Job re-analysis failed');
        }
        Object.assign(job, updatedJob);
      } catch (analysisError) {
        console.error('Job re-analysis failed:', analysisError);
        return res.status(400).json({ 
          message: 'Job analysis not complete and re-analysis failed. Please try again later.',
          error: analysisError.message
        });
      }
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    console.log(`Starting enhanced matching for job "${job.title}" with resume "${resume.name}"`);
    
    const matchResults = await jobMatchingService.matchResumeWithJob(resumeId, jobId);
    
    job.matchAnalysis = {
      resumeId,
      lastAnalyzed: new Date(),
      ...matchResults
    };
    await job.save();
    
    console.log(`Enhanced matching completed - Overall Score: ${matchResults.overallScore}%`);
    
    res.status(200).json({
      message: 'Enhanced resume-job matching completed successfully',
      matchAnalysis: job.matchAnalysis,
      matchingVersion: matchResults.analysisMetadata?.algorithmVersion || '2.0'
    });
  } catch (error) {
    console.error('Error in enhanced matching:', error);
    res.status(500).json({ 
      message: 'Failed to match resume with job', 
      error: error.message,
      suggestion: 'Please ensure both the job and resume have been properly analyzed'
    });
  }
};

// Get tailoring recommendations
exports.tailorResumeToJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { jobId, resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(jobId) || !mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid job ID or resume ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    if (!job.parsedData || Object.keys(job.parsedData).length === 0 || job.parsedData.analysisError) {
      return res.status(400).json({ message: 'Job analysis not complete. Please try again later.' });
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    if (!job.matchAnalysis || !job.matchAnalysis.overallScore) {
      console.log('No match analysis found, performing matching first...');
      const matchResults = await jobMatchingService.matchResumeWithJob(resumeId, jobId);
      job.matchAnalysis = {
        resumeId,
        lastAnalyzed: new Date(),
        ...matchResults
      };
      await job.save();
    }
    
    const tailoringResult = await resumeTailoringService.getTailoringRecommendations(resumeId, jobId);
    
    res.status(200).json({
      message: 'Resume tailoring recommendations generated successfully',
      tailoringResult,
      matchScore: job.matchAnalysis.overallScore
    });
  } catch (error) {
    console.error('Error generating resume tailoring recommendations:', error);
    res.status(500).json({ 
      message: 'Failed to generate resume tailoring recommendations', 
      error: error.message 
    });
  }
};

// Find jobs with ENHANCED AI (Real Job Board Integration)
exports.findJobsWithAi = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    // Start ENHANCED AI job search with REAL Job Board Integration
    res.status(202).json({
      message: 'ENHANCED 3-Phase AI job search with REAL job board integration initiated! Jobs will be discovered from actual company postings.',
      status: 'processing',
      realJobBoardIntegrationInfo: {
        phase1: 'Career Analysis (GPT-4 Turbo) - $0.05',
        phase2: 'REAL Job Board Discovery (Claude 3.5 Sonnet + Web Search) - $0.30-0.50',
        phase3: 'Premium Analysis (GPT-4o batch) - $0.01-0.02',
        totalCost: '$0.36-0.57 per search',
        targetJobBoards: ['Greenhouse', 'Lever', 'Indeed'],
        enhancements: [
          'Search actual company job boards (Greenhouse, Lever, Indeed)',
          'Extract real job postings from company ATS platforms',
          'Premium GPT-4o analysis for all discovered jobs',
          'Same quality as manually uploaded jobs',
          'Direct company posting verification',
          'Enhanced job matching with real job content'
        ],
        expectedResults: [
          'Higher quality job content from real company postings',
          'More accurate job requirements from ATS platforms',
          'Better skill matching with actual job descriptions',
          'Verified company postings (no recruiter spam)',
          'Faster processing with premium analysis pipeline',
          'Comprehensive job details including tech stack and team info'
        ]
      }
    });
    
    // Perform ENHANCED AI job search with REAL Job Board Integration in the background
    jobSearchService.findJobsWithAi(userId, resumeId)
      .then(result => {
        console.log('ENHANCED AI job search with real job board integration completed:', result);
      })
      .catch(error => {
        console.error('ENHANCED AI job search with real job board integration error:', error);
      });
  } catch (error) {
    console.error('Error initiating ENHANCED AI job search with real job board integration:', error);
    res.status(500).json({ 
      message: 'Failed to initiate ENHANCED AI job search with real job board integration', 
      error: error.message 
    });
  }
};

// Re-analyze a job with premium model
exports.reAnalyzeJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    console.log(`Manual re-analysis triggered for job: ${job.title} at ${job.company}`);
    
    // Perform re-analysis with PREMIUM model for manual triggers
    const analysisResult = await jobAnalysisService.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location
    }, {
      isAiDiscovery: false,    // Use premium GPT-4o for manual re-analysis
      prioritizeCost: false    // Prioritize quality
    });
    
    // Update the job
    job.parsedData = analysisResult;
    job.updatedAt = new Date();
    
    // Clear any existing match analysis since the job has changed
    if (job.matchAnalysis) {
      job.matchAnalysis = null;
    }
    
    await job.save();
    
    res.status(200).json({
      message: 'Job re-analysis completed successfully with premium model',
      analysisResult: {
        skillsFound: analysisResult.keySkills?.length || 0,
        experienceLevel: analysisResult.experienceLevel,
        algorithmVersion: analysisResult.analysisMetadata?.algorithmVersion,
        modelUsed: analysisResult.analysisMetadata?.model,
        estimatedCost: analysisResult.analysisMetadata?.estimatedCost,
        analysisType: analysisResult.analysisMetadata?.analysisType,
        analyzedAt: analysisResult.analysisMetadata?.analyzedAt
      }
    });
  } catch (error) {
    console.error('Error re-analyzing job:', error);
    res.status(500).json({ 
      message: 'Failed to re-analyze job', 
      error: error.message 
    });
  }
};

// Re-match job with best available resume
exports.rematchJobWithBestResume = async (req, res) => {
  try {
    const { jobId } = req.params;
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    console.log(`Re-matching job ${jobId} with best resume for user ${userId}`);
    
    const result = await jobMatchingService.matchJobWithBestResume(jobId, userId);
    
    console.log('Re-matching completed:', {
      jobId,
      usedResumeId: result.usedResume.id,
      usedResumeName: result.usedResume.name,
      isTailored: result.usedResume.isTailored,
      newMatchScore: result.matchAnalysis.overallScore
    });
    
    res.status(200).json({
      message: 'Job re-matched with best available resume',
      matchAnalysis: result.matchAnalysis,
      usedResume: result.usedResume
    });
    
  } catch (error) {
    console.error('Error re-matching job:', error);
    res.status(500).json({ 
      message: 'Failed to re-match job with best resume', 
      error: error.message 
    });
  }
};

// Get resume match status for a specific job
exports.getResumeMatchStatus = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const resumes = await Resume.find({ userId });
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const tailoredResumes = await Resume.find({ 
      userId, 
      isTailored: true, 
      'tailoredForJob.jobId': jobId 
    });
    
    const resumeStatusMap = {};
    
    resumes.forEach(resume => {
      const resumeId = resume._id.toString();
      resumeStatusMap[resumeId] = {
        id: resume._id,
        name: resume.name,
        isMatched: job.matchAnalysis && job.matchAnalysis.resumeId && 
                   job.matchAnalysis.resumeId.toString() === resumeId,
        isTailored: false,
        tailoredVersions: []
      };
    });
    
    tailoredResumes.forEach(tailoredResume => {
      const originalResumeId = tailoredResume.tailoredForJob?.originalResumeId?.toString();
      
      if (originalResumeId && resumeStatusMap[originalResumeId]) {
        resumeStatusMap[originalResumeId].isTailored = true;
        resumeStatusMap[originalResumeId].tailoredVersions.push({
          id: tailoredResume._id,
          name: tailoredResume.name,
          createdAt: tailoredResume.createdAt
        });
      } else {
        console.log('Found tailored resume without clear original reference:', tailoredResume.name);
      }
    });
    
    res.status(200).json({ 
      resumeStatusMap,
      jobMatchedResumeId: job.matchAnalysis?.resumeId?.toString() || null
    });
  } catch (error) {
    console.error('Error fetching resume match status:', error);
    res.status(500).json({ message: 'Failed to fetch resume match status', error: error.message });
  }
};

// Get job analysis insights with real job board statistics
exports.getJobAnalysisInsights = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    // Get all user's jobs with analysis data
    const jobs = await Job.find({ 
      userId,
      parsedData: { $exists: true, $ne: {} }
    });
    
    // Calculate insights with model usage breakdown and real job board stats
    const insights = {
      totalJobsAnalyzed: jobs.length,
      experienceLevels: {},
      topSkillsRequired: {},
      industryDistribution: {},
      averageSkillsPerJob: 0,
      recentAnalyses: [],
      modelUsageStats: {
        'gpt-4o': 0,           // Premium for both manual and AI discovery
        'gpt-4o-mini': 0,      // Legacy (now deprecated)
        'fallback': 0,         // Fallback analyses
        'unknown': 0
      },
      costBreakdown: {
        manualJobs: { count: 0, estimatedCost: 0 },
        aiDiscoveryJobs: { count: 0, estimatedCost: 0 },
        totalEstimatedCost: 0
      },
      // ENHANCED: Real job board statistics
      realJobBoardStats: {
        totalRealJobBoardJobs: 0,
        jobBoardBreakdown: {
          greenhouse: 0,
          lever: 0,
          indeed: 0
        },
        averageContentQuality: 'unknown',
        realVsLegacyAI: {
          realJobBoards: 0,
          legacyAI: 0,
          manual: 0
        }
      }
    };
    
    let totalSkills = 0;
    
    jobs.forEach(job => {
      if (job.parsedData && !job.parsedData.analysisError) {
        // Experience levels
        const expLevel = job.parsedData.experienceLevel || 'unknown';
        insights.experienceLevels[expLevel] = (insights.experienceLevels[expLevel] || 0) + 1;
        
        // Industry distribution
        const industry = job.parsedData.industryContext || 'unknown';
        insights.industryDistribution[industry] = (insights.industryDistribution[industry] || 0) + 1;
        
        // Skills aggregation
        if (job.parsedData.keySkills && Array.isArray(job.parsedData.keySkills)) {
          totalSkills += job.parsedData.keySkills.length;
          job.parsedData.keySkills.forEach(skill => {
            const skillName = skill.name || skill;
            insights.topSkillsRequired[skillName] = (insights.topSkillsRequired[skillName] || 0) + 1;
          });
        }
        
        // Model usage tracking
        const model = job.parsedData.analysisMetadata?.model || 'unknown';
        const modelKey = model.includes('mini') ? 'gpt-4o-mini' : 
                        model.includes('gpt-4o') ? 'gpt-4o' : 
                        model.includes('fallback') ? 'fallback' : 'unknown';
        insights.modelUsageStats[modelKey]++;
        
        // Enhanced job classification with real job board detection
        const isRealJobBoard = job.sourcePlatform && (
          job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
          job.sourcePlatform.includes('AI_FOUND_LEVER') ||
          job.sourcePlatform.includes('AI_FOUND_INDEED')
        );
        
        const isAiDiscovery = job.sourcePlatform === 'AI_FOUND' || 
                             job.sourcePlatform === 'AI_FOUND_OPTIMIZED' ||
                             job.sourcePlatform === 'AI_FOUND_INTELLIGENT' ||
                             isRealJobBoard;
        
        if (isRealJobBoard) {
          insights.realJobBoardStats.totalRealJobBoardJobs++;
          insights.realJobBoardStats.realVsLegacyAI.realJobBoards++;
          
          // Track specific job board
          if (job.sourcePlatform.includes('GREENHOUSE')) {
            insights.realJobBoardStats.jobBoardBreakdown.greenhouse++;
          } else if (job.sourcePlatform.includes('LEVER')) {
            insights.realJobBoardStats.jobBoardBreakdown.lever++;
          } else if (job.sourcePlatform.includes('INDEED')) {
            insights.realJobBoardStats.jobBoardBreakdown.indeed++;
          }
        } else if (isAiDiscovery) {
          insights.realJobBoardStats.realVsLegacyAI.legacyAI++;
        } else {
          insights.realJobBoardStats.realVsLegacyAI.manual++;
        }
        
        // Cost tracking
        if (isAiDiscovery) {
          insights.costBreakdown.aiDiscoveryJobs.count++;
          insights.costBreakdown.aiDiscoveryJobs.estimatedCost += 0.02; // Premium analysis cost
        } else {
          insights.costBreakdown.manualJobs.count++;
          insights.costBreakdown.manualJobs.estimatedCost += 0.02; // Premium analysis cost
        }
        
        // Recent analyses with job board info
        if (job.parsedData.analysisMetadata?.analyzedAt) {
          insights.recentAnalyses.push({
            jobId: job._id,
            title: job.title,
            company: job.company,
            analyzedAt: job.parsedData.analysisMetadata.analyzedAt,
            skillsFound: job.parsedData.keySkills?.length || 0,
            model: job.parsedData.analysisMetadata.model,
            analysisType: job.parsedData.analysisMetadata.analysisType,
            sourcePlatform: job.sourcePlatform,
            isRealJobBoardDiscovery: isRealJobBoard,
            sourceJobBoard: isRealJobBoard ? (
              job.sourcePlatform.includes('GREENHOUSE') ? 'Greenhouse' :
              job.sourcePlatform.includes('LEVER') ? 'Lever' :
              job.sourcePlatform.includes('INDEED') ? 'Indeed' : 'Unknown'
            ) : null
          });
        }
      }
    });
    
    // Calculate totals and averages
    insights.averageSkillsPerJob = jobs.length > 0 ? Math.round(totalSkills / jobs.length) : 0;
    insights.costBreakdown.totalEstimatedCost = 
      insights.costBreakdown.manualJobs.estimatedCost + 
      insights.costBreakdown.aiDiscoveryJobs.estimatedCost;
    
    // Calculate real job board average content quality
    if (insights.realJobBoardStats.totalRealJobBoardJobs > 0) {
      insights.realJobBoardStats.averageContentQuality = 'high'; // Real job boards typically have high quality
    }
    
    // Sort top skills by frequency
    insights.topSkillsRequired = Object.entries(insights.topSkillsRequired)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .reduce((obj, [skill, count]) => {
        obj[skill] = count;
        return obj;
      }, {});
    
    // Sort recent analyses by date
    insights.recentAnalyses = insights.recentAnalyses
      .sort((a, b) => new Date(b.analyzedAt) - new Date(a.analyzedAt))
      .slice(0, 5);
    
    res.status(200).json({ 
      insights,
      enhancedRealJobBoardInfo: {
        description: 'ENHANCED 3-Phase Approach with REAL Job Board Integration: Career Analysis → Real Job Board Discovery → Premium Analysis',
        improvements: [
          'Phase 1: Enhanced career targeting with GPT-4 Turbo',
          'Phase 2: REAL job board discovery from Greenhouse, Lever, and Indeed',
          'Phase 3: Premium job analysis with GPT-4o (same quality for all jobs)',
          'Direct company posting verification',
          'Enhanced job content quality from ATS platforms'
        ],
        realJobBoardBenefits: [
          'Search actual company job boards (no recruiter spam)',
          'Extract comprehensive job details from ATS platforms',
          'Verify direct company postings with enhanced metadata',
          'Access to tech stack, team info, and hiring manager details',
          'Higher quality job content and requirements'
        ],
        costStructure: {
          phase1: 'Career Analysis: $0.05 (GPT-4 Turbo)',
          phase2: 'Real Job Board Discovery: $0.30-0.50 (Claude 3.5 Sonnet)',
          phase3: 'Premium Analysis: $0.01-0.02 (GPT-4o batch)',
          totalPerSearch: '$0.36-0.57',
          comparison: 'Same cost as previous but now searches REAL job boards'
        },
        targetJobBoards: {
          greenhouse: 'Tech startups and scale-ups with comprehensive postings',
          lever: 'Growth-stage companies with detailed role information',
          indeed: 'Established companies with verified direct postings'
        }
      }
    });
  } catch (error) {
    console.error('Error getting job analysis insights:', error);
    res.status(500).json({ 
      message: 'Failed to get job analysis insights', 
      error: error.message 
    });
  }
};

// AI Search Management Routes

// Get user AI searches
exports.getUserAiSearches = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const searches = await jobSearchService.getUserAiSearches(userId);
    
    res.status(200).json({ searches });
  } catch (error) {
    console.error('Error fetching AI searches:', error);
    res.status(500).json({ 
      message: 'Failed to fetch AI job searches', 
      error: error.message 
    });
  }
};

// Pause AI search
exports.pauseAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.pauseAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error pausing AI search:', error);
    res.status(500).json({ 
      message: 'Failed to pause AI search', 
      error: error.message 
    });
  }
};

// Resume AI search
exports.resumeAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.resumeAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error resuming AI search:', error);
    res.status(500).json({ 
      message: 'Failed to resume AI search', 
      error: error.message 
    });
  }
};

// Delete AI search
exports.deleteAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.deleteAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error deleting AI search:', error);
    res.status(500).json({ 
      message: 'Failed to delete AI search', 
      error: error.message 
    });
  }
};

================
File: backend/controllers/recruiter.controller.js
================
// backend/controllers/recruiter.controller.js - COMPLETE UPDATED VERSION
const { Pool } = require('pg');
const Outreach = require('../models/mongodb/outreach.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const { openai } = require('../config/openai');

// PostgreSQL connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

/**
 * Search recruiters with simplified filtering (no experience or sort filters)
 */
exports.searchRecruiters = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      query = '',
      company = '',
      industry = '',
      location = '',
      title = '',
      limit = 20,
      offset = 0
    } = req.query;

    console.log(`🔍 Searching recruiters for user ${userId}:`, {
      query, company, industry, location, title, limit: parseInt(limit)
    });

    // Build the SQL query dynamically
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone as phone,
        r.title,
        r.linkedin_profile_url as linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        i.name as industry_name,
        l.city,
        l.state,
        l.country,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    // Add search filters with COALESCE to handle NULL values
    if (query) {
      sqlQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${paramIndex} OR
        COALESCE(r.title, '') ILIKE $${paramIndex} OR
        COALESCE(c.name, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${query.toLowerCase()}%`);
      paramIndex++;
    }

    if (company) {
      sqlQuery += ` AND COALESCE(c.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${company.toLowerCase()}%`);
      paramIndex++;
    }

    if (industry) {
      sqlQuery += ` AND COALESCE(i.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${industry.toLowerCase()}%`);
      paramIndex++;
    }

    if (location) {
      sqlQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${paramIndex} OR
        COALESCE(l.state, '') ILIKE $${paramIndex} OR
        COALESCE(l.country, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${location.toLowerCase()}%`);
      paramIndex++;
    }

    if (title) {
      sqlQuery += ` AND COALESCE(r.title, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${title.toLowerCase()}%`);
      paramIndex++;
    }

    // Simple ordering by ID (most recent recruiters first)
    sqlQuery += ` ORDER BY r.id DESC`;
    
    // Add pagination
    sqlQuery += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    queryParams.push(parseInt(limit), parseInt(offset));

    console.log('🗄️ Executing SQL query with params:', queryParams);

    // Execute the query
    const result = await pool.query(sqlQuery, queryParams);

    // Get total count for pagination
    let countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;
    
    const countParams = [userId.toString()];
    let countParamIndex = 2;

    // Apply same filters to count query
    if (query) {
      countQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${countParamIndex} OR
        COALESCE(r.title, '') ILIKE $${countParamIndex} OR
        COALESCE(c.name, '') ILIKE $${countParamIndex}
      )`;
      countParams.push(`%${query.toLowerCase()}%`);
      countParamIndex++;
    }

    if (company) {
      countQuery += ` AND COALESCE(c.name, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${company.toLowerCase()}%`);
      countParamIndex++;
    }

    if (industry) {
      countQuery += ` AND COALESCE(i.name, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${industry.toLowerCase()}%`);
      countParamIndex++;
    }

    if (location) {
      countQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${countParamIndex} OR
        COALESCE(l.state, '') ILIKE $${countParamIndex} OR
        COALESCE(l.country, '') ILIKE $${countParamIndex}
      )`;
      countParams.push(`%${location.toLowerCase()}%`);
      countParamIndex++;
    }

    if (title) {
      countQuery += ` AND COALESCE(r.title, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${title.toLowerCase()}%`);
      countParamIndex++;
    }

    const countResult = await pool.query(countQuery, countParams);

    const recruiters = result.rows.map(row => ({
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      fullName: `${row.first_name || ''} ${row.last_name || ''}`.trim(),
      email: row.email,
      phone: row.phone,
      title: row.title,
      linkedinUrl: row.linkedin_url,
      experienceYears: row.experience_years,
      lastActiveDate: row.last_active_date,
      rating: row.rating,
      company: {
        name: row.company_name,
        website: row.company_website,
        size: row.company_size,
        logo: row.company_logo
      },
      industry: row.industry_name,
      location: {
        city: row.city,
        state: row.state,
        country: row.country
      },
      outreach: {
        hasContacted: !!row.last_contact_date,
        lastContactDate: row.last_contact_date,
        status: row.outreach_status
      }
    }));

    console.log(`✅ Found ${recruiters.length} recruiters (Total: ${countResult.rows[0].count})`);

    res.json({
      success: true,
      recruiters,
      pagination: {
        total: parseInt(countResult.rows[0].count),
        limit: parseInt(limit),
        offset: parseInt(offset),
        hasMore: parseInt(offset) + parseInt(limit) < parseInt(countResult.rows[0].count)
      }
    });

  } catch (error) {
    console.error('Search recruiters error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to search recruiters',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get recruiter details by ID
 */
exports.getRecruiterById = async (req, res) => {
  try {
    const userId = req.user._id;
    const { recruiterId } = req.params;

    console.log(`👤 Getting recruiter details for ID: ${recruiterId}`);

    const sqlQuery = `
      SELECT 
        r.*,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        c.description as company_description,
        c.founded_year,
        i.name as industry_name,
        i.description as industry_description,
        l.city,
        l.state,
        l.country,
        l.postal_code,
        -- Outreach history
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.id = $2
    `;

    const result = await pool.query(sqlQuery, [userId.toString(), recruiterId]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const row = result.rows[0];
    
    // Get recruiter's skills
    const skillsQuery = `
      SELECT s.name, s.category
      FROM recruiter_skills rs
      JOIN skills s ON rs.skill_id = s.id
      WHERE rs.recruiter_id = $1
    `;
    const skillsResult = await pool.query(skillsQuery, [recruiterId]);

    // Get outreach history from MongoDB
    const outreachHistory = await Outreach.find({
      userId,
      recruiterId: recruiterId
    }).sort({ createdAt: -1 }).limit(10);

    const recruiter = {
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      fullName: `${row.first_name || ''} ${row.last_name || ''}`.trim(),
      email: row.email,
      phone: row.direct_phone,
      title: row.title,
      linkedinUrl: row.linkedin_profile_url,
      otherSocialUrls: row.other_social_urls,
      experienceYears: row.experience_years,
      lastActiveDate: row.last_active_date,
      rating: row.rating,
      notes: row.notes,
      specializations: row.specializations,
      company: {
        name: row.company_name,
        website: row.company_website,
        size: row.company_size,
        logo: row.company_logo,
        description: row.company_description,
        foundedYear: row.founded_year
      },
      industry: {
        name: row.industry_name,
        description: row.industry_description
      },
      location: {
        city: row.city,
        state: row.state,
        country: row.country,
        postalCode: row.postal_code
      },
      skills: skillsResult.rows.map(skill => ({
        name: skill.name,
        category: skill.category
      })),
      outreach: {
        hasContacted: !!row.last_contact_date,
        lastContactDate: row.last_contact_date,
        status: row.outreach_status,
        history: outreachHistory
      },
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };

    console.log(`✅ Retrieved recruiter: ${recruiter.fullName} at ${recruiter.company.name}`);

    res.json({
      success: true,
      recruiter
    });

  } catch (error) {
    console.error('Get recruiter details error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get recruiter details',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get filter options for recruiter search (simplified - no experience ranges)
 */
exports.getFilterOptions = async (req, res) => {
  try {
    console.log('📊 Getting filter options for recruiter search');

    // Get top companies
    const companiesQuery = `
      SELECT c.name, COUNT(r.id) as recruiter_count
      FROM companies c
      JOIN recruiters r ON c.id = r.current_company_id
      WHERE r.is_active = true
      GROUP BY c.id, c.name
      ORDER BY recruiter_count DESC
      LIMIT 50
    `;

    // Get industries
    const industriesQuery = `
      SELECT i.name, COUNT(r.id) as recruiter_count
      FROM industries i
      JOIN recruiters r ON i.id = r.industry_id
      WHERE r.is_active = true
      GROUP BY i.id, i.name
      ORDER BY recruiter_count DESC
      LIMIT 30
    `;

    // Get locations
    const locationsQuery = `
      SELECT 
        CASE 
          WHEN l.state IS NOT NULL THEN l.city || ', ' || l.state || ', ' || l.country
          ELSE l.city || ', ' || l.country
        END as location,
        COUNT(r.id) as recruiter_count
      FROM locations l
      JOIN recruiters r ON l.id = r.location_id
      WHERE r.is_active = true
      GROUP BY l.city, l.state, l.country
      ORDER BY recruiter_count DESC
      LIMIT 50
    `;

    const [companies, industries, locations] = await Promise.all([
      pool.query(companiesQuery),
      pool.query(industriesQuery),
      pool.query(locationsQuery)
    ]);

    const filterOptions = {
      companies: companies.rows.map(row => ({
        name: row.name,
        count: parseInt(row.recruiter_count)
      })),
      industries: industries.rows.map(row => ({
        name: row.name,
        count: parseInt(row.recruiter_count)
      })),
      locations: locations.rows.map(row => ({
        name: row.location,
        count: parseInt(row.recruiter_count)
      }))
    };

    console.log(`✅ Retrieved filter options - ${filterOptions.companies.length} companies, ${filterOptions.industries.length} industries`);

    res.json({
      success: true,
      filterOptions
    });

  } catch (error) {
    console.error('Get filter options error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get filter options',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Create outreach campaign
 */
exports.createOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      recruiterId,
      jobId,
      messageContent,
      messageTemplate,
      sentVia = 'linkedin',
      customizations = []
    } = req.body;

    console.log(`📧 Creating outreach for recruiter ${recruiterId} by user ${userId}`);

    // Validate inputs
    if (!recruiterId || !messageContent) {
      return res.status(400).json({
        success: false,
        error: 'Recruiter ID and message content are required'
      });
    }

    // Get recruiter details for validation
    const recruiterQuery = `SELECT id, first_name, last_name, email FROM recruiters WHERE id = $1`;
    const recruiterResult = await pool.query(recruiterQuery, [recruiterId]);

    if (recruiterResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const recruiter = recruiterResult.rows[0];

    // Create outreach record in MongoDB
    const outreach = new Outreach({
      userId,
      recruiterId: recruiterId.toString(),
      jobId,
      messageContent,
      messageTemplate,
      customizations,
      sentVia,
      status: 'drafted',
      createdAt: new Date()
    });

    await outreach.save();

    // Update PostgreSQL outreach history
    const upsertQuery = `
      INSERT INTO outreach_history (recruiter_id, mongodb_outreach_id, mongodb_user_id, status, last_contact_date)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (recruiter_id, mongodb_user_id) 
      DO UPDATE SET 
        mongodb_outreach_id = $2,
        status = $4,
        last_contact_date = $5,
        updated_at = NOW()
    `;

    await pool.query(upsertQuery, [
      recruiterId,
      outreach._id.toString(),
      userId.toString(),
      'drafted',
      new Date()
    ]);

    console.log(`✅ Created outreach campaign: ${outreach._id}`);

    res.json({
      success: true,
      outreach: {
        id: outreach._id,
        recruiterId: outreach.recruiterId,
        recruiterName: `${recruiter.first_name} ${recruiter.last_name}`,
        messageContent: outreach.messageContent,
        status: outreach.status,
        createdAt: outreach.createdAt
      },
      message: 'Outreach campaign created successfully'
    });

  } catch (error) {
    console.error('Create outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Update outreach campaign - NEW METHOD
 */
exports.updateOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;
    const updates = req.body;

    console.log(`📝 Updating outreach ${outreachId} for user ${userId}`);

    // Find and update outreach
    const outreach = await Outreach.findOneAndUpdate(
      { _id: outreachId, userId },
      { ...updates, updatedAt: new Date() },
      { new: true }
    );

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    // Update PostgreSQL record if status changed
    if (updates.status) {
      await pool.query(
        'UPDATE outreach_history SET status = $1, updated_at = NOW() WHERE mongodb_outreach_id = $2',
        [updates.status, outreachId]
      );
    }

    console.log(`✅ Outreach updated successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach campaign updated successfully',
      outreach: {
        id: outreach._id,
        status: outreach.status,
        messageContent: outreach.messageContent,
        updatedAt: outreach.updatedAt
      }
    });

  } catch (error) {
    console.error('Update outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Delete outreach campaign - NEW METHOD
 */
exports.deleteOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;

    console.log(`🗑️ Deleting outreach ${outreachId} for user ${userId}`);

    // Find and delete outreach from MongoDB
    const outreach = await Outreach.findOneAndDelete({ _id: outreachId, userId });

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    // Delete from PostgreSQL outreach history
    await pool.query(
      'DELETE FROM outreach_history WHERE mongodb_outreach_id = $1 AND mongodb_user_id = $2',
      [outreachId, userId.toString()]
    );

    console.log(`✅ Outreach deleted successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach campaign deleted successfully',
      deletedId: outreachId
    });

  } catch (error) {
    console.error('Delete outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Send outreach message
 */
exports.sendOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;

    console.log(`📤 Sending outreach ${outreachId} for user ${userId}`);

    // Find and update outreach
    const outreach = await Outreach.findOne({ _id: outreachId, userId });

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    if (outreach.status !== 'drafted') {
      return res.status(400).json({
        success: false,
        error: 'Outreach has already been sent'
      });
    }

    // Update outreach status
    outreach.status = 'sent';
    outreach.sentAt = new Date();
    await outreach.save();

    // Update PostgreSQL record
    await pool.query(
      'UPDATE outreach_history SET status = $1, last_contact_date = $2 WHERE mongodb_outreach_id = $3',
      ['sent', new Date(), outreachId]
    );

    console.log(`✅ Outreach sent successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach sent successfully',
      outreach: {
        id: outreach._id,
        status: outreach.status,
        sentAt: outreach.sentAt
      }
    });

  } catch (error) {
    console.error('Send outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send outreach',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get user's outreach campaigns
 */
exports.getUserOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { status, limit = 20, offset = 0 } = req.query;

    console.log(`📋 Getting outreach campaigns for user ${userId}`);

    // Build filter
    const filter = { userId };
    if (status) {
      filter.status = status;
    }

    // Get outreach campaigns
    const outreaches = await Outreach.find(filter)
      .sort({ createdAt: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));

    // Get recruiter details for each outreach
    const recruiterIds = outreaches.map(o => o.recruiterId);
    
    if (recruiterIds.length > 0) {
      const recruitersQuery = `
        SELECT r.id, r.first_name, r.last_name, r.title, r.email,
               c.name as company_name, c.logo_url as company_logo
        FROM recruiters r
        LEFT JOIN companies c ON r.current_company_id = c.id
        WHERE r.id = ANY($1)
      `;
      
      const recruitersResult = await pool.query(recruitersQuery, [recruiterIds]);
      const recruitersMap = new Map(recruitersResult.rows.map(r => [r.id.toString(), r]));

      // Combine data
      const enrichedOutreaches = outreaches.map(outreach => {
        const recruiter = recruitersMap.get(outreach.recruiterId);
        return {
          id: outreach._id,
          recruiterId: outreach.recruiterId,
          recruiter: recruiter ? {
            name: `${recruiter.first_name} ${recruiter.last_name}`,
            title: recruiter.title,
            email: recruiter.email,
            company: {
              name: recruiter.company_name,
              logo: recruiter.company_logo
            }
          } : null,
          messageContent: outreach.messageContent,
          status: outreach.status,
          sentVia: outreach.sentVia,
          createdAt: outreach.createdAt,
          sentAt: outreach.sentAt,
          repliesCount: outreach.replies ? outreach.replies.length : 0,
          followUpsCount: outreach.followUps ? outreach.followUps.length : 0
        };
      });

      res.json({
        success: true,
        outreaches: enrichedOutreaches,
        pagination: {
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: outreaches.length === parseInt(limit)
        }
      });
    } else {
      res.json({
        success: true,
        outreaches: [],
        pagination: {
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: false
        }
      });
    }

  } catch (error) {
    console.error('Get user outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get outreach campaigns',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Generate AI-powered personalized message
 */
exports.generatePersonalizedMessage = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      recruiterId,
      resumeId,
      jobId,
      messageType = 'introduction',
      tone = 'professional',
      customRequirements = ''
    } = req.body;

    console.log(`🤖 Generating personalized message for recruiter ${recruiterId}`);

    // Get recruiter details
    const recruiterQuery = `
      SELECT r.first_name, r.last_name, r.title, r.specializations,
             c.name as company_name, c.description as company_description,
             i.name as industry_name
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      WHERE r.id = $1
    `;
    const recruiterResult = await pool.query(recruiterQuery, [recruiterId]);

    if (recruiterResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const recruiter = recruiterResult.rows[0];

    // Get user's resume if provided
    let resume = null;
    if (resumeId) {
      resume = await Resume.findOne({ _id: resumeId, userId });
    }

    // Get job details if provided
    let job = null;
    if (jobId) {
      job = await Job.findOne({ _id: jobId, userId });
    }

    // Build AI prompt
    const prompt = buildPersonalizedMessagePrompt(recruiter, resume, job, messageType, tone, customRequirements);

    // Generate message using OpenAI
    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: 'You are an expert career coach and networking specialist. Generate professional, personalized outreach messages that are engaging and authentic.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 500
    });

    const generatedMessage = response.choices[0].message.content;

    console.log(`✅ Generated personalized message (${generatedMessage.length} characters)`);

    res.json({
      success: true,
      message: generatedMessage,
      metadata: {
        recruiterName: `${recruiter.first_name} ${recruiter.last_name}`,
        company: recruiter.company_name,
        messageType,
        tone,
        tokensUsed: response.usage?.total_tokens || 0
      }
    });

  } catch (error) {
    console.error('Generate personalized message error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to generate personalized message',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get outreach analytics
 */
exports.getOutreachAnalytics = async (req, res) => {
  try {
    const userId = req.user._id;
    const { timeframe = '30d' } = req.query;

    console.log(`📊 Getting outreach analytics for user ${userId}`);

    // Calculate date range
    const startDate = new Date();
    switch (timeframe) {
      case '7d':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(startDate.getDate() - 30);
        break;
      case '90d':
        startDate.setDate(startDate.getDate() - 90);
        break;
    }

    // Get analytics from MongoDB
    const analytics = await Outreach.aggregate([
      {
        $match: {
          userId: userId,
          createdAt: { $gte: startDate }
        }
      },
      {
        $group: {
          _id: null,
          totalOutreach: { $sum: 1 },
sent: { $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] } },
         replied: { $sum: { $cond: [{ $eq: ['$status', 'replied'] }, 1, 0] } },
         drafted: { $sum: { $cond: [{ $eq: ['$status', 'drafted'] }, 1, 0] } },
         totalReplies: { $sum: { $size: { $ifNull: ['$replies', []] } } },
         totalFollowUps: { $sum: { $size: { $ifNull: ['$followUps', []] } } }
       }
     }
   ]);

   const stats = analytics[0] || {
     totalOutreach: 0,
     sent: 0,
     replied: 0,
     drafted: 0,
     totalReplies: 0,
     totalFollowUps: 0
   };

   // Calculate rates
   const responseRate = stats.sent > 0 ? (stats.replied / stats.sent) * 100 : 0;
   const sendRate = stats.totalOutreach > 0 ? (stats.sent / stats.totalOutreach) * 100 : 0;

   res.json({
     success: true,
     analytics: {
       ...stats,
       responseRate: Math.round(responseRate * 100) / 100,
       sendRate: Math.round(sendRate * 100) / 100,
       timeframe
     }
   });

 } catch (error) {
   console.error('Get outreach analytics error:', error);
   res.status(500).json({
     success: false,
     error: 'Failed to get outreach analytics',
     details: process.env.NODE_ENV !== 'production' ? error.message : undefined
   });
 }
};

// Helper function to build AI prompt
function buildPersonalizedMessagePrompt(recruiter, resume, job, messageType, tone, customRequirements) {
 const recruiterName = `${recruiter.first_name} ${recruiter.last_name}`;
 const company = recruiter.company_name;
 
 let prompt = `Generate a ${tone} ${messageType} message to ${recruiterName}, a ${recruiter.title} at ${company}.\n\n`;
 
 prompt += `RECRUITER CONTEXT:\n`;
 prompt += `- Name: ${recruiterName}\n`;
 prompt += `- Title: ${recruiter.title}\n`;
 prompt += `- Company: ${company}\n`;
 if (recruiter.specializations) {
   prompt += `- Specializations: ${recruiter.specializations.join(', ')}\n`;
 }
 if (recruiter.industry_name) {
   prompt += `- Industry: ${recruiter.industry_name}\n`;
 }
 
 if (resume) {
   prompt += `\nUSER BACKGROUND:\n`;
   prompt += `- Name: ${resume.parsedData?.contactInfo?.name || 'Professional'}\n`;
   if (resume.parsedData?.summary) {
     prompt += `- Summary: ${resume.parsedData.summary}\n`;
   }
   if (resume.parsedData?.experience?.length > 0) {
     const currentRole = resume.parsedData.experience[0];
     prompt += `- Current Role: ${currentRole.title} at ${currentRole.company}\n`;
   }
   if (resume.parsedData?.skills?.length > 0) {
     const topSkills = resume.parsedData.skills.slice(0, 5).map(s => typeof s === 'string' ? s : s.name);
     prompt += `- Key Skills: ${topSkills.join(', ')}\n`;
   }
 }
 
 if (job) {
   prompt += `\nTARGET POSITION:\n`;
   prompt += `- Title: ${job.title}\n`;
   prompt += `- Company: ${job.company}\n`;
   if (job.description) {
     prompt += `- Description: ${job.description.substring(0, 200)}...\n`;
   }
 }
 
 if (customRequirements) {
   prompt += `\nCUSTOM REQUIREMENTS:\n${customRequirements}\n`;
 }
 
 prompt += `\nGUIDELINES:\n`;
 prompt += `- Keep the message concise (2-3 paragraphs)\n`;
 prompt += `- Make it personal and specific to ${recruiterName}\n`;
 prompt += `- Use a ${tone} tone\n`;
 prompt += `- Include a clear call-to-action\n`;
 prompt += `- Avoid overly salesy language\n`;
 prompt += `- Make it authentic and professional\n`;
 
 if (messageType === 'introduction') {
   prompt += `- Focus on introducing yourself and expressing interest in their company\n`;
 } else if (messageType === 'follow_up') {
   prompt += `- Reference previous contact and provide additional value\n`;
 } else if (messageType === 'application') {
   prompt += `- Express interest in a specific role and highlight relevant qualifications\n`;
 }
 
 return prompt;
}

module.exports = exports;

================
File: backend/controllers/resume.controller.js
================
// controllers/resume.controller.js - COMPLETE FIXED VERSION
const { PutObjectCommand, GetObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const { s3Client, S3_BUCKET } = require('../config/s3');
const Resume = require('../models/mongodb/resume.model');
const resumeParserService = require('../services/resumeParser.service');
const resumeAnalysisService = require('../services/resumeAnalysis.service');
const mongoose = require('mongoose');
const path = require('path');
const uuid = require('uuid').v4;

// Helper function to generate S3 key for a resume file
const generateS3Key = (userId, originalFilename) => {
  const extension = path.extname(originalFilename);
  return `resumes/${userId}/${uuid()}${extension}`;
};

// Upload a new resume
exports.uploadResume = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Get userId from either req.user._id or req.userId (depending on how auth middleware works)
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }

    const originalFilename = req.file.originalname;
    
    // Determine file type - IMPORTANT: Use UPPERCASE to match the schema enum
    let fileType;
    if (req.file.mimetype === 'application/pdf' || originalFilename.toLowerCase().endsWith('.pdf')) {
      fileType = 'PDF'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
      originalFilename.toLowerCase().endsWith('.docx')
    ) {
      fileType = 'DOCX'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/msword' || 
      originalFilename.toLowerCase().endsWith('.doc')
    ) {
      fileType = 'DOC'; // Uppercase to match schema enum
    } else {
      return res.status(400).json({ message: 'Only PDF, DOCX, and DOC files are supported' });
    }
    
    console.log('Determined file type:', fileType); // Log for debugging
    
    const s3Key = generateS3Key(userId, originalFilename);
    
    // Create resume record in MongoDB with initial processing status
    const resume = new Resume({
      userId,
      name: req.body.name || originalFilename,
      originalFilename,
      fileUrl: s3Key,
      fileType: fileType, // Using uppercase file type to match schema enum
      processingStatus: {
        status: 'uploading',
        progress: 10,
        message: 'Uploading file to storage...',
        updatedAt: new Date()
      },
      parsedData: {}, // Will be populated after analysis
      analysis: {}, // Will be populated after analysis
      versions: []
    });

    await resume.save();
    console.log('Resume record created in MongoDB');
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: req.file.buffer,
      ContentType: req.file.mimetype
    };

    // Log the upload attempt for debugging
    console.log('Attempting S3 upload with params:', {
      Bucket: S3_BUCKET,
      Key: `${s3Key.substring(0, 20)}...`, // Don't log the full key for security
      ContentType: req.file.mimetype,
      FileSize: req.file.size
    });

    await s3Client.send(new PutObjectCommand(uploadParams));
    console.log('S3 upload successful');
    
    // Update processing status after successful upload
    resume.processingStatus = {
      status: 'parsing',
      progress: 25,
      message: 'Parsing resume content...',
      updatedAt: new Date()
    };
    await resume.save();

    // IMPORTANT: Initiate async parsing and analysis in the background
    // This way the user doesn't have to wait for the process to complete
    processResumeInBackground(resume._id, s3Key, fileType).catch(err => {
      console.error('Background resume processing error:', err);
      // Update status to error if background processing fails
      updateResumeProcessingStatus(resume._id, 'error', 0, 'Error processing resume', err.message)
        .catch(updateErr => console.error('Error updating processing status:', updateErr));
    });

    // Return response with resume data and processing status
    res.status(201).json({
      message: 'Resume uploaded successfully and processing initiated',
      resume: {
        id: resume._id,
        name: resume.name,
        originalFilename: resume.originalFilename,
        fileType: resume.fileType,
        createdAt: resume.createdAt,
        processingStatus: resume.processingStatus
      }
    });
  } catch (error) {
    console.error('Error uploading resume:', error);
    res.status(500).json({ message: 'Failed to upload resume', error: error.message });
  }
};

// Helper function to update resume processing status
async function updateResumeProcessingStatus(resumeId, status, progress, message, error = '') {
  try {
    const resume = await Resume.findById(resumeId);
    if (!resume) {
      console.error(`Resume not found for ID: ${resumeId}`);
      return false;
    }
    
    resume.processingStatus = {
      status,
      progress,
      message,
      error,
      updatedAt: new Date()
    };
    
    await resume.save();
    console.log(`Updated processing status for resume ${resumeId}: ${status} (${progress}%)`);
    return true;
  } catch (err) {
    console.error('Error updating resume processing status:', err);
    return false;
  }
}

// Background processing function - UPDATED WITH BETTER ERROR HANDLING AND LOGGING
async function processResumeInBackground(resumeId, fileUrl, fileType) {
  try {
    console.log(`Starting background processing for resume: ${resumeId}`);
    
    // Get the resume from the database
    const resume = await Resume.findById(resumeId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    // Step 1: Parse the resume using OpenAI
    console.log('Starting resume parsing...');
    // Update status to parsing (25-50%)
    await updateResumeProcessingStatus(resumeId, 'parsing', 30, 'Extracting content from resume...');
    
    const parsedData = await resumeParserService.parseResume(fileUrl, fileType);
    
    // CRITICAL FIX: Ensure parsedData is valid before saving
    if (!parsedData || typeof parsedData !== 'object') {
      throw new Error('Invalid parsed data received from parser service');
    }
    
    // Update the resume with parsed data
    resume.parsedData = parsedData;
    await resume.save();
    console.log('Resume parsing completed, data saved to database');
    
    // Update status to analyzing (50-90%)
    await updateResumeProcessingStatus(resumeId, 'analyzing', 50, 'Parsing complete. Starting AI analysis...');
    
    // Step 2: Analyze the resume using OpenAI
    console.log('Starting resume analysis...');
    const analysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // CRITICAL FIX: Validate analysis data before saving
    if (!analysis || typeof analysis !== 'object') {
      throw new Error('Invalid analysis data received from analysis service');
    }
    
    console.log('Analysis completed, data structure:', {
      overallScore: analysis.overallScore,
      atsCompatibility: analysis.atsCompatibility,
      hasProfileSummary: !!analysis.profileSummary,
      strengthsCount: analysis.strengths?.length || 0,
      weaknessesCount: analysis.weaknesses?.length || 0,
      improvementAreasCount: analysis.improvementAreas?.length || 0
    });
    
    // Update progress during analysis
    await updateResumeProcessingStatus(resumeId, 'analyzing', 75, 'AI analysis in progress...');
    
    // CRITICAL FIX: Ensure analysis data is properly assigned and saved
    resume.analysis = analysis;
    
    // Force save and verify
    const savedResume = await resume.save();
    console.log('Resume analysis saved to database:', {
      resumeId: savedResume._id,
      hasAnalysis: !!savedResume.analysis,
      overallScore: savedResume.analysis?.overallScore,
      atsCompatibility: savedResume.analysis?.atsCompatibility
    });
    
    // Double-check by re-fetching from database
    const verificationResume = await Resume.findById(resumeId);
    if (!verificationResume.analysis || !verificationResume.analysis.overallScore) {
      console.error('CRITICAL ERROR: Analysis data was not saved properly to database');
      throw new Error('Failed to save analysis data to database');
    }
    
    console.log('Database verification successful - analysis data persisted correctly');
    
    // Update status to completed (100%)
    await updateResumeProcessingStatus(resumeId, 'completed', 100, 'Resume processing completed successfully');
    console.log('Resume analyzed successfully');
    
    return true;
  } catch (error) {
    console.error('Error in background processing:', error);
    // Update status to error
    await updateResumeProcessingStatus(
      resumeId, 
      'error', 
      0, 
      'Error processing resume', 
      error.message || 'Unknown error'
    );
    throw error;
  }
}

// Create a tailored resume
exports.createTailoredResume = async (req, res) => {
  try {
    const { resumeId, jobId } = req.params;
    const { name, notes } = req.body;
    
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    // Validate input
    if (!resumeId || !jobId) {
      return res.status(400).json({ message: 'Resume ID and Job ID are required' });
    }
    
    console.log(`Creating tailored resume: resumeId=${resumeId}, jobId=${jobId}, userId=${userId}`);
    
    // Import the tailoring service
    const resumeTailoringService = require('../services/resumeTailoring.service');
    
    // Create the tailored resume with improved PDF generation and fresh analysis
    const result = await resumeTailoringService.createTailoredResume(resumeId, jobId, {
      name,
      notes
    });
    
    console.log('Tailored resume created successfully:', {
      resumeId: result.resume.id,
      hasAnalysis: !!result.resume.analysis,
      overallScore: result.resume.analysis?.overallScore,
      downloadUrl: !!result.resume.downloadUrl
    });
    
    res.status(201).json(result);
  } catch (error) {
    console.error('Error creating tailored resume:', error);
    res.status(500).json({ 
      message: 'Failed to create tailored resume', 
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// Get all resumes for a user
exports.getUserResumes = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    
    // Generate temporary signed URLs for each resume
    const resumesWithUrls = await Promise.all(resumes.map(async (resume) => {
      const getObjectParams = {
        Bucket: S3_BUCKET,
        Key: resume.fileUrl
      };
      
      const command = new GetObjectCommand(getObjectParams);
      const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 }); // URL expires in 1 hour
      
      return {
        _id: resume._id,
        name: resume.name,
        originalFilename: resume.originalFilename,
        fileType: resume.fileType,
        createdAt: resume.createdAt,
        updatedAt: resume.updatedAt,
        downloadUrl: signedUrl,
        analysis: resume.analysis,
        processingStatus: resume.processingStatus || {
          status: 'completed',
          progress: 100,
          message: 'Resume processing completed'
        },
        isTailored: resume.isTailored || false,
        tailoredForJob: resume.tailoredForJob || null,
        versions: resume.versions.map(v => ({
          id: v._id,
          versionNumber: v.versionNumber,
          createdAt: v.createdAt,
          changesDescription: v.changesDescription
        }))
      };
    }));
    
    res.status(200).json({ resumes: resumesWithUrls });
  } catch (error) {
    console.error('Error fetching resumes:', error);
    res.status(500).json({ message: 'Failed to fetch resumes', error: error.message });
  }
};

// Get a specific resume by ID
exports.getResumeById = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // CRITICAL DEBUG: Log what we're retrieving
    console.log('Retrieved resume from database:', {
      resumeId: resume._id,
      hasAnalysis: !!resume.analysis,
      hasProcessingStatus: !!resume.processingStatus,
      overallScore: resume.analysis?.overallScore,
      atsCompatibility: resume.analysis?.atsCompatibility,
      analysisKeys: resume.analysis ? Object.keys(resume.analysis) : []
    });
    
    // Generate temporary signed URL for the resume
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: resume.fileUrl
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 }); // URL expires in 1 hour
    
    // Generate URLs for all versions if they exist
    const versionsWithUrls = await Promise.all((resume.versions || []).map(async (version) => {
      const versionParams = {
        Bucket: S3_BUCKET,
        Key: version.fileUrl
      };
      
      const versionCommand = new GetObjectCommand(versionParams);
      const versionUrl = await getSignedUrl(s3Client, versionCommand, { expiresIn: 3600 });
      
      return {
        id: version._id,
        versionNumber: version.versionNumber,
        createdAt: version.createdAt,
        changesDescription: version.changesDescription,
        downloadUrl: versionUrl,
        jobId: version.jobId
      };
    }));
    
    // CRITICAL FIX: Ensure analysis data is properly structured for the frontend
    const analysisData = resume.analysis || {};
    
    const resumeData = {
      id: resume._id,
      name: resume.name,
      originalFilename: resume.originalFilename,
      fileType: resume.fileType,
      createdAt: resume.createdAt,
      updatedAt: resume.updatedAt,
      downloadUrl: signedUrl,
      parsedData: resume.parsedData || {},
      analysis: {
        overallScore: analysisData.overallScore || 0,
        atsCompatibility: analysisData.atsCompatibility || 0,
        profileSummary: analysisData.profileSummary || {
          currentRole: "Not specified",
          careerLevel: "Mid-level",
          industries: [],
          suggestedJobTitles: [],
          suggestedIndustries: []
        },
        strengths: analysisData.strengths || [],
        weaknesses: analysisData.weaknesses || [],
        keywordsSuggestions: analysisData.keywordsSuggestions || [],
        improvementAreas: analysisData.improvementAreas || []
      },
      processingStatus: resume.processingStatus || {
        status: 'completed',
        progress: 100,
        message: 'Resume processing completed'
      },
      isTailored: resume.isTailored || false,
      tailoredForJob: resume.tailoredForJob || null,
      versions: versionsWithUrls
    };
    
    // CRITICAL DEBUG: Log what we're sending to frontend
    console.log('Sending resume data to frontend:', {
      hasAnalysis: !!resumeData.analysis,
      overallScore: resumeData.analysis.overallScore,
      atsCompatibility: resumeData.analysis.atsCompatibility,
      strengthsCount: resumeData.analysis.strengths.length,
      weaknessesCount: resumeData.analysis.weaknesses.length
    });
    
    res.status(200).json({ resume: resumeData });
  } catch (error) {
    console.error('Error fetching resume:', error);
    res.status(500).json({ message: 'Failed to fetch resume', error: error.message });
  }
};

// Optimize resume for ATS with real-time progress via SSE
exports.optimizeResumeForATS = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    console.log(`🤖 AJ: Starting ATS optimization for resume ${resumeId}`);
    
    // Import the resume editor service
    const ResumeEditorService = require('../services/resumeEditor.service');
    
    // Get optional target job from request body
    const targetJob = req.body.targetJob || null;
    
    // Store original resume data for before/after comparison
    const Resume = require('../models/mongodb/resume.model');
    const originalResume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!originalResume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Store original data for comparison
    const originalData = {
      parsedData: JSON.parse(JSON.stringify(originalResume.parsedData)),
      analysis: JSON.parse(JSON.stringify(originalResume.analysis || {}))
    };
    
    // Create progress callback function
    const progressCallback = (stage, percentage, message) => {
      console.log(`📊 Backend Progress: ${percentage}% - ${message}`);
      // In a real implementation, you might store this in Redis or broadcast via WebSocket
      // For now, we'll rely on the backend logs and frontend timing
    };
    
    // Call the ATS optimization service with progress callback
    const result = await ResumeEditorService.optimizeForATSWithProgress(
      resumeId, 
      userId, 
      targetJob,
      originalData,
      progressCallback
    );
    
    console.log(`✅ AJ: ATS optimization completed. New score: ${result.newATSScore}%`);
    
    res.status(200).json({
      success: true,
      message: 'Resume optimized for ATS successfully',
      data: {
        optimizations: result.optimizations,
        previousATSScore: result.previousScore,
        newATSScore: result.newATSScore,
        improvementGain: result.newATSScore - result.previousScore,
        updatedResume: {
          id: result.updatedResume._id,
          name: result.updatedResume.name,
          analysis: result.updatedResume.analysis,
          versions: result.updatedResume.versions
        },
        // Add before/after comparison data
        comparison: result.comparison,
        // Add timing information for frontend
        processingTime: result.processingTime,
        stages: result.stages
      }
    });
  } catch (error) {
    console.error('❌ ATS optimization error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to optimize resume for ATS', 
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// 📡 SSE endpoint for real-time optimization progress - FIXED SINGLE VERSION
exports.getOptimizationProgress = async (req, res) => {
  try {
    console.log('📡 SSE optimization-progress endpoint hit:', req.params.id, 'Query:', req.query);
    
    const resumeId = req.params.id;
    let userId;
    
    // Handle authentication via token query parameter
    if (req.query.token) {
      try {
        const jwt = require('jsonwebtoken');
        const User = require('../models/mongodb/user.model');
        
        const decoded = jwt.verify(req.query.token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.id);
        
        if (!user || !user.active) {
          console.error('❌ Invalid user for SSE');
          return res.status(401).json({ error: 'Invalid user' });
        }
        
        userId = user._id;
        console.log('📡 SSE authenticated for resume:', resumeId, 'user:', userId);
        
      } catch (tokenError) {
        console.error('❌ SSE Token verification failed:', tokenError.message);
        return res.status(401).json({ error: 'Invalid token' });
      }
    } else {
      console.error('❌ SSE No token provided');
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    console.log('📡 Setting up SSE headers for resume:', resumeId);
    
    // Set SSE headers
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // Send initial connection message
    const welcomeMessage = {
      type: 'connected',
      message: 'Progress stream connected successfully',
      resumeId: resumeId,
      timestamp: new Date().toISOString()
    };
    
    res.write(`data: ${JSON.stringify(welcomeMessage)}\n\n`);
    console.log('📡 Sent welcome message:', welcomeMessage);

    // Store client for progress updates
    const clientId = `${userId}_${resumeId}_${Date.now()}`;
    
    if (!global.progressClients) {
      global.progressClients = new Map();
    }
    
    global.progressClients.set(clientId, res);
    console.log(`📡 SSE client registered: ${clientId}. Total clients: ${global.progressClients.size}`);
    
    // Send a test progress message
    setTimeout(() => {
      try {
        const testMessage = {
          type: 'progress',
          percentage: 10,
          message: 'SSE connection established, ready for progress updates',
          resumeId: resumeId,
          timestamp: new Date().toISOString()
        };
        res.write(`data: ${JSON.stringify(testMessage)}\n\n`);
        console.log('📡 Sent test progress message');
      } catch (error) {
        console.error('❌ Error sending test message:', error);
      }
    }, 1000);
    
    // Cleanup on client disconnect
    req.on('close', () => {
      console.log(`📡 SSE client disconnected: ${clientId}`);
      global.progressClients.delete(clientId);
      console.log(`📡 Remaining SSE clients: ${global.progressClients.size}`);
    });
    
    req.on('error', (err) => {
      console.error('📡 SSE connection error:', err);
      global.progressClients.delete(clientId);
    });

    // Keep connection alive with heartbeat
    const heartbeat = setInterval(() => {
      try {
        if (global.progressClients.has(clientId)) {
          res.write(`data: ${JSON.stringify({ 
            type: 'heartbeat', 
            timestamp: new Date().toISOString() 
          })}\n\n`);
        } else {
          clearInterval(heartbeat);
        }
      } catch (error) {
        console.error('❌ SSE heartbeat failed:', error);
        clearInterval(heartbeat);
        global.progressClients.delete(clientId);
      }
    }, 30000);

    // Cleanup heartbeat on disconnect
    req.on('close', () => {
      clearInterval(heartbeat);
    });

  } catch (error) {
    console.error('❌ SSE Setup Error:', error);
    try {
      res.status(500).json({ error: 'Failed to setup progress stream', details: error.message });
    } catch (responseError) {
      console.error('❌ Error sending error response:', responseError);
    }
  }
};

// Manually trigger resume analysis
exports.analyzeResume = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // If resume hasn't been parsed yet, parse it first
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      try {
        const parsedData = await resumeParserService.parseResume(resume.fileUrl, resume.fileType);
        resume.parsedData = parsedData;
        await resume.save();
      } catch (parseError) {
        console.error('Error parsing resume:', parseError);
        return res.status(500).json({ 
          message: 'Failed to parse resume',
          error: parseError.message
        });
      }
    }
    
    // Analyze the resume using OpenAI
    try {
      const analysis = await resumeAnalysisService.analyzeResume(resumeId);
      
      // Update the resume with analysis data
      resume.analysis = analysis;
      await resume.save();
      
      res.status(200).json({ 
        message: 'Resume analyzed successfully',
        analysis
      });
    } catch (analysisError) {
      console.error('Error analyzing resume:', analysisError);
      res.status(500).json({ 
        message: 'Failed to analyze resume',
        error: analysisError.message
      });
    }
  } catch (error) {
    console.error('Error in analyze resume endpoint:', error);
    res.status(500).json({ message: 'Failed to process request', error: error.message });
  }
};

// Add a new version to an existing resume
exports.addResumeVersion = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    const originalFilename = req.file.originalname;
    
// Determine file type - IMPORTANT: Use UPPERCASE to match the schema enum
    let fileType;
    if (req.file.mimetype === 'application/pdf' || originalFilename.toLowerCase().endsWith('.pdf')) {
      fileType = 'PDF'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
      originalFilename.toLowerCase().endsWith('.docx')
    ) {
      fileType = 'DOCX'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/msword' || 
      originalFilename.toLowerCase().endsWith('.doc')
    ) {
      fileType = 'DOC'; // Uppercase to match schema enum
    } else {
      return res.status(400).json({ message: 'Only PDF, DOCX, and DOC files are supported' });
    }
    
    const s3Key = generateS3Key(userId, originalFilename);
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: req.file.buffer,
      ContentType: req.file.mimetype
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    
    // Create new version
    const versionNumber = (resume.versions || []).length + 2; // +2 because original is version 1
    const newVersion = {
      versionNumber,
      createdAt: new Date(),
      fileUrl: s3Key,
      changesDescription: req.body.changesDescription || `Version ${versionNumber}`,
      jobId: req.body.jobId || null
    };
    
    // Add to versions array
    if (!resume.versions) {
      resume.versions = [];
    }
    resume.versions.push(newVersion);
    await resume.save();
    
    // Generate signed URL for the new version
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: s3Key
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
    
    res.status(200).json({
      message: 'Resume version added successfully',
      version: {
        id: newVersion._id,
        versionNumber: newVersion.versionNumber,
        createdAt: newVersion.createdAt,
        changesDescription: newVersion.changesDescription,
        downloadUrl: signedUrl,
        jobId: newVersion.jobId
      }
    });
  } catch (error) {
    console.error('Error adding resume version:', error);
    res.status(500).json({ message: 'Failed to add resume version', error: error.message });
  }
};

// Get resume processing status
exports.getResumeProcessingStatus = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId }, 'processingStatus');
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Return just the processing status
    const processingStatus = resume.processingStatus || {
      status: 'completed',
      progress: 100,
      message: 'Resume processing completed'
    };
    
    res.status(200).json({ processingStatus });
  } catch (error) {
    console.error('Error fetching resume processing status:', error);
    res.status(500).json({ message: 'Failed to fetch processing status', error: error.message });
  }
};

// Delete a resume
exports.deleteResume = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Delete resume document from MongoDB
    await Resume.deleteOne({ _id: resumeId, userId });
    
    res.status(200).json({ message: 'Resume deleted successfully' });
  } catch (error) {
    console.error('Error deleting resume:', error);
    res.status(500).json({ message: 'Failed to delete resume', error: error.message });
  }
};

================
File: backend/controllers/search.controller.js
================
// backend/controllers/search.controller.js - FIXED VERSION
const User = require('../models/mongodb/user.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const db = require('../config/postgresql');

/**
 * Global search controller that searches across multiple data types
 */
class SearchController {
  /**
   * Unified search across jobs, resumes, and recruiters
   */
  static async globalSearch(req, res) {
    try {
      const { 
        query, 
        category = 'all', 
        limit = 20, 
        includeContent = false 
      } = req.query;
      
      const userId = req.user._id;

      if (!query || query.trim().length < 2) {
        return res.status(400).json({
          success: false,
          error: 'Search query must be at least 2 characters long'
        });
      }

      console.log(`🔍 Global search: "${query}" for user ${userId}, category: ${category}`);

      const searchResults = {
        query: query.trim(),
        category,
        results: {
          jobs: [],
          resumes: [],
          recruiters: [],
          totalCount: 0
        },
        suggestions: [],
        recentSearches: []
      };

      // Parallel search execution
      const searchPromises = [];

      if (category === 'all' || category === 'jobs') {
        searchPromises.push(SearchController.searchJobs(userId, query, limit));
      }

      if (category === 'all' || category === 'resumes') {
        searchPromises.push(SearchController.searchResumes(userId, query, limit));
      }

      if (category === 'all' || category === 'recruiters') {
        searchPromises.push(SearchController.searchRecruiters(userId, query, limit));
      }

      // Execute all searches in parallel
      const results = await Promise.allSettled(searchPromises);

      // Process results
      let resultIndex = 0;
      if (category === 'all' || category === 'jobs') {
        const jobResults = results[resultIndex];
        if (jobResults.status === 'fulfilled') {
          searchResults.results.jobs = jobResults.value || [];
        } else {
          console.error('Job search failed:', jobResults.reason);
        }
        resultIndex++;
      }

      if (category === 'all' || category === 'resumes') {
        const resumeResults = results[resultIndex];
        if (resumeResults.status === 'fulfilled') {
          searchResults.results.resumes = resumeResults.value || [];
        } else {
          console.error('Resume search failed:', resumeResults.reason);
        }
        resultIndex++;
      }

      if (category === 'all' || category === 'recruiters') {
        const recruiterResults = results[resultIndex];
        if (recruiterResults.status === 'fulfilled') {
          searchResults.results.recruiters = recruiterResults.value || [];
        } else {
          console.error('Recruiter search failed:', recruiterResults.reason);
        }
        resultIndex++;
      }

      // Calculate total count
      searchResults.results.totalCount = 
        searchResults.results.jobs.length +
        searchResults.results.resumes.length +
        searchResults.results.recruiters.length;

      // Generate suggestions if no results found
      if (searchResults.results.totalCount === 0) {
        searchResults.suggestions = await SearchController.generateSuggestions(query);
      }

      // Get recent searches
      searchResults.recentSearches = await SearchController.getRecentSearches(userId);

      // Save this search
      await SearchController.saveSearch(userId, query, category, searchResults.results.totalCount);

      console.log(`✅ Search completed: ${searchResults.results.totalCount} total results`);

      res.json({
        success: true,
        data: searchResults
      });

    } catch (error) {
      console.error('Global search error:', error);
      res.status(500).json({
        success: false,
        error: 'Search failed',
        details: error.message
      });
    }
  }

  /**
   * Search jobs
   */
  static async searchJobs(userId, query, limit = 10) {
    try {
      const searchRegex = new RegExp(query, 'i');
      
      const jobs = await Job.find({
        userId,
        $or: [
          { title: searchRegex },
          { company: searchRegex },
          { description: searchRegex },
          { 'parsedData.keySkills.name': searchRegex },
          { 'parsedData.requirements': searchRegex },
          { 'parsedData.responsibilities': searchRegex }
        ]
      })
      .select('title company description parsedData.keySkills matchAnalysis applicationStatus createdAt')
      .sort({ createdAt: -1 })
      .limit(limit)
      .lean();

      return jobs.map(job => ({
        id: job._id,
        type: 'job',
        title: job.title,
        subtitle: job.company,
        description: job.description ? job.description.substring(0, 150) + '...' : '',
        matchScore: job.matchAnalysis?.overallScore || null,
        status: job.applicationStatus || 'not_applied',
        skills: job.parsedData?.keySkills?.slice(0, 5) || [],
        createdAt: job.createdAt,
        url: `/jobs/${job._id}`
      }));

    } catch (error) {
      console.error('Job search error:', error);
      return [];
    }
  }

  /**
   * Search resumes
   */
  static async searchResumes(userId, query, limit = 10) {
    try {
      const searchRegex = new RegExp(query, 'i');
      
      const resumes = await Resume.find({
        userId,
        $or: [
          { name: searchRegex },
          { 'parsedData.summary': searchRegex },
          { 'parsedData.experience.title': searchRegex },
          { 'parsedData.experience.company': searchRegex },
          { 'parsedData.skills.name': searchRegex },
          { 'parsedData.education.institution': searchRegex },
          { 'parsedData.education.degree': searchRegex }
        ]
      })
      .select('name parsedData.summary parsedData.skills analysis isActive createdAt')
      .sort({ isActive: -1, createdAt: -1 })
      .limit(limit)
      .lean();

      return resumes.map(resume => ({
        id: resume._id,
        type: 'resume',
        title: resume.name,
        subtitle: resume.parsedData?.summary ? 
          resume.parsedData.summary.substring(0, 100) + '...' : 
          'Professional Resume',
        description: `${resume.parsedData?.skills?.length || 0} skills listed`,
        score: resume.analysis?.overallScore || null,
        isActive: resume.isActive,
        skills: resume.parsedData?.skills?.slice(0, 5) || [],
        createdAt: resume.createdAt,
        url: `/resumes/${resume._id}`
      }));

    } catch (error) {
      console.error('Resume search error:', error);
      return [];
    }
  }

  /**
   * Search recruiters
   */
  static async searchRecruiters(userId, query, limit = 10) {
    try {
      // Simplified search - just search by name and title for now
      const searchTerm = `%${query.toLowerCase()}%`;
      
      const recruitersQuery = `
        SELECT 
          r.id,
          r.first_name,
          r.last_name,
          r.title,
          r.email,
          r.linkedin_url,
          r.experience_years,
          r.last_active_date,
          companies.name as company_name,
          industries.name as industry_name,
          locations.city,
          locations.state,
          locations.country
        FROM recruiters r
        LEFT JOIN companies ON r.current_company_id = companies.id
        LEFT JOIN industries ON r.industry_id = industries.id
        LEFT JOIN locations ON r.location_id = locations.id
        WHERE r.is_active = true 
        AND (
          LOWER(r.first_name) LIKE $1 OR 
          LOWER(r.last_name) LIKE $1 OR 
          LOWER(r.title) LIKE $1 OR 
          LOWER(companies.name) LIKE $1
        )
        ORDER BY r.last_active_date DESC NULLS LAST
        LIMIT $2
      `;

      const result = await db.query(recruitersQuery, [searchTerm, limit]);

      return result.rows.map(recruiter => ({
        id: recruiter.id,
        type: 'recruiter',
        title: `${recruiter.first_name} ${recruiter.last_name}`,
        subtitle: recruiter.title || 'Recruiter',
        description: `${recruiter.company_name || 'Unknown Company'}${recruiter.industry_name ? ` • ${recruiter.industry_name}` : ''}`,
        location: recruiter.city ? 
          `${recruiter.city}${recruiter.state ? `, ${recruiter.state}` : ''}` : 
          null,
        experience: recruiter.experience_years,
        hasContact: !!(recruiter.email || recruiter.linkedin_url),
        hasBeenContacted: false, // Simplified for now
        lastActiveDate: recruiter.last_active_date,
        url: `/recruiters/${recruiter.id}`
      }));

    } catch (error) {
      console.error('Recruiter search error:', error);
      return [];
    }
  }

  /**
   * Generate search suggestions
   */
  static async generateSuggestions(query) {
    try {
      const suggestions = [];
      
      // Common job titles
      const jobTitles = [
        'Software Engineer', 'Product Manager', 'Data Scientist', 
        'Marketing Manager', 'Sales Representative', 'Business Analyst'
      ];
      
      // Common skills
      const skills = [
        'JavaScript', 'Python', 'React', 'Node.js', 'SQL', 
        'Machine Learning', 'Project Management', 'Marketing'
      ];
      
      // Common companies (you could populate this from your database)
      const companies = [
        'Google', 'Microsoft', 'Amazon', 'Apple', 'Meta', 'Netflix'
      ];

      // Find matching suggestions
      const queryLower = query.toLowerCase();
      
      jobTitles.forEach(title => {
        if (title.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: title, type: 'job_title' });
        }
      });
      
      skills.forEach(skill => {
        if (skill.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: skill, type: 'skill' });
        }
      });
      
      companies.forEach(company => {
        if (company.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: company, type: 'company' });
        }
      });

      return suggestions.slice(0, 5);

    } catch (error) {
      console.error('Generate suggestions error:', error);
      return [];
    }
  }

  /**
   * Get recent searches for user
   */
  static async getRecentSearches(userId, limit = 5) {
    try {
      // You could implement a search history collection in MongoDB
      // For now, return empty array
      return [];
    } catch (error) {
      console.error('Get recent searches error:', error);
      return [];
    }
  }

  /**
   * Save search for analytics and recent searches
   */
  static async saveSearch(userId, query, category, resultCount) {
    try {
      // You could implement search analytics here
      console.log(`📊 Search saved: ${query} (${resultCount} results)`);
    } catch (error) {
      console.error('Save search error:', error);
    }
  }

  /**
   * Get search suggestions as user types
   */
  static async getSearchSuggestions(req, res) {
    try {
      const { query, limit = 5 } = req.query;
      
      if (!query || query.length < 2) {
        return res.json({
          success: true,
          data: { suggestions: [] }
        });
      }

      const suggestions = await SearchController.generateSuggestions(query);
      
      res.json({
        success: true,
        data: { suggestions: suggestions.slice(0, limit) }
      });

    } catch (error) {
      console.error('Get search suggestions error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get suggestions'
      });
    }
  }

  /**
   * Get popular searches
   */
  static async getPopularSearches(req, res) {
    try {
      // Return common search terms
      const popularSearches = [
        'Software Engineer',
        'Product Manager',
        'JavaScript',
        'Remote Jobs',
        'Data Science',
        'Marketing',
        'Google',
        'Startup'
      ];

      res.json({
        success: true,
        data: { searches: popularSearches }
      });

    } catch (error) {
      console.error('Get popular searches error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get popular searches'
      });
    }
  }
}

module.exports = SearchController;

================
File: backend/controllers/settings.controller.js
================
// backend/controllers/settings.controller.js
const bcrypt = require('bcryptjs');
const User = require('../models/mongodb/user.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const Outreach = require('../models/mongodb/outreach.model');
const sendEmail = require('../utils/send-email');

/**
 * Get user profile information
 */
exports.getProfile = async (req, res) => {
  try {
    console.log('📋 Getting profile for user:', req.user.id);
    
    const user = await User.findById(req.user.id).select('-password -passwordResetToken -passwordResetExpires');
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    console.log('✅ Profile retrieved successfully');
    
    res.status(200).json({
      success: true,
      data: {
        user: {
          id: user._id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          phoneNumber: user.phoneNumber,
          isEmailVerified: user.isEmailVerified,
          profilePicture: user.profilePicture,
          location: user.location,
          socialProfiles: user.socialProfiles,
          createdAt: user.createdAt,
          updatedAt: user.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('❌ Get profile error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve profile information'
    });
  }
};

/**
 * Update user profile information
 */
exports.updateProfile = async (req, res) => {
  try {
    const { firstName, lastName, email, phoneNumber, location, socialProfiles } = req.body;
    const userId = req.user.id;

    console.log('📝 Updating profile for user:', userId);
    console.log('📝 Update data:', { firstName, lastName, email, phoneNumber });

    // Validation
    if (!firstName || !lastName || !email) {
      return res.status(400).json({
        success: false,
        error: 'First name, last name, and email are required'
      });
    }

    // Email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        error: 'Please provide a valid email address'
      });
    }

    // Check if email is already taken by another user
    if (email !== req.user.email) {
      const existingUser = await User.findOne({ email, _id: { $ne: userId } });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          error: 'Email address is already in use'
        });
      }
    }

    // Prepare update data
    const updateData = {
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      email: email.toLowerCase().trim(),
      phoneNumber: phoneNumber ? phoneNumber.trim() : '',
      updatedAt: new Date()
    };

    // If email changed, mark as unverified
    if (email !== req.user.email) {
      updateData.isEmailVerified = false;
      updateData.emailVerificationToken = crypto.randomBytes(32).toString('hex');
      updateData.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours
    }

    // Update location if provided
    if (location) {
      updateData.location = location;
    }

    // Update social profiles if provided
    if (socialProfiles) {
      updateData.socialProfiles = socialProfiles;
    }

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      updateData,
      { new: true, runValidators: true }
    ).select('-password -passwordResetToken -passwordResetExpires');

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Send verification email if email changed
    if (email !== req.user.email) {
      try {
        const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${updateData.emailVerificationToken}`;
        
        await sendEmail({
          email: updatedUser.email,
          subject: 'Verify Your New Email Address - auto-job.ai',
          message: `Hi ${updatedUser.firstName},\n\nPlease verify your new email address by clicking the link below:\n\n${verificationUrl}\n\nThis link will expire in 24 hours.\n\nBest regards,\nThe auto-job.ai Team`
        });

        console.log('📧 Verification email sent to:', updatedUser.email);
      } catch (emailError) {
        console.error('📧 Failed to send verification email:', emailError);
        // Don't fail the update if email sending fails
      }
    }

    console.log('✅ Profile updated successfully');

    res.status(200).json({
      success: true,
      message: email !== req.user.email ? 'Profile updated successfully. Please check your email to verify your new email address.' : 'Profile updated successfully',
      data: {
        user: {
          id: updatedUser._id,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          email: updatedUser.email,
          phoneNumber: updatedUser.phoneNumber,
          isEmailVerified: updatedUser.isEmailVerified,
          profilePicture: updatedUser.profilePicture,
          location: updatedUser.location,
          socialProfiles: updatedUser.socialProfiles,
          createdAt: updatedUser.createdAt,
          updatedAt: updatedUser.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('❌ Update profile error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update profile'
    });
  }
};

/**
 * Change user password
 */
exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const userId = req.user.id;

    console.log('🔒 Changing password for user:', userId);

    // Validation
    if (!currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        error: 'Current password and new password are required'
      });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        error: 'New password must be at least 6 characters long'
      });
    }

    // Get user with password
    const user = await User.findById(userId).select('+password');
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Verify current password
    const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isCurrentPasswordValid) {
      return res.status(400).json({
        success: false,
        error: 'Current password is incorrect'
      });
    }

    // Check if new password is different from current
    const isSamePassword = await bcrypt.compare(newPassword, user.password);
    if (isSamePassword) {
      return res.status(400).json({
        success: false,
        error: 'New password must be different from current password'
      });
    }

    // Hash new password
    const salt = await bcrypt.genSalt(10); // Use 10 rounds to match your user model
    const hashedNewPassword = await bcrypt.hash(newPassword, salt);

    // Update password
    await User.findByIdAndUpdate(userId, {
      password: hashedNewPassword,
      updatedAt: new Date(),
      // Clear any password reset tokens
      passwordResetToken: undefined,
      passwordResetExpires: undefined
    });

    console.log('✅ Password changed successfully');

    // Send notification email
    try {
      await sendEmail({
        email: user.email,
        subject: 'Password Changed Successfully - auto-job.ai',
        message: `Hi ${user.firstName},\n\nYour password has been changed successfully.\n\nIf you did not make this change, please contact our support team immediately.\n\nBest regards,\nThe auto-job.ai Team`
      });
    } catch (emailError) {
      console.error('📧 Failed to send password change notification:', emailError);
    }

    res.status(200).json({
      success: true,
      message: 'Password changed successfully'
    });

  } catch (error) {
    console.error('❌ Change password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to change password'
    });
  }
};

/**
 * Delete user account and all associated data
 */
exports.deleteAccount = async (req, res) => {
  try {
    const userId = req.user.id;
    const { confirmationText } = req.body;

    console.log('🗑️ Deleting account for user:', userId);

    // Optional: Require confirmation text
    if (confirmationText && confirmationText !== 'DELETE') {
      return res.status(400).json({
        success: false,
        error: 'Please type DELETE to confirm account deletion'
      });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Start deletion process
    console.log('🗑️ Starting account deletion process...');

    // Delete user's resumes
    const deletedResumes = await Resume.deleteMany({ userId });
    console.log(`🗑️ Deleted ${deletedResumes.deletedCount} resumes`);

    // Delete user's jobs
    const deletedJobs = await Job.deleteMany({ userId });
    console.log(`🗑️ Deleted ${deletedJobs.deletedCount} jobs`);

    // Delete user's outreach campaigns
    const deletedOutreach = await Outreach.deleteMany({ userId });
    console.log(`🗑️ Deleted ${deletedOutreach.deletedCount} outreach campaigns`);

    // TODO: Delete from PostgreSQL tables if needed
    // This would include recruiter outreach history, etc.

    // Finally, delete the user account
    await User.findByIdAndDelete(userId);
    console.log('🗑️ User account deleted');

    // Send farewell email
    try {
      await sendEmail({
        email: user.email,
        subject: 'Account Deleted Successfully - auto-job.ai',
        message: `Hi ${user.firstName},\n\nYour auto-job.ai account has been successfully deleted along with all associated data.\n\nWe're sorry to see you go. If you have any feedback or would like to return in the future, we'd love to hear from you.\n\nBest regards,\nThe auto-job.ai Team`
      });
    } catch (emailError) {
      console.error('📧 Failed to send farewell email:', emailError);
    }

    console.log('✅ Account deletion completed successfully');

    res.status(200).json({
      success: true,
      message: 'Account deleted successfully'
    });

  } catch (error) {
    console.error('❌ Delete account error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete account'
    });
  }
};

/**
 * Send email verification
 */
exports.sendVerificationEmail = async (req, res) => {
  try {
    const userId = req.user.id;

    console.log('📧 Sending verification email for user:', userId);

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    if (user.isEmailVerified) {
      return res.status(400).json({
        success: false,
        error: 'Email is already verified'
      });
    }

    // Generate verification token
    const verificationToken = crypto.randomBytes(32).toString('hex');
    const verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours

    // Update user with verification token
    await User.findByIdAndUpdate(userId, {
      emailVerificationToken: verificationToken,
      emailVerificationExpires: verificationExpires
    });

    // Send verification email
    const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`;
    
    await sendEmail({
      email: user.email,
      subject: 'Verify Your Email Address - auto-job.ai',
      message: `Hi ${user.firstName},\n\nPlease verify your email address by clicking the link below:\n\n${verificationUrl}\n\nThis link will expire in 24 hours.\n\nBest regards,\nThe auto-job.ai Team`
    });

    console.log('✅ Verification email sent successfully');

    res.status(200).json({
      success: true,
      message: 'Verification email sent successfully'
    });

  } catch (error) {
    console.error('❌ Send verification email error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send verification email'
    });
  }
};

/**
 * Verify email address
 */
exports.verifyEmail = async (req, res) => {
  try {
    const { token } = req.params;

    console.log('✉️ Verifying email with token:', token);

    if (!token) {
      return res.status(400).json({
        success: false,
        error: 'Verification token is required'
      });
    }

    // Find user with valid verification token
    const user = await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: Date.now() }
    });

    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired verification token'
      });
    }

    // Mark email as verified
    await User.findByIdAndUpdate(user._id, {
      isEmailVerified: true,
      emailVerificationToken: undefined,
      emailVerificationExpires: undefined,
      updatedAt: new Date()
    });

    console.log('✅ Email verified successfully for user:', user.email);

    res.status(200).json({
      success: true,
      message: 'Email verified successfully'
    });

  } catch (error) {
    console.error('❌ Verify email error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify email'
    });
  }
};

================
File: backend/controllers/subscription.controller.js
================
// backend/controllers/subscription.controller.js - COMPLETE MONTHLY ONLY VERSION
const subscriptionService = require('../services/subscription.service');
const stripeService = require('../services/stripe.service');
const usageService = require('../services/usage.service');
const User = require('../models/mongodb/user.model');
const db = require('../config/postgresql');

class SubscriptionController {
  /**
   * Get all available subscription plans
   * @route GET /api/subscriptions/plans
   * @access Public
   */
  static async getPlans(req, res) {
    try {
      const plans = await subscriptionService.getAvailablePlans();
      
      res.status(200).json({
        success: true,
        data: {
          plans,
          billingCycle: 'monthly',
          message: 'Monthly subscription plans retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting subscription plans:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve subscription plans'
      });
    }
  }

  /**
   * Get plan comparison matrix
   * @route GET /api/subscriptions/plans/compare
   * @access Public
   */
  static async getPlansComparison(req, res) {
    try {
      const comparison = await subscriptionService.getPlanComparison();
      
      res.status(200).json({
        success: true,
        data: {
          comparison,
          billingCycle: 'monthly',
          message: 'Monthly plan comparison retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting plan comparison:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve plan comparison'
      });
    }
  }

  /**
   * Get user's current subscription
   * @route GET /api/subscriptions/current
   * @access Private
   */
  static async getCurrentSubscription(req, res) {
    try {
      const userId = req.user.id;
      const subscription = await subscriptionService.getCurrentSubscription(userId);
      
      res.status(200).json({
        success: true,
        data: {
          subscription,
          billingCycle: 'monthly',
          message: 'Current subscription retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting current subscription:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve current subscription'
      });
    }
  }

  /**
   * Get user's usage statistics
   * @route GET /api/subscriptions/usage
   * @access Private
   */
  static async getUsageStats(req, res) {
    try {
      const userId = req.user.id;
      const usageStats = await usageService.getUserUsageStats(userId);
      
      res.status(200).json({
        success: true,
        data: {
          usage: usageStats,
          message: 'Usage statistics retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting usage stats:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve usage statistics'
      });
    }
  }

  /**
   * Get user's usage history
   * @route GET /api/subscriptions/usage/history
   * @access Private
   */
  static async getUsageHistory(req, res) {
    try {
      const userId = req.user.id;
      const months = parseInt(req.query.months) || 12;
      
      const history = await usageService.getUserUsageHistory(userId, months);
      
      res.status(200).json({
        success: true,
        data: {
          history,
          message: 'Usage history retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting usage history:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve usage history'
      });
    }
  }

  /**
   * Create checkout session for subscription (Monthly only)
   * @route POST /api/subscriptions/create-checkout
   * @access Private
   */
  static async createCheckoutSession(req, res) {
    try {
      const userId = req.user.id;
      const { planName } = req.body;

      if (!planName) {
        return res.status(400).json({
          success: false,
          error: 'Plan name is required'
        });
      }

      // Build URLs
      const baseUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
      const successUrl = `${baseUrl}/subscription/success?session_id={CHECKOUT_SESSION_ID}`;
      const cancelUrl = `${baseUrl}/pricing`;

      const session = await subscriptionService.createCheckoutSession(
        userId,
        planName,
        successUrl,
        cancelUrl
      );

      res.status(200).json({
        success: true,
        data: {
          checkoutUrl: session.url,
          sessionId: session.id,
          planName,
          billingCycle: 'monthly',
          message: 'Monthly checkout session created successfully'
        }
      });
    } catch (error) {
      console.error('Error creating checkout session:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to create checkout session'
      });
    }
  }

  /**
   * Create customer portal session
   * @route POST /api/subscriptions/customer-portal
   * @access Private
   */
  static async createCustomerPortal(req, res) {
    try {
      const userId = req.user.id;
      const baseUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
      const returnUrl = `${baseUrl}/settings`;

      const session = await subscriptionService.createCustomerPortalSession(userId, returnUrl);

      res.status(200).json({
        success: true,
        data: {
          portalUrl: session.url,
          message: 'Customer portal session created successfully'
        }
      });
    } catch (error) {
      console.error('Error creating customer portal session:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to create customer portal session'
      });
    }
  }

  /**
   * Cancel subscription
   * @route POST /api/subscriptions/cancel
   * @access Private
   */
  static async cancelSubscription(req, res) {
    try {
      const userId = req.user.id;
      const { atPeriodEnd = true } = req.body;

      const result = await subscriptionService.cancelSubscription(userId, atPeriodEnd);

      res.status(200).json({
        success: true,
        data: {
          subscription: result,
          message: atPeriodEnd 
            ? 'Subscription will be canceled at the end of the monthly billing period'
            : 'Subscription canceled immediately'
        }
      });
    } catch (error) {
      console.error('Error canceling subscription:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to cancel subscription'
      });
    }
  }

  /**
   * Resume subscription
   * @route POST /api/subscriptions/resume
   * @access Private
   */
  static async resumeSubscription(req, res) {
    try {
      const userId = req.user.id;
      
      const result = await subscriptionService.resumeSubscription(userId);

      res.status(200).json({
        success: true,
        data: {
          subscription: result,
          message: 'Monthly subscription resumed successfully'
        }
      });
    } catch (error) {
      console.error('Error resuming subscription:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to resume subscription'
      });
    }
  }

  /**
   * Change subscription plan (Monthly only)
   * @route PUT /api/subscriptions/change-plan
   * @access Private
   */
  static async changeSubscriptionPlan(req, res) {
    try {
      const userId = req.user.id;
      const { newPlanName } = req.body;

      if (!newPlanName) {
        return res.status(400).json({
          success: false,
          error: 'New plan name is required'
        });
      }

      const result = await subscriptionService.changeSubscriptionPlan(
        userId,
        newPlanName
      );

      res.status(200).json({
        success: true,
        data: {
          subscription: result,
          newPlan: newPlanName,
          billingCycle: 'monthly',
          message: `Plan changed to ${newPlanName} (monthly) successfully`
        }
      });
    } catch (error) {
      console.error('Error changing subscription plan:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to change subscription plan'
      });
    }
  }

  /**
   * Sync subscription status with Stripe
   * @route POST /api/subscriptions/sync
   * @access Private
   */
  static async syncSubscription(req, res) {
    try {
      const userId = req.user.id;
      
      const result = await subscriptionService.syncSubscriptionStatus(userId);

      res.status(200).json({
        success: true,
        data: {
          result,
          message: 'Subscription status synced successfully'
        }
      });
    } catch (error) {
      console.error('Error syncing subscription:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to sync subscription status'
      });
    }
  }

  /**
   * Get billing history
   * @route GET /api/subscriptions/billing-history
   * @access Private
   */
  static async getBillingHistory(req, res) {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 10;
      
      const history = await subscriptionService.getBillingHistory(userId, limit);

      res.status(200).json({
        success: true,
        data: {
          history,
          billingCycle: 'monthly',
          message: 'Monthly billing history retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting billing history:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve billing history'
      });
    }
  }

  /**
   * Handle Stripe webhooks
   * @route POST /api/subscriptions/webhook
   * @access Public (but verified)
   */
  static async handleWebhook(req, res) {
    try {
      const signature = req.headers['stripe-signature'];
      const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

      if (!signature || !endpointSecret) {
        return res.status(400).json({
          success: false,
          error: 'Missing webhook signature or secret'
        });
      }

      // Verify webhook signature
      const event = stripeService.verifyWebhookSignature(
        req.body,
        signature,
        endpointSecret
      );

      // Handle the event
      await stripeService.handleWebhookEvent(event);

      res.status(200).json({
        success: true,
        message: 'Webhook handled successfully'
      });
    } catch (error) {
      console.error('Webhook handling error:', error);
      res.status(400).json({
        success: false,
        error: 'Webhook handling failed'
      });
    }
  }

  /**
   * Check feature permission
   * @route GET /api/subscriptions/permissions/:feature
   * @access Private
   */
  static async checkPermission(req, res) {
    try {
      const userId = req.user.id;
      const { feature } = req.params;
      const quantity = parseInt(req.query.quantity) || 1;

      if (!feature) {
        return res.status(400).json({
          success: false,
          error: 'Feature parameter is required'
        });
      }

      const permission = await subscriptionService.checkPermission(userId, feature, quantity);

      res.status(200).json({
        success: true,
        data: {
          permission,
          feature,
          quantity,
          message: 'Permission check completed'
        }
      });
    } catch (error) {
      console.error('Error checking permission:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to check permission'
      });
    }
  }

  /**
   * Get usage warnings
   * @route GET /api/subscriptions/usage/warnings
   * @access Private
   */
  static async getUsageWarnings(req, res) {
    try {
      const userId = req.user.id;
      
      const warnings = await usageService.getUsageWarnings(userId);

      res.status(200).json({
        success: true,
        data: {
          warnings,
          count: warnings.length,
          message: 'Usage warnings retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting usage warnings:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve usage warnings'
      });
    }
  }

  /**
   * Track usage manually (for testing)
   * @route POST /api/subscriptions/usage/track
   * @access Private
   */
  static async trackUsage(req, res) {
    try {
      const userId = req.user.id;
      const { action, quantity = 1, metadata = {} } = req.body;

      if (!action) {
        return res.status(400).json({
          success: false,
          error: 'Action is required'
        });
      }

      const result = await usageService.trackUsage(userId, action, quantity, metadata);

      res.status(200).json({
        success: true,
        data: {
          result,
          message: 'Usage tracked successfully'
        }
      });
    } catch (error) {
      console.error('Error tracking usage:', error);
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to track usage'
      });
    }
  }

  /**
   * Get subscription analytics (Admin only)
   * @route GET /api/subscriptions/analytics
   * @access Private (Admin)
   */
  static async getSubscriptionAnalytics(req, res) {
    try {
      // Check if user is admin
      if (req.user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const {
        startDate,
        endDate,
        planTier,
        feature
      } = req.query;

      const filters = {
        ...(startDate && { startDate: new Date(startDate) }),
        ...(endDate && { endDate: new Date(endDate) }),
        ...(planTier && { planTier }),
        ...(feature && { feature })
      };

      const analytics = await usageService.getUsageAnalytics(filters);

      res.status(200).json({
        success: true,
        data: {
          analytics,
          billingCycle: 'monthly',
          message: 'Monthly subscription analytics retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting subscription analytics:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve analytics'
      });
    }
  }

  /**
   * Get feature trends (Admin only)
   * @route GET /api/subscriptions/analytics/trends/:feature
   * @access Private (Admin)
   */
  static async getFeatureTrends(req, res) {
    try {
      // Check if user is admin
      if (req.user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { feature } = req.params;
      const days = parseInt(req.query.days) || 30;

      if (!feature) {
        return res.status(400).json({
          success: false,
          error: 'Feature parameter is required'
        });
      }

      const trends = await usageService.getFeatureTrends(feature, days);

      res.status(200).json({
        success: true,
        data: {
          trends,
          message: 'Feature trends retrieved successfully'
        }
      });
    } catch (error) {
      console.error('Error getting feature trends:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve feature trends'
      });
    }
  }

  /**
   * Preview plan change (Monthly only)
   * @route POST /api/subscriptions/preview-change
   * @access Private
   */
  static async previewPlanChange(req, res) {
    try {
      const userId = req.user.id;
      const { newPlanName } = req.body;

      if (!newPlanName) {
        return res.status(400).json({
          success: false,
          error: 'New plan name is required'
        });
      }

      // Get current subscription
      const currentSubscription = await subscriptionService.getCurrentSubscription(userId);
      
      if (!currentSubscription.subscription) {
        return res.status(400).json({
          success: false,
          error: 'No active subscription found'
        });
      }

      // Get new plan details
      const plansQuery = await db.query(`
        SELECT * FROM subscription_plans 
        WHERE name = $1 AND is_active = true
      `, [newPlanName]);

      const newPlan = plansQuery.rows[0];
      if (!newPlan) {
        return res.status(404).json({
          success: false,
          error: 'Plan not found'
        });
      }

      // Get current plan details
      const currentPlan = await db.query(`
        SELECT * FROM subscription_plans 
        WHERE name = $1
      `, [currentSubscription.user.subscriptionTier]);

      // Use monthly prices only
      const currentPrice = currentPlan.rows[0]?.price_monthly || 0;
      const newPrice = newPlan.price_monthly;
      const priceDifference = newPrice - currentPrice;

      res.status(200).json({
        success: true,
        data: {
          currentPlan: {
            name: currentSubscription.user.subscriptionTier,
            price: currentPrice
          },
          newPlan: {
            name: newPlanName,
            price: newPrice
          },
          priceDifference,
          billingCycle: 'monthly',
          isUpgrade: priceDifference > 0,
          isDowngrade: priceDifference < 0,
          message: 'Monthly plan change preview calculated successfully'
        }
      });
    } catch (error) {
      console.error('Error previewing plan change:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to preview plan change'
      });
    }
  }

  /**
   * Get subscription health check
   * @route GET /api/subscriptions/health
   * @access Private
   */
  static async getSubscriptionHealth(req, res) {
    try {
      const userId = req.user.id;
      
      const subscription = await subscriptionService.getCurrentSubscription(userId);
      const warnings = await usageService.getUsageWarnings(userId);
      
      const now = new Date();
      const health = {
        subscriptionActive: subscription.isActive,
        planTier: subscription.user.subscriptionTier,
        billingCycle: 'monthly',
        usageWarnings: warnings,
        healthScore: 100, // Base score
        issues: [],
        recommendations: []
      };

      // Check for issues
      if (!subscription.isActive && subscription.user.subscriptionTier !== 'free') {
        health.issues.push('Subscription is inactive');
        health.healthScore -= 30;
        health.recommendations.push('Renew your monthly subscription to continue using premium features');
      }

      if (subscription.user.cancelAtPeriodEnd) {
        health.issues.push('Subscription set to cancel at period end');
        health.healthScore -= 20;
        health.recommendations.push('Consider resuming your monthly subscription if you want to continue');
      }

      if (subscription.user.subscriptionEndDate) {
        const daysUntilExpiry = Math.ceil((new Date(subscription.user.subscriptionEndDate) - now) / (1000 * 60 * 60 * 24));
        if (daysUntilExpiry <= 7 && daysUntilExpiry > 0) {
          health.issues.push(`Monthly subscription expires in ${daysUntilExpiry} days`);
          health.healthScore -= 15;
          health.recommendations.push('Your monthly subscription is expiring soon. Please ensure your payment method is up to date');
        }
      }

      // Check usage warnings
      const criticalWarnings = warnings.filter(w => w.severity === 'critical');
      if (criticalWarnings.length > 0) {
        health.issues.push(`${criticalWarnings.length} features at usage limit`);
        health.healthScore -= 10 * criticalWarnings.length;
        health.recommendations.push('Consider upgrading your plan for higher usage limits');
      }

      health.healthScore = Math.max(0, health.healthScore);

      res.status(200).json({
        success: true,
        data: {
          health,
          message: 'Subscription health check completed'
        }
      });
    } catch (error) {
      console.error('Error getting subscription health:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get subscription health'
      });
    }
  }
}

module.exports = SubscriptionController;

================
File: backend/debug-controller-params.js
================
// backend/debug-controller-params.js - Debug what's happening with parameters
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugControllerParams() {
  try {
    console.log('🐛 DEBUGGING CONTROLLER PARAMETERS');
    console.log('====================================');
    
    // Simulate the exact request parameters from your log
    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';
    const company = '';
    const industry = '';
    const location = '';
    const title = '';
    const experience_min = '';
    const experience_max = '20'; // This is what's in your query string
    const limit = 20;
    const offset = 0;
    const sort_by = 'last_active_date';
    const sort_order = 'DESC';

    console.log('📋 Input Parameters:');
    console.log(`   userId: ${userId}`);
    console.log(`   query: "${query}"`);
    console.log(`   company: "${company}"`);
    console.log(`   industry: "${industry}"`);
    console.log(`   location: "${location}"`);
    console.log(`   title: "${title}"`);
    console.log(`   experience_min: "${experience_min}"`);
    console.log(`   experience_max: "${experience_max}"`);
    console.log(`   limit: ${limit}`);
    console.log(`   offset: ${offset}`);

    // Build query exactly like the controller
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone as phone,
        r.title,
        r.linkedin_profile_url as linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        i.name as industry_name,
        l.city,
        l.state,
        l.country,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    console.log('\n🔧 Building Query Step by Step:');
    console.log(`1. Base query with userId: ${userId}`);

    // Add search filters with COALESCE to handle NULL values
    if (query) {
      sqlQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${paramIndex} OR
        COALESCE(r.title, '') ILIKE $${paramIndex} OR
        COALESCE(c.name, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${query.toLowerCase()}%`);
      console.log(`2. Added query filter: %${query.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (company) {
      sqlQuery += ` AND COALESCE(c.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${company.toLowerCase()}%`);
      console.log(`3. Added company filter: %${company.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (industry) {
      sqlQuery += ` AND COALESCE(i.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${industry.toLowerCase()}%`);
      console.log(`4. Added industry filter: %${industry.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (location) {
      sqlQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${paramIndex} OR
        COALESCE(l.state, '') ILIKE $${paramIndex} OR
        COALESCE(l.country, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${location.toLowerCase()}%`);
      console.log(`5. Added location filter: %${location.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (title) {
      sqlQuery += ` AND COALESCE(r.title, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${title.toLowerCase()}%`);
      console.log(`6. Added title filter: %${title.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    // ⚠️ CRITICAL: Check if experience filters are being applied
    console.log(`\n⚠️  EXPERIENCE FILTER CHECK:`);
    console.log(`   experience_min: "${experience_min}" (truthy: ${!!experience_min})`);
    console.log(`   experience_max: "${experience_max}" (truthy: ${!!experience_max})`);

    if (experience_min) {
      sqlQuery += ` AND r.experience_years >= $${paramIndex}`;
      queryParams.push(parseInt(experience_min));
      console.log(`7. Added experience_min filter: >= ${experience_min} (param $${paramIndex})`);
      paramIndex++;
    }

    if (experience_max) {
      sqlQuery += ` AND r.experience_years <= $${paramIndex}`;
      queryParams.push(parseInt(experience_max));
      console.log(`8. ⚠️  Added experience_max filter: <= ${experience_max} (param $${paramIndex})`);
      paramIndex++;
    }

    // Add ordering
    const validSortFields = ['last_active_date', 'rating', 'experience_years', 'first_name'];
    const sortField = validSortFields.includes(sort_by) ? sort_by : 'last_active_date';
    const sortDirection = sort_order.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
    
    sqlQuery += ` ORDER BY r.${sortField} ${sortDirection}`;
    console.log(`9. Added sorting: ORDER BY r.${sortField} ${sortDirection}`);
    
    // Add pagination
    sqlQuery += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    queryParams.push(parseInt(limit), parseInt(offset));
    console.log(`10. Added pagination: LIMIT ${limit} OFFSET ${offset} (params $${paramIndex}, $${paramIndex + 1})`);

    console.log('\n📝 FINAL QUERY:');
    console.log(sqlQuery);
    console.log('\n📋 FINAL PARAMETERS:');
    console.log(queryParams);

    // Execute the query
    console.log('\n🗄️ EXECUTING QUERY...');
    const result = await pool.query(sqlQuery, queryParams);
    console.log(`✅ Query executed successfully: ${result.rows.length} rows returned`);

    if (result.rows.length > 0) {
      console.log('\n👥 SAMPLE RESULTS:');
      result.rows.slice(0, 3).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title} (Experience: ${row.experience_years || 'N/A'} years)`);
      });
    }

    // Test without experience_max filter
    console.log('\n🧪 TESTING WITHOUT EXPERIENCE_MAX FILTER:');
    
    let testQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $2 OR
           COALESCE(r.title, '') ILIKE $2 OR
           COALESCE(c.name, '') ILIKE $2)
    `;
    
    const testResult = await pool.query(testQuery, [userId, `%${query.toLowerCase()}%`]);
    console.log(`📊 Without experience_max filter: ${testResult.rows[0].count} matches`);

    // Test with experience_max filter
    testQuery += ` AND r.experience_years <= $3`;
    const testResult2 = await pool.query(testQuery, [userId, `%${query.toLowerCase()}%`, parseInt(experience_max)]);
    console.log(`📊 With experience_max <= ${experience_max}: ${testResult2.rows[0].count} matches`);

    // Check experience_years distribution
    console.log('\n📈 EXPERIENCE YEARS DISTRIBUTION FOR SARAH:');
    const expQuery = `
      SELECT 
        r.experience_years,
        COUNT(*) as count,
        array_agg(r.first_name || ' ' || r.last_name) as names
      FROM recruiters r
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $1)
      GROUP BY r.experience_years
      ORDER BY r.experience_years
    `;
    
    const expResult = await pool.query(expQuery, [`%${query.toLowerCase()}%`]);
    expResult.rows.forEach(row => {
      console.log(`   ${row.experience_years || 'NULL'} years: ${row.count} people`);
      if (row.count <= 3) {
        console.log(`      Names: ${row.names.join(', ')}`);
      }
    });

  } catch (error) {
    console.error('❌ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

debugControllerParams();

================
File: backend/debug-recruiter-search.js
================
// backend/debug-recruiter-search.js - Debug script to check recruiter data
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugRecruiterSearch() {
  try {
    console.log('🔍 DEBUGGING RECRUITER SEARCH');
    console.log('================================');

    // 1. Check basic table counts
    console.log('\n1️⃣ CHECKING TABLE COUNTS:');
    const counts = await Promise.all([
      pool.query('SELECT COUNT(*) as count FROM recruiters'),
      pool.query('SELECT COUNT(*) as count FROM companies'),
      pool.query('SELECT COUNT(*) as count FROM industries'),
      pool.query('SELECT COUNT(*) as count FROM locations')
    ]);

    console.log(`   Recruiters: ${counts[0].rows[0].count}`);
    console.log(`   Companies: ${counts[1].rows[0].count}`);
    console.log(`   Industries: ${counts[2].rows[0].count}`);
    console.log(`   Locations: ${counts[3].rows[0].count}`);

    // 2. Check for active recruiters
    console.log('\n2️⃣ CHECKING ACTIVE RECRUITERS:');
    const activeCount = await pool.query('SELECT COUNT(*) as count FROM recruiters WHERE is_active = true');
    const inactiveCount = await pool.query('SELECT COUNT(*) as count FROM recruiters WHERE is_active = false OR is_active IS NULL');
    
    console.log(`   Active recruiters: ${activeCount.rows[0].count}`);
    console.log(`   Inactive/NULL recruiters: ${inactiveCount.rows[0].count}`);

    // 3. Sample recruiter data
    console.log('\n3️⃣ SAMPLE RECRUITER DATA:');
    const sampleRecruiters = await pool.query(`
      SELECT 
        r.id, r.first_name, r.last_name, r.email, r.title, r.is_active,
        c.name as company_name,
        i.name as industry_name
      FROM recruiters r 
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LIMIT 10
    `);

    sampleRecruiters.rows.forEach((recruiter, index) => {
      console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} (${recruiter.email}) - Active: ${recruiter.is_active}`);
      console.log(`      Title: ${recruiter.title}`);
      console.log(`      Company: ${recruiter.company_name}`);
      console.log(`      Industry: ${recruiter.industry_name}`);
      console.log('');
    });

    // 4. Check for "Sarah" specifically (case insensitive)
    console.log('\n4️⃣ SEARCHING FOR "SARAH" (CASE INSENSITIVE):');
    const sarahSearch = await pool.query(`
      SELECT 
        r.first_name, r.last_name, r.email, r.is_active,
        c.name as company_name
      FROM recruiters r 
      LEFT JOIN companies c ON r.current_company_id = c.id
      WHERE LOWER(r.first_name) LIKE LOWER('%sarah%') 
         OR LOWER(r.last_name) LIKE LOWER('%sarah%')
      LIMIT 5
    `);

    if (sarahSearch.rows.length > 0) {
      console.log(`   Found ${sarahSearch.rows.length} results for "Sarah":`);
      sarahSearch.rows.forEach((recruiter, index) => {
        console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} (${recruiter.email}) - Active: ${recruiter.is_active}`);
        console.log(`      Company: ${recruiter.company_name}`);
      });
    } else {
      console.log('   ❌ No results found for "Sarah"');
    }

    // 5. Check the exact search query that's failing
    console.log('\n5️⃣ TESTING EXACT SEARCH QUERY:');
    
    const testQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.title,
        r.is_active,
        c.name as company_name
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      WHERE r.is_active = true
        AND (
          LOWER(r.first_name || ' ' || r.last_name) LIKE LOWER('%sarah%') OR
          LOWER(r.title) LIKE LOWER('%sarah%') OR
          LOWER(c.name) LIKE LOWER('%sarah%')
        )
      LIMIT 5
    `;

    const exactSearch = await pool.query(testQuery);
    
    if (exactSearch.rows.length > 0) {
      console.log(`   ✅ Found ${exactSearch.rows.length} results with exact query:`);
      exactSearch.rows.forEach((recruiter, index) => {
        console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} - ${recruiter.title}`);
        console.log(`      Company: ${recruiter.company_name}`);
        console.log(`      Active: ${recruiter.is_active}`);
      });
    } else {
      console.log('   ❌ No results with exact search query');
    }

    // 6. Check for null values that might cause issues
    console.log('\n6️⃣ CHECKING FOR NULL VALUES:');
    const nullCheck = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(first_name) as has_first_name,
        COUNT(last_name) as has_last_name,
        COUNT(title) as has_title,
        COUNT(is_active) as has_is_active
      FROM recruiters
    `);

    const nullStats = nullCheck.rows[0];
    console.log(`   Total recruiters: ${nullStats.total}`);
    console.log(`   With first_name: ${nullStats.has_first_name}`);
    console.log(`   With last_name: ${nullStats.has_last_name}`);
    console.log(`   With title: ${nullStats.has_title}`);
    console.log(`   With is_active: ${nullStats.has_is_active}`);

    // 7. Check industry data specifically
    console.log('\n7️⃣ CHECKING INDUSTRY DATA:');
    const industryData = await pool.query(`
      SELECT i.name, COUNT(r.id) as recruiter_count
      FROM industries i
      LEFT JOIN recruiters r ON i.id = r.industry_id AND r.is_active = true
      GROUP BY i.id, i.name
      ORDER BY recruiter_count DESC
      LIMIT 10
    `);

    if (industryData.rows.length > 0) {
      console.log('   Top industries:');
      industryData.rows.forEach((industry, index) => {
        console.log(`   ${index + 1}. ${industry.name}: ${industry.recruiter_count} recruiters`);
      });
    } else {
      console.log('   ❌ No industry data found');
    }

    // 8. Test if the issue is with the is_active column
    console.log('\n8️⃣ TESTING WITHOUT is_active FILTER:');
    const noActiveFilter = await pool.query(`
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      WHERE LOWER(r.first_name || ' ' || r.last_name) LIKE LOWER('%sarah%')
    `);

    console.log(`   Results without is_active filter: ${noActiveFilter.rows[0].count}`);

    // 9. Check schema for is_active column
    console.log('\n9️⃣ CHECKING SCHEMA FOR is_active COLUMN:');
    const schemaCheck = await pool.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns 
      WHERE table_name = 'recruiters' AND column_name = 'is_active'
    `);

    if (schemaCheck.rows.length > 0) {
      const col = schemaCheck.rows[0];
      console.log(`   is_active column exists: ${col.data_type}, nullable: ${col.is_nullable}, default: ${col.column_default}`);
    } else {
      console.log('   ❌ is_active column does not exist!');
    }

    console.log('\n✅ Debug complete!');

  } catch (error) {
    console.error('❌ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

// Run the debug
debugRecruiterSearch();

================
File: backend/debug-search-query.js
================
// backend/debug-search-query.js - Debug the exact search query
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugSearchQuery() {
  try {
    console.log('🔍 DEBUGGING SEARCH QUERY FOR "SARAH"');
    console.log('===========================================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Test 1: Basic recruiter count
    console.log('\n1️⃣ TOTAL ACTIVE RECRUITERS:');
    const totalActiveResult = await pool.query(`
      SELECT COUNT(*) as count FROM recruiters WHERE is_active = true
    `);
    console.log(`   Active recruiters: ${totalActiveResult.rows[0].count}`);

    // Test 2: Sarah search without joins
    console.log('\n2️⃣ SARAH SEARCH WITHOUT JOINS:');
    const sarahBasicResult = await pool.query(`
      SELECT COUNT(*) as count 
      FROM recruiters r
      WHERE r.is_active = true 
        AND ((r.first_name || ' ' || r.last_name) ILIKE $1 OR r.title ILIKE $1)
    `, [`%${query}%`]);
    console.log(`   Sarah matches without joins: ${sarahBasicResult.rows[0].count}`);

    // Test 3: Exact query from controller
    console.log('\n3️⃣ EXACT CONTROLLER QUERY (with outreach join):');
    const exactQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE $2 OR r.title ILIKE $2)
      ORDER BY r.first_name ASC
      LIMIT 20 OFFSET 0
    `;

    const exactResult = await pool.query(exactQuery, [userId, `%${query}%`]);
    console.log(`   Exact controller query results: ${exactResult.rows.length}`);

    if (exactResult.rows.length > 0) {
      console.log('\n   📋 Sample results:');
      exactResult.rows.slice(0, 5).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    }

    // Test 4: Check the count query specifically
    console.log('\n4️⃣ CONTROLLER COUNT QUERY:');
    const countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
      AND ((r.first_name || ' ' || r.last_name) ILIKE '%${query}%' OR r.title ILIKE '%${query}%')
    `;
    console.log('   Count query SQL:');
    console.log(`   ${countQuery}`);
    
    const countResult = await pool.query(countQuery);
    console.log(`   Count query result: ${countResult.rows[0].count}`);

    // Test 5: Check if there's a parameter binding issue
    console.log('\n5️⃣ PARAMETER BINDING TEST:');
    const parameterTestQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE $1 OR r.title ILIKE $1)
    `;
    const parameterTestResult = await pool.query(parameterTestQuery, [`%${query}%`]);
    console.log(`   Parameterized count result: ${parameterTestResult.rows[0].count}`);

    // Test 6: Check outreach_history table
    console.log('\n6️⃣ OUTREACH HISTORY CHECK:');
    const outreachHistoryResult = await pool.query(`
      SELECT COUNT(*) as count FROM outreach_history WHERE mongodb_user_id = $1
    `, [userId]);
    console.log(`   Outreach history records for user: ${outreachHistoryResult.rows[0].count}`);

    // Test 7: Check if the issue is with the name concatenation
    console.log('\n7️⃣ NAME CONCATENATION TEST:');
    const nameTestResult = await pool.query(`
      SELECT first_name, last_name, (first_name || ' ' || last_name) as full_name
      FROM recruiters 
      WHERE is_active = true
        AND LOWER(first_name) LIKE LOWER('%sarah%')
      LIMIT 5
    `);
    console.log('   Sample name concatenation results:');
    nameTestResult.rows.forEach((row, index) => {
      console.log(`   ${index + 1}. "${row.first_name}" + "${row.last_name}" = "${row.full_name}"`);
    });

    // Test 8: Check for NULL values that might break concatenation
    console.log('\n8️⃣ NULL VALUE CHECK:');
    const nullCheckResult = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(first_name) as has_first_name,
        COUNT(last_name) as has_last_name,
        COUNT(CASE WHEN first_name IS NULL OR last_name IS NULL THEN 1 END) as has_null_names
      FROM recruiters 
      WHERE is_active = true
    `);
    const nullStats = nullCheckResult.rows[0];
    console.log(`   Total active: ${nullStats.total}`);
    console.log(`   Has first_name: ${nullStats.has_first_name}`);
    console.log(`   Has last_name: ${nullStats.has_last_name}`);
    console.log(`   Has NULL names: ${nullStats.has_null_names}`);

    console.log('\n✅ Debug complete!');

  } catch (error) {
    console.error('❌ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

// Run the debug
debugSearchQuery();

================
File: backend/middleware/auth.middleware.js
================
// backend/middleware/auth.middleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/mongodb/user.model');

/**
 * Middleware to protect routes that require authentication
 */
exports.protect = async (req, res, next) => {
  try {
    let token;
    
    // Check for token in Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    }
    // Also check for token in cookies
    else if (req.cookies && req.cookies.token) {
      token = req.cookies.token;
    }
    
    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to access this route - no token provided'
      });
    }
    
    try {
      // Verify the token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Find the user by ID
      const user = await User.findById(decoded.id);
      
      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'The user belonging to this token no longer exists'
        });
      }
      
      // Check if user is active
      if (!user.active) {
        return res.status(401).json({
          success: false,
          error: 'This account has been deactivated'
        });
      }
      
      // TEMPORARILY DISABLED EMAIL VERIFICATION CHECK FOR DEBUGGING
      // TODO: Re-enable this after login is working
      /*
      if (!user.isEmailVerified) {
        return res.status(403).json({
          success: false,
          error: 'Please verify your email to access this resource'
        });
      }
      */
      
      // Set user in request object
      req.user = user;
      req.userId = user._id; // Add this for compatibility
      next();
    } catch (jwtError) {
      console.error('JWT verification error:', jwtError.message);
      return res.status(401).json({
        success: false,
        error: 'Invalid token'
      });
    }
  } catch (error) {
    console.error('Auth middleware error:', error);
    return res.status(500).json({
      success: false,
      error: 'Authentication server error'
    });
  }
};

/**
 * Middleware to restrict access based on user role
 */
exports.restrictTo = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to perform this action'
      });
    }
    next();
  };
};

/**
 * Middleware to check if email is verified
 * Soft check - allows request but adds verified status to req object
 */
exports.checkEmailVerification = async (req, res, next) => {
  try {
    if (req.user && !req.user.isEmailVerified) {
      req.isEmailVerified = false;
    } else {
      req.isEmailVerified = true;
    }
    next();
  } catch (error) {
    next(error);
  }
};

/**
 * Optional authentication middleware - doesn't fail if no token
 * Useful for routes that work for both authenticated and non-authenticated users
 */
exports.optionalAuth = async (req, res, next) => {
  try {
    let token;
    
    // Check for token in Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    }
    // Also check for token in cookies
    else if (req.cookies && req.cookies.token) {
      token = req.cookies.token;
    }
    
    if (token) {
      try {
        // Verify the token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // Find the user by ID
        const user = await User.findById(decoded.id);
        
        if (user && user.active) {
          req.user = user;
          req.userId = user._id;
          req.isAuthenticated = true;
        }
      } catch (jwtError) {
        // Token is invalid, but that's okay for optional auth
        console.log('Optional auth - invalid token:', jwtError.message);
      }
    }
    
    // Always continue regardless of token validity
    next();
  } catch (error) {
    // Even if there's an error, continue (optional auth)
    console.error('Optional auth middleware error:', error);
    next();
  }
};

================
File: backend/middleware/subscription.middleware.js
================
// backend/middleware/subscription.middleware.js
const User = require('../models/mongodb/user.model');
const subscriptionService = require('../services/subscription.service');

class SubscriptionMiddleware {
  /**
   * Verify user has active subscription
   * @param {Array} allowedPlans - Array of plan names that can access this route
   */
  static requireSubscription(allowedPlans = ['casual', 'hunter']) {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required'
          });
        }

        const user = await User.findById(userId);
        if (!user) {
          return res.status(404).json({
            success: false,
            error: 'User not found'
          });
        }

        // Check if user's plan is in allowed plans
        if (!allowedPlans.includes(user.subscriptionTier)) {
          return res.status(403).json({
            success: false,
            error: 'Subscription upgrade required',
            details: {
              currentPlan: user.subscriptionTier,
              requiredPlans: allowedPlans,
              upgradeRequired: true
            }
          });
        }

        // Check if subscription is active
        if (!user.hasActiveSubscription()) {
          return res.status(403).json({
            success: false,
            error: 'Active subscription required',
            details: {
              subscriptionStatus: user.subscriptionStatus,
              subscriptionEndDate: user.subscriptionEndDate,
              renewalRequired: true
            }
          });
        }

        // Add subscription info to request for later use
        req.subscription = {
          tier: user.subscriptionTier,
          status: user.subscriptionStatus,
          endDate: user.subscriptionEndDate,
          isActive: user.hasActiveSubscription()
        };

        next();
      } catch (error) {
        console.error('Subscription middleware error:', error);
        res.status(500).json({
          success: false,
          error: 'Subscription verification failed'
        });
      }
    };
  }

  /**
   * Require specific plan tier
   * @param {string} minimumPlan - Minimum plan required ('free', 'casual', 'hunter')
   */
  static requirePlan(minimumPlan) {
    const planHierarchy = { free: 0, casual: 1, hunter: 2 };
    
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required'
          });
        }

        const user = await User.findById(userId);
        if (!user) {
          return res.status(404).json({
            success: false,
            error: 'User not found'
          });
        }

        const userPlanLevel = planHierarchy[user.subscriptionTier] || 0;
        const requiredPlanLevel = planHierarchy[minimumPlan] || 0;

        if (userPlanLevel < requiredPlanLevel) {
          return res.status(403).json({
            success: false,
            error: 'Plan upgrade required',
            details: {
              currentPlan: user.subscriptionTier,
              requiredPlan: minimumPlan,
              upgradeRequired: true
            }
          });
        }

        // For non-free plans, also check if subscription is active
        if (minimumPlan !== 'free' && !user.hasActiveSubscription()) {
          return res.status(403).json({
            success: false,
            error: 'Active subscription required',
            details: {
              subscriptionStatus: user.subscriptionStatus,
              subscriptionEndDate: user.subscriptionEndDate,
              renewalRequired: true
            }
          });
        }

        req.subscription = {
          tier: user.subscriptionTier,
          status: user.subscriptionStatus,
          endDate: user.subscriptionEndDate,
          isActive: user.hasActiveSubscription()
        };

        next();
      } catch (error) {
        console.error('Plan requirement middleware error:', error);
        res.status(500).json({
          success: false,
          error: 'Plan verification failed'
        });
      }
    };
  }

  /**
   * Require specific feature access
   * @param {string} feature - Feature name to check
   */
  static requireFeature(feature) {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required'
          });
        }

        const user = await User.findById(userId);
        if (!user) {
          return res.status(404).json({
            success: false,
            error: 'User not found'
          });
        }

        const planLimits = user.getPlanLimits();
        
        // Check feature access based on feature type
        if (feature === 'recruiterAccess' && !planLimits.recruiterAccess) {
          return res.status(403).json({
            success: false,
            error: 'Recruiter access not available in your plan',
            details: {
              feature,
              currentPlan: user.subscriptionTier,
              upgradeRequired: true,
              recommendedPlan: 'casual'
            }
          });
        }

        if (feature === 'aiAssistant' && !planLimits.aiAssistant) {
          return res.status(403).json({
            success: false,
            error: 'AI Assistant not available in your plan',
            details: {
              feature,
              currentPlan: user.subscriptionTier,
              upgradeRequired: true,
              recommendedPlan: 'hunter'
            }
          });
        }

        if (feature === 'aiJobDiscovery' && !planLimits.aiJobDiscovery) {
          return res.status(403).json({
            success: false,
            error: 'AI Job Discovery not available in your plan',
            details: {
              feature,
              currentPlan: user.subscriptionTier,
              upgradeRequired: true,
              recommendedPlan: 'casual'
            }
          });
        }

        req.subscription = {
          tier: user.subscriptionTier,
          status: user.subscriptionStatus,
          endDate: user.subscriptionEndDate,
          isActive: user.hasActiveSubscription(),
          planLimits
        };

        next();
      } catch (error) {
        console.error('Feature requirement middleware error:', error);
        res.status(500).json({
          success: false,
          error: 'Feature verification failed'
        });
      }
    };
  }

  /**
   * Inject subscription context into request
   * This middleware adds subscription info to all authenticated requests
   */
  static injectSubscriptionContext() {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return next(); // Skip for unauthenticated requests
        }

        const user = await User.findById(userId);
        if (!user) {
          return next(); // Skip if user not found
        }

        // Add subscription context to request
        req.subscription = {
          tier: user.subscriptionTier,
          status: user.subscriptionStatus,
          startDate: user.subscriptionStartDate,
          endDate: user.subscriptionEndDate,
          trialEndDate: user.trialEndDate,
          cancelAtPeriodEnd: user.cancelAtPeriodEnd,
          billingCycle: user.billingCycle,
          isActive: user.hasActiveSubscription(),
          planLimits: user.getPlanLimits(),
          usageStats: user.getUsageStats(),
          stripeCustomerId: user.stripeCustomerId
        };

        // Also add to response for client-side access
        res.locals.subscription = req.subscription;

        next();
      } catch (error) {
        console.error('Subscription context injection error:', error);
        // Don't fail the request, just continue without subscription context
        next();
      }
    };
  }

  /**
   * Check subscription status and sync with Stripe if needed
   */
  static checkSubscriptionStatus() {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return next();
        }

        const user = await User.findById(userId);
        if (!user || user.subscriptionTier === 'free') {
          return next();
        }

        // Check if subscription might be expired
        const now = new Date();
        if (user.subscriptionEndDate && user.subscriptionEndDate < now && user.subscriptionStatus === 'active') {
          console.log(`Detected potentially expired subscription for user ${userId}, syncing with Stripe...`);
          
          try {
            await subscriptionService.syncSubscriptionStatus(userId);
          } catch (syncError) {
            console.error('Error syncing subscription status:', syncError);
            // Continue with existing status rather than failing the request
          }
        }

        next();
      } catch (error) {
        console.error('Subscription status check error:', error);
        next(); // Continue with request
      }
    };
  }

  /**
   * Handle trial period logic
   */
  static handleTrialPeriod() {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return next();
        }

        const user = await User.findById(userId);
        if (!user) {
          return next();
        }

        // Check if trial is ending soon (within 3 days)
        if (user.trialEndDate) {
          const now = new Date();
          const trialEnd = new Date(user.trialEndDate);
          const daysUntilExpiry = Math.ceil((trialEnd - now) / (1000 * 60 * 60 * 24));

          if (daysUntilExpiry <= 3 && daysUntilExpiry > 0) {
            req.trialWarning = {
              daysRemaining: daysUntilExpiry,
              trialEndDate: trialEnd,
              upgradeRequired: true
            };
          }
        }

        next();
      } catch (error) {
        console.error('Trial period check error:', error);
        next();
      }
    };
  }

  /**
   * Add subscription information to API responses
   */
  static addSubscriptionToResponse() {
    return (req, res, next) => {
      // Override res.json to include subscription info
      const originalJson = res.json;
      
      res.json = function(body) {
        if (req.subscription && body && typeof body === 'object' && body.success !== false) {
          body.subscription = {
            tier: req.subscription.tier,
            status: req.subscription.status,
            isActive: req.subscription.isActive,
            planLimits: req.subscription.planLimits,
            usageStats: req.subscription.usageStats
          };

          // Add trial warning if present
          if (req.trialWarning) {
            body.trialWarning = req.trialWarning;
          }
        }
        
        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Log subscription-related activities
   */
  static logSubscriptionActivity() {
    return (req, res, next) => {
      if (req.subscription && req.method !== 'GET') {
        console.log(`Subscription Activity: ${req.method} ${req.originalUrl} - User: ${req.user?.id} - Plan: ${req.subscription.tier} - Status: ${req.subscription.status}`);
      }
      next();
    };
  }
}

module.exports = SubscriptionMiddleware;

================
File: backend/middleware/usage.middleware.js
================
// backend/middleware/usage.middleware.js
const usageService = require('../services/usage.service');
const User = require('../models/mongodb/user.model');

class UsageMiddleware {
  /**
   * Check usage limit before allowing action
   * @param {string} action - Action to check (e.g., 'resumeUploads', 'jobImports')
   * @param {number} quantity - Quantity needed (default: 1)
   */
  static checkUsageLimit(action, quantity = 1) {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required'
          });
        }

        // For dynamic quantity, check if it's specified in request body or params
        let actualQuantity = quantity;
        if (req.body?.quantity && typeof req.body.quantity === 'number') {
          actualQuantity = req.body.quantity;
        } else if (req.params?.quantity && !isNaN(parseInt(req.params.quantity))) {
          actualQuantity = parseInt(req.params.quantity);
        }

        const usageCheck = await usageService.checkUsageLimit(userId, action, actualQuantity);

        if (!usageCheck.allowed) {
          return res.status(403).json({
            success: false,
            error: 'Usage limit exceeded',
            details: {
              action,
              reason: usageCheck.reason,
              current: usageCheck.current,
              limit: usageCheck.limit,
              plan: usageCheck.plan,
              upgradeRequired: true,
              recommendedPlan: usageService.getRecommendedPlan(action)
            }
          });
        }

        // Store usage check result for potential tracking later
        req.usageCheck = usageCheck;
        req.usageAction = action;
        req.usageQuantity = actualQuantity;

        next();
      } catch (error) {
        console.error('Usage limit check error:', error);
        res.status(500).json({
          success: false,
          error: 'Usage verification failed'
        });
      }
    };
  }

  /**
   * Track usage after successful action
   * @param {string} action - Action to track
   * @param {number} quantity - Quantity to track (default: 1)
   * @param {Function} metadataExtractor - Function to extract metadata from request
   */
  static trackUsage(action, quantity = 1, metadataExtractor = null) {
    return async (req, res, next) => {
      // Store original res.json to intercept successful responses
      const originalJson = res.json;
      
      res.json = async function(body) {
        try {
          // Only track usage on successful responses
          if (body && body.success !== false && res.statusCode < 400) {
            const userId = req.user?.id;
            if (userId) {
              // Use quantity from previous usage check or default
              let actualQuantity = req.usageQuantity || quantity;
              
              // Extract metadata if extractor function provided
              let metadata = {};
              if (metadataExtractor && typeof metadataExtractor === 'function') {
                try {
                  metadata = metadataExtractor(req, res, body);
                } catch (extractorError) {
                  console.error('Error extracting metadata:', extractorError);
                }
              }

              try {
                const usageResult = await usageService.trackUsage(
                  userId, 
                  action, 
                  actualQuantity, 
                  metadata
                );

                // Add usage information to response
                if (body && typeof body === 'object') {
                  body.usage = {
                    action,
                    tracked: actualQuantity,
                    remaining: usageResult.remaining,
                    stats: usageResult.usageStats
                  };
                }
              } catch (trackingError) {
                console.error(`Error tracking usage for ${action}:`, trackingError);
                // Don't fail the response for tracking errors
              }
            }
          }
        } catch (error) {
          console.error('Usage tracking middleware error:', error);
        }

        // Call original res.json
        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Combined middleware: check limit then track usage
   * @param {string} action - Action to check and track
   * @param {number} quantity - Quantity (default: 1)
   * @param {Function} metadataExtractor - Function to extract metadata
   */
  static checkAndTrack(action, quantity = 1, metadataExtractor = null) {
    return [
      this.checkUsageLimit(action, quantity),
      this.trackUsage(action, quantity, metadataExtractor)
    ];
  }

  /**
   * Validate multiple usage requirements
   * @param {Array} requirements - Array of {action, quantity} objects
   */
  static checkMultipleUsageLimits(requirements) {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required'
          });
        }

        const failedChecks = [];
        const passedChecks = [];

        for (const { action, quantity = 1 } of requirements) {
          const usageCheck = await usageService.checkUsageLimit(userId, action, quantity);
          
          if (!usageCheck.allowed) {
            failedChecks.push({
              action,
              reason: usageCheck.reason,
              current: usageCheck.current,
              limit: usageCheck.limit
            });
          } else {
            passedChecks.push(usageCheck);
          }
        }

        if (failedChecks.length > 0) {
          return res.status(403).json({
            success: false,
            error: 'Usage limits exceeded',
            details: {
              failedChecks,
              upgradeRequired: true
            }
          });
        }

        req.multipleUsageChecks = passedChecks;
        next();
      } catch (error) {
        console.error('Multiple usage limits check error:', error);
        res.status(500).json({
          success: false,
          error: 'Usage verification failed'
        });
      }
    };
  }

  /**
   * Track multiple usage items
   * @param {Array} trackingItems - Array of {action, quantity, metadataExtractor} objects
   */
  static trackMultipleUsage(trackingItems) {
    return async (req, res, next) => {
      const originalJson = res.json;
      
      res.json = async function(body) {
        try {
          if (body && body.success !== false && res.statusCode < 400) {
            const userId = req.user?.id;
            if (userId) {
              const trackingResults = [];

              for (const { action, quantity = 1, metadataExtractor } of trackingItems) {
                try {
                  let metadata = {};
                  if (metadataExtractor && typeof metadataExtractor === 'function') {
                    metadata = metadataExtractor(req, res, body);
                  }

                  const usageResult = await usageService.trackUsage(
                    userId, 
                    action, 
                    quantity, 
                    metadata
                  );

                  trackingResults.push({
                    action,
                    tracked: quantity,
                    remaining: usageResult.remaining
                  });
                } catch (trackingError) {
                  console.error(`Error tracking usage for ${action}:`, trackingError);
                }
              }

              if (body && typeof body === 'object' && trackingResults.length > 0) {
                body.usageTracked = trackingResults;
              }
            }
          }
        } catch (error) {
          console.error('Multiple usage tracking error:', error);
        }

        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Add usage warnings to response
   */
  static addUsageWarnings() {
    return async (req, res, next) => {
      const originalJson = res.json;
      
      res.json = async function(body) {
        try {
          const userId = req.user?.id;
          if (userId && body && body.success !== false) {
            const warnings = await usageService.getUsageWarnings(userId);
            
            if (warnings.length > 0) {
              if (typeof body === 'object') {
                body.usageWarnings = warnings;
              }
            }
          }
        } catch (error) {
          console.error('Error adding usage warnings:', error);
        }

        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Middleware for AI Assistant specific usage tracking
   * Tracks both conversations and messages
   */
  static trackAIUsage() {
    return async (req, res, next) => {
      const originalJson = res.json;
      
      res.json = async function(body) {
        try {
          if (body && body.success !== false && res.statusCode < 400) {
            const userId = req.user?.id;
            if (userId) {
              // Extract AI usage metadata from request/response
              const isNewConversation = req.body?.newConversation || false;
              const messageCount = 1; // Each request is typically one message
              const tokensUsed = body.tokensUsed || 0;
              const costUsd = body.costUsd || 0;
              const conversationId = body.conversationId || req.body?.conversationId;
              const featureType = req.body?.featureType || 'general';

              const trackingActions = [];

              // Track new conversation
              if (isNewConversation) {
                trackingActions.push({
                  action: 'aiConversations',
                  quantity: 1,
                  metadata: {
                    conversationId,
                    featureType,
                    tokensUsed,
                    costUsd
                  }
                });
              }

              // Always track messages
              trackingActions.push({
                action: 'aiMessagesTotal',
                quantity: messageCount,
                metadata: {
                  conversationId,
                  featureType,
                  tokensUsed,
                  costUsd
                }
              });

              // Track usage
              for (const { action, quantity, metadata } of trackingActions) {
                try {
                  await usageService.trackUsage(userId, action, quantity, metadata);
                } catch (trackingError) {
                  console.error(`Error tracking AI usage for ${action}:`, trackingError);
                }
              }

              // Add AI usage info to response
              if (body && typeof body === 'object') {
                body.aiUsageTracked = {
                  conversationTracked: isNewConversation,
                  messagesTracked: messageCount,
                  tokensUsed,
                  costUsd
                };
              }
            }
          }
        } catch (error) {
          console.error('AI usage tracking error:', error);
        }

        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Rate limiting based on usage
   * @param {string} action - Action to rate limit
   * @param {number} maxPerHour - Maximum allowed per hour
   */
  static rateLimitByUsage(action, maxPerHour = 10) {
    const userHourlyUsage = new Map();

    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required'
          });
        }

        const now = Date.now();
        const hourKey = `${userId}-${Math.floor(now / (1000 * 60 * 60))}`;
        
        const currentHourUsage = userHourlyUsage.get(hourKey) || 0;
        
        if (currentHourUsage >= maxPerHour) {
          return res.status(429).json({
            success: false,
            error: 'Rate limit exceeded',
            details: {
              action,
              maxPerHour,
              currentUsage: currentHourUsage,
              resetTime: new Date(Math.ceil(now / (1000 * 60 * 60)) * (1000 * 60 * 60))
            }
          });
        }

        // Increment usage
        userHourlyUsage.set(hourKey, currentHourUsage + 1);

        // Clean up old entries periodically
        if (Math.random() < 0.01) { // 1% chance
          const cutoff = Math.floor(now / (1000 * 60 * 60)) - 24; // Keep last 24 hours
          for (const [key] of userHourlyUsage) {
            if (key.includes('-') && parseInt(key.split('-')[1]) < cutoff) {
              userHourlyUsage.delete(key);
            }
          }
        }

        next();
      } catch (error) {
        console.error('Usage-based rate limiting error:', error);
        res.status(500).json({
          success: false,
          error: 'Rate limiting check failed'
        });
      }
    };
  }

  /**
   * Validate usage for specific routes based on request parameters
   */
  static validateUsageFromRequest(actionExtractor, quantityExtractor = () => 1) {
    return async (req, res, next) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required'
          });
        }

        let action, quantity;
        
        try {
          action = actionExtractor(req);
          quantity = quantityExtractor(req);
        } catch (extractorError) {
          return res.status(400).json({
            success: false,
            error: 'Invalid request parameters for usage validation'
          });
        }

        const validation = await usageService.validateUsage(userId, action, quantity);

        if (!validation.valid) {
          return res.status(403).json({
            success: false,
            error: 'Usage limit exceeded',
            details: {
              action,
              reason: validation.reason,
              current: validation.current,
              limit: validation.limit,
              upgradeRequired: validation.upgradeRequired,
              recommendedPlan: validation.recommendedPlan
            }
          });
        }

        req.validatedUsage = { action, quantity, validation };
        next();
      } catch (error) {
        console.error('Request-based usage validation error:', error);
        res.status(500).json({
          success: false,
          error: 'Usage validation failed'
        });
      }
    };
  }

  /**
   * Middleware to inject current usage stats into response
   */
  static injectUsageStats() {
    return async (req, res, next) => {
      const originalJson = res.json;
      
      res.json = async function(body) {
        try {
          const userId = req.user?.id;
          if (userId && body && body.success !== false) {
            const usageStats = await usageService.getUserUsageStats(userId);
            
            if (body && typeof body === 'object') {
              body.currentUsage = usageStats;
            }
          }
        } catch (error) {
          console.error('Error injecting usage stats:', error);
        }

        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Log usage activity for monitoring
   */
  static logUsageActivity(action) {
    return (req, res, next) => {
      const originalJson = res.json;
      
      res.json = function(body) {
        if (body && body.success !== false && res.statusCode < 400) {
          const userId = req.user?.id;
          if (userId) {
            console.log(`Usage Activity: ${action} - User: ${userId} - Method: ${req.method} ${req.originalUrl}`);
          }
        }
        
        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Prevent usage tracking on failed requests
   */
  static skipTrackingOnError() {
    return (req, res, next) => {
      const originalJson = res.json;
      
      res.json = function(body) {
        // Mark response for usage tracking middleware
        if (body && (body.success === false || res.statusCode >= 400)) {
          res.skipUsageTracking = true;
        }
        
        return originalJson.call(this, body);
      };

      next();
    };
  }

  /**
   * Conditional usage tracking based on response
   */
  static conditionalTrack(action, condition = null) {
    return async (req, res, next) => {
      const originalJson = res.json;
      
      res.json = async function(body) {
        try {
          if (!res.skipUsageTracking && body && body.success !== false && res.statusCode < 400) {
            const userId = req.user?.id;
            if (userId) {
              // Check condition if provided
              let shouldTrack = true;
              if (condition && typeof condition === 'function') {
                shouldTrack = condition(req, res, body);
              }

              if (shouldTrack) {
                try {
                  await usageService.trackUsage(userId, action, 1);
                } catch (trackingError) {
                  console.error(`Error in conditional tracking for ${action}:`, trackingError);
                }
              }
            }
          }
        } catch (error) {
          console.error('Conditional usage tracking error:', error);
        }

        return originalJson.call(this, body);
      };

      next();
    };
  }
}

module.exports = UsageMiddleware;

================
File: backend/middleware/validation.middleware.js
================
// backend/middleware/validation.middleware.js
const { validationResult, check } = require('express-validator');

// Middleware to handle validation errors
exports.handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      errors: errors.array()
    });
  }
  next();
};

// Validation rules for registration
exports.validateRegistration = [
  check('firstName')
    .trim()
    .notEmpty()
    .withMessage('First name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters'),
  
  check('lastName')
    .trim()
    .notEmpty()
    .withMessage('Last name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters'),
  
  check('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

// Validation rules for login
exports.validateLogin = [
  check('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
];

// Validation rules for password reset
exports.validatePasswordReset = [
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

// Validation rules for update details
exports.validateUpdateDetails = [
  check('firstName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters'),
  
  check('lastName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters'),
  
  check('phoneNumber')
    .optional()
    .trim()
    .isMobilePhone()
    .withMessage('Please provide a valid phone number'),
  
  check('location.city')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('City must be between 2 and 100 characters'),
  
  check('location.state')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('State must be between 2 and 100 characters'),
  
  check('location.country')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Country must be between 2 and 100 characters')
];

// Validation rules for update password
exports.validateUpdatePassword = [
  check('currentPassword')
    .trim()
    .notEmpty()
    .withMessage('Current password is required'),
  
  check('newPassword')
    .trim()
    .notEmpty()
    .withMessage('New password is required')
    .isLength({ min: 8 })
    .withMessage('New password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

================
File: backend/models/mongodb/aiAgent.model.js
================
// backend/models/mongodb/aiAgent.model.js
const mongoose = require('mongoose');

const aiAgentSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true
  },
  description: String,
  type: {
    type: String,
    enum: ['ResumeAnalysis', 'JobMatching', 'ContentGeneration', 'JobDiscovery'],
    required: true
  },
  config: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  },
  api: {
    endpoint: String,
    apiKey: String,
    modelName: String,
    parameters: mongoose.Schema.Types.Mixed
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastRun: Date,
  performance: {
    averageResponseTime: Number,
    successRate: Number,
    errorRate: Number
  },
  version: String
}, {
  timestamps: true
});

// Add method to invoke the agent
aiAgentSchema.methods.invoke = async function(input, context = {}) {
  // This is a placeholder for actual API call logic
  try {
    // Implement agent-specific processing logic here based on agent type
    switch(this.type) {
      case 'ResumeAnalysis':
        return await this.analyzeResume(input, context);
      case 'JobMatching':
        return await this.matchJob(input, context);
      case 'ContentGeneration':
        return await this.generateContent(input, context);
      case 'JobDiscovery':
        return await this.discoverJobs(input, context);
      default:
        throw new Error(`Unknown agent type: ${this.type}`);
    }
  } catch (error) {
    console.error(`Error invoking AI agent ${this.name}:`, error);
    throw error;
  }
};

// Placeholder for actual implementation
aiAgentSchema.methods.analyzeResume = async function(resume, context) {
  // Implementation will involve calling an NLP service or LLM API
  return { message: 'Resume analysis not yet implemented' };
};

aiAgentSchema.methods.matchJob = async function(data, context) {
  // Implementation will compare resume and job description
  return { message: 'Job matching not yet implemented' };
};

aiAgentSchema.methods.generateContent = async function(data, context) {
  // Implementation will generate content based on input
  return { message: 'Content generation not yet implemented' };
};

aiAgentSchema.methods.discoverJobs = async function(data, context) {
  // Implementation will search for relevant jobs
  return { message: 'Job discovery not yet implemented' };
};

const AIAgent = mongoose.model('AIAgent', aiAgentSchema);

module.exports = AIAgent;

================
File: backend/models/mongodb/aiJobSearch.model.js
================
// models/mongodb/aiJobSearch.model.js - UPDATED WITH ADZUNA API SUPPORT
const mongoose = require('mongoose');

const aiJobSearchSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    required: true
  },
  resumeName: {
    type: String,
    required: true
  },
  searchCriteria: {
    jobTitle: String,
    skills: [String],
    location: String,
    experienceLevel: String,
    salaryRange: {
      min: Number,
      max: Number,
      currency: String
    },
    jobTypes: [String], // ['FULL_TIME', 'CONTRACT', etc.]
    industries: [String],
    companySizes: [String],
    workEnvironment: String // 'remote', 'hybrid', 'onsite', 'any'
  },
  status: {
    type: String,
    enum: ['running', 'paused', 'completed', 'failed', 'cancelled'],
    default: 'running'
  },
  searchType: {
    type: String,
    enum: ['basic', 'enhanced', 'premium', 'intelligent', 'adzuna_api'],
    default: 'adzuna_api'
  },
  dailyLimit: {
    type: Number,
    default: 10
  },
  jobsFoundToday: {
    type: Number,
    default: 0
  },
  totalJobsFound: {
    type: Number,
    default: 0
  },
  lastSearchDate: {
    type: Date,
    default: null
  },
  
  // Enhanced tracking
  jobsFound: [{
    jobId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    },
    title: String,
    company: String,
    foundAt: Date,
    contentQuality: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    extractionSuccess: Boolean,
    matchScore: Number,
    sourceUrl: String,
    sourcePlatform: String,
    extractionMethod: String,
    premiumAnalysis: {
      type: Boolean,
      default: false
    },
    // NEW: Adzuna API specific fields
    apiSource: {
      type: String,
      enum: ['adzuna_aggregator', 'claude_web_search', 'manual'],
      default: 'adzuna_aggregator'
    },
    adzunaId: String,
    jobBoardOrigin: String, // Indeed, LinkedIn, Monster, etc.
    directCompanyPosting: Boolean,
    salaryPredicted: Boolean
  }],
  
  // Search performance metrics
  searchMetrics: {
    totalSearchesPerformed: {
      type: Number,
      default: 0
    },
    totalJobsDiscovered: {
      type: Number,
      default: 0
    },
    successfulExtractions: {
      type: Number,
      default: 0
    },
    failedExtractions: {
      type: Number,
      default: 0
    },
    premiumAnalysesCompleted: {
      type: Number,
      default: 0
    },
    avgContentQuality: String,
    avgProcessingTime: Number, // in seconds
    lastPerformanceUpdate: Date,
    // Phase specific metrics
    phase1Duration: Number, // Career analysis time
    phase2Duration: Number, // Job discovery time (Adzuna API)
    phase3Duration: Number, // Premium analysis time
    totalSearchDuration: Number,
    // NEW: Adzuna API specific metrics
    adzunaApiCalls: {
      type: Number,
      default: 0
    },
    adzunaSuccessRate: Number, // Percentage of successful API calls
    adzunaJobBoardsCovered: [String], // Which job boards returned results
    costSavings: Number // Cost savings vs Claude web search
  },
  
  // Search history
  searchHistory: [{
    searchDate: Date,
    searchApproach: {
      type: String,
      enum: [
        '5-phase-legacy', 
        '3-phase-intelligent', 
        '3-phase-intelligent-real-boards',
        '3-phase-intelligent-claude-web-search',
        '3-phase-intelligent-adzuna-api'
      ],
      default: '3-phase-intelligent-adzuna-api'
    },
    phase1Results: { // Career Analysis
      jobTitles: [String],
      keywords: [String],
      experienceLevel: String,
      duration: Number
    },
    phase2Results: { // Adzuna API Job Discovery
      apiCallsMade: Number,
      jobsReturned: Number,
      successfulApiCalls: Number,
      jobBoardsCovered: [String], // Indeed, LinkedIn, Monster, etc.
      averageContentLength: Number,
      duration: Number,
      costSavings: String // vs Claude web search
    },
    phase3Results: { // Premium Analysis
      jobsAnalyzed: Number,
      successfulAnalyses: Number,
      averageSkillsFound: Number,
      duration: Number
    },
    totalDuration: Number,
    costBreakdown: {
      phase1Cost: String, // "$0.05"
      phase2Cost: String, // "$0.00 (Free API)"
      phase3Cost: String, // "$0.01-0.02"
      totalCost: String,  // "$0.06-0.07"
      savings: String     // "87% cost reduction vs Claude"
    },
    errors: [String],
    qualityMetrics: {
      averageMatchScore: Number,
      contentQualityDistribution: {
        high: Number,
        medium: Number,
        low: Number
      },
      jobBoardDistribution: {
        indeed: Number,
        linkedin: Number,
        monster: Number,
        careerbuilder: Number,
        others: Number
      }
    }
  }],
  
  // Error tracking
  errors: [{
    timestamp: Date,
    errorType: {
      type: String,
      enum: [
        'career_analysis_failed', 
        'adzuna_api_failed',
        'adzuna_auth_failed',
        'adzuna_rate_limited',
        'job_discovery_failed', 
        'premium_analysis_failed',
        'content_extraction_failed',
        'api_error', 
        'validation_error', 
        'rate_limit',
        'claude_error',
        'openai_error'
      ]
    },
    errorMessage: String,
    phase: {
      type: String,
      enum: ['career_analysis', 'adzuna_api_discovery', 'web_search_discovery', 'content_extraction', 'premium_analysis', 'job_saving', 'general']
    },
    context: String,
    resolved: {
      type: Boolean,
      default: false
    }
  }],
  
  // AI Model usage tracking
  aiUsage: {
    // Phase 1: Career Analysis
    openaiCareerAnalysis: {
      type: Number,
      default: 0
    },
    // Phase 2: Adzuna API (No AI cost!)
    adzunaApiCalls: {
      type: Number,
      default: 0
    },
    adzunaApiCost: {
      type: Number,
      default: 0 // FREE API
    },
    // Phase 3: Premium Analysis
    openaiPremiumAnalyses: {
      type: Number,
      default: 0
    },
    openaiBatchAnalyses: {
      type: Number,
      default: 0
    },
    totalTokensUsed: {
      type: Number,
      default: 0
    },
    estimatedCost: {
      type: Number,
      default: 0
    },
    // Cost breakdown by phase
    costBreakdown: {
      phase1Cost: Number, // Career analysis
      phase2Cost: Number, // Adzuna API (always $0)
      phase3Cost: Number, // Premium analysis
      totalCost: Number,
      costSavings: Number // vs Claude web search
    }
  },
  
  // Search optimization
  optimization: {
    successRate: Number, // percentage of successful job discoveries
    avgRelevanceScore: Number,
    adzunaApiEfficiency: Number, // Jobs found per API call
    premiumAnalysisAccuracy: Number, // Successful analyses percentage
    bestSearchTimes: [String], // times of day with best results
    recommendedAdjustments: [String],
    // Quality metrics
    contentQualityTrend: String, // 'improving', 'stable', 'declining'
    matchScoreTrend: String,
    userSatisfactionIndicators: {
      viewedJobsRate: Number,
      appliedJobsRate: Number,
      favoriteJobsRate: Number
    },
    // NEW: Adzuna API specific optimization
    optimalJobTitles: [String], // Job titles that work best with Adzuna
    bestPerformingJobBoards: [String], // Which job boards yield best results
    locationOptimization: [String] // Best locations for API searches
  },
  
  // User preferences learned over time
  learnedPreferences: {
    preferredCompanies: [String],
    avoidedCompanies: [String],
    preferredLocations: [String],
    successfulKeywords: [String],
    // Learned from Adzuna API discovery
    effectiveJobTitles: [String],
    preferredWorkArrangements: [String],
    salaryExpectationLearned: {
      min: Number,
      max: Number,
      currency: String
    },
    interactionPatterns: {
      viewedJobs: Number,
      appliedJobs: Number,
      favoriteJobs: Number,
      avgTimeSpentPerJob: Number,
      preferredJobTypes: [String]
    },
    // NEW: Adzuna API preferences
    preferredJobBoards: [String], // Indeed, LinkedIn, Monster, etc.
    bestPerformingSearchTerms: [String],
    optimalSalaryRanges: [{
      min: Number,
      max: Number,
      resultCount: Number
    }]
  },
  
  // Schedule and automation
  schedule: {
    isScheduled: {
      type: Boolean,
      default: false
    },
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'bi-weekly', 'monthly'],
      default: 'daily'
    },
    preferredTime: String, // '09:00' format
    timezone: String,
    nextScheduledRun: Date,
    pauseUntil: Date,
    intelligentScheduling: {
      type: Boolean,
      default: false
    },
    optimalSearchDays: [String], // Days with best results
    lastSuccessfulSearchTime: Date,
    // NEW: API usage optimization
    adzunaRateLimitTracking: {
      callsThisMonth: Number,
      resetDate: Date,
      remainingCalls: Number
    }
  },
  
  // Notification settings
  notifications: {
    emailOnNewJobs: {
      type: Boolean,
      default: true
    },
    emailOnHighMatch: {
      type: Boolean,
      default: true
    },
    emailOnErrors: {
      type: Boolean,
      default: true
    },
    matchScoreThreshold: {
      type: Number,
      default: 75
    },
    maxEmailsPerDay: {
      type: Number,
      default: 5
    },
    // Intelligent notifications
    smartNotifications: {
      type: Boolean,
      default: true
    },
    notifyOnQualityJobs: {
      type: Boolean,
      default: true
    },
    premiumAnalysisAlerts: {
      type: Boolean,
      default: true
    },
    // NEW: Adzuna API specific notifications
    adzunaApiFailures: {
      type: Boolean,
      default: true
    },
    rateLimitWarnings: {
      type: Boolean,
      default: true
    }
  },
  
  // AI Reasoning Logs for search process tracking
  reasoningLogs: [{
    phase: {
      type: String,
      enum: [
        'initialization', 
        'career_analysis', 
        'adzuna_api_discovery',    // NEW: Adzuna API specific phase
        'intelligent_discovery',   // Legacy support
        'web_search_discovery',    // Legacy support
        'content_extraction',      // Legacy support
        'premium_analysis',      
        'job_saving', 
        'completion', 
        'error'
      ],
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    message: {
      type: String,
      required: true
    },
    details: {
      type: mongoose.Schema.Types.Mixed,
      default: {}
    },
    success: {
      type: Boolean,
      default: true
    },
    duration: {
      type: Number, // Duration in milliseconds
      default: 0
    },
    metadata: {
      // Phase 1: Career Analysis
      targetJobTitles: [String],
      targetKeywords: [String],
      experienceLevel: String,
      
      // Phase 2: Adzuna API Discovery
      apiProvider: String, // 'adzuna_aggregator'
      apiCallsMade: Number,
      jobsReturned: Number,
      jobBoardsCovered: [String],
      averageContentLength: Number,
      
      // Phase 3: Premium Analysis
      jobsAnalyzed: Number,
      successfulAnalyses: Number,
      averageSkillsFound: Number,
      
      // General metadata
      aiModel: String,
      errorDetails: String,
      companyName: String,
      jobTitle: String,
      contentLength: Number,
      extractionMethod: String,
      batchSize: Number,
      qualityLevel: String,
      
      // Cost tracking per log entry
      estimatedCost: String,
      tokenUsage: Number,
      costSavings: String, // vs Claude web search
      
      // Quality indicators
      matchScore: Number,
      contentQuality: String,
      analysisAccuracy: String,
      
      // NEW: Adzuna API specific metadata
      adzunaJobId: String,
      originalJobBoard: String, // Indeed, LinkedIn, etc.
      salaryPredicted: Boolean,
      contractType: String,
      directCompanyPosting: Boolean,
      apiHealth: String,
      rateLimitStatus: String
    }
  }],
  
  lastUpdateMessage: String,
  lastUpdated: {
    type: Date,
    default: Date.now
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  
  // UPDATED: Search approach metadata with Adzuna support
  searchApproach: {
    type: String,
    enum: [
      '5-phase-legacy', 
      '3-phase-intelligent', 
      '3-phase-intelligent-real-boards',
      '3-phase-intelligent-claude-web-search',
      '3-phase-intelligent-adzuna-api'
    ],
    default: '3-phase-intelligent-adzuna-api'
  },
  approachVersion: {
    type: String,
    default: '4.0-adzuna-api-integration'
  },
  qualityLevel: {
    type: String,
    enum: ['standard', 'premium', 'intelligent', 'claude-web-search', 'adzuna-api-enhanced'],
    default: 'adzuna-api-enhanced'
  },
  
  // NEW: Adzuna API specific configuration and tracking
  adzunaConfig: {
    apiCallsUsed: {
      type: Number,
      default: 0
    },
    monthlyLimit: {
      type: Number,
      default: 1000 // Free tier limit
    },
    lastApiCall: Date,
    apiHealth: {
      type: String,
      enum: ['healthy', 'degraded', 'down', 'not_configured'],
      default: 'not_configured'
    },
    preferredJobBoards: [String], // User's preferred job boards
    searchOptimizations: {
      bestPerformingTitles: [String],
      optimalLocationTerms: [String],
      effectiveKeywords: [String]
    },
    costComparison: {
      previousCostPerSearch: Number, // Claude web search cost
      currentCostPerSearch: Number,  // Adzuna API cost
      savingsPercent: Number
    }
  }
});

// Indexes for better performance
aiJobSearchSchema.index({ userId: 1, status: 1 });
aiJobSearchSchema.index({ userId: 1, createdAt: -1 });
aiJobSearchSchema.index({ status: 1, 'schedule.nextScheduledRun': 1 });
aiJobSearchSchema.index({ 'jobsFound.jobId': 1 });
aiJobSearchSchema.index({ lastSearchDate: 1 });
aiJobSearchSchema.index({ 'reasoningLogs.timestamp': -1 });
aiJobSearchSchema.index({ 'reasoningLogs.phase': 1 });
// NEW: Indexes for Adzuna API approach
aiJobSearchSchema.index({ searchApproach: 1 });
aiJobSearchSchema.index({ qualityLevel: 1 });
aiJobSearchSchema.index({ 'adzunaConfig.apiHealth': 1 });
aiJobSearchSchema.index({ 'jobsFound.apiSource': 1 });
aiJobSearchSchema.index({ 'jobsFound.jobBoardOrigin': 1 });

// Middleware
aiJobSearchSchema.pre('save', function(next) {
  this.lastUpdated = Date.now();
  
  // Update performance metrics
  if (this.isModified('jobsFound')) {
    this.updatePerformanceMetrics();
  }
  
  // Update Adzuna API usage tracking
  if (this.isModified('adzunaConfig.apiCallsUsed')) {
    this.updateAdzunaUsageMetrics();
  }
  
  next();
});

// Instance methods
aiJobSearchSchema.methods.updatePerformanceMetrics = function() {
  const jobs = this.jobsFound;
  if (jobs.length === 0) return;
  
  // Calculate success rate
  const successfulExtractions = jobs.filter(job => job.extractionSuccess).length;
  this.searchMetrics.successfulExtractions = successfulExtractions;
  this.searchMetrics.failedExtractions = jobs.length - successfulExtractions;
  
  // Calculate premium analyses
  const premiumAnalyses = jobs.filter(job => job.premiumAnalysis).length;
  this.searchMetrics.premiumAnalysesCompleted = premiumAnalyses;
  
  // Calculate Adzuna API specific metrics
  const adzunaJobs = jobs.filter(job => job.apiSource === 'adzuna_aggregator');
  if (adzunaJobs.length > 0) {
    this.searchMetrics.adzunaJobBoardsCovered = [...new Set(adzunaJobs.map(job => job.jobBoardOrigin))];
    this.searchMetrics.adzunaSuccessRate = (adzunaJobs.length / this.searchMetrics.adzunaApiCalls) * 100;
  }
  
  // Calculate average content quality
  const qualityScores = jobs.map(job => {
    switch(job.contentQuality) {
      case 'high': return 3;
      case 'medium': return 2;
      case 'low': return 1;
      default: return 1;
    }
  });
  
  const avgQuality = qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length;
  if (avgQuality >= 2.5) this.searchMetrics.avgContentQuality = 'high';
  else if (avgQuality >= 1.5) this.searchMetrics.avgContentQuality = 'medium';
  else this.searchMetrics.avgContentQuality = 'low';
  
  // Update optimization data
  this.optimization.successRate = (successfulExtractions / jobs.length) * 100;
  this.optimization.premiumAnalysisAccuracy = premiumAnalyses > 0 ? (premiumAnalyses / jobs.length) * 100 : 0;
  this.optimization.adzunaApiEfficiency = jobs.length / Math.max(this.searchMetrics.adzunaApiCalls, 1);
  
  this.searchMetrics.lastPerformanceUpdate = new Date();
};

// NEW: Update Adzuna API usage metrics
aiJobSearchSchema.methods.updateAdzunaUsageMetrics = function() {
  const currentMonth = new Date().getMonth();
  const currentYear = new Date().getFullYear();
  
  // Reset monthly counter if it's a new month
  if (!this.adzunaConfig.lastApiCall || 
      this.adzunaConfig.lastApiCall.getMonth() !== currentMonth ||
      this.adzunaConfig.lastApiCall.getFullYear() !== currentYear) {
    this.adzunaConfig.apiCallsUsed = 0;
  }
  
  // Calculate remaining calls for the month
  const remainingCalls = this.adzunaConfig.monthlyLimit - this.adzunaConfig.apiCallsUsed;
  
  // Update cost comparison
  const previousCost = 0.43; // Average Claude web search cost
  const currentCost = 0.06;  // Adzuna API + GPT-4o cost
  this.adzunaConfig.costComparison = {
    previousCostPerSearch: previousCost,
    currentCostPerSearch: currentCost,
    savingsPercent: Math.round(((previousCost - currentCost) / previousCost) * 100)
  };
  
  this.adzunaConfig.lastApiCall = new Date();
};

aiJobSearchSchema.methods.addJobFound = function(jobData) {
  this.jobsFound.push({
    jobId: jobData.jobId,
    title: jobData.title,
    company: jobData.company,
    foundAt: new Date(),
    contentQuality: jobData.contentQuality || 'medium',
    extractionSuccess: jobData.extractionSuccess !== false,
    matchScore: jobData.matchScore,
    sourceUrl: jobData.sourceUrl,
    sourcePlatform: jobData.sourcePlatform,
    extractionMethod: jobData.extractionMethod || 'adzuna_api_enhanced',
    premiumAnalysis: jobData.premiumAnalysis || true,
    // NEW: Adzuna API fields
    apiSource: jobData.apiSource || 'adzuna_aggregator',
    adzunaId: jobData.adzunaId,
    jobBoardOrigin: jobData.jobBoardOrigin || jobData.sourcePlatform,
    directCompanyPosting: jobData.directCompanyPosting || false,
    salaryPredicted: jobData.salaryPredicted || false
  });
  
  this.totalJobsFound += 1;
  this.jobsFoundToday += 1;
  
  return this.save();
};

aiJobSearchSchema.methods.addError = function(errorType, message, phase, context) {
  this.errors.push({
    timestamp: new Date(),
    errorType,
    errorMessage: message,
    phase: phase || 'general',
    context,
    resolved: false
  });
  
  return this.save();
};

// UPDATED: Track AI usage for Adzuna API approach
aiJobSearchSchema.methods.updateAiUsage = function(phase, type, tokens = 0, cost = 0) {
  switch(phase) {
    case 'career_analysis':
      if (type === 'openai') this.aiUsage.openaiCareerAnalysis += 1;
      if (!this.aiUsage.costBreakdown.phase1Cost) this.aiUsage.costBreakdown.phase1Cost = 0;
      this.aiUsage.costBreakdown.phase1Cost += cost;
      break;
      
    case 'adzuna_api_discovery':
      if (type === 'adzuna_api') {
        this.aiUsage.adzunaApiCalls += 1;
        this.searchMetrics.adzunaApiCalls += 1;
        this.adzunaConfig.apiCallsUsed += 1;
      }
      // Adzuna API is free, so no cost added
      this.aiUsage.costBreakdown.phase2Cost = 0;
      break;
      
    case 'web_search_discovery':
    case 'intelligent_discovery':
      // Legacy support for older searches
      if (!this.aiUsage.costBreakdown.phase2Cost) this.aiUsage.costBreakdown.phase2Cost = 0;
      this.aiUsage.costBreakdown.phase2Cost += cost;
      break;
      
    case 'premium_analysis':
      if (type === 'openai_analysis') this.aiUsage.openaiPremiumAnalyses += 1;
      if (type === 'openai_batch') this.aiUsage.openaiBatchAnalyses += 1;
      if (!this.aiUsage.costBreakdown.phase3Cost) this.aiUsage.costBreakdown.phase3Cost = 0;
      this.aiUsage.costBreakdown.phase3Cost += cost;
      break;
  }
  
  this.aiUsage.totalTokensUsed += tokens;
  this.aiUsage.estimatedCost += cost;
  this.aiUsage.costBreakdown.totalCost = 
    (this.aiUsage.costBreakdown.phase1Cost || 0) +
    (this.aiUsage.costBreakdown.phase2Cost || 0) +
    (this.aiUsage.costBreakdown.phase3Cost || 0);
  
  // Calculate cost savings vs Claude web search
  const claudeCost = 0.43; // Estimated Claude web search cost
  this.aiUsage.costBreakdown.costSavings = claudeCost - this.aiUsage.costBreakdown.totalCost;
  
  return this.save();
};

aiJobSearchSchema.methods.addReasoningLog = function(phase, message, details = {}, success = true, duration = 0) {
  // Helper function to sanitize numeric values
  const sanitizeNumeric = (value) => {
    if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
      return 0;
    }
    return value;
  };
  
  // Sanitize all numeric fields in details
  const sanitizedDetails = { ...details };
  Object.keys(sanitizedDetails).forEach(key => {
    sanitizedDetails[key] = sanitizeNumeric(sanitizedDetails[key]);
  });
  
  const reasoningLog = {
    phase,
    message,
    details: sanitizedDetails,
    success,
    duration: sanitizeNumeric(duration),
    timestamp: new Date(),
    metadata: {
      // USER-FRIENDLY METADATA (no technical details)
      
      // Phase-specific user-friendly info
      targetJobTitles: details.targetJobTitles,
      experienceLevel: details.experienceLevel,
      
      // Job discovery user-friendly info
      totalJobs: sanitizeNumeric(details.totalJobs || details.totalJobsFound),
      jobsReturned: sanitizeNumeric(details.jobsReturned),
      jobBoards: details.jobBoards || details.jobBoardsCovered,
      searchAttempts: sanitizeNumeric(details.searchAttempts),
      
      // Analysis user-friendly info
      jobsAnalyzed: sanitizeNumeric(details.jobsAnalyzed),
      successfulAnalyses: sanitizeNumeric(details.successfulAnalyses),
      averageSkillsFound: sanitizeNumeric(details.averageSkillsFound),
      
      // Job details (user-friendly)
      companyName: details.company || details.companyName,
      jobTitle: details.jobTitle,
      skillsFound: sanitizeNumeric(details.skillsFound),
      analysisQuality: details.analysisQuality || details.qualityLevel,
      
      // Progress and completion info
      batchNumber: sanitizeNumeric(details.batchNumber),
      jobsInBatch: sanitizeNumeric(details.jobsInBatch),
      savedJobs: sanitizeNumeric(details.savedJobs),
      duplicatesSkipped: sanitizeNumeric(details.duplicatesSkipped),
      
      // User-friendly timing (convert milliseconds to seconds)
      searchTime: details.searchTime || (duration > 0 ? `${Math.round(duration / 1000)} seconds` : undefined),
      
      // Helpful context for users
      suggestion: details.suggestion,
      nextAction: details.nextAction,
      reason: details.reason,
      
      // Sample data (helpful for users)
      sampleCompanies: details.sampleCompanies,
      topCompanies: details.topCompanies,
      jobTitles: details.jobTitles,
      
      // Remove all technical details that users don't need to see:
      // - No API provider info
      // - No model names (GPT-4o, Claude, etc.)
      // - No cost estimates
      // - No token usage
      // - No algorithm versions
      // - No error stack traces
      // - No technical extraction methods
      
      // Only include what helps users understand what's happening
      phase: details.phase,
      searchStrategy: details.searchStrategy,
      searchApproach: details.searchApproach,
      jobBoardsAvailable: details.jobBoardsAvailable
    }
  };
  
  this.reasoningLogs.push(reasoningLog);
  
  // Keep only the last 100 logs to prevent document from growing too large
  if (this.reasoningLogs.length > 100) {
    this.reasoningLogs = this.reasoningLogs.slice(-100);
  }
  
  return this.save();
};

// Also update the helper method to return user-friendly descriptions
aiJobSearchSchema.methods.getDefaultModelForPhase = function(phase) {
  // Return user-friendly descriptions instead of technical model names
  switch(phase) {
    case 'career_analysis': return 'Career Analyzer';
    case 'adzuna_api_discovery': return 'Job Board Search';
    case 'web_search_discovery':
    case 'intelligent_discovery':
    case 'content_extraction': return 'Job Discovery';
    case 'premium_analysis': return 'Job Analyzer';
    default: return 'Processing';
  }
};

// UPDATED: Helper method to get default model for each phase
aiJobSearchSchema.methods.getDefaultModelForPhase = function(phase) {
  switch(phase) {
    case 'career_analysis': return 'gpt-4-turbo';
    case 'adzuna_api_discovery': return 'adzuna-api';
    case 'web_search_discovery':
    case 'intelligent_discovery':
    case 'content_extraction': return 'claude-3.5-sonnet';
    case 'premium_analysis': return 'gpt-4o';
    default: return 'unknown';
  }
};

// Method to get recent reasoning logs (for UI display)
aiJobSearchSchema.methods.getRecentReasoningLogs = function(limit = 10) {
  return this.reasoningLogs
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, limit);
};

// Method to get reasoning logs by phase
aiJobSearchSchema.methods.getReasoningLogsByPhase = function(phase) {
  return this.reasoningLogs
    .filter(log => log.phase === phase)
    .sort((a, b) => b.timestamp - a.timestamp);
};

// UPDATED: Method to get performance summary for Adzuna API approach
aiJobSearchSchema.methods.getAdzunaApiPerformanceSummary = function() {
  return {
    searchApproach: this.searchApproach || '3-phase-intelligent-adzuna-api',
    approachVersion: this.approachVersion || '4.0-adzuna-api-integration',
    qualityLevel: this.qualityLevel || 'adzuna-api-enhanced',
    totalJobsFound: this.totalJobsFound,
    successRate: this.optimization?.successRate || 0,
    adzunaApiEfficiency: this.optimization?.adzunaApiEfficiency || 0,
    premiumAnalysisAccuracy: this.optimization?.premiumAnalysisAccuracy || 0,
    avgContentQuality: this.searchMetrics?.avgContentQuality || 'unknown',
    costBreakdown: this.aiUsage?.costBreakdown || {},
    costSavings: this.adzunaConfig?.costComparison?.savingsPercent || 0,
    lastSuccessfulSearch: this.lastSearchDate,
    apiHealth: this.adzunaConfig?.apiHealth || 'not_configured',
    monthlyApiUsage: {
      used: this.adzunaConfig?.apiCallsUsed || 0,
      limit: this.adzunaConfig?.monthlyLimit || 1000,
      remaining: (this.adzunaConfig?.monthlyLimit || 1000) - (this.adzunaConfig?.apiCallsUsed || 0)
    },
    jobBoardsCovered: this.searchMetrics?.adzunaJobBoardsCovered || [],
    isHighPerformance: (this.optimization?.successRate || 0) > 80 && 
                       (this.optimization?.adzunaApiEfficiency || 0) > 0.5
  };
};

// Schedule next run with Adzuna API considerations
aiJobSearchSchema.methods.scheduleNextRun = function(frequency = 'daily', preferredTime = '09:00') {
  const now = new Date();
  const nextRun = new Date();
  
  // Check if we have API calls remaining for the month
  const remainingCalls = (this.adzunaConfig?.monthlyLimit || 1000) - (this.adzunaConfig?.apiCallsUsed || 0);
  
  if (remainingCalls <= 0) {
    // If no API calls remaining, schedule for next month
    nextRun.setMonth(now.getMonth() + 1);
    nextRun.setDate(1);
    this.addReasoningLog('initialization', 'Scheduled for next month - Adzuna API monthly limit reached', {
      remainingCalls: 0,
      nextResetDate: nextRun
    });
  } else {
    // Normal scheduling
    switch(frequency) {
      case 'daily':
        nextRun.setDate(now.getDate() + 1);
        break;
      case 'weekly':
        nextRun.setDate(now.getDate() + 7);
        break;
      case 'bi-weekly':
        nextRun.setDate(now.getDate() + 14);
        break;
      case 'monthly':
        nextRun.setMonth(now.getMonth() + 1);
        break;
    }
  }
  
  const [hours, minutes] = preferredTime.split(':');
  nextRun.setHours(parseInt(hours), parseInt(minutes), 0, 0);
  
  this.schedule.nextScheduledRun = nextRun;
  this.schedule.frequency = frequency;
  this.schedule.preferredTime = preferredTime;
  this.schedule.isScheduled = true;
  
  // Update rate limit tracking
  this.schedule.adzunaRateLimitTracking = {
    callsThisMonth: this.adzunaConfig?.apiCallsUsed || 0,
    resetDate: new Date(now.getFullYear(), now.getMonth() + 1, 1),
    remainingCalls: remainingCalls
  };
  
  return this.save();
};

aiJobSearchSchema.methods.pause = function(pauseUntil) {
  this.status = 'paused';
  if (pauseUntil) {
    this.schedule.pauseUntil = pauseUntil;
  }
  this.lastUpdateMessage = 'Search paused by user';
  return this.save();
};

aiJobSearchSchema.methods.resume = function() {
  this.status = 'running';
  this.schedule.pauseUntil = null;
  this.lastUpdateMessage = 'Search resumed by user - using Adzuna API approach';
  return this.save();
};

// Static methods
aiJobSearchSchema.statics.findActiveAdzunaSearches = function() {
  return this.find({ 
    status: 'running',
    searchApproach: '3-phase-intelligent-adzuna-api',
    'adzunaConfig.apiCallsUsed': { $lt: 1000 }, // Has API calls remaining
    $or: [
      { 'schedule.nextScheduledRun': { $lte: new Date() } },
      { 'schedule.isScheduled': false }
    ]
  });
};

aiJobSearchSchema.statics.findUserSearches = function(userId) {
  return this.find({ userId }).sort({ createdAt: -1 });
};

// Static method to get AI searches with reasoning logs for Adzuna API approach
aiJobSearchSchema.statics.getWithReasoningLogs = function(userId, includeDeleted = false) {
  const query = { userId };
  
  if (!includeDeleted) {
    query.status = { $ne: 'cancelled' };
  }
  
  return this.find(query)
    .populate('resumeId', 'name')
    .sort({ createdAt: -1 })
    .select('+reasoningLogs');
};

// UPDATED: Get search statistics for Adzuna API approach
aiJobSearchSchema.statics.getSearchStatistics = function(userId) {
  return this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId) } },
    {
      $group: {
        _id: null,
        totalSearches: { $sum: 1 },
        adzunaApiSearches: { $sum: { $cond: [{ $eq: ['$searchApproach', '3-phase-intelligent-adzuna-api'] }, 1, 0] } },
        claudeWebSearches: { $sum: { $cond: [{ $eq: ['$searchApproach', '3-phase-intelligent-claude-web-search'] }, 1, 0] } },
        activeSearches: { $sum: { $cond: [{ $eq: ['$status', 'running'] }, 1, 0] } },
        totalJobsFound: { $sum: '$totalJobsFound' },
        avgJobsPerSearch: { $avg: '$totalJobsFound' },
        totalPremiumAnalyses: { $sum: '$searchMetrics.premiumAnalysesCompleted' },
        totalAiUsage: { $sum: '$aiUsage.totalTokensUsed' },
        estimatedTotalCost: { $sum: '$aiUsage.estimatedCost' },
        totalCostSavings: { $sum: '$aiUsage.costBreakdown.costSavings' },
        avgSuccessRate: { $avg: '$optimization.successRate' },
        avgAdzunaApiEfficiency: { $avg: '$optimization.adzunaApiEfficiency' },
        totalAdzunaApiCalls: { $sum: '$searchMetrics.adzunaApiCalls' },
        avgAdzunaSuccessRate: { $avg: '$searchMetrics.adzunaSuccessRate' }
      }
    }
  ]);
};

aiJobSearchSchema.statics.findScheduledSearches = function() {
  return this.find({
    'schedule.isScheduled': true,
    'schedule.nextScheduledRun': { $lte: new Date() },
    status: 'running',
    'adzunaConfig.apiCallsUsed': { $lt: 1000 }, // Has API calls remaining
    $or: [
      { 'schedule.pauseUntil': { $exists: false } },
      { 'schedule.pauseUntil': null },
      { 'schedule.pauseUntil': { $lte: new Date() } }
    ]
  });
};

// NEW: Find searches that need API limit reset
aiJobSearchSchema.statics.findSearchesNeedingApiReset = function() {
  const firstOfMonth = new Date();
  firstOfMonth.setDate(1);
  firstOfMonth.setHours(0, 0, 0, 0);
  
  return this.find({
    'adzunaConfig.lastApiCall': { $lt: firstOfMonth },
    'adzunaConfig.apiCallsUsed': { $gt: 0 }
  });
};

// NEW: Get Adzuna API usage summary
aiJobSearchSchema.statics.getAdzunaApiUsageSummary = function(userId) {
  return this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId), searchApproach: '3-phase-intelligent-adzuna-api' } },
    {
      $group: {
        _id: null,
        totalApiCalls: { $sum: '$adzunaConfig.apiCallsUsed' },
        totalJobsFound: { $sum: '$totalJobsFound' },
        avgJobsPerApiCall: { $avg: { $divide: ['$totalJobsFound', { $max: ['$adzunaConfig.apiCallsUsed', 1] }] } },
        totalCostSavings: { $sum: '$adzunaConfig.costComparison.savingsPercent' },
        activeSearches: { $sum: { $cond: [{ $eq: ['$status', 'running'] }, 1, 0] } },
        monthlyApiUsage: { $avg: '$adzunaConfig.apiCallsUsed' },
        jobBoardsCovered: { $addToSet: '$searchMetrics.adzunaJobBoardsCovered' }
      }
    }
  ]);
};

// Virtual for search performance with Adzuna API focus
aiJobSearchSchema.virtual('adzunaApiPerformanceSummary').get(function() {
  return {
    searchApproach: this.searchApproach || '3-phase-intelligent-adzuna-api',
    successRate: this.optimization?.successRate || 0,
    adzunaApiEfficiency: this.optimization?.adzunaApiEfficiency || 0,
    premiumAnalysisAccuracy: this.optimization?.premiumAnalysisAccuracy || 0,
    avgContentQuality: this.searchMetrics?.avgContentQuality || 'unknown',
    totalJobs: this.totalJobsFound,
    avgJobsPerApiCall: this.totalJobsFound / Math.max(1, this.searchMetrics?.adzunaApiCalls || 1),
    estimatedCost: this.aiUsage?.estimatedCost || 0,
    costBreakdown: this.aiUsage?.costBreakdown || {},
    costSavingsPercent: this.adzunaConfig?.costComparison?.savingsPercent || 0,
    apiHealthStatus: this.adzunaConfig?.apiHealth || 'not_configured',
    monthlyApiUsage: {
      used: this.adzunaConfig?.apiCallsUsed || 0,
      limit: this.adzunaConfig?.monthlyLimit || 1000,
      remaining: (this.adzunaConfig?.monthlyLimit || 1000) - (this.adzunaConfig?.apiCallsUsed || 0),
      percentUsed: Math.round(((this.adzunaConfig?.apiCallsUsed || 0) / (this.adzunaConfig?.monthlyLimit || 1000)) * 100)
    },
    jobBoardsCovered: this.searchMetrics?.adzunaJobBoardsCovered || [],
    isHighPerformance: (this.optimization?.successRate || 0) > 80 && 
                       (this.optimization?.adzunaApiEfficiency || 0) > 0.5,
    qualityLevel: this.qualityLevel || 'adzuna-api-enhanced'
  };
});

// Virtual for recent reasoning logs (for UI)
aiJobSearchSchema.virtual('recentAdzunaApiLogs').get(function() {
  return this.reasoningLogs
    .filter(log => log.phase === 'adzuna_api_discovery' || log.metadata?.apiProvider === 'adzuna_aggregator')
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, 10);
});

// NEW: Virtual for Adzuna API health and status
aiJobSearchSchema.virtual('adzunaApiStatus').get(function() {
  const remainingCalls = (this.adzunaConfig?.monthlyLimit || 1000) - (this.adzunaConfig?.apiCallsUsed || 0);
  const percentUsed = Math.round(((this.adzunaConfig?.apiCallsUsed || 0) / (this.adzunaConfig?.monthlyLimit || 1000)) * 100);
  
  let status = 'healthy';
  let message = 'Adzuna API ready for job discovery';
  
  if (this.adzunaConfig?.apiHealth === 'not_configured') {
    status = 'not_configured';
    message = 'Adzuna API keys not configured. Set ADZUNA_APP_ID and ADZUNA_APP_KEY in .env file.';
  } else if (remainingCalls <= 0) {
    status = 'rate_limited';
    message = 'Monthly API limit reached. Searches will resume next month.';
  } else if (percentUsed > 90) {
    status = 'warning';
    message = `API usage high (${percentUsed}%). ${remainingCalls} calls remaining this month.`;
  } else if (percentUsed > 75) {
    status = 'caution';
    message = `API usage at ${percentUsed}%. ${remainingCalls} calls remaining this month.`;
  }
  
  return {
    status,
    message,
    usage: {
      used: this.adzunaConfig?.apiCallsUsed || 0,
      limit: this.adzunaConfig?.monthlyLimit || 1000,
      remaining: remainingCalls,
      percentUsed: percentUsed
    },
    nextReset: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 1),
    costSavings: this.adzunaConfig?.costComparison?.savingsPercent || 0
  };
});

module.exports = mongoose.model('AiJobSearch', aiJobSearchSchema);

================
File: backend/models/mongodb/assistantSession.model.js
================
// backend/models/mongodb/assistantSession.model.js
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['user', 'assistant', 'system'],
    required: true
  },
  content: {
    type: String,
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  metadata: {
    suggestions: [String],
    resumeEdits: mongoose.Schema.Types.Mixed,
    actionItems: [String],
    confidence: Number,
    processingTime: Number,
    tokensUsed: Number
  }
});

const assistantSessionSchema = new mongoose.Schema({
  sessionId: {
    type: String,
    required: true,
    unique: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    required: false
  },
  resumeSnapshot: {
    // Store resume data at time of session start for context
    name: String,
    parsedData: mongoose.Schema.Types.Mixed,
    version: Number,
    capturedAt: Date
  },
  context: {
    type: String,
    enum: ['resume_editing', 'job_matching', 'career_advice', 'interview_prep', 'general'],
    default: 'resume_editing'
  },
  status: {
    type: String,
    enum: ['active', 'ended', 'expired'],
    default: 'active'
  },
  messages: [messageSchema],
  
  // Session analytics
  analytics: {
    totalMessages: {
      type: Number,
      default: 0
    },
    userMessages: {
      type: Number,
      default: 0
    },
    assistantMessages: {
      type: Number,
      default: 0
    },
    totalTokensUsed: {
      type: Number,
      default: 0
    },
    averageResponseTime: Number,
    sessionsLength: Number, // in seconds
    resumeChangesApplied: {
      type: Number,
      default: 0
    },
    userSatisfactionRating: Number,
    helpfulnessRating: Number
  },

  // AI Context and Memory
  aiContext: {
    userPreferences: {
      communicationStyle: String, // formal, casual, detailed, concise
      focusAreas: [String], // skills, experience, formatting, content
      careerGoals: String,
      industryFocus: String,
      experienceLevel: String
    },
    conversationSummary: String,
    keyTopicsDiscussed: [String],
    actionItemsGenerated: [String],
    improvementsImplemented: [String],
    pendingRecommendations: [String]
  },

  // Resume editing history during session
  resumeEditHistory: [{
    timestamp: Date,
    section: String,
    changeType: {
      type: String,
      enum: ['suggestion', 'applied', 'rejected', 'modified']
    },
    originalContent: String,
    suggestedContent: String,
    finalContent: String,
    aiReasoning: String
  }],

  // Session settings
  settings: {
    language: {
      type: String,
      default: 'en'
    },
    assistantPersonality: {
      type: String,
      enum: ['professional', 'friendly', 'detailed', 'concise'],
      default: 'professional'
    },
    autoApplyChanges: {
      type: Boolean,
      default: false
    },
    notificationsEnabled: {
      type: Boolean,
      default: true
    }
  },

  // Integration data
  integrations: {
    connectedJobs: [mongoose.Schema.Types.ObjectId],
    sharedWithRecruiter: Boolean,
    exportedSuggestions: [{
      timestamp: Date,
      format: String,
      destination: String
    }]
  },

  startedAt: {
    type: Date,
    default: Date.now
  },
  lastActivityAt: {
    type: Date,
    default: Date.now
  },
  endedAt: Date,
  
  // Auto-expire sessions after 24 hours of inactivity
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 24 * 60 * 60 * 1000)
  }
});

// Indexes
assistantSessionSchema.index({ sessionId: 1 }, { unique: true });
assistantSessionSchema.index({ userId: 1, status: 1 });
assistantSessionSchema.index({ resumeId: 1 });
assistantSessionSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
assistantSessionSchema.index({ lastActivityAt: 1 });

// Middleware
assistantSessionSchema.pre('save', function(next) {
  this.lastActivityAt = new Date();
  
  // Update analytics
  if (this.isModified('messages')) {
    this.analytics.totalMessages = this.messages.length;
    this.analytics.userMessages = this.messages.filter(m => m.type === 'user').length;
    this.analytics.assistantMessages = this.messages.filter(m => m.type === 'assistant').length;
    
    // Calculate total tokens used
    this.analytics.totalTokensUsed = this.messages.reduce((total, msg) => {
      return total + (msg.metadata?.tokensUsed || 0);
    }, 0);
    
    // Calculate session length if ended
    if (this.status === 'ended' && this.endedAt) {
      this.analytics.sessionsLength = Math.round((this.endedAt - this.startedAt) / 1000);
    }
  }
  
  next();
});

// Instance methods
assistantSessionSchema.methods.addMessage = function(messageData) {
  const message = {
    id: messageData.id || new mongoose.Types.ObjectId().toString(),
    type: messageData.type,
    content: messageData.content,
    timestamp: new Date(),
    metadata: messageData.metadata || {}
  };
  
  this.messages.push(message);
  this.lastActivityAt = new Date();
  
  return this.save();
};

assistantSessionSchema.methods.updateContext = function(contextUpdates) {
  Object.assign(this.aiContext, contextUpdates);
  return this.save();
};

assistantSessionSchema.methods.addResumeEdit = function(editData) {
  const edit = {
    timestamp: new Date(),
    section: editData.section,
    changeType: editData.changeType,
    originalContent: editData.originalContent,
    suggestedContent: editData.suggestedContent,
    finalContent: editData.finalContent,
    aiReasoning: editData.aiReasoning
  };
  
  this.resumeEditHistory.push(edit);
  
  if (editData.changeType === 'applied') {
    this.analytics.resumeChangesApplied += 1;
  }
  
  return this.save();
};

assistantSessionSchema.methods.endSession = function(endData = {}) {
  this.status = 'ended';
  this.endedAt = new Date();
  
  if (endData.userSatisfactionRating) {
    this.analytics.userSatisfactionRating = endData.userSatisfactionRating;
  }
  
  if (endData.helpfulnessRating) {
    this.analytics.helpfulnessRating = endData.helpfulnessRating;
  }
  
  return this.save();
};

assistantSessionSchema.methods.getRecentMessages = function(limit = 10) {
  return this.messages.slice(-limit);
};

assistantSessionSchema.methods.getContextSummary = function() {
  return {
    sessionId: this.sessionId,
    context: this.context,
    resumeName: this.resumeSnapshot?.name,
    messageCount: this.messages.length,
    keyTopics: this.aiContext.keyTopicsDiscussed,
    userPreferences: this.aiContext.userPreferences,
    conversationSummary: this.aiContext.conversationSummary
  };
};

// Static methods
assistantSessionSchema.statics.findActiveSession = function(userId, resumeId = null) {
  const query = { 
    userId, 
    status: 'active',
    expiresAt: { $gt: new Date() }
  };
  
  if (resumeId) {
    query.resumeId = resumeId;
  }
  
  return this.findOne(query).sort({ lastActivityAt: -1 });
};

// Continuation of assistantSession.model.js

assistantSessionSchema.statics.getUserSessions = function(userId, limit = 20) {
  return this.find({ userId })
    .sort({ lastActivityAt: -1 })
    .limit(limit)
    .select('sessionId context resumeSnapshot.name analytics startedAt lastActivityAt status');
};

assistantSessionSchema.statics.getSessionAnalytics = function(userId, timeframe = '30d') {
  const startDate = new Date();
  
  switch(timeframe) {
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(startDate.getDate() - 90);
      break;
  }

  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        startedAt: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: null,
        totalSessions: { $sum: 1 },
        totalMessages: { $sum: '$analytics.totalMessages' },
        totalTokensUsed: { $sum: '$analytics.totalTokensUsed' },
        totalResumeChanges: { $sum: '$analytics.resumeChangesApplied' },
        avgSessionLength: { $avg: '$analytics.sessionsLength' },
        avgSatisfactionRating: { $avg: '$analytics.userSatisfactionRating' },
        avgHelpfulnessRating: { $avg: '$analytics.helpfulnessRating' }
      }
    }
  ]);
};

assistantSessionSchema.statics.cleanupExpiredSessions = function() {
  return this.updateMany(
    { 
      status: 'active',
      expiresAt: { $lt: new Date() }
    },
    { 
      $set: { 
        status: 'expired',
        endedAt: new Date()
      }
    }
  );
};

// Virtual for session duration
assistantSessionSchema.virtual('duration').get(function() {
  if (this.endedAt) {
    return Math.round((this.endedAt - this.startedAt) / 1000);
  }
  return Math.round((new Date() - this.startedAt) / 1000);
});

// Virtual for session summary
assistantSessionSchema.virtual('summary').get(function() {
  return {
    id: this.sessionId,
    duration: this.duration,
    messageCount: this.messages.length,
    resumeName: this.resumeSnapshot?.name,
    context: this.context,
    changesApplied: this.analytics.resumeChangesApplied,
    isActive: this.status === 'active',
    lastActivity: this.lastActivityAt
  };
});

module.exports = mongoose.model('AssistantSession', assistantSessionSchema);

================
File: backend/models/mongodb/conversation.model.js
================
// backend/models/mongodb/conversation.model.js - ENHANCED FOR PERSISTENCE
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    default: () => `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  },
  type: {
    type: String,
    enum: ['user', 'ai', 'system'],
    required: true
  },
  content: {
    type: String,
    required: true
  },
  metadata: {
    tokens: Number,
    model: String,
    temperature: Number,
    context: {
      page: String,
      resumeId: String,
      jobId: String,
      action: String
    },
    suggestions: [String],
    actions: [{
      type: String,
      confidence: Number,
      data: mongoose.Schema.Types.Mixed
    }],
    sentiment: {
      score: Number,
      magnitude: Number,
      label: String
    },
    // NEW: Resume editing specific metadata
    isResumeEdit: {
      type: Boolean,
      default: false
    },
    resumeChanges: [{
      section: String,
      action: String,
      reason: String
    }],
    newAnalysis: {
      overallScore: Number,
      atsCompatibility: Number,
      strengths: [String],
      weaknesses: [String]
    }
  },
  attachments: [{
    type: String,
    name: String,
    url: String,
    size: Number
  }],
  isEdited: {
    type: Boolean,
    default: false
  },
  editHistory: [{
    originalContent: String,
    editedAt: Date,
    reason: String
  }]
}, {
  timestamps: true,
  _id: false
});

const conversationSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  category: {
    type: String,
    enum: [
      'resume_help',
      'job_search',
      'career_advice',
      'interview_prep',
      'skill_development',
      'general',
      'troubleshooting'
    ],
    default: 'general'
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  messages: [messageSchema],
  summary: {
    content: String,
    keyTopics: [String],
    actionItems: [String],
    outcomes: [String],
    generatedAt: Date,
    version: {
      type: Number,
      default: 1
    }
  },
  context: {
    primaryResumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    },
    relatedJobIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    }],
    skillsFocused: [String],
    careerGoals: [String],
    userSentiment: {
      overall: String,
      trend: String,
      lastUpdated: Date
    }
  },
  analytics: {
    messageCount: {
      type: Number,
      default: 0
    },
    tokensUsed: {
      type: Number,
      default: 0
    },
    averageResponseTime: {
      type: Number,
      default: 0
    },
    userSatisfaction: {
      rating: Number,
      feedback: String,
      ratedAt: Date
    },
    topActions: [{
      action: String,
      count: Number
    }],
    engagementScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    insights: [{
      type: String,
      description: String,
      confidence: Number,
      actionable: Boolean,
      generatedAt: Date
    }],
    lastAnalyzedAt: Date
  },
  settings: {
    memoryEnabled: {
      type: Boolean,
      default: true
    },
    autoSummarize: {
      type: Boolean,
      default: true
    },
    shareWithTeam: {
      type: Boolean,
      default: false
    },
    archiveAfterDays: {
      type: Number,
      default: 90
    }
  },
  // ENHANCED: Better state management
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },
  isStarred: {
    type: Boolean,
    default: false,
    index: true
  },
  isPinned: {
    type: Boolean,
    default: false,
    index: true
  },
  lastActiveAt: {
    type: Date,
    default: Date.now,
    index: true
  },
  // DEPRECATED: Keep for backward compatibility but use isActive instead
  status: {
    type: String,
    enum: ['active', 'archived', 'deleted'],
    default: 'active'
  },
  // Legacy fields - keep for backward compatibility
  pinned: {
    type: Boolean,
    default: false
  },
  starred: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});

// ENHANCED: Compound indexes for better performance
conversationSchema.index({ userId: 1, isActive: 1, lastActiveAt: -1 });
conversationSchema.index({ userId: 1, category: 1, isActive: 1 });
conversationSchema.index({ userId: 1, tags: 1, isActive: 1 });
conversationSchema.index({ userId: 1, isStarred: 1, isActive: 1 });
conversationSchema.index({ userId: 1, isPinned: 1, isActive: 1 });
conversationSchema.index({ 'messages.type': 1, 'messages.createdAt': -1 });
conversationSchema.index({ 'summary.keyTopics': 1 });
conversationSchema.index({ lastActiveAt: -1 });

// Virtual for message count
conversationSchema.virtual('totalMessages').get(function() {
  return this.messages ? this.messages.length : 0;
});

// Virtual for last message
conversationSchema.virtual('lastMessage').get(function() {
  return this.messages && this.messages.length > 0 ? this.messages[this.messages.length - 1] : null;
});

// ENHANCED: Pre-save middleware with better analytics
conversationSchema.pre('save', function(next) {
  // Update message count and last active time when messages are modified
  if (this.isModified('messages')) {
    this.analytics.messageCount = this.messages ? this.messages.length : 0;
    this.analytics.tokensUsed = this.messages ? this.messages.reduce((total, msg) => {
      return total + (msg.metadata?.tokens || 0);
    }, 0) : 0;
    this.lastActiveAt = new Date();
  }
  
  // Ensure backward compatibility
  if (this.isModified('isStarred')) {
    this.starred = this.isStarred;
  }
  if (this.isModified('isPinned')) {
    this.pinned = this.isPinned;
  }
  if (this.isModified('isActive')) {
    this.status = this.isActive ? 'active' : 'archived';
  }
  
  next();
});

// ENHANCED: Instance methods
conversationSchema.methods.addMessage = function(messageData) {
  // Generate a more robust unique ID
  const messageId = messageData.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${this.messages.length}`;
  
  const message = {
    id: messageId,
    type: messageData.type,
    content: messageData.content,
    metadata: messageData.metadata || {},
    attachments: messageData.attachments || [],
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  this.messages.push(message);
  this.lastActiveAt = new Date();
  this.markModified('messages');
  
  return message;
};

conversationSchema.methods.getRecentMessages = function(limit = 10) {
  if (!this.messages) return [];
  return this.messages
    .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
    .slice(0, limit);
};

conversationSchema.methods.getMessagesByType = function(type) {
  if (!this.messages) return [];
  return this.messages.filter(msg => msg.type === type);
};

conversationSchema.methods.searchMessages = function(query) {
  if (!this.messages) return [];
  const searchRegex = new RegExp(query, 'i');
  return this.messages.filter(msg => 
    searchRegex.test(msg.content) || 
    (msg.metadata?.suggestions && msg.metadata.suggestions.some(s => searchRegex.test(s)))
  );
};

conversationSchema.methods.updateSummary = function(summaryData) {
  this.summary = {
    ...this.summary,
    ...summaryData,
    generatedAt: new Date(),
    version: (this.summary?.version || 0) + 1
  };
  this.markModified('summary');
};

conversationSchema.methods.calculateEngagementScore = function() {
  const messageCount = this.messages ? this.messages.length : 0;
  const userMessages = this.messages ? this.messages.filter(m => m.type === 'user').length : 0;
  const aiMessages = this.messages ? this.messages.filter(m => m.type === 'ai').length : 0;
  
  // Base score on conversation length
  let score = Math.min(messageCount * 2, 40);
  
  // Bonus for balanced conversation
  if (userMessages > 0 && aiMessages > 0) {
    const balance = Math.min(userMessages, aiMessages) / Math.max(userMessages, aiMessages);
    score += balance * 20;
  }
  
  // Bonus for user actions taken
  const actionCount = this.messages ? this.messages.reduce((count, msg) => {
    return count + (msg.metadata?.actions?.length || 0);
  }, 0) : 0;
  score += Math.min(actionCount * 5, 20);
  
  // Bonus for user satisfaction
  if (this.analytics.userSatisfaction?.rating) {
    score += (this.analytics.userSatisfaction.rating / 5) * 20;
  }
  
  this.analytics.engagementScore = Math.min(Math.round(score), 100);
  return this.analytics.engagementScore;
};

// ENHANCED: Static methods
conversationSchema.statics.findByUserId = function(userId, options = {}) {
  const query = { 
    userId, 
    isActive: true  // Use isActive instead of status
  };
  
  if (options.category) query.category = options.category;
  if (options.tags && options.tags.length > 0) query.tags = { $in: options.tags };
  if (options.pinned !== undefined) query.isPinned = options.pinned;
  if (options.starred !== undefined) query.isStarred = options.starred;
  
  return this.find(query)
    .sort(options.sort || { lastActiveAt: -1 })
    .limit(options.limit || 50)
    .populate('context.primaryResumeId', 'name analysis.overallScore')
    .populate('context.relatedJobIds', 'title company');
};

conversationSchema.statics.searchConversations = function(userId, searchQuery, options = {}) {
  const searchRegex = new RegExp(searchQuery, 'i');
  
  return this.find({
    userId,
    isActive: true,
    $or: [
      { title: searchRegex },
      { description: searchRegex },
      { tags: searchRegex },
      { 'summary.keyTopics': searchRegex },
      { 'messages.content': searchRegex }
    ]
  })
  .sort({ lastActiveAt: -1 })
  .limit(options.limit || 20);
};

conversationSchema.statics.getConversationStats = function(userId) {
  return this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId), isActive: true } },
    {
      $group: {
        _id: null,
        totalConversations: { $sum: 1 },
        totalMessages: { $sum: '$analytics.messageCount' },
        totalTokens: { $sum: '$analytics.tokensUsed' },
        avgEngagement: { $avg: '$analytics.engagementScore' },
        categoriesCount: { $addToSet: '$category' }
      }
    }
  ]);
};

// ENHANCED: Migration helper method
conversationSchema.statics.migrateToIsActive = async function(userId = null) {
  const query = userId ? { userId } : {};
  
  try {
    // Migrate status to isActive
    await this.updateMany(
      { ...query, status: 'active' },
      { $set: { isActive: true } }
    );
    
    await this.updateMany(
      { ...query, status: { $in: ['archived', 'deleted'] } },
      { $set: { isActive: false } }
    );
    
    // Migrate pinned/starred to isPinned/isStarred
    await this.updateMany(
      { ...query, pinned: true },
      { $set: { isPinned: true } }
    );
    
    await this.updateMany(
      { ...query, starred: true },
      { $set: { isStarred: true } }
    );
    
    console.log('✅ Conversation migration completed');
  } catch (error) {
    console.error('❌ Conversation migration failed:', error);
    throw error;
  }
};

// Text search index
conversationSchema.index({
  title: 'text',
  description: 'text',
  'messages.content': 'text',
  'summary.keyTopics': 'text'
});

const Conversation = mongoose.model('Conversation', conversationSchema);

module.exports = Conversation;

================
File: backend/models/mongodb/job.model.js
================
// models/mongodb/job.model.js - FIXED SCHEMA WITH PROPER ENUM VALUES
const mongoose = require('mongoose');

const jobSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    index: true
  },
  company: {
    type: String,
    required: true,
    index: true
  },
  location: {
    city: String,
    state: String,
    country: String,
    remote: Boolean,
    fullAddress: String
  },
  description: {
    type: String,
    required: true
  },
  sourceUrl: {
    type: String,
    index: true
  },
  sourcePlatform: {
    type: String,
    enum: [
      'MANUAL',
      'AI_FOUND', 
      'AI_FOUND_OPTIMIZED', 
      'AI_FOUND_INTELLIGENT',
      // Adzuna API platform support
      'AI_FOUND_ADZUNA_INDEED',
      'AI_FOUND_ADZUNA_LINKEDIN', 
      'AI_FOUND_ADZUNA_MONSTER',
      'AI_FOUND_ADZUNA_CAREERBUILDER',
      'AI_FOUND_ADZUNA_GLASSDOOR',
      'AI_FOUND_ADZUNA_ZIPRECRUITER',
      'AI_FOUND_ADZUNA_DICE',
      'AI_FOUND_ADZUNA_PARTNER',
      'AI_FOUND_ADZUNA_DIRECT',
      'AI_FOUND_ADZUNA_OTHER'
    ],
    required: true
  },
  salary: {
    min: Number,
    max: Number,
    currency: {
      type: String,
      default: 'USD'
    },
    isExplicit: Boolean
  },
  jobType: {
    type: String,
    enum: ['FULL_TIME', 'PART_TIME', 'CONTRACT', 'FREELANCE', 'INTERNSHIP', 'TEMPORARY'],
    default: 'FULL_TIME'
  },
  applicationStatus: {
    type: String,
    enum: ['NOT_APPLIED', 'APPLIED', 'INTERVIEW', 'OFFER', 'REJECTED', 'WITHDRAWN'],
    default: 'NOT_APPLIED',
    index: true
  },
  applicationDate: Date,
  isAiGenerated: {
    type: Boolean,
    default: false,
    index: true
  },
  aiSearchId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'AiJobSearch',
    index: true
  },
  
  // Enhanced parsed data with FIXED skill categories
  parsedData: {
    requirements: [String],
    responsibilities: [String],
    qualifications: {
      required: [String],
      preferred: [String]
    },
    benefits: [String],
    keySkills: [{
      name: String,
      importance: {
        type: Number,
        min: 1,
        max: 10
      },
      // FIXED: Updated enum to match what the validation functions produce
      category: {
        type: String,
        enum: ['technical', 'soft', 'business'] // ADDED 'business', REMOVED 'domain' and 'certification' as they're not used
      },
      skillType: {
        type: String,
        enum: ['programming', 'management', 'analytical', 'communication', 'design', 'general']
      }
    }],
    experienceLevel: {
      type: String,
      enum: ['entry', 'junior', 'mid', 'senior', 'lead', 'principal', 'executive']
    },
    yearsOfExperience: {
      minimum: Number,
      preferred: Number
    },
    educationRequirements: [String],
    workArrangement: {
      type: String,
      enum: ['remote', 'hybrid', 'onsite', 'unknown']
    },
    industryContext: String,
    roleCategory: String,
    seniorityLevel: String,
    technicalComplexity: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    leadershipRequired: Boolean,
    certifications: [String],
    softSkills: [String],
    technicalSkills: [String],
    toolsAndTechnologies: [String],
    companySize: String,
    extractedAt: Date,
    extractionMethod: String,
    
    // Adzuna API specific data
    adzunaApiData: {
      platform: String,
      originalUrl: String,
      postedDate: Date,
      adzunaId: String,
      category: String,
      contractType: String,
      contractTime: String,
      salaryPredicted: Boolean,
      directCompanyPosting: Boolean,
      discoveryMethod: String
    },
    
    analysisMetadata: {
      analyzedAt: Date,
      algorithmVersion: String,
      model: String,
      originalLength: Number,
      extractedSkillsCount: Number,
      costOptimized: Boolean,
      analysisType: String,
      estimatedCost: String,
      qualityLevel: String,
      sourceJobBoard: String,
      completeValidationApplied: Boolean
    }
  },
  
  // Enhanced AI search metadata for Adzuna API
  aiSearchMetadata: {
    searchScore: Number,
    discoveryMethod: String,
    extractionSuccess: Boolean,
    contentQuality: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    premiumAnalysis: Boolean,
    intelligentDiscovery: Boolean,
    adzunaApiDiscovery: Boolean,
    phase: String,
    originalPlatform: String,
    postedDate: Date,
    workArrangement: String,
    experienceLevel: String,
    department: String,
    companySize: String,
    industry: String,
    keyRequirements: [String],
    matchReason: String,
    benefits: [String],
    techStack: [String],
    relevanceScore: Number,
    
    // Adzuna API specific metadata
    adzunaApiMetadata: {
      discoveryMethod: String,
      apiProvider: String,
      jobBoardsCovered: String,
      apiHealth: String,
      costEfficient: Boolean,
      reliability: String,
      completeValidationApplied: Boolean
    }
  },
  
  // Analysis status for tracking background processing
  analysisStatus: {
    status: {
      type: String,
      enum: ['pending', 'analyzing', 'completed', 'error'],
      default: 'pending'
    },
    progress: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    message: String,
    startedAt: Date,
    completedAt: Date,
    updatedAt: Date,
    canViewJob: {
      type: Boolean,
      default: true
    },
    skillsFound: Number,
    experienceLevel: String,
    modelUsed: String,
    analysisType: String,
    error: String,
    estimatedCompletion: Date,
    searchApproach: String,
    qualityLevel: String
  },
  
  // Match analysis results
  matchAnalysis: {
    resumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    },
    overallScore: Number,
    categoryScores: {
      skills: Number,
      experience: Number,
      education: Number
    },
    matchedSkills: [{
      skill: String,
      found: Boolean,
      importance: Number,
      resumeStrength: Number
    }],
    missingSkills: [{
      skill: String,
      importance: Number,
      suggestionToAdd: String
    }],
    strengthAreas: [String],
    improvementAreas: [String],
    lastAnalyzed: Date,
    analysisMetadata: {
      algorithmVersion: String,
      modelUsed: String
    }
  },
  
  // Cover letter reference
  coverLetterId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'CoverLetter'
  },
  
  // Notes and interactions
  notes: [{
    content: String,
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // User interactions
  userInteractions: {
    viewCount: {
      type: Number,
      default: 0
    },
    lastViewed: Date,
    bookmarked: {
      type: Boolean,
      default: false
    },
    bookmarkedAt: Date,
    applied: {
      type: Boolean,
      default: false
    },
    appliedAt: Date,
    rating: {
      type: Number,
      min: 1,
      max: 5
    },
    feedback: String
  }
}, {
  timestamps: true
});

// Indexes for better performance
jobSchema.index({ userId: 1, createdAt: -1 });
jobSchema.index({ userId: 1, applicationStatus: 1 });
jobSchema.index({ userId: 1, sourcePlatform: 1 });
jobSchema.index({ userId: 1, 'parsedData.experienceLevel': 1 });
jobSchema.index({ userId: 1, 'parsedData.workArrangement': 1 });
jobSchema.index({ title: 'text', company: 'text', description: 'text' });
jobSchema.index({ 'parsedData.keySkills.name': 1 });
jobSchema.index({ aiSearchId: 1 });
jobSchema.index({ sourceUrl: 1 });

// Adzuna API specific indexes
jobSchema.index({ 'aiSearchMetadata.adzunaApiDiscovery': 1 });
jobSchema.index({ 'aiSearchMetadata.originalPlatform': 1 });
jobSchema.index({ 'aiSearchMetadata.relevanceScore': -1 });

// Compound indexes for common queries
jobSchema.index({ userId: 1, sourcePlatform: 1, createdAt: -1 });
jobSchema.index({ userId: 1, applicationStatus: 1, createdAt: -1 });
jobSchema.index({ userId: 1, 'matchAnalysis.overallScore': -1 });

// Virtual for checking if job is from Adzuna API
jobSchema.virtual('isFromAdzunaApi').get(function() {
  return this.sourcePlatform && this.sourcePlatform.includes('AI_FOUND_ADZUNA');
});

// Virtual for getting source platform name
jobSchema.virtual('sourceJobBoardName').get(function() {
  if (!this.isFromAdzunaApi) return null;
  
  if (this.sourcePlatform.includes('INDEED')) return 'Indeed';
  if (this.sourcePlatform.includes('LINKEDIN')) return 'LinkedIn';
  if (this.sourcePlatform.includes('MONSTER')) return 'Monster';
  if (this.sourcePlatform.includes('CAREERBUILDER')) return 'CareerBuilder';
  if (this.sourcePlatform.includes('GLASSDOOR')) return 'Glassdoor';
  if (this.sourcePlatform.includes('ZIPRECRUITER')) return 'ZipRecruiter';
  if (this.sourcePlatform.includes('DICE')) return 'Dice';
  
  return 'Adzuna Partner';
});

// Virtual for enhanced job quality score
jobSchema.virtual('qualityScore').get(function() {
  let score = 50; // Base score
  
  // Adzuna API bonus
  if (this.isFromAdzunaApi) score += 20;
  
  // Content quality
  if (this.aiSearchMetadata?.contentQuality === 'high') score += 15;
  else if (this.aiSearchMetadata?.contentQuality === 'medium') score += 10;
  
  // Premium analysis bonus
  if (this.aiSearchMetadata?.premiumAnalysis) score += 10;
  
  // Relevance score bonus
  if (this.aiSearchMetadata?.relevanceScore > 80) score += 5;
  
  return Math.min(score, 100);
});

// Method to check if job analysis is complete
jobSchema.methods.isAnalysisComplete = function() {
  return this.analysisStatus?.status === 'completed' &&
         this.parsedData && 
         Object.keys(this.parsedData).length > 0 && 
         !this.parsedData.analysisError;
};

// Method to get Adzuna API specific data
jobSchema.methods.getAdzunaApiData = function() {
  if (!this.isFromAdzunaApi) return null;
  
  return {
    platform: this.sourceJobBoardName,
    originalUrl: this.parsedData?.adzunaApiData?.originalUrl,
    postedDate: this.parsedData?.adzunaApiData?.postedDate,
    adzunaId: this.parsedData?.adzunaApiData?.adzunaId,
    category: this.parsedData?.adzunaApiData?.category,
    directCompanyPosting: this.parsedData?.adzunaApiData?.directCompanyPosting || false,
    discoveryMethod: this.parsedData?.adzunaApiData?.discoveryMethod || 'adzuna_api_aggregation'
  };
};

// Method to update user interaction
jobSchema.methods.recordUserInteraction = function(interactionType, data = {}) {
  if (!this.userInteractions) {
    this.userInteractions = { viewCount: 0 };
  }
  
  switch (interactionType) {
    case 'view':
      this.userInteractions.viewCount += 1;
      this.userInteractions.lastViewed = new Date();
      break;
    case 'bookmark':
      this.userInteractions.bookmarked = true;
      this.userInteractions.bookmarkedAt = new Date();
      break;
    case 'unbookmark':
      this.userInteractions.bookmarked = false;
      this.userInteractions.bookmarkedAt = null;
      break;
    case 'apply':
      this.userInteractions.applied = true;
      this.userInteractions.appliedAt = new Date();
      this.applicationStatus = 'APPLIED';
      this.applicationDate = new Date();
      break;
    case 'rate':
      this.userInteractions.rating = data.rating;
      this.userInteractions.feedback = data.feedback;
      break;
  }
  
  return this.save();
};

// Static method to find jobs from Adzuna API
jobSchema.statics.findAdzunaApiJobs = function(userId, options = {}) {
  const query = {
    userId,
    sourcePlatform: {
      $regex: /^AI_FOUND_ADZUNA/
    }
  };
  
  if (options.jobBoard) {
    query.sourcePlatform = `AI_FOUND_ADZUNA_${options.jobBoard.toUpperCase()}`;
  }
  
  if (options.dateRange) {
    query.createdAt = {
      $gte: options.dateRange.start,
      $lte: options.dateRange.end
    };
  }
  
  return this.find(query).sort({ createdAt: -1 });
};

// Static method to get Adzuna API statistics
jobSchema.statics.getAdzunaApiStats = function(userId) {
  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        sourcePlatform: { $regex: /^AI_FOUND_ADZUNA/ }
      }
    },
    {
      $group: {
        _id: '$sourcePlatform',
        count: { $sum: 1 },
        avgQualityScore: { $avg: '$aiSearchMetadata.searchScore' },
        avgRelevanceScore: { $avg: '$aiSearchMetadata.relevanceScore' },
        totalViews: { $sum: '$userInteractions.viewCount' },
        appliedJobs: {
          $sum: {
            $cond: [{ $eq: ['$applicationStatus', 'APPLIED'] }, 1, 0]
          }
        }
      }
    },
    {
      $project: {
        jobBoard: {
          $switch: {
            branches: [
              { case: { $regex: ['$_id', /INDEED/] }, then: 'Indeed' },
              { case: { $regex: ['$_id', /LINKEDIN/] }, then: 'LinkedIn' },
              { case: { $regex: ['$_id', /MONSTER/] }, then: 'Monster' },
              { case: { $regex: ['$_id', /CAREERBUILDER/] }, then: 'CareerBuilder' },
              { case: { $regex: ['$_id', /GLASSDOOR/] }, then: 'Glassdoor' }
            ],
            default: 'Adzuna Partner'
          }
        },
        count: 1,
        avgQualityScore: { $round: ['$avgQualityScore', 1] },
        avgRelevanceScore: { $round: ['$avgRelevanceScore', 1] },
        totalViews: 1,
        appliedJobs: 1,
        applicationRate: {
          $round: [{ $multiply: [{ $divide: ['$appliedJobs', '$count'] }, 100] }, 1]
        }
      }
    }
  ]);
};

// Pre-save middleware
jobSchema.pre('save', function(next) {
  // Auto-detect Adzuna API from source platform
  if (this.isModified('sourcePlatform') && this.isFromAdzunaApi) {
    if (!this.aiSearchMetadata) this.aiSearchMetadata = {};
    this.aiSearchMetadata.adzunaApiDiscovery = true;
    this.aiSearchMetadata.originalPlatform = this.sourceJobBoardName;
  }
  
  // Ensure Adzuna API data consistency
  if (this.isFromAdzunaApi && this.parsedData?.adzunaApiData) {
    this.parsedData.adzunaApiData.platform = this.sourceJobBoardName;
  }
  
  next();
});

// Post-save middleware for analytics
jobSchema.post('save', function(doc) {
  // Analytics events for Adzuna API tracking
  if (doc.isFromAdzunaApi && doc.isNew) {
    console.log(`📊 New Adzuna API job saved: ${doc.title} from ${doc.sourceJobBoardName} (Relevance: ${doc.aiSearchMetadata?.relevanceScore || 'N/A'}%)`);
  }
});

module.exports = mongoose.model('Job', jobSchema);

================
File: backend/models/mongodb/outreach.model.js
================
// backend/models/mongodb/outreach.model.js
const mongoose = require('mongoose');

const replySchema = new mongoose.Schema({
  content: {
    type: String,
    required: true
  },
  receivedAt: {
    type: Date,
    default: Date.now
  },
  sentiment: {
    type: String,
    enum: ['positive', 'neutral', 'negative'],
    default: 'neutral'
  },
  extractedInfo: {
    nextSteps: [String],
    scheduledMeeting: {
      type: Boolean,
      default: false
    },
    referralMade: {
      type: Boolean,
      default: false
    }
  }
}, {
  timestamps: true,
  _id: true
});

const followUpSchema = new mongoose.Schema({
  content: {
    type: String,
    required: true
  },
  sentAt: {
    type: Date,
    default: Date.now
  },
  status: {
    type: String,
    enum: ['drafted', 'sent', 'replied'],
    default: 'drafted'
  },
  type: {
    type: String,
    enum: ['reminder', 'additional_info', 'thank_you', 'check_in'],
    default: 'reminder'
  },
  scheduledFor: Date
}, {
  timestamps: true,
  _id: true
});

const outreachSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  recruiterId: {
    type: String, // PostgreSQL recruiter ID
    required: true,
    index: true
  },
  jobId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Job',
    index: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    index: true
  },
  
  // Message content
  messageContent: {
    type: String,
    required: true
  },
  messageTemplate: {
    type: String,
    enum: ['introduction', 'follow_up', 'application', 'thank_you', 'custom'],
    default: 'custom'
  },
  subject: String,
  
  // Customizations and personalization
  customizations: [{
    type: {
      type: String,
      enum: ['tone_adjustment', 'content_addition', 'length_modification', 'style_change']
    },
    description: String,
    appliedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // AI generation metadata
  aiGenerated: {
    type: Boolean,
    default: false
  },
  aiMetadata: {
    model: String,
    tokensUsed: Number,
    confidence: Number,
    generatedAt: Date,
    prompt: String
  },
  
  // Communication details
  sentVia: {
    type: String,
    enum: ['email', 'linkedin', 'phone', 'other'],
    default: 'linkedin'
  },
  status: {
    type: String,
    enum: ['drafted', 'sent', 'delivered', 'opened', 'replied', 'no_reply', 'bounced'],
    default: 'drafted'
  },
  
  // Timing
  sentAt: Date,
  deliveredAt: Date,
  openedAt: Date,
  scheduledFor: Date,
  
  // Responses and follow-ups
  replies: [replySchema],
  followUps: [followUpSchema],
  
  // Tracking and analytics
  analytics: {
    views: {
      type: Number,
      default: 0
    },
    clicks: {
      type: Number,
      default: 0
    },
    responseTime: Number, // Time to first response in hours
    engagementScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    }
  },
  
  // Campaign information
  campaignId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Campaign'
  },
  campaignName: String,
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  
  // Outcome tracking
  outcome: {
    result: {
      type: String,
      enum: ['meeting_scheduled', 'referral_received', 'application_submitted', 'no_response', 'not_interested', 'connection_made']
    },
    notes: String,
    nextSteps: [String],
    followUpDate: Date
  },
  
  // Tags and categorization
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  category: {
    type: String,
    enum: ['cold_outreach', 'warm_introduction', 'referral_request', 'application_follow_up', 'networking'],
    default: 'cold_outreach'
  },
  
  // Relationship context
  relationship: {
    connectionLevel: {
      type: String,
      enum: ['1st', '2nd', '3rd', 'none'],
      default: 'none'
    },
    mutualConnections: [String],
    previousInteractions: [{
      date: Date,
      type: String,
      notes: String
    }]
  },
  
  // Reminders and notifications
  reminders: [{
    type: {
      type: String,
      enum: ['follow_up', 'response_check', 'next_action']
    },
    scheduledFor: Date,
    completed: {
      type: Boolean,
      default: false
    },
    completedAt: Date
  }],
  
  // Integration data
  integrations: {
    linkedinMessageId: String,
    emailMessageId: String,
    crmId: String,
    externalData: mongoose.Schema.Types.Mixed
  },
  
  // Archival and cleanup
  isActive: {
    type: Boolean,
    default: true
  },
  archivedAt: Date,
  archivedReason: String,
  
  // User notes
  notes: String,
  privateNotes: String,
  
}, {
  timestamps: true
});

// Indexes for performance
outreachSchema.index({ userId: 1, status: 1 });
outreachSchema.index({ userId: 1, createdAt: -1 });
outreachSchema.index({ recruiterId: 1, userId: 1 });
outreachSchema.index({ jobId: 1 });
outreachSchema.index({ status: 1, sentAt: 1 });
outreachSchema.index({ campaignId: 1 });
outreachSchema.index({ scheduledFor: 1 });
outreachSchema.index({ 'reminders.scheduledFor': 1, 'reminders.completed': 1 });

// Text search index
outreachSchema.index({
  messageContent: 'text',
  subject: 'text',
  notes: 'text',
  tags: 'text'
});

// Virtual for response time calculation
outreachSchema.virtual('responseTimeHours').get(function() {
  if (this.sentAt && this.replies && this.replies.length > 0) {
    const firstReply = this.replies[0];
    return Math.round((firstReply.receivedAt - this.sentAt) / (1000 * 60 * 60));
  }
  return null;
});

// Virtual for days since sent
outreachSchema.virtual('daysSinceSent').get(function() {
  if (this.sentAt) {
    return Math.floor((Date.now() - this.sentAt) / (1000 * 60 * 60 * 24));
  }
  return null;
});

// Virtual for reply count
outreachSchema.virtual('replyCount').get(function() {
  return this.replies ? this.replies.length : 0;
});

// Virtual for follow-up count
outreachSchema.virtual('followUpCount').get(function() {
  return this.followUps ? this.followUps.length : 0;
});

// Pre-save middleware
outreachSchema.pre('save', function(next) {
  // Update engagement score based on interactions
  if (this.isModified('replies') || this.isModified('analytics')) {
    this.calculateEngagementScore();
  }
  
  // Update response time
  if (this.isModified('replies') && this.replies.length > 0 && this.sentAt) {
    const firstReply = this.replies[0];
    this.analytics.responseTime = (firstReply.receivedAt - this.sentAt) / (1000 * 60 * 60);
  }
  
  next();
});

// Instance methods
outreachSchema.methods.addReply = function(replyData) {
  this.replies.push({
    content: replyData.content,
    receivedAt: replyData.receivedAt || new Date(),
    sentiment: replyData.sentiment || 'neutral',
    extractedInfo: replyData.extractedInfo || {}
  });
  
  // Update status
  if (this.status === 'sent' || this.status === 'delivered') {
    this.status = 'replied';
  }
  
  return this.save();
};

outreachSchema.methods.addFollowUp = function(followUpData) {
  this.followUps.push({
    content: followUpData.content,
    type: followUpData.type || 'reminder',
    scheduledFor: followUpData.scheduledFor,
    status: followUpData.status || 'drafted'
  });
  
  return this.save();
};

outreachSchema.methods.markAsSent = function() {
  this.status = 'sent';
  this.sentAt = new Date();
  
  // Schedule follow-up reminder if not replied within 7 days
  this.reminders.push({
    type: 'follow_up',
    scheduledFor: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  });
  
  return this.save();
};

outreachSchema.methods.calculateEngagementScore = function() {
  let score = 0;
  
  // Base score for being sent
  if (this.status === 'sent' || this.status === 'delivered' || this.status === 'replied') {
    score += 20;
  }
  
  // Bonus for being opened/delivered
  if (this.status === 'delivered' || this.status === 'opened' || this.status === 'replied') {
    score += 20;
  }
  
  // Major bonus for replies
  score += Math.min(this.replies.length * 30, 60);
  
  // Bonus for positive sentiment
  const positivReplies = this.replies.filter(r => r.sentiment === 'positive').length;
  score += positiveReplies * 10;
  
  // Bonus for quick response
  if (this.analytics.responseTime && this.analytics.responseTime <= 24) {
    score += 15;
  }
  
  // Bonus for follow-ups
  score += Math.min(this.followUps.length * 5, 15);
  
  this.analytics.engagementScore = Math.min(score, 100);
  return this.analytics.engagementScore;
};

outreachSchema.methods.scheduleReminder = function(type, date) {
  this.reminders.push({
    type: type,
    scheduledFor: date,
    completed: false
  });
  
  return this.save();
};

outreachSchema.methods.markReminderComplete = function(reminderId) {
  const reminder = this.reminders.id(reminderId);
  if (reminder) {
    reminder.completed = true;
    reminder.completedAt = new Date();
  }
  
  return this.save();
};

// Static methods
outreachSchema.statics.findByRecruiter = function(recruiterId, userId, options = {}) {
  const query = { recruiterId, userId };
  
  if (options.status) {
    query.status = options.status;
  }
  
  return this.find(query)
    .sort(options.sort || { createdAt: -1 })
    .limit(options.limit || 10);
};

outreachSchema.statics.getAnalytics = function(userId, timeframe = '30d') {
  const startDate = new Date();
  
  switch(timeframe) {
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(startDate.getDate() - 90);
      break;
  }

  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        createdAt: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: null,
        totalOutreach: { $sum: 1 },
        sent: { $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] } },
        replied: { $sum: { $cond: [{ $eq: ['$status', 'replied'] }, 1, 0] } },
        avgEngagement: { $avg: '$analytics.engagementScore' },
        avgResponseTime: { $avg: '$analytics.responseTime' }
      }
    }
  ]);
};

outreachSchema.statics.findPendingReminders = function() {
  return this.find({
    'reminders.scheduledFor': { $lte: new Date() },
    'reminders.completed': false,
    isActive: true
  });
};

outreachSchema.statics.getTopPerformingTemplates = function(userId, limit = 5) {
  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        status: { $in: ['sent', 'replied'] }
      }
    },
    {
      $group: {
        _id: '$messageTemplate',
        count: { $sum: 1 },
        responseRate: {
          $avg: {
            $cond: [{ $eq: ['$status', 'replied'] }, 1, 0]
          }
        },
        avgEngagement: { $avg: '$analytics.engagementScore' }
      }
    },
    {
      $sort: { responseRate: -1, avgEngagement: -1 }
    },
    {
      $limit: limit
    }
  ]);
};

const Outreach = mongoose.model('Outreach', outreachSchema);

module.exports = Outreach;

================
File: backend/models/mongodb/resume.model.js
================
// models/mongodb/resume.model.js
const mongoose = require('mongoose');

const resumeSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  processingStatus: {
    status: {
      type: String,
      enum: ['pending', 'uploading', 'parsing', 'analyzing', 'completed', 'error'],
      default: 'pending'
    },
    progress: {
      type: Number,
      default: 0,
      min: 0,
      max: 100
    },
    message: {
      type: String,
      default: ''
    },
    error: {
      type: String,
      default: ''
    },
    updatedAt: {
      type: Date,
      default: Date.now
    }
  },
  name: {
    type: String,
    required: true
  },
  originalFilename: {
    type: String,
    required: true
  },
  fileUrl: {
    type: String,
    required: true
  },
  fileType: {
    type: String,
    enum: ['PDF', 'DOCX', 'DOC'],
    required: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  parsedData: {
    contactInfo: {
      name: String,
      email: String,
      phone: String,
      location: String,
      websites: [String]
    },
    summary: String,
    experience: [{
      company: String,
      title: String,
      location: String,
      startDate: Date,
      endDate: Date,
      description: String,
      highlights: [String],
      skills: [String]
    }],
    education: [{
      institution: String,
      degree: String,
      field: String,
      startDate: Date,
      endDate: Date,
      gpa: Number,
      highlights: [String]
    }],
    skills: [{
      name: String,
      level: String,
      yearsOfExperience: Number
    }],
    certifications: [{
      name: String,
      issuer: String,
      dateObtained: Date,
      validUntil: Date
    }],
    languages: [{
      language: String,
      proficiency: String
    }],
    projects: [{
      name: String,
      description: String,
      url: String,
      startDate: Date,
      endDate: Date,
      skills: [String]
    }]
  },
  analysis: {
    overallScore: Number,
    atsCompatibility: Number,
    profileSummary: {
      currentRole: String,
      careerLevel: String,
      industries: [String],
      suggestedJobTitles: [String],
      suggestedIndustries: [String]
    },
    strengths: [String],
    weaknesses: [String],
    keywordsSuggestions: [String],
    improvementAreas: [{
      section: String,
      suggestions: [String],
      improvedSnippets: [{
        original: String,
        improved: String
      }]
    }]
  },
  // New fields for tailored resumes
  isTailored: {
    type: Boolean,
    default: false
  },
  tailoredForJob: {
    jobId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    },
    jobTitle: String,
    company: String,
    originalResumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    }
  },
  versions: [{
    versionNumber: Number,
    createdAt: Date,
    fileUrl: String,
    changesDescription: String,
    jobId: mongoose.Schema.Types.ObjectId
  }],
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Resume', resumeSchema);

================
File: backend/models/mongodb/user.model.js
================
// backend/models/mongodb/user.model.js - COMPLETE MONTHLY ONLY VERSION
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Please provide an email'],
    unique: true,
    trim: true,
    lowercase: true,
    match: [
      /^([\w-\.]+@([\w-]+\.)+[\w-]{2,4})?$/,
      'Please provide a valid email'
    ]
  },
  password: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: [8, 'Password should be at least 8 characters'],
    select: false
  },
  firstName: {
    type: String,
    required: [true, 'Please provide your first name'],
    trim: true
  },
  lastName: {
    type: String,
    required: [true, 'Please provide your last name'],
    trim: true
  },
  profilePicture: {
    type: String
  },
  location: {
    city: String,
    state: String,
    country: String
  },
  phoneNumber: {
    type: String,
    trim: true
  },
  socialProfiles: {
    linkedin: String,
    github: String,
    portfolio: String
  },
  preferences: {
    jobTypes: [String],
    industries: [String],
    locations: [{
      city: String,
      state: String,
      country: String,
      remote: Boolean
    }],
    salaryRange: {
      min: Number,
      max: Number,
      currency: String
    },
    notifications: {
      email: {
        type: Boolean,
        default: true
      },
      jobAlerts: {
        type: Boolean,
        default: true
      }
    }
  },
  accountType: {
    type: String,
    enum: ['Free', 'Basic', 'Premium'],
    default: 'Free'
  },
  
  // ======================================
  // SUBSCRIPTION FIELDS (MONTHLY ONLY)
  // ======================================
  
  subscriptionTier: {
    type: String,
    enum: ['free', 'casual', 'hunter'],
    default: 'free'
  },
  stripeCustomerId: {
    type: String,
    sparse: true
  },
  subscriptionStatus: {
    type: String,
    enum: ['active', 'canceled', 'past_due', 'unpaid', 'trialing', 'incomplete'],
    default: 'active'
  },
  subscriptionEndDate: {
    type: Date
  },
  subscriptionStartDate: {
    type: Date
  },
  trialEndDate: {
    type: Date
  },
  cancelAtPeriodEnd: {
    type: Boolean,
    default: false
  },
  // billingCycle removed since we only do monthly
  currentUsage: {
    resumeUploads: { type: Number, default: 0 },
    resumeAnalysis: { type: Number, default: 0 },
    jobImports: { type: Number, default: 0 },
    resumeTailoring: { type: Number, default: 0 },
    recruiterUnlocks: { type: Number, default: 0 },
    aiJobDiscovery: { type: Number, default: 0 },
    aiConversations: { type: Number, default: 0 },
    aiMessagesTotal: { type: Number, default: 0 },
    resetDate: { type: Date, default: Date.now }
  },
  usageHistory: [{
    month: { type: Date, required: true },
    usage: {
      resumeUploads: { type: Number, default: 0 },
      resumeAnalysis: { type: Number, default: 0 },
      jobImports: { type: Number, default: 0 },
      resumeTailoring: { type: Number, default: 0 },
      recruiterUnlocks: { type: Number, default: 0 },
      aiJobDiscovery: { type: Number, default: 0 },
      aiConversations: { type: Number, default: 0 },
      aiMessagesTotal: { type: Number, default: 0 }
    }
  }],
  
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isEmailVerified: {
    type: Boolean,
    default: false
  },
  emailVerificationToken: String,
  emailVerificationExpires: Date,
  passwordResetToken: String,
  passwordResetExpires: Date,
  loginAttempts: {
    type: Number,
    default: 0
  },
  lockUntil: Date,
  lastLogin: Date,
  active: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

// Generate email verification token
userSchema.methods.generateEmailVerificationToken = function() {
  const token = crypto.randomBytes(32).toString('hex');
  
  this.emailVerificationToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  this.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000;
  
  return token;
};

// Generate password reset token
userSchema.methods.generatePasswordResetToken = function() {
  const token = crypto.randomBytes(32).toString('hex');
  
  this.passwordResetToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  this.passwordResetExpires = Date.now() + 10 * 60 * 1000;
  
  return token;
};

// Check if account is locked
userSchema.methods.isLocked = function() {
  return !!(this.lockUntil && this.lockUntil > Date.now());
};

// Increment login attempts and lock account if needed
userSchema.methods.incrementLoginAttempts = async function() {
  if (this.lockUntil && this.lockUntil < Date.now()) {
    return this.updateOne({
      $set: { loginAttempts: 1 },
      $unset: { lockUntil: 1 }
    });
  }
  
  const updates = { $inc: { loginAttempts: 1 } };
  
  if (this.loginAttempts + 1 >= 5 && !this.isLocked()) {
    updates.$set = { lockUntil: Date.now() + 60 * 60 * 1000 };
  }
  
  return this.updateOne(updates);
};

// Reset login attempts
userSchema.methods.resetLoginAttempts = function() {
  return this.updateOne({
    $set: { loginAttempts: 0 },
    $unset: { lockUntil: 1 }
  });
};

// ======================================
// SUBSCRIPTION METHODS (MONTHLY ONLY)
// ======================================

// Get current subscription plan limits
userSchema.methods.getPlanLimits = function() {
  const PLAN_LIMITS = {
    free: {
      resumeUploads: 1,
      resumeAnalysis: 1,
      jobImports: 3,
      resumeTailoring: 1,
      recruiterAccess: false,
      recruiterUnlocks: 0,
      aiJobDiscovery: false,
      aiAssistant: false,
      aiConversations: 0,
      aiMessagesPerConversation: 0
    },
    casual: {
      resumeUploads: 5,
      resumeAnalysis: 5,
      jobImports: 25,
      resumeTailoring: 25,
      recruiterAccess: true,
      recruiterUnlocks: 25,
      aiJobDiscovery: 1,
      aiAssistant: false,
      aiConversations: 0,
      aiMessagesPerConversation: 0
    },
    hunter: {
      resumeUploads: -1, // unlimited
      resumeAnalysis: -1, // unlimited
      jobImports: -1, // unlimited
      resumeTailoring: 50,
      recruiterAccess: true,
      recruiterUnlocks: -1, // unlimited
      aiJobDiscovery: -1, // unlimited
      aiAssistant: true,
      aiConversations: 5,
      aiMessagesPerConversation: 20
    }
  };
  
  return PLAN_LIMITS[this.subscriptionTier] || PLAN_LIMITS.free;
};

// Check if user can perform a specific action
userSchema.methods.canPerformAction = function(action, quantity = 1) {
  const limits = this.getPlanLimits();
  const usage = this.currentUsage || {};
  
  // Check if feature is available for this plan
  if (action === 'recruiterAccess' && !limits.recruiterAccess) {
    return { allowed: false, reason: 'Recruiter access not available in your plan' };
  }
  
  if (action === 'aiAssistant' && !limits.aiAssistant) {
    return { allowed: false, reason: 'AI Assistant not available in your plan' };
  }
  
  if (action === 'aiJobDiscovery' && !limits.aiJobDiscovery) {
    return { allowed: false, reason: 'AI Job Discovery not available in your plan' };
  }
  
  // Check usage limits
  const limit = limits[action];
  if (limit === -1) {
    return { allowed: true }; // Unlimited
  }
  
  if (limit === 0) {
    return { allowed: false, reason: 'Feature not available in your plan' };
  }
  
  const currentUsed = usage[action] || 0;
  if (currentUsed + quantity > limit) {
    return { 
      allowed: false, 
      reason: `Usage limit exceeded. You have used ${currentUsed}/${limit} for this month`,
      current: currentUsed,
      limit: limit
    };
  }
  
  return { 
    allowed: true, 
    remaining: limit - currentUsed - quantity,
    current: currentUsed,
    limit: limit
  };
};

// Track usage for a specific action
userSchema.methods.trackUsage = async function(action, quantity = 1) {
  const now = new Date();
  const resetDate = this.currentUsage?.resetDate || new Date();
  
  // Check if we need to reset monthly usage
  if (now.getMonth() !== resetDate.getMonth() || now.getFullYear() !== resetDate.getFullYear()) {
    // Archive current usage to history
    if (this.currentUsage && Object.keys(this.currentUsage).length > 1) {
      this.usageHistory.push({
        month: resetDate,
        usage: { ...this.currentUsage }
      });
      
      // Keep only last 12 months of history
      if (this.usageHistory.length > 12) {
        this.usageHistory = this.usageHistory.slice(-12);
      }
    }
    
    // Reset current usage
    this.currentUsage = {
      resumeUploads: 0,
      resumeAnalysis: 0,
      jobImports: 0,
      resumeTailoring: 0,
      recruiterUnlocks: 0,
      aiJobDiscovery: 0,
      aiConversations: 0,
      aiMessagesTotal: 0,
      resetDate: now
    };
  }
  
  // Initialize currentUsage if it doesn't exist
  if (!this.currentUsage) {
    this.currentUsage = {
      resumeUploads: 0,
      resumeAnalysis: 0,
      jobImports: 0,
      resumeTailoring: 0,
      recruiterUnlocks: 0,
      aiJobDiscovery: 0,
      aiConversations: 0,
      aiMessagesTotal: 0,
      resetDate: now
    };
  }
  
  // Update usage
  this.currentUsage[action] = (this.currentUsage[action] || 0) + quantity;
  this.currentUsage.resetDate = now;
  
  return this.save();
};

// Get usage statistics
userSchema.methods.getUsageStats = function() {
  const limits = this.getPlanLimits();
  const usage = this.currentUsage || {};
  
  const stats = {};
  
  Object.keys(limits).forEach(action => {
    if (typeof limits[action] === 'number') {
      const limit = limits[action];
      const used = usage[action] || 0;
      
      stats[action] = {
        used,
        limit,
        unlimited: limit === -1,
        percentage: limit > 0 ? Math.round((used / limit) * 100) : 0,
        remaining: limit > 0 ? Math.max(0, limit - used) : -1
      };
    }
  });
  
  return stats;
};

// Check if subscription is active and valid (monthly billing assumed)
userSchema.methods.hasActiveSubscription = function() {
  if (this.subscriptionTier === 'free') return true;
  
  const now = new Date();
  return (
    this.subscriptionStatus === 'active' &&
    (!this.subscriptionEndDate || this.subscriptionEndDate > now)
  );
};

// Get billing cycle (always monthly)
userSchema.methods.getBillingCycle = function() {
  return 'monthly';
};

// Get subscription summary
userSchema.methods.getSubscriptionSummary = function() {
  return {
    tier: this.subscriptionTier,
    status: this.subscriptionStatus,
    billingCycle: 'monthly',
    startDate: this.subscriptionStartDate,
    endDate: this.subscriptionEndDate,
    trialEndDate: this.trialEndDate,
    cancelAtPeriodEnd: this.cancelAtPeriodEnd,
    isActive: this.hasActiveSubscription(),
    planLimits: this.getPlanLimits(),
    usageStats: this.getUsageStats()
  };
};

const User = mongoose.model('User', userSchema);

module.exports = User;

================
File: backend/models/mongodb/userMemory.model.js
================
// backend/models/mongodb/userMemory.model.js - FIXED SCHEMA FOR INSIGHTS
const mongoose = require('mongoose');

const memoryEntrySchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true
  },
  type: {
    type: String,
    enum: [
      'preference',
      'skill',
      'career_goal',
      'experience',
      'achievement',
      'challenge',
      'personality_trait',
      'communication_style',
      'work_style',
      'industry_knowledge',
      'tool_preference',
      'feedback_pattern',
      'education',           // ADDED: For degrees, certifications, etc.
      'learning_goal',       // ADDED: For things like "want to learn Python"
      'weakness'             // ADDED: For challenges like "system design interviews"
    ],
    required: true
  },
  category: {
    type: String,
    enum: [
      'personal',
      'professional',
      'technical',
      'behavioral',
      'contextual'
    ],
    required: true
  },
  content: {
    type: String,
    required: true,
    trim: true
  },
  confidence: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.8
  },
  importance: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  source: {
    conversationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Conversation'
    },
    messageId: String,
    extractionMethod: {
      type: String,
      enum: [
        'explicit', 
        'inferred', 
        'pattern_detected', 
        'user_confirmed',
        'ai_extracted',
        'summary_extracted',
        'user_added'
      ],
      default: 'inferred'
    },
    model: String,
    timestamp: {
      type: Date,
      default: Date.now
    }
  },
  context: {
    resumeIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    }],
    jobIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    }],
    timeframe: {
      from: Date,
      to: Date
    },
    situation: String
  },
  verification: {
    isVerified: {
      type: Boolean,
      default: false
    },
    verifiedAt: Date,
    verificationMethod: {
      type: String,
      enum: ['user_confirmed', 'repeated_observation', 'cross_referenced']
    },
    verificationCount: {
      type: Number,
      default: 0
    }
  },
  usage: {
    accessCount: {
      type: Number,
      default: 0
    },
    lastAccessedAt: Date,
    effectivenessRating: {
      type: Number,
      min: 1,
      max: 5
    },
    userFeedback: String
  },
  relationships: [{
    relatedMemoryId: String,
    relationshipType: {
      type: String,
      enum: ['reinforces', 'contradicts', 'builds_on', 'specifies', 'generalizes']
    },
    strength: {
      type: Number,
      min: 0,
      max: 1
    }
  }],
  decay: {
    lastReinforced: {
      type: Date,
      default: Date.now
    },
    reinforcementCount: {
      type: Number,
      default: 1
    },
    decayRate: {
      type: Number,
      default: 0.1
    }
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true,
  _id: false
});

const userMemorySchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    unique: true,
    index: true
  },
  memories: [memoryEntrySchema],
  
  // User profile intelligence derived from memories
  profile: {
    careerStage: {
      type: String,
      enum: ['student', 'entry_level', 'mid_level', 'senior_level', 'executive', 'career_changer', 'returning_professional'],
      confidence: Number
    },
    industries: [{
      name: String,
      experience_level: String,
      interest_level: Number,
      confidence: Number
    }],
    skills: [{
      name: String,
      level: {
        type: String,
        enum: ['beginner', 'intermediate', 'advanced', 'expert']
      },
      confidence: Number,
      lastMentioned: Date
    }],
    personalityTraits: [{
      trait: String,
      strength: Number,
      confidence: Number
    }],
    communicationStyle: {
      formality: {
        type: String,
        enum: ['very_formal', 'formal', 'neutral', 'casual', 'very_casual']
      },
      detail_preference: {
        type: String,
        enum: ['brief', 'moderate', 'detailed', 'comprehensive']
      },
      learning_style: {
        type: String,
        enum: ['visual', 'auditory', 'kinesthetic', 'reading']
      },
      feedback_preference: {
        type: String,
        enum: ['direct', 'gentle', 'detailed', 'actionable']
      }
    },
    goals: [{
      type: {
        type: String,
        enum: ['short_term', 'medium_term', 'long_term']
      },
      category: {
        type: String,
        enum: ['career', 'skill', 'personal', 'financial']
      },
      description: String,
      priority: Number,
      deadline: Date,
      progress: Number,
      confidence: Number
    }],
    preferences: {
      work_environment: [{
        type: String,
        preference_level: Number
      }],
      company_size: {
        type: String,
        enum: ['startup', 'small', 'medium', 'large', 'enterprise']
      },
      work_style: {
        type: String,
        enum: ['independent', 'collaborative', 'mixed']
      },
      communication_frequency: {
        type: String,
        enum: ['minimal', 'regular', 'frequent', 'constant']
      }
    }
  },

  // FIXED: Memory analytics with proper object schemas
  analytics: {
    totalMemories: {
      type: Number,
      default: 0
    },
    // FIXED: Array of objects with proper schema definition
    memoriesByType: [{
      _id: false,  // Disable _id for subdocuments
      type: {
        type: String,
        required: true
      },
      count: {
        type: Number,
        required: true
      }
    }],
    // FIXED: Array of objects with proper schema definition
    memoriesByCategory: [{
      _id: false,  // Disable _id for subdocuments
      category: {
        type: String,
        required: true
      },
      count: {
        type: Number,
        required: true
      }
    }],
    averageConfidence: {
      type: Number,
      default: 0
    },
    memoryAccuracy: {
      type: Number,
      default: 0
    },
    lastAnalyzedAt: Date,
    // FIXED: Array of insight objects with proper schema definition
    insights: [{
      _id: false,  // Disable _id for subdocuments
      type: {
        type: String,
        enum: ['pattern', 'opportunity', 'strength', 'challenge', 'recommendation'],
        required: true
      },
      description: {
        type: String,
        required: true
      },
      confidence: {
        type: Number,
        min: 0,
        max: 1,
        required: true
      },
      actionable: {
        type: Boolean,
        required: true
      },
      generatedAt: {
        type: Date,
        default: Date.now
      }
    }]
  },

  // Memory management settings
  settings: {
    memoryRetention: {
      type: String,
      enum: ['aggressive', 'normal', 'conservative'],
      default: 'normal'
    },
    autoDecay: {
      type: Boolean,
      default: true
    },
    requireVerification: {
      type: Boolean,
      default: false
    },
    shareInsights: {
      type: Boolean,
      default: true
    },
    maxMemories: {
      type: Number,
      default: 1000
    }
  },

  lastUpdated: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Indexes for efficient querying
userMemorySchema.index({ userId: 1 });
userMemorySchema.index({ 'memories.type': 1 });
userMemorySchema.index({ 'memories.category': 1 });
userMemorySchema.index({ 'memories.importance': 1 });
userMemorySchema.index({ 'memories.tags': 1 });
userMemorySchema.index({ 'memories.isActive': 1 });
userMemorySchema.index({ 'memories.confidence': -1 });

// Instance methods
userMemorySchema.methods.addMemory = function(memoryData) {
  const memoryId = `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  const memory = {
    id: memoryId,
    type: memoryData.type,
    category: memoryData.category,
    content: memoryData.content,
    confidence: memoryData.confidence || 0.8,
    importance: memoryData.importance || 'medium',
    source: {
      ...memoryData.source,
      timestamp: new Date()
    },
    context: memoryData.context || {},
    tags: memoryData.tags || [],
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  // Check for similar memories to avoid duplicates
  const similarMemory = this.findSimilarMemory(memory);
  if (similarMemory) {
    return this.reinforceMemory(similarMemory.id, memory);
  }
  
  this.memories.push(memory);
  this.analytics.totalMemories = this.memories.length;
  this.lastUpdated = new Date();
  
  return memory;
};

userMemorySchema.methods.findSimilarMemory = function(newMemory) {
  return this.memories.find(existing => 
    existing.type === newMemory.type &&
    existing.category === newMemory.category &&
    this.calculateSimilarity(existing.content, newMemory.content) > 0.8
  );
};

userMemorySchema.methods.calculateSimilarity = function(content1, content2) {
  const words1 = content1.toLowerCase().split(' ');
  const words2 = content2.toLowerCase().split(' ');
  const commonWords = words1.filter(word => words2.includes(word));
  return commonWords.length / Math.max(words1.length, words2.length);
};

userMemorySchema.methods.reinforceMemory = function(memoryId, reinforcementData) {
  const memory = this.memories.find(m => m.id === memoryId);
  if (memory) {
    memory.decay.lastReinforced = new Date();
    memory.decay.reinforcementCount += 1;
    memory.confidence = Math.min(1, memory.confidence + 0.1);
    
    if (reinforcementData) {
      memory.content = reinforcementData.content || memory.content;
      memory.tags = [...new Set([...memory.tags, ...(reinforcementData.tags || [])])];
    }
    
    this.lastUpdated = new Date();
    return memory;
  }
  return null;
};

userMemorySchema.methods.getMemoriesByType = function(type, options = {}) {
  let memories = this.memories.filter(m => m.type === type && m.isActive);
  
  if (options.minConfidence) {
    memories = memories.filter(m => m.confidence >= options.minConfidence);
  }
  
  if (options.importance) {
    memories = memories.filter(m => m.importance === options.importance);
  }
  
  return memories.sort((a, b) => {
    if (options.sortBy === 'confidence') return b.confidence - a.confidence;
    if (options.sortBy === 'recent') return new Date(b.updatedAt) - new Date(a.updatedAt);
    return b.decay.reinforcementCount - a.decay.reinforcementCount;
  });
};

userMemorySchema.methods.searchMemories = function(query, options = {}) {
  const searchRegex = new RegExp(query, 'i');
  
  let memories = this.memories.filter(m => 
    m.isActive && (
      searchRegex.test(m.content) ||
      m.tags.some(tag => searchRegex.test(tag)) ||
      searchRegex.test(m.type) ||
      searchRegex.test(m.category)
    )
  );
  
  if (options.minConfidence) {
    memories = memories.filter(m => m.confidence >= options.minConfidence);
  }
  
  return memories.sort((a, b) => b.confidence - a.confidence);
};

userMemorySchema.methods.getRelevantMemories = function(context, limit = 10) {
  let relevantMemories = [];
  
  // Get memories by context tags
  if (context.tags && context.tags.length > 0) {
    const taggedMemories = this.memories.filter(m => 
      m.isActive && m.tags.some(tag => context.tags.includes(tag))
    );
    relevantMemories.push(...taggedMemories);
  }
  
  // Get memories by type/category
  if (context.types && context.types.length > 0) {
    const typedMemories = this.memories.filter(m => 
      m.isActive && context.types.includes(m.type)
    );
    relevantMemories.push(...typedMemories);
  }
  
  // Get high-importance memories
  const importantMemories = this.memories.filter(m => 
    m.isActive && ['high', 'critical'].includes(m.importance)
  );
  relevantMemories.push(...importantMemories);
  
  // Remove duplicates and sort by relevance
  const uniqueMemories = Array.from(new Set(relevantMemories.map(m => m.id)))
    .map(id => relevantMemories.find(m => m.id === id))
    .sort((a, b) => {
      const aScore = this.calculateRelevanceScore(a, context);
      const bScore = this.calculateRelevanceScore(b, context);
      return bScore - aScore;
    });
  
  return uniqueMemories.slice(0, limit);
};

userMemorySchema.methods.calculateRelevanceScore = function(memory, context) {
  let score = memory.confidence;
  
  // Boost score for importance
  const importanceBoost = {
    'critical': 0.4,
    'high': 0.3,
    'medium': 0.1,
    'low': 0
  };
  score += importanceBoost[memory.importance] || 0;
  
  // Boost score for recent reinforcement
  const daysSinceReinforced = (Date.now() - memory.decay.lastReinforced) / (1000 * 60 * 60 * 24);
  score += Math.max(0, 0.2 - (daysSinceReinforced * 0.01));
  
  // Boost score for tag matches
  if (context.tags) {
    const tagMatches = memory.tags.filter(tag => context.tags.includes(tag)).length;
    score += tagMatches * 0.1;
  }
  
  return Math.min(1, score);
};

// FIXED: Update profile method with correct object structure - PROPER VERSION
userMemorySchema.methods.updateProfile = function() {
  // Initialize analytics if it doesn't exist
  if (!this.analytics) {
    this.analytics = {
      totalMemories: 0,
      memoriesByType: [],
      memoriesByCategory: [],
      averageConfidence: 0,
      insights: []
    };
  }

  const activeMemories = this.memories.filter(m => m.isActive);
  
  // Update basic analytics
  this.analytics.totalMemories = activeMemories.length;
  this.analytics.averageConfidence = activeMemories.length > 0 
    ? activeMemories.reduce((sum, m) => sum + m.confidence, 0) / activeMemories.length 
    : 0;
  
  // FIXED: Clear existing arrays before rebuilding
  this.analytics.memoriesByType = [];
  this.analytics.memoriesByCategory = [];
  
  // Update memory counts by type as objects
  const typeGroups = activeMemories.reduce((groups, memory) => {
    groups[memory.type] = (groups[memory.type] || 0) + 1;
    return groups;
  }, {});
  
  // FIXED: Build new array properly
  for (const [type, count] of Object.entries(typeGroups)) {
    this.analytics.memoriesByType.push({ type, count });
  }
  
  // Update memory counts by category as objects  
  const categoryGroups = activeMemories.reduce((groups, memory) => {
    groups[memory.category] = (groups[memory.category] || 0) + 1;
    return groups;
  }, {});
  
  // FIXED: Build new array properly
  for (const [category, count] of Object.entries(categoryGroups)) {
    this.analytics.memoriesByCategory.push({ category, count });
  }
  
  this.analytics.lastAnalyzedAt = new Date();
  this.lastUpdated = new Date();
  
  // Mark the analytics as modified to ensure Mongoose saves it
  this.markModified('analytics');
};

userMemorySchema.methods.decayMemories = function() {
  const now = Date.now();
  let decayedCount = 0;
  
  this.memories.forEach(memory => {
    if (!memory.isActive) return;
    
    const daysSinceReinforced = (now - memory.decay.lastReinforced) / (1000 * 60 * 60 * 24);
    const decayAmount = daysSinceReinforced * memory.decay.decayRate;
    
    memory.confidence = Math.max(0.1, memory.confidence - decayAmount);
    
    // Deactivate memories with very low confidence
    if (memory.confidence < 0.2) {
      memory.isActive = false;
      decayedCount++;
    }
  });
  
  if (decayedCount > 0) {
    this.updateProfile();
  }
  
  return decayedCount;
};

// Static methods
userMemorySchema.statics.findByUserId = function(userId) {
  return this.findOne({ userId });
};

userMemorySchema.statics.createForUser = function(userId) {
  return this.create({
    userId,
    memories: [],
    profile: {},
    analytics: {
      totalMemories: 0,
      memoriesByType: [],
      memoriesByCategory: [],
      averageConfidence: 0,
      memoryAccuracy: 0,
      insights: []
    },
    settings: {
      memoryRetention: 'normal',
      autoDecay: true,
      requireVerification: false,
      shareInsights: true,
      maxMemories: 1000
    }
  });
};

const UserMemory = mongoose.model('UserMemory', userMemorySchema);

module.exports = UserMemory;

================
File: backend/models/postgresql/schema.js
================
// backend/models/postgresql/schema.js - COMPLETE MONTHLY ONLY VERSION
const db = require('../../config/postgresql');

const createTables = async () => {
  try {
    console.log('Creating PostgreSQL tables...');
    
    // Industries Table with additional classification codes
    await db.query(`
      CREATE TABLE IF NOT EXISTS industries (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        description TEXT,
        sic_codes TEXT[],
        naics_codes TEXT[],
        primary_category VARCHAR(255),
        sub_category VARCHAR(255),
        hierarchical_category VARCHAR(255),
        all_industries TEXT[],
        all_sub_industries TEXT[],
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Locations Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS locations (
        id SERIAL PRIMARY KEY,
        street_address TEXT,
        city VARCHAR(100),
        state VARCHAR(100),
        postal_code VARCHAR(20),
        country VARCHAR(100) NOT NULL,
        is_remote BOOLEAN DEFAULT FALSE,
        full_address TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Companies Table with expanded fields
    await db.query(`
      CREATE TABLE IF NOT EXISTS companies (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        website VARCHAR(255),
        industry_id INTEGER REFERENCES industries(id),
        company_size VARCHAR(50),
        employee_count INTEGER,
        employee_range VARCHAR(50),
        founded_year INTEGER,
        headquarters_location_id INTEGER REFERENCES locations(id),
        description TEXT,
        logo_url VARCHAR(255),
        phone VARCHAR(50),
        fax VARCHAR(50),
        email_domain VARCHAR(255),
        revenue DECIMAL(15,2),
        revenue_range VARCHAR(50),
        revenue_usd_thousands INTEGER,
        ownership_type VARCHAR(50),
        business_model VARCHAR(50),
        stock_ticker VARCHAR(20),
        alexa_rank INTEGER,
        zoominfo_id VARCHAR(50),
        zoominfo_url TEXT,
        linkedin_url TEXT,
        facebook_url TEXT,
        twitter_url TEXT,
        funding_total DECIMAL(15,2),
        funding_total_usd_thousands INTEGER,
        recent_funding DECIMAL(15,2),
        recent_funding_usd_thousands INTEGER,
        recent_funding_round VARCHAR(50),
        recent_funding_date DATE,
        recent_investors TEXT[],
        all_investors TEXT[],
        location_count INTEGER,
        sic_codes TEXT[],
        naics_codes TEXT[],
        is_certified_active BOOLEAN DEFAULT FALSE,
        certification_date DATE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Add missing columns to companies table if they don't exist
    console.log('Checking and adding missing columns to companies table...');
    
    const companyColumnsToAdd = [
      { name: 'revenue_usd_thousands', type: 'INTEGER' },
      { name: 'funding_total_usd_thousands', type: 'INTEGER' },
      { name: 'recent_funding_usd_thousands', type: 'INTEGER' },
      { name: 'sic_codes', type: 'TEXT[]' },
      { name: 'naics_codes', type: 'TEXT[]' },
      { name: 'recent_investors', type: 'TEXT[]' },
      { name: 'all_investors', type: 'TEXT[]' },
      { name: 'is_certified_active', type: 'BOOLEAN DEFAULT FALSE' },
      { name: 'certification_date', type: 'DATE' },
      { name: 'zoominfo_id', type: 'VARCHAR(50)' },
      { name: 'zoominfo_url', type: 'TEXT' },
      { name: 'stock_ticker', type: 'VARCHAR(20)' },
      { name: 'alexa_rank', type: 'INTEGER' },
      { name: 'location_count', type: 'INTEGER' },
      { name: 'recent_funding_round', type: 'VARCHAR(50)' },
      { name: 'recent_funding_date', type: 'DATE' }
    ];

    for (const column of companyColumnsToAdd) {
      try {
        await db.query(`
          ALTER TABLE companies ADD COLUMN IF NOT EXISTS ${column.name} ${column.type};
        `);
        console.log(`✅ Added column ${column.name} to companies table`);
      } catch (error) {
        console.log(`Column ${column.name} already exists or cannot be added: ${error.message}`);
      }
    }

    // Add unique constraint to companies if it doesn't exist
    try {
      await db.query(`
        ALTER TABLE companies ADD CONSTRAINT companies_name_website_unique UNIQUE (name, website);
      `);
    } catch (error) {
      // Constraint might already exist, that's okay
      console.log('Companies unique constraint already exists or cannot be added');
    }
    
    // Recruiters Table with expanded fields for CSV data
    await db.query(`
      CREATE TABLE IF NOT EXISTS recruiters (
        id SERIAL PRIMARY KEY,
        first_name VARCHAR(100) NOT NULL,
        last_name VARCHAR(100) NOT NULL,
        middle_name VARCHAR(100),
        salutation VARCHAR(20),
        suffix VARCHAR(20),
        email VARCHAR(255),
        email_domain VARCHAR(255),
        supplemental_email VARCHAR(255),
        direct_phone VARCHAR(50),
        mobile_phone VARCHAR(50),
        current_company_id INTEGER REFERENCES companies(id),
        title VARCHAR(255),
        job_title_hierarchy_level INTEGER,
        management_level VARCHAR(50),
        job_start_date DATE,
        job_function VARCHAR(100),
        department VARCHAR(100),
        company_division VARCHAR(100),
        education_level VARCHAR(100),
        highest_education VARCHAR(100),
        accuracy_score INTEGER,
        accuracy_grade VARCHAR(10),
        contact_accuracy_score INTEGER,
        contact_accuracy_grade VARCHAR(10),
        zoominfo_url TEXT,
        linkedin_url TEXT,
        zoominfo_profile_url TEXT,
        linkedin_profile_url TEXT,
        notice_provided_date DATE,
        location_id INTEGER REFERENCES locations(id),
        industry_id INTEGER REFERENCES industries(id),
        specializations VARCHAR(255)[],
        experience_years INTEGER,
        last_active_date DATE,
        rating DECIMAL(3,2),
        notes TEXT,
        is_active BOOLEAN DEFAULT TRUE,
        last_contacted DATE,
        contact_attempts INTEGER DEFAULT 0,
        response_rate DECIMAL(5,2) DEFAULT 0,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Add missing columns to recruiters table if they don't exist
    console.log('Checking and adding missing columns to recruiters table...');
    
    const recruiterColumnsToAdd = [
      { name: 'person_street', type: 'VARCHAR(255)' },
      { name: 'person_city', type: 'VARCHAR(100)' },
      { name: 'person_state', type: 'VARCHAR(100)' },
      { name: 'person_zip_code', type: 'VARCHAR(20)' },
      { name: 'person_country', type: 'VARCHAR(100)' },
      { name: 'is_active', type: 'BOOLEAN DEFAULT TRUE' }
    ];

    for (const column of recruiterColumnsToAdd) {
      try {
        await db.query(`
          ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS ${column.name} ${column.type};
        `);
        console.log(`✅ Added column ${column.name} to recruiters table`);
      } catch (error) {
        console.log(`Column ${column.name} already exists or cannot be added`);
      }
    }

    // Add unique constraint to recruiters email if it doesn't exist
    try {
      await db.query(`
        ALTER TABLE recruiters ADD CONSTRAINT recruiters_email_unique UNIQUE (email);
      `);
    } catch (error) {
      // Constraint might already exist, that's okay
      console.log('Recruiters email unique constraint already exists or cannot be added');
    }
    
    // Skills Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS skills (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        category VARCHAR(100),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // RecruiterSkills Table (Junction)
    await db.query(`
      CREATE TABLE IF NOT EXISTS recruiter_skills (
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        skill_id INTEGER REFERENCES skills(id) ON DELETE CASCADE,
        PRIMARY KEY (recruiter_id, skill_id)
      );
    `);
    
    // Outreach Campaigns Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_campaigns (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(50) NOT NULL,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        status VARCHAR(50) DEFAULT 'active',
        target_job_title VARCHAR(255),
        target_companies TEXT[],
        target_locations TEXT[],
        message_template TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);

    // Outreach Messages Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_messages (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(50) NOT NULL,
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        campaign_id INTEGER REFERENCES outreach_campaigns(id) ON DELETE SET NULL,
        subject VARCHAR(255),
        message_content TEXT NOT NULL,
        sent_via VARCHAR(50) DEFAULT 'email',
        sent_at TIMESTAMP,
        status VARCHAR(50) DEFAULT 'draft',
        response_received BOOLEAN DEFAULT FALSE,
        response_content TEXT,
        response_received_at TIMESTAMP,
        follow_up_scheduled DATE,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);
    
    // OutreachHistory Table (Connecting MongoDB to PostgreSQL)
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_history (
        id SERIAL PRIMARY KEY,
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        mongodb_outreach_id VARCHAR(24) NOT NULL,
        mongodb_user_id VARCHAR(24) NOT NULL,
        status VARCHAR(50) NOT NULL,
        last_contact_date TIMESTAMP,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // EmailTemplates Table for outreach
    await db.query(`
      CREATE TABLE IF NOT EXISTS email_templates (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        subject_template TEXT NOT NULL,
        body_template TEXT NOT NULL,
        context_variables JSONB,
        category VARCHAR(100),
        tags VARCHAR(50)[],
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Job Boards Table for scraping
    await db.query(`
      CREATE TABLE IF NOT EXISTS job_boards (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        url TEXT NOT NULL,
        scraping_config JSONB,
        is_active BOOLEAN DEFAULT TRUE,
        last_scraped_at TIMESTAMP,
        scraping_frequency_hours INTEGER DEFAULT 24,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // ======================================
    // SUBSCRIPTION TABLES (MONTHLY ONLY)
    // ======================================

    // Subscription Plans Table - Monthly only pricing
    await db.query(`
      CREATE TABLE IF NOT EXISTS subscription_plans (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100) NOT NULL UNIQUE,
        display_name VARCHAR(255) NOT NULL,
        description TEXT,
        price_monthly DECIMAL(10,2) NOT NULL DEFAULT 0,
        stripe_monthly_price_id VARCHAR(255),
        features JSONB NOT NULL DEFAULT '{}',
        limits JSONB NOT NULL DEFAULT '{}',
        is_active BOOLEAN DEFAULT TRUE,
        sort_order INTEGER DEFAULT 0,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // User Subscriptions Table - Monthly billing only
    await db.query(`
      CREATE TABLE IF NOT EXISTS user_subscriptions (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(24) NOT NULL UNIQUE,
        subscription_plan_id INTEGER REFERENCES subscription_plans(id),
        stripe_customer_id VARCHAR(255),
        stripe_subscription_id VARCHAR(255),
        status VARCHAR(50) NOT NULL DEFAULT 'active',
        current_period_start TIMESTAMP,
        current_period_end TIMESTAMP,
        cancel_at_period_end BOOLEAN DEFAULT FALSE,
        canceled_at TIMESTAMP,
        trial_start TIMESTAMP,
        trial_end TIMESTAMP,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // User Usage Tracking Table - Monthly usage tracking per feature
    await db.query(`
      CREATE TABLE IF NOT EXISTS user_usage (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(24) NOT NULL,
        usage_period DATE NOT NULL,
        resume_uploads INTEGER DEFAULT 0,
        resume_analysis INTEGER DEFAULT 0,
        job_imports INTEGER DEFAULT 0,
        resume_tailoring INTEGER DEFAULT 0,
        recruiter_unlocks INTEGER DEFAULT 0,
        ai_job_discovery INTEGER DEFAULT 0,
        ai_conversations INTEGER DEFAULT 0,
        ai_messages_total INTEGER DEFAULT 0,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
        UNIQUE(user_id, usage_period)
      );
    `);

    // AI Assistant Usage Table - Detailed AI conversation tracking
    await db.query(`
      CREATE TABLE IF NOT EXISTS ai_assistant_usage (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(24) NOT NULL,
        conversation_id VARCHAR(24),
        message_count INTEGER DEFAULT 1,
        tokens_used INTEGER DEFAULT 0,
        cost_usd DECIMAL(10,4) DEFAULT 0,
        feature_type VARCHAR(100),
        usage_date DATE NOT NULL DEFAULT CURRENT_DATE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Payment History Table - Transaction records
    await db.query(`
      CREATE TABLE IF NOT EXISTS payment_history (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(24) NOT NULL,
        stripe_payment_intent_id VARCHAR(255) UNIQUE,
        stripe_invoice_id VARCHAR(255),
        amount DECIMAL(10,2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'usd',
        status VARCHAR(50) NOT NULL,
        payment_method VARCHAR(100),
        billing_reason VARCHAR(100),
        description TEXT,
        invoice_url TEXT,
        receipt_url TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Webhook Events Table - Track Stripe webhook events for debugging
    await db.query(`
      CREATE TABLE IF NOT EXISTS webhook_events (
        id SERIAL PRIMARY KEY,
        stripe_event_id VARCHAR(255) UNIQUE NOT NULL,
        event_type VARCHAR(100) NOT NULL,
        processed BOOLEAN DEFAULT FALSE,
        data JSONB,
        error_message TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        processed_at TIMESTAMP
      );
    `);
    
    console.log('✅ Tables created successfully');
    
    // Create Indexes
    console.log('Creating indexes...');
    
    const basicIndexes = [
      'CREATE INDEX IF NOT EXISTS idx_recruiters_company ON recruiters(current_company_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_industry ON recruiters(industry_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_location ON recruiters(location_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_name ON recruiters(last_name, first_name)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_email ON recruiters(email)',
      'CREATE INDEX IF NOT EXISTS idx_companies_industry ON companies(industry_id)',
      'CREATE INDEX IF NOT EXISTS idx_companies_name ON companies(name)',
      'CREATE INDEX IF NOT EXISTS idx_companies_domain ON companies(email_domain)',
      'CREATE INDEX IF NOT EXISTS idx_companies_website ON companies(website)',
      'CREATE INDEX IF NOT EXISTS idx_recruiter_skills ON recruiter_skills(skill_id)',
      'CREATE INDEX IF NOT EXISTS idx_skills_name ON skills(name)',
      'CREATE INDEX IF NOT EXISTS idx_skills_category ON skills(category)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_recruiter ON outreach_history(recruiter_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_mongodb_ids ON outreach_history(mongodb_outreach_id, mongodb_user_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_user ON outreach_messages(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_recruiter ON outreach_messages(recruiter_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_status ON outreach_messages(status)',
      
      // Subscription-related indexes
      'CREATE INDEX IF NOT EXISTS idx_user_subscriptions_user_id ON user_subscriptions(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_user_subscriptions_stripe_customer ON user_subscriptions(stripe_customer_id)',
      'CREATE INDEX IF NOT EXISTS idx_user_subscriptions_status ON user_subscriptions(status)',
      'CREATE INDEX IF NOT EXISTS idx_user_usage_user_period ON user_usage(user_id, usage_period)',
      'CREATE INDEX IF NOT EXISTS idx_ai_usage_user_date ON ai_assistant_usage(user_id, usage_date)',
      'CREATE INDEX IF NOT EXISTS idx_payment_history_user ON payment_history(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_payment_history_stripe_payment ON payment_history(stripe_payment_intent_id)',
      'CREATE INDEX IF NOT EXISTS idx_webhook_events_stripe_id ON webhook_events(stripe_event_id)',
      'CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed)',
      'CREATE INDEX IF NOT EXISTS idx_subscription_plans_active ON subscription_plans(is_active, sort_order)'
    ];

    for (const indexQuery of basicIndexes) {
      try {
        await db.query(indexQuery);
      } catch (error) {
        console.log(`Index creation failed (this is usually okay): ${error.message}`);
      }
    }
    
    console.log('✅ Indexes created successfully');
    console.log('✅ PostgreSQL tables setup completed successfully');
    
  } catch (error) {
    console.error('Error creating PostgreSQL tables:', error);
    throw error;
  }
};

// Function to seed some initial data for testing
const seedInitialData = async () => {
  try {
    // Seed industry data
    const industryCount = await db.query('SELECT COUNT(*) FROM industries');
    
    if (parseInt(industryCount.rows[0].count) === 0) {
      console.log('Seeding initial industry data...');
      
      await db.query(`
        INSERT INTO industries (name, description, primary_category, sub_category) VALUES
        ('Business Services', 'Business consulting, professional services', 'Business Services', 'Custom Software & IT Services'),
        ('Technology', 'Software, hardware, and IT services', 'Business Services', 'Custom Software & IT Services'),
        ('Healthcare', 'Medical services, pharmaceuticals, and healthcare technology', 'Healthcare', 'Healthcare Services'),
        ('Finance', 'Banking, investments, and financial services', 'Financial Services', 'Banking & Financial Services'),
        ('Education', 'Schools, universities, and educational technology', 'Education', 'Education Services'),
        ('Manufacturing', 'Production of goods and related services', 'Manufacturing', 'General Manufacturing'),
        ('Telecommunications', 'Telecom infrastructure and services', 'Telecommunications', 'Telephony & Wireless'),
        ('HR & Staffing', 'Human resources and staffing services', 'Business Services', 'HR & Staffing')
        ON CONFLICT (name) DO NOTHING;
      `);
      
      console.log('Initial industry data seeded successfully');
    }
    
    // Seed skills data
    const skillCount = await db.query('SELECT COUNT(*) FROM skills');
    
    if (parseInt(skillCount.rows[0].count) === 0) {
      console.log('Seeding initial skill data...');
      
      await db.query(`
        INSERT INTO skills (name, category) VALUES
        ('JavaScript', 'Programming Languages'),
        ('Python', 'Programming Languages'),
        ('Java', 'Programming Languages'),
        ('React', 'Frontend Development'),
        ('Node.js', 'Backend Development'),
        ('AWS', 'Cloud Computing'),
        ('SQL', 'Database'),
        ('Machine Learning', 'Data Science'),
        ('Product Management', 'Management'),
        ('Technical Recruiting', 'Recruiting'),
        ('Business Development', 'Sales'),
        ('Talent Acquisition', 'Recruiting'),
        ('HR Specialist', 'Human Resources'),
        ('ERP Support', 'Technical Support')
        ON CONFLICT (name) DO NOTHING;
      `);
      
      console.log('Initial skill data seeded successfully');
    }

    // Seed subscription plans (MONTHLY ONLY)
    const planCount = await db.query('SELECT COUNT(*) FROM subscription_plans');
    
    if (parseInt(planCount.rows[0].count) === 0) {
      console.log('Seeding monthly subscription plans...');
      
      await db.query(`
        INSERT INTO subscription_plans (
          name, 
          display_name, 
          description, 
          price_monthly,
          stripe_monthly_price_id,
          features,
          limits,
          sort_order
        ) VALUES
        (
          'free',
          'Free',
          'Perfect for getting started with job searching',
          0.00,
          NULL,
          '{"resumeUploads": true, "resumeAnalysis": true, "jobImports": true, "resumeTailoring": true, "recruiterAccess": false, "aiJobDiscovery": false, "aiAssistant": false}',
          '{"resumeUploads": 1, "resumeAnalysis": 1, "jobImports": 3, "resumeTailoring": 1, "recruiterUnlocks": 0, "aiJobDiscovery": 0, "aiAssistant": false, "aiConversations": 0, "aiMessagesPerConversation": 0}',
          1
        ),
        (
          'casual',
          'Casual',
          'For active job seekers who want more tools',
          19.99,
          'price_casual_monthly_placeholder',
          '{"resumeUploads": true, "resumeAnalysis": true, "jobImports": true, "resumeTailoring": true, "recruiterAccess": true, "recruiterUnlocks": true, "aiJobDiscovery": true, "aiAssistant": false}',
          '{"resumeUploads": 5, "resumeAnalysis": 5, "jobImports": 25, "resumeTailoring": 25, "recruiterUnlocks": 25, "aiJobDiscovery": 1, "aiAssistant": false, "aiConversations": 0, "aiMessagesPerConversation": 0}',
          2
        ),
        (
          'hunter',
          'Hunter',
          'For serious job hunters who want unlimited access',
          49.99,
          'price_hunter_monthly_placeholder',
          '{"resumeUploads": true, "resumeAnalysis": true, "jobImports": true, "resumeTailoring": true, "recruiterAccess": true, "recruiterUnlocks": true, "aiJobDiscovery": true, "aiAssistant": true}',
          '{"resumeUploads": -1, "resumeAnalysis": -1, "jobImports": -1, "resumeTailoring": 50, "recruiterUnlocks": -1, "aiJobDiscovery": -1, "aiAssistant": true, "aiConversations": 5, "aiMessagesPerConversation": 20}',
          3
        )
        ON CONFLICT (name) DO NOTHING;
      `);
      
      console.log('Monthly subscription plans seeded successfully');
      console.log('⚠️ Remember to update the stripe_monthly_price_id values with your actual Stripe price IDs!');
    }
    
    console.log('Basic initial data seeded successfully');
  } catch (error) {
    console.error('Error seeding initial data:', error);
    throw error;
  }
};

module.exports = { createTables, seedInitialData };

================
File: backend/package.json
================
{
  "name": "auto-job-backend",
  "version": "1.0.0",
  "description": "Auto-Job.ai Backend API",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "build": "echo 'No build step needed for Node.js'",
    "test": "echo 'No tests specified'",
    "setup:db": "node models/postgresql/schema.js"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=8.0.0"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.24.0",
    "@aws-sdk/client-s3": "^3.450.0",
    "@aws-sdk/s3-request-presigner": "^3.450.0",
    "aws-sdk": "^2.1450.0",
    "axios": "^1.6.2",
    "bcryptjs": "^2.4.3",
    "cheerio": "^1.1.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "docx": "^8.2.2",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^6.8.1",
    "express-validator": "^7.2.1",
    "helmet": "^7.0.0",
    "hpp": "^0.2.3",
    "jsonwebtoken": "^9.0.2",
    "mammoth": "^1.6.0",
    "mongoose": "^7.5.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "multer-s3": "^3.0.1",
    "nodemailer": "^6.9.4",
    "openai": "^4.0.0",
    "pdf-parse": "^1.1.1",
    "pdfkit": "^0.14.0",
    "pg": "^8.11.0",
    "playwright": "^1.53.1",
    "puppeteer": "^24.10.2",
    "stripe": "^18.2.1",
    "user-agents": "^1.1.582",
    "uuid": "^9.0.1",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "keywords": [
    "job",
    "ai",
    "recruitment",
    "api",
    "autojob"
  ],
  "author": "Auto-Job.ai",
  "license": "MIT"
}

================
File: backend/railway.json
================
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "npm install"
  },
  "deploy": {
    "startCommand": "npm start",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}

================
File: backend/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-12T01:59:41.292Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
config/anthropic.js
config/jobBoards.js
config/mongodb.js
config/openai.js
config/postgresql.js
config/s3.js
controllers/assistant.controller.js
controllers/auth.controller.js
controllers/job.controller.js
controllers/recruiter.controller.js
controllers/resume.controller.js
controllers/search.controller.js
controllers/settings.controller.js
debug-controller-params.js
debug-recruiter-search.js
debug-search-query.js
middleware/auth.middleware.js
middleware/validation.middleware.js
models/mongodb/aiAgent.model.js
models/mongodb/aiJobSearch.model.js
models/mongodb/assistantSession.model.js
models/mongodb/conversation.model.js
models/mongodb/job.model.js
models/mongodb/outreach.model.js
models/mongodb/resume.model.js
models/mongodb/user.model.js
models/mongodb/userMemory.model.js
models/postgresql/schema.js
package.json
routes/assistant.routes.js
routes/auth.routes.js
routes/job.routes.js
routes/recruiter.routes.js
routes/resume.routes.js
routes/search.routes.js
routes/settings.routes.js
routes/test.routes.js
scripts/fix-missing-columns.js
scripts/fix-outreach-history.js
scripts/import-recruiters.js
scripts/update-recruiter-industries.js
server.js
services/assistant.service.js
services/conversationService.js
services/jobAnalysis.service.js
services/jobMatching.service.js
services/jobSearch.service.js
services/memoryService.js
services/realJobBoard.service.js
services/recruiterImport.service.js
services/resumeAnalysis.service.js
services/resumeEditor.service.js
services/resumeParser.service.js
services/resumeTailoring.service.js
test-controller.js
test-extraction.js
test-s3.js
tests/test-auth.js
tests/test-neon-connection.js
utils/email-templates.js
utils/jobBoardPatterns.js
utils/recruiter-importer.js
utils/send-email.js
verify-controller.js

================================================================
Repository Files
================================================================

================
File: config/anthropic.js
================
const Anthropic = require('@anthropic-ai/sdk');

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

module.exports = { anthropic };

================
File: config/jobBoards.js
================
// config/jobBoards.js - REAL JOB BOARD CONFIGURATION
module.exports = {
  // Supported job board platforms
  platforms: {
    greenhouse: {
      name: 'Greenhouse',
      displayName: 'Greenhouse',
      icon: '🌱',
      description: 'Tech startups and scale-ups with comprehensive job details',
      urlPatterns: [
        'greenhouse.io/jobs',
        'greenhouse.io/job',
        'boards.greenhouse.io'
      ],
      searchPriority: 1, // Higher priority for tech roles
      expectedFeatures: [
        'Comprehensive job descriptions',
        'Team and culture information',
        'Tech stack details',
        'Interview process overview'
      ],
      targetCompanyTypes: [
        'Tech startups',
        'Scale-ups',
        'Venture-backed companies',
        'Y Combinator companies',
        'Series A-C companies'
      ],
      averageContentQuality: 'high',
      searchModifiers: ['site:greenhouse.io', 'inurl:jobs'],
      apiEndpoints: {
        // Note: These would be used if we had direct API access
        publicJobs: 'https://boards-api.greenhouse.io/v1/boards/{board_token}/jobs',
        departments: 'https://boards-api.greenhouse.io/v1/boards/{board_token}/departments'
      }
    },
    
    lever: {
      name: 'Lever',
      displayName: 'Lever',
      icon: '⚡',
      description: 'Growth-stage companies with detailed role information',
      urlPatterns: [
        'jobs.lever.co',
        'lever.co/jobs'
      ],
      searchPriority: 2,
      expectedFeatures: [
        'Detailed role descriptions',
        'Career progression paths',
        'Team structure information',
        'Hiring manager details'
      ],
      targetCompanyTypes: [
        'Growth-stage companies',
        'Expanding teams',
        'Series A-D companies',
        'Scale-ups with clear structure'
      ],
      averageContentQuality: 'high',
      searchModifiers: ['site:lever.co', 'inurl:jobs'],
      apiEndpoints: {
        // Note: These would be used if we had direct API access
        postings: 'https://api.lever.co/v0/postings/{company}',
        departments: 'https://api.lever.co/v0/postings/{company}?group=department'
      }
    },
    
    indeed: {
      name: 'Indeed',
      displayName: 'Indeed',
      icon: '🔍',
      description: 'Established companies with verified direct postings',
      urlPatterns: [
        'indeed.com/viewjob',
        'indeed.com/jobs',
        'indeed.com/job'
      ],
      searchPriority: 3, // Lower priority but good for established companies
      expectedFeatures: [
        'Direct company postings',
        'Verified employer accounts',
        'Complete job details',
        'Application instructions'
      ],
      targetCompanyTypes: [
        'Established companies',
        'Enterprise organizations',
        'Public companies',
        'Direct employers'
      ],
      averageContentQuality: 'medium',
      searchModifiers: ['site:indeed.com', 'inurl:viewjob', '-recruiter', '-staffing'],
      exclusionKeywords: [
        'staffing',
        'recruiting',
        'placement',
        'consulting firm',
        'headhunter'
      ]
    }
  },
  
  // Search configuration
  searchConfig: {
    maxJobsPerPlatform: 5,
    maxTotalJobs: 12,
    minContentLength: 400,
    maxPostingAge: 30, // days
    timeoutPerPlatform: 30000, // 30 seconds
    retryAttempts: 2,
    rateLimitDelay: 1000, // 1 second between requests
    
    // Quality thresholds
    qualityThresholds: {
      minQualityScore: 60,
      minMatchScore: 70,
      requiredSections: ['requirements', 'responsibilities'],
      preferredSections: ['benefits', 'tech_stack', 'team_info']
    },
    
    // Search strategy
    searchStrategy: {
      useParallelSearch: false, // Sequential to avoid rate limiting
      prioritizeRecent: true,
      diversifyPlatforms: true,
      maxSearchQueriesPerPlatform: 3
    }
  },
  
  // Content validation rules
  contentValidation: {
    minWordCount: 100,
    maxWordCount: 5000,
    requiredKeywords: {
      jobPosting: ['position', 'role', 'job', 'opportunity'],
      requirements: ['requirement', 'qualification', 'skill', 'experience'],
      company: ['company', 'team', 'organization', 'we are']
    },
    blacklistedKeywords: [
      'this posting has expired',
      'job no longer available',
      'position filled',
      'scam',
      'pyramid scheme'
    ],
    urlValidation: {
      allowedProtocols: ['https'],
      requiredDomains: ['greenhouse.io', 'lever.co', 'indeed.com'],
      blockedDomains: ['spam.com', 'fake-jobs.com']
    }
  },
  
  // Platform-specific extraction rules
  extractionRules: {
    greenhouse: {
      selectors: {
        title: '.app-title, [data-qa="job-title"]',
        description: '.job-post-content, [data-qa="job-description"]',
        requirements: '.requirements, [data-qa="requirements"]',
        team: '.team-info, [data-qa="team"]',
        benefits: '.benefits, [data-qa="benefits"]'
      },
      identifierPatterns: {
        jobId: /\/jobs\/(\d+)/,
        officeId: /office_id=(\d+)/
      }
    },
    
    lever: {
      selectors: {
        title: '.posting-headline, [data-qa="posting-name"]',
        description: '.posting-description, [data-qa="posting-description"]',
        team: '.posting-categories, [data-qa="posting-team"]',
        requirements: '.posting-requirements'
      },
      identifierPatterns: {
        company: /jobs\.lever\.co\/([^\/]+)/,
        postingId: /jobs\.lever\.co\/[^\/]+\/([^\/\?]+)/
      }
    },
    
    indeed: {
      selectors: {
        title: '[data-jk] h1, .jobsearch-JobInfoHeader-title',
        description: '.jobsearch-jobDescriptionText, #jobDescriptionText',
        company: '[data-jk] .jobsearch-CompanyInfoContainer',
        salary: '.jobsearch-JobMetadataHeader-item'
      },
      identifierPatterns: {
        jobKey: /jk=([^&]+)/,
        companyId: /cmp=([^&]+)/
      }
    }
  },
  
  // Error handling configuration
  errorHandling: {
    retryableErrors: [
      'TIMEOUT',
      'RATE_LIMITED',
      'TEMPORARY_FAILURE',
      'NETWORK_ERROR'
    ],
    fatalErrors: [
      'INVALID_CREDENTIALS',
      'BLOCKED_ACCESS',
      'PLATFORM_DISCONTINUED'
    ],
    fallbackStrategies: {
      onPlatformFailure: 'continue_with_other_platforms',
      onAllPlatformFailure: 'return_partial_results',
      onContentExtractionFailure: 'use_fallback_extraction'
    }
  },
  
  // Analytics and monitoring
  analytics: {
    trackSearchPerformance: true,
    trackContentQuality: true,
    trackUserEngagement: true,
    metrics: {
      searchLatency: 'platform_search_duration',
      extractionSuccess: 'content_extraction_rate',
      qualityScore: 'average_content_quality',
      userSatisfaction: 'job_application_rate'
    }
  },
  
  // Rate limiting and respectful scraping
  respectfulScraping: {
    observeRobotsTxt: true,
    respectRateLimits: true,
    userAgent: 'auto-job.ai-bot/1.0 (Job Discovery Service)',
    crawlDelay: 1000, // 1 second between requests
    concurrentRequests: 1, // Sequential processing
    sessionRotation: true
  },
  
  // Legal and compliance
  compliance: {
    respectTermsOfService: true,
    attributeSource: true,
    respectCopyright: true,
    dataRetentionDays: 90,
    anonymizeUserData: true,
    complianceNotes: [
      'All job board searches respect terms of service',
      'Content is used for matching purposes only',
      'No bulk downloading or data resale',
      'Attribution to original job boards maintained'
    ]
  },
  
  // Cost optimization
  costOptimization: {
    claudeSearchCost: 0.35, // Average cost per search with Claude
    gpt4AnalysisCost: 0.02, // Average cost per job analysis
    targetTotalCost: 0.57, // Target cost per complete search
    optimizations: [
      'Batch processing for analysis',
      'Efficient content extraction',
      'Smart retry logic',
      'Quality-based filtering'
    ]
  }
};

================
File: config/mongodb.js
================
const mongoose = require('mongoose');
require('dotenv').config();

const connectMongoDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = connectMongoDB;

================
File: config/openai.js
================
// config/openai.js
const OpenAI = require('openai');
require('dotenv').config();

// Initialize the OpenAI client with your API key
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Log a message to help with debugging
if (!process.env.OPENAI_API_KEY) {
  console.warn('WARNING: OPENAI_API_KEY environment variable is not defined. AI features will not work.');
} else {
  console.log('OpenAI configuration loaded successfully');
}

module.exports = { openai };

================
File: config/postgresql.js
================
// backend/config/postgresql.js
const { Pool } = require('pg');
require('dotenv').config();

// Create a connection pool
const pool = new Pool({
  connectionString: process.env.POSTGRES_URI,
  ssl: {
    rejectUnauthorized: false // Required for Neon and many other cloud PostgreSQL providers
  }
});

// Test connection function
const testConnection = async () => {
  let client;
  try {
    client = await pool.connect();
    console.log('PostgreSQL connected successfully');
    return true;
  } catch (error) {
    console.error('PostgreSQL connection error:', error);
    return false;
  } finally {
    if (client) client.release();
  }
};

// Execute when module is loaded to test the connection
testConnection();

module.exports = {
  query: (text, params) => pool.query(text, params),
  pool,
  testConnection
};

================
File: config/s3.js
================
// config/s3.js
const { S3Client } = require('@aws-sdk/client-s3');
require('dotenv').config();

// Create S3 client with proper configuration
const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-2',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
  }
});

// Export the AWS S3 bucket name as a constant
// Look for either AWS_S3_BUCKET or AWS_BUCKET_NAME to be backward compatible
const S3_BUCKET = process.env.AWS_S3_BUCKET || process.env.AWS_BUCKET_NAME;

// If the bucket name is not defined, log a warning
if (!S3_BUCKET) {
  console.warn('WARNING: AWS_BUCKET_NAME environment variable is not defined. File uploads will fail.');
}

module.exports = { s3Client, S3_BUCKET };

================
File: controllers/assistant.controller.js
================
// controllers/assistant.controller.js - COMPLETE WITH RESUME EDITING AND ANALYSIS REFRESH
const { openai } = require('../config/openai');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const User = require('../models/mongodb/user.model');
const Conversation = require('../models/mongodb/conversation.model');
const UserMemory = require('../models/mongodb/userMemory.model');
const MemoryService = require('../services/memoryService');
const ConversationService = require('../services/conversationService');

// ===================================================================
// CORE AI CHAT WITH MEMORY & CONVERSATIONS
// ===================================================================

/**
 * Enhanced chat endpoint with ACTUAL resume editing using your existing service
 */
exports.chat = async (req, res) => {
  try {
    const userId = req.user._id;
    const { 
      message, 
      context, 
      conversationHistory, 
      conversationId, 
      newConversation = false 
    } = req.body;

    if (!message || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Message is required'
      });
    }

    console.log(`🤖 AI Chat request from user ${userId}: ${message.substring(0, 50)}...`);

    // ================================================================
    // 🔧 RESUME EDITING: Detect and handle resume editing requests
    // ================================================================
    const isResumeEditingRequest = detectResumeEditingIntent(message, context);
    
    if (isResumeEditingRequest && context?.currentResume?.id) {
      console.log(`🎯 Detected resume editing request for resume: ${context.currentResume.id}`);
      
      try {
        // Use your existing ResumeEditorService
        const ResumeEditorService = require('../services/resumeEditor.service');
        
        // Apply the actual resume changes using your existing service
        const editResult = await ResumeEditorService.applyResumeChanges(
          context.currentResume.id,
          userId,
          message  // Your service handles natural language parsing
        );

        console.log(`✅ Resume editing completed:`, {
          changesCount: editResult.changes?.length || 0,
          newFileUrl: editResult.newFileUrl ? 'Generated' : 'Not generated',
          summary: editResult.changesSummary
        });

        // 🔥 CRITICAL FIX: Re-analyze the resume for new scores (like Auto-Fix button does)
        console.log(`🔍 Re-analyzing resume for updated scores...`);
        const resumeAnalysisService = require('../services/resumeAnalysis.service');
        const newAnalysis = await resumeAnalysisService.analyzeResume(context.currentResume.id);
        
        // Update the resume with new analysis
        const updatedResume = await Resume.findById(context.currentResume.id);
        updatedResume.analysis = newAnalysis;
        await updatedResume.save();
        
        console.log(`✅ Resume re-analysis completed:`, {
          previousScore: context.currentResume.score || 'Unknown',
          newOverallScore: newAnalysis.overallScore,
          newATSScore: newAnalysis.atsCompatibility
        });

        // Generate success response with actual changes and NEW SCORES
        const successMessage = `✅ I've successfully updated your resume "${context.currentResume.name}"!

${editResult.changesSummary}

📊 **Updated Scores:**
- Overall Score: ${newAnalysis.overallScore}%
- ATS Compatibility: ${newAnalysis.atsCompatibility}%

${editResult.changes?.length > 0 ? 
  `\nChanges made:\n${editResult.changes.map(change => 
    `• ${change.action.charAt(0).toUpperCase() + change.action.slice(1)} ${change.section}: ${change.reason || 'Updated content'}`
  ).join('\n')}` : 
  'Your resume has been improved and optimized.'
}

The updated resume with new scores is ready to download.`;

        // Save the interaction to conversation
        let conversation = await getOrCreateConversation(conversationId, userId, newConversation, message, context);
        
        await ConversationService.addMessage(conversation._id, {
          type: 'user',
          content: message,
          metadata: { 
            context, 
            isResumeEdit: true,
            resumeId: context.currentResume.id
          }
        });

        await ConversationService.addMessage(conversation._id, {
          type: 'ai',
          content: successMessage,
          metadata: {
            isResumeEdit: true,
            resumeChanges: editResult.changes,
            newFileUrl: editResult.newFileUrl,
            changesSummary: editResult.changesSummary,
            // 🔥 CRITICAL: Include new analysis scores
            newAnalysis: {
              overallScore: newAnalysis.overallScore,
              atsCompatibility: newAnalysis.atsCompatibility
            },
            suggestions: [
              'Make more changes',
              'Optimize for ATS', 
              'View updated resume',
              'Download new version'
            ]
          }
        });

        // Extract memories from this resume editing session
        try {
          await MemoryService.extractMemoriesFromMessage(userId, 
            `Updated resume: ${editResult.changesSummary}. New scores: Overall ${newAnalysis.overallScore}%, ATS ${newAnalysis.atsCompatibility}%`, 
            {
              conversationId: conversation._id,
              resumeId: context.currentResume.id,
              category: 'resume_improvement',
              tags: ['resume_editing', 'ai_assistance', 'score_improvement']
            }
          );
        } catch (memoryError) {
          console.warn('Memory extraction failed:', memoryError);
        }

        // Return success response with resume editing confirmation AND NEW SCORES
        return res.json({
          success: true,
          message: successMessage,
          suggestions: [
            'Make more changes',
            'Optimize for ATS', 
            'View updated resume',
            'Download new version'
          ],
          actions: [],
          confidence: 0.95,
          conversationId: conversation._id,
          conversationTitle: conversation.title,
          // Resume editing specific fields
          resumeUpdated: true, // ← Critical flag to trigger UI refresh
          resumeChanges: editResult.changes,
          newFileUrl: editResult.newFileUrl,
          changesSummary: editResult.changesSummary,
          // 🔥 CRITICAL FIX: Include new analysis data for frontend refresh
          newAnalysis: {
            overallScore: newAnalysis.overallScore,
            atsCompatibility: newAnalysis.atsCompatibility,
            strengths: newAnalysis.strengths,
            weaknesses: newAnalysis.weaknesses,
            improvementAreas: newAnalysis.improvementAreas
          },
          usage: {
            tokens: 0 // Resume editing tokens counted separately
          }
        });

      } catch (resumeEditError) {
        console.error('Resume editing failed:', resumeEditError);
        
        // Fall back to regular AI response with error context
        const errorMessage = `I encountered an issue updating your resume: ${resumeEditError.message}. Let me provide some guidance instead.

Here's what I would suggest for your resume improvement:
- Focus on quantifying your achievements with specific numbers
- Use strong action verbs to start each bullet point
- Ensure your skills section includes relevant keywords
- Consider adding more details about your AI and Python experience

Would you like me to try a different approach to updating your resume?`;
        
        return res.json({
          success: true,
          message: errorMessage,
          suggestions: [
            'Try a simpler request',
            'Focus on one section',
            'Check resume format',
            'Contact support'
          ],
          resumeEditError: true,
          error: resumeEditError.message
        });
      }
    }

    // ================================================================
    // 🤖 REGULAR AI CHAT: Continue with normal AI conversation
    // ================================================================
    
    // Get or create conversation
    let conversation = await getOrCreateConversation(conversationId, userId, newConversation, message, context);

    // Build AI context with memory
    const user = await User.findById(userId);
    const resumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    const jobs = await Job.find({ userId }).sort({ createdAt: -1 });
    const memoryContext = await MemoryService.buildAIContext(userId, context);
    
    const systemPrompt = buildSystemPrompt(user, resumes, jobs, context, conversation, memoryContext);
    const messages = buildMessages(systemPrompt, conversation.messages.slice(-10), message);

    // Call OpenAI for regular chat
    const aiResponse = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: messages,
      temperature: 0.7,
      max_tokens: 1200,
      presence_penalty: 0.1,
      frequency_penalty: 0.1
    });

    const aiMessage = aiResponse.choices[0].message.content;
    const parsedResponse = parseResponse(aiMessage, context);

    // Save messages to conversation
    await ConversationService.addMessage(conversation._id, {
      type: 'user',
      content: message,
      metadata: { context }
    });

    await ConversationService.addMessage(conversation._id, {
      type: 'ai',
      content: parsedResponse.message,
      metadata: {
        suggestions: parsedResponse.suggestions,
        actions: parsedResponse.actions,
        confidence: parsedResponse.confidence,
        tokens: aiResponse.usage?.total_tokens || 0
      }
    });

    // Extract memories from conversation
    try {
      await MemoryService.extractMemoriesFromMessage(userId, message, {
        conversationId: conversation._id,
        page: context?.page,
        category: conversation.category
      });
    } catch (memoryError) {
      console.warn('Memory extraction failed:', memoryError);
    }

    console.log(`✅ AI response generated (${aiResponse.usage?.total_tokens || 0} tokens)`);

    res.json({
      success: true,
      message: parsedResponse.message,
      suggestions: parsedResponse.suggestions,
      actions: parsedResponse.actions,
      confidence: parsedResponse.confidence,
      conversationId: conversation._id,
      conversationTitle: conversation.title,
      usage: {
        tokens: aiResponse.usage?.total_tokens || 0
      }
    });

  } catch (error) {
    console.error('Chat error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to process chat message',
      fallback_message: getFallbackResponse(req.body.message, req.body.context)
    });
  }
};

// [REST OF THE FILE REMAINS THE SAME - all other exports, helper functions, etc.]

// ===================================================================
// CONVERSATION MANAGEMENT
// ===================================================================

exports.getConversations = async (req, res) => {
  try {
    const userId = req.user._id;
    const options = {
      category: req.query.category,
      tags: req.query.tags ? req.query.tags.split(',') : undefined,
      search: req.query.search,
      pinned: req.query.pinned === 'true' ? true : req.query.pinned === 'false' ? false : undefined,
      starred: req.query.starred === 'true' ? true : req.query.starred === 'false' ? false : undefined,
      limit: parseInt(req.query.limit) || 20,
      offset: parseInt(req.query.offset) || 0,
      sortBy: req.query.sortBy || 'lastActiveAt'
    };

    const result = await ConversationService.getUserConversations(userId, options);
    res.json({ success: true, ...result });

  } catch (error) {
    console.error('Get conversations error:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch conversations' });
  }
};

exports.getConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const conversation = await ConversationService.getConversation(conversationId, userId);
    res.json({ success: true, conversation });
  } catch (error) {
    console.error('Get conversation error:', error);
    res.status(404).json({ success: false, error: 'Conversation not found' });
  }
};

exports.updateConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const conversation = await ConversationService.updateConversation(conversationId, userId, req.body);
    res.json({ success: true, conversation });
  } catch (error) {
    console.error('Update conversation error:', error);
    res.status(500).json({ success: false, error: 'Failed to update conversation' });
  }
};

exports.deleteConversation = async (req, res) => {
  try {
    const userId = req.user._id;
    const { conversationId } = req.params;
    const { permanent = false } = req.query;
    
    await ConversationService.deleteConversation(conversationId, userId, permanent === 'true');
    res.json({ success: true, message: 'Conversation deleted' });
  } catch (error) {
    console.error('Delete conversation error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete conversation' });
  }
};

// ===================================================================
// MEMORY MANAGEMENT
// ===================================================================

exports.getMemories = async (req, res) => {
  try {
    const userId = req.user._id;
    const { type, category, search, minConfidence = 0.5, limit = 50 } = req.query;

    const userMemory = await UserMemory.findByUserId(userId);
    if (!userMemory) {
      return res.json({ success: true, memories: [], total: 0 });
    }

    let memories = userMemory.memories.filter(m => m.isActive);

    // Apply filters
    if (type) memories = memories.filter(m => m.type === type);
    if (category) memories = memories.filter(m => m.category === category);
    if (search) {
      const searchRegex = new RegExp(search, 'i');
      memories = memories.filter(m => searchRegex.test(m.content) || m.tags.some(tag => searchRegex.test(tag)));
    }
    
    memories = memories.filter(m => m.confidence >= parseFloat(minConfidence));
    memories.sort((a, b) => b.confidence - a.confidence);

    res.json({
      success: true,
      memories: memories.slice(0, parseInt(limit)),
      total: memories.length,
      analytics: userMemory.analytics
    });

  } catch (error) {
    console.error('Get memories error:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch memories' });
  }
};

exports.updateMemory = async (req, res) => {
  try {
    const userId = req.user._id;
    const { memoryData } = req.body;

    const memory = await MemoryService.addMemoryToUser(userId, {
      ...memoryData,
      source: { extractionMethod: 'user_added', timestamp: new Date() }
    });

    res.json({ success: true, memory, message: 'Memory updated successfully' });
  } catch (error) {
    console.error('Update memory error:', error);
    res.status(500).json({ success: false, error: 'Failed to update memory' });
  }
};

exports.deleteMemory = async (req, res) => {
  try {
    const userId = req.user._id;
    const { memoryId } = req.params;

    const userMemory = await UserMemory.findByUserId(userId);
    if (!userMemory) {
      return res.status(404).json({ success: false, error: 'User memory not found' });
    }

    const memory = userMemory.memories.find(m => m.id === memoryId);
    if (!memory) {
      return res.status(404).json({ success: false, error: 'Memory not found' });
    }

    memory.isActive = false;
    userMemory.updateProfile();
    await userMemory.save();

    res.json({ success: true, message: 'Memory deleted successfully' });
  } catch (error) {
    console.error('Delete memory error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete memory' });
  }
};

/**
 * Get memory insights and analytics
 */
exports.getMemoryInsights = async (req, res) => {
  try {
    const userId = req.user._id;
    console.log('🧠 Getting memory insights for user:', userId);

    const userMemory = await UserMemory.findByUserId(userId);
    if (!userMemory) {
      console.log('📝 No user memory found, returning empty insights');
      return res.json({
        success: true,
        insights: [],
        analytics: {
          totalMemories: 0,
          averageConfidence: 0,
          memoriesByType: [],
          memoriesByCategory: []
        },
        profile: {}
      });
    }

    console.log('📊 Found user memory with', userMemory.memories?.length || 0, 'memories');

    // Generate fresh insights if needed
    if (!userMemory.analytics?.lastAnalyzedAt || 
        Date.now() - new Date(userMemory.analytics.lastAnalyzedAt).getTime() > 24 * 60 * 60 * 1000) {
      
      console.log('🔄 Generating fresh memory insights...');
      try {
        const insights = await generateMemoryInsights(userMemory);
        
        // Ensure analytics object exists
        if (!userMemory.analytics) {
          userMemory.analytics = {
            totalMemories: 0,
            memoriesByType: [],
            memoriesByCategory: [],
            averageConfidence: 0,
            insights: []
          };
        }
        
        userMemory.analytics.insights = insights;
        userMemory.analytics.lastAnalyzedAt = new Date();
        userMemory.updateProfile();
        
        await userMemory.save();
        console.log('✅ Generated and saved', insights.length, 'new insights');
      } catch (insightError) {
        console.error('⚠️ Error generating insights:', insightError);
      }
    }

    const response = {
      success: true,
      insights: userMemory.analytics?.insights || [],
      analytics: {
        totalMemories: userMemory.memories?.filter(m => m.isActive).length || 0,
        averageConfidence: userMemory.analytics?.averageConfidence || 0,
        memoriesByType: userMemory.analytics?.memoriesByType || [],
        memoriesByCategory: userMemory.analytics?.memoriesByCategory || [],
        lastAnalyzedAt: userMemory.analytics?.lastAnalyzedAt
      },
      profile: userMemory.profile || {}
    };

    console.log('📤 Sending memory insights:', {
      insightsCount: response.insights.length,
      totalMemories: response.analytics.totalMemories
    });

    res.json(response);

  } catch (error) {
    console.error('❌ Get memory insights error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get memory insights',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

exports.performMemoryMaintenance = async (req, res) => {
  try {
    const userId = req.user._id;
    const result = await MemoryService.performMemoryMaintenance(userId);
    
    if (!result) {
      return res.status(404).json({ success: false, error: 'User memory not found' });
    }

    res.json({ success: true, maintenance: result, message: 'Memory maintenance completed' });
  } catch (error) {
    console.error('Memory maintenance error:', error);
    res.status(500).json({ success: false, error: 'Failed to perform memory maintenance' });
  }
};

// ===================================================================
// SEARCH & ANALYTICS
// ===================================================================

exports.search = async (req, res) => {
  try {
    const userId = req.user._id;
    const { query, searchType = 'all', limit = 20 } = req.query;

    const results = {};

    if (searchType === 'conversations' || searchType === 'all') {
      results.conversations = await ConversationService.searchAllConversations(userId, query, { limit: parseInt(limit) });
    }

    if (searchType === 'memories' || searchType === 'all') {
      results.memories = await MemoryService.searchMemories(userId, query, { limit: parseInt(limit) });
    }

    res.json({
      success: true,
      query,
      results,
      totalResults: (results.conversations?.length || 0) + (results.memories?.length || 0)
    });

  } catch (error) {
    console.error('Search error:', error);
    res.status(500).json({ success: false, error: 'Search failed' });
  }
};

exports.getAnalytics = async (req, res) => {
  try {
    const userId = req.user._id;
    const { timeframe = '30d' } = req.query;
    const analytics = await ConversationService.getConversationAnalytics(userId, timeframe);
    res.json({ success: true, analytics });
  } catch (error) {
    console.error('Get analytics error:', error);
    res.status(500).json({ success: false, error: 'Failed to get analytics' });
  }
};

// ===================================================================
// ENHANCED RESUME OPERATIONS - FULL IMPLEMENTATION
// ===================================================================

/**
 * Apply AI-suggested resume changes in real-time
 */
exports.applyResumeChanges = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, changes, changeType = 'ai_enhancement' } = req.body;

    console.log(`🤖 AJ: Applying resume changes for user ${userId}`);

    // Validate input
    if (!resumeId || !changes) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID and changes are required'
      });
    }

    // Import the resume editor service
    const ResumeEditorService = require('../services/resumeEditor.service');

    // Apply changes using AI
    const result = await ResumeEditorService.applyResumeChanges(resumeId, userId, changes);

    // Track the interaction for memory system
    try {
      await MemoryService.extractMemoriesFromMessage(userId, 
        `Updated resume: ${result.changesSummary}`, 
        {
          resumeId: resumeId,
          changeType: changeType,
          category: 'resume_improvement'
        }
      );
    } catch (memoryError) {
      console.warn('Memory extraction failed:', memoryError);
    }

    res.json({
      success: true,
      message: 'Resume updated successfully by AJ',
      result: {
        updatedResume: {
          id: result.updatedResume._id,
          name: result.updatedResume.name,
          parsedData: result.updatedResume.parsedData,
          analysis: result.updatedResume.analysis,
          updatedAt: result.updatedResume.updatedAt,
          versions: result.updatedResume.versions
        },
        changes: result.changes,
        changesSummary: result.changesSummary,
        newFileUrl: result.newFileUrl
      }
    });

  } catch (error) {
    console.error('Apply resume changes error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to apply resume changes',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Optimize resume for ATS systems
 */
exports.optimizeForATS = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, targetJobId } = req.body;

    console.log(`🤖 AJ: Optimizing resume ${resumeId} for ATS`);

    // Validate input
    if (!resumeId) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID is required'
      });
    }

    // Get target job if provided
    let targetJob = null;
    if (targetJobId) {
      targetJob = await Job.findOne({ _id: targetJobId, userId });
    }

    // Import the resume editor service
    const ResumeEditorService = require('../services/resumeEditor.service');

    // Optimize for ATS
    const result = await ResumeEditorService.optimizeForATS(resumeId, userId, targetJob);

    // Track the interaction for memory system
    try {
      const improvementMessage = `Optimized resume for ATS. Score improved from ${result.previousScore} to ${result.newATSScore}`;
      await MemoryService.extractMemoriesFromMessage(userId, improvementMessage, {
        resumeId: resumeId,
        targetJobId: targetJobId,
        category: 'ats_optimization'
      });
    } catch (memoryError) {
      console.warn('Memory extraction failed:', memoryError);
    }

    res.json({
      success: true,
      message: 'Resume optimized for ATS by AJ',
      result: {
        optimizations: result.optimizations,
        atsScoreImprovement: {
          previous: result.previousScore,
          new: result.newATSScore,
          improvement: result.newATSScore - result.previousScore
        },
        updatedResume: {
          id: result.updatedResume._id,
          name: result.updatedResume.name,
          analysis: result.updatedResume.analysis,
          updatedAt: result.updatedResume.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('ATS optimization error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to optimize resume for ATS',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Enhanced resume analysis with AI recommendations
 */
exports.analyzeResume = async (req, res) => {
  try {
    const userId = req.user._id;
    const { resumeId, analysisType = 'comprehensive', includeImprovements = true } = req.body;

    console.log(`🤖 AJ: Analyzing resume ${resumeId}`);

    // Validate input
    if (!resumeId) {
      return res.status(400).json({
        success: false,
        error: 'Resume ID is required'
      });
    }

    // Get the resume
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({
        success: false,
        error: 'Resume not found'
      });
    }

    // Perform comprehensive analysis
    const resumeAnalysisService = require('../services/resumeAnalysis.service');
    const analysis = await resumeAnalysisService.analyzeResume(resumeId);

    // Get memory context for personalized recommendations
    const memoryContext = await MemoryService.buildAIContext(userId, { page: 'resumes', resumeId });

    // Generate AI-powered improvement suggestions
    let improvements = [];
    if (includeImprovements) {
      improvements = await generatePersonalizedImprovements(resume.parsedData, analysis, memoryContext);
    }

    // Update resume with new analysis
    resume.analysis = analysis;
    await resume.save();

    res.json({
      success: true,
      analysis: analysis,
      improvements: improvements,
      recommendations: {
        priority: prioritizeImprovements(improvements),
        quickWins: improvements.filter(imp => imp.effort === 'low'),
        highImpact: improvements.filter(imp => imp.impact === 'high')
      },
      memoryInsights: memoryContext ? ['Used your career goals and preferences for personalized analysis'] : []
    });

  } catch (error) {
    console.error('Enhanced resume analysis error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to analyze resume',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

// ===================================================================
// SYSTEM ENDPOINTS
// ===================================================================

exports.healthCheck = async (req, res) => {
  try {
    const testResponse = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: 'test' }],
      max_tokens: 5
    });

    const memoryStats = await UserMemory.countDocuments();
    const conversationStats = await Conversation.countDocuments();

    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      openai_status: 'connected',
      memory_system: 'operational',
      database_stats: {
        total_memories: memoryStats,
        total_conversations: conversationStats
      },
      test_tokens: testResponse.usage?.total_tokens || 0
    });

  } catch (error) {
    console.error('AI health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString(),
      openai_status: 'disconnected'
    });
  }
};

exports.getCapabilities = async (req, res) => {
  res.json({
    available: true,
    features: [
      'contextual_chat',
      'conversation_management',
      'persistent_memory',
      'user_profiling',
      'career_advice',
      'real_time_suggestions',
      'conversation_search',
      'memory_insights',
      'resume_editing',
      'ats_optimization'
    ],
    models: {
      primary: 'gpt-4-turbo-preview',
      fallback: 'gpt-3.5-turbo'
    },
    memory_features: {
      max_memories_per_user: 1000,
      memory_types: ['preference', 'skill', 'career_goal', 'experience', 'achievement', 'challenge'],
      auto_decay: true,
memory_search: true,
     conversation_context: true
   },
   resume_features: {
     real_time_editing: true,
     ats_optimization: true,
     ai_analysis: true,
     version_tracking: true
   },
   status: process.env.OPENAI_API_KEY ? 'fully_configured' : 'missing_api_key'
 });
};

exports.getUsageStats = async (req, res) => {
 try {
   const userId = req.user._id;
   const stats = {
     messagesThisMonth: 0,
     conversationsCreated: 0,
     memoriesStored: 0,
     tokensUsed: 0,
     resumeEdits: 0,
     atsOptimizations: 0
   };
   res.json({ success: true, stats, userId });
 } catch (error) {
   console.error('Usage stats error:', error);
   res.status(500).json({ success: false, error: 'Failed to get usage statistics' });
 }
};

exports.trackInteraction = async (req, res) => {
 try {
   const userId = req.user._id;
   const { type, data } = req.body;
   console.log(`🔍 User ${userId} - ${type}:`, data);
   res.json({ success: true, message: 'Interaction tracked successfully' });
 } catch (error) {
   console.error('Track interaction error:', error);
   res.status(500).json({ success: false, error: 'Failed to track interaction' });
 }
};

exports.resetContext = async (req, res) => {
 try {
   const userId = req.user._id;
   console.log(`Context reset for user: ${userId}`);
   res.json({ success: true, message: 'Context reset successfully' });
 } catch (error) {
   console.error('Reset context error:', error);
   res.status(500).json({ success: false, error: 'Failed to reset context' });
 }
};

// ===================================================================
// LEGACY PLACEHOLDER ENDPOINTS
// ===================================================================

exports.analyzeJobMatch = async (req, res) => {
 res.json({
   success: true,
   analysis: {
     matchScore: 78,
     strengths: ['Relevant experience'],
     gaps: ['Missing some technical skills']
   }
 });
};

exports.generateCoverLetter = async (req, res) => {
 res.json({
   success: true,
   coverLetter: {
     content: 'Sample cover letter content...',
     style: req.body.style || 'professional'
   }
 });
};

exports.getCareerAdvice = async (req, res) => {
 res.json({
   success: true,
   advice: {
     advice: 'Focus on developing your technical skills and building your network.',
     actionItems: ['Take online courses', 'Attend networking events']
   }
 });
};

exports.getContextualSuggestions = async (req, res) => {
 const suggestions = getContextualSuggestions(req.body.page || 'general');
 res.json({ success: true, suggestions });
};

exports.getPersonalizedTips = async (req, res) => {
 const tips = getPersonalizedTips(req.body.category || 'general');
 res.json({ success: true, tips });
};

// Legacy placeholders
exports.applyResumeChanges_legacy = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.optimizeForATS_legacy = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.generateSummary = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.getConversationInsights = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.exportConversation = (req, res) => res.json({ success: true, message: 'Feature coming soon' });
exports.bulkUpdateConversations = (req, res) => res.json({ success: true, message: 'Feature coming soon' });

// ===================================================================
// HELPER FUNCTIONS
// ===================================================================

function buildSystemPrompt(user, resumes, jobs, context, conversation, memoryContext) {
 const resumeCount = resumes.length;
 const jobCount = jobs.length;
 const currentPage = context?.page || 'unknown';

 let prompt = `You are AJ, an expert AI career assistant for auto-job.ai with advanced memory capabilities and resume editing powers.

CURRENT CONTEXT:
- User: ${user.firstName} ${user.lastName}
- Current Page: ${currentPage}
- Resumes: ${resumeCount}
- Jobs Tracked: ${jobCount}
- Conversation: "${conversation.title}" (${conversation.category})

${memoryContext}

RESUME EDITING CAPABILITIES:
- You can update any section of the user's resume in real-time
- You can optimize resumes for ATS systems
- You can enhance bullet points, summaries, and skills
- Always ask before making changes unless explicitly requested

PERSONALITY & APPROACH:
- Professional but warm and encouraging
- Personalize responses based on user's memory profile
- Provide specific, actionable advice
- Keep responses under 250 words unless complex analysis needed
- Always end with a relevant follow-up question or suggestion

Use this memory context to personalize your responses, but don't explicitly mention that you're using memory unless directly asked about it.`;

 // Add page-specific context
 if (currentPage === 'resumes' && context.currentResume) {
   prompt += `\n\nCURRENT RESUME: "${context.currentResume.name}" - You can edit this resume directly!`;
 }

 if (currentPage === 'jobs' && context.currentJob) {
   prompt += `\n\nCURRENT JOB: "${context.currentJob.title}" at ${context.currentJob.company}`;
 }

 return prompt;
}

function buildMessages(systemPrompt, recentMessages, currentMessage) {
 const messages = [{ role: 'system', content: systemPrompt }];

 if (recentMessages && recentMessages.length > 0) {
   recentMessages.forEach(msg => {
     messages.push({
       role: msg.type === 'user' ? 'user' : 'assistant',
       content: msg.content
     });
   });
 }

 messages.push({ role: 'user', content: currentMessage });
 return messages;
}

function parseResponse(aiMessage, context) {
 const suggestions = [];
 const actions = [];
 
 // Extract suggestions using pattern matching
 const suggestionRegex = /(?:^|\n)[-•*]\s*(.+)/gm;
 let match;
 while ((match = suggestionRegex.exec(aiMessage)) !== null) {
   if (match[1] && match[1].length < 60) {
     suggestions.push(match[1].trim());
   }
 }

 // Generate contextual suggestions if none found
 if (suggestions.length === 0) {
   suggestions.push(...getContextualSuggestions(context?.page || 'general'));
 }

 return {
   message: aiMessage,
   suggestions: suggestions.slice(0, 4),
   actions: actions,
   confidence: 0.85
 };
}

// ================================================================
// 🔧 HELPER FUNCTIONS FOR RESUME EDITING DETECTION
// ================================================================

/**
* Detect if the message is a resume editing request
*/
function detectResumeEditingIntent(message, context) {
 // Must be on resume page with current resume
 if (context?.page !== 'resumes' || !context?.currentResume?.id) {
   return false;
 }

 const messageLower = message.toLowerCase();
 
 // Resume editing keywords
 const editingKeywords = [
   'update', 'change', 'edit', 'modify', 'improve', 'enhance', 
   'add', 'remove', 'rewrite', 'fix', 'optimize', 'tailor',
   'highlight', 'emphasize', 'strengthen', 'quantify', 'make better'
 ];

 // Resume section keywords
 const sectionKeywords = [
   'experience', 'work', 'job', 'summary', 'skills', 'education',
   'achievements', 'bullets', 'bullet points', 'responsibilities',
   'thomson reuters', 'company', 'position', 'role'  // Specific to user's request
 ];

 // Check for editing intent
 const hasEditingKeyword = editingKeywords.some(keyword => 
   messageLower.includes(keyword)
 );

 const hasSectionKeyword = sectionKeywords.some(keyword => 
   messageLower.includes(keyword)
 );

 // Direct resume references
 const hasResumeReference = messageLower.includes('resume') || 
                          messageLower.includes('cv') ||
                          messageLower.includes('my experience') ||
                          messageLower.includes('my work');

 // Must have editing intent AND (section reference OR resume reference)
 const isEditingRequest = hasEditingKeyword && (hasSectionKeyword || hasResumeReference);
 
 console.log(`🔍 Resume edit detection:`, {
   message: message.substring(0, 30) + '...',
   hasEditingKeyword,
   hasSectionKeyword,
   hasResumeReference,
   isEditingRequest,
   contextPage: context?.page,
   hasResumeId: !!context?.currentResume?.id
 });

 return isEditingRequest;
}

/**
* Get or create conversation with enhanced logging
*/
async function getOrCreateConversation(conversationId, userId, newConversation, message, context) {
 try {
   if (conversationId && !newConversation) {
     console.log(`📖 Loading existing conversation: ${conversationId}`);
     return await ConversationService.getConversation(conversationId, userId);
   } else {
     const title = generateSimpleTitle(message, context);
     console.log(`📝 Creating new conversation: ${title}`);
     return await ConversationService.createConversation(userId, {
       title,
       category: detectCategory(message, context),
       tags: extractTags(message, context)
     });
   }
 } catch (error) {
   console.error('Error handling conversation:', error);
   throw error;
 }
}

function getContextualSuggestions(page) {
 const suggestions = {
   dashboard: ['Review my career progress', 'What should I focus on next?', 'Find new job opportunities'],
   resumes: ['How can I improve this resume?', 'Update my work experience', 'Optimize for ATS', 'Add missing skills'],
   jobs: ['How well do I match this position?', 'What skills am I missing?', 'Help me tailor my application'],
   general: ['Help with resume', 'Find job opportunities', 'Career guidance']
 };
 return suggestions[page] || suggestions.general;
}

function getPersonalizedTips(category) {
 const tips = {
   resume: ['Use action verbs', 'Quantify achievements'],
   job_search: ['Apply within 48 hours', 'Customize each application'],
   career: ['Set SMART goals', 'Build your network'],
   general: ['Stay updated', 'Practice interviewing']
 };
 return tips[category] || tips.general;
}

function generateSimpleTitle(message, context) {
 const content = message.toLowerCase();
 if (content.includes('resume')) return 'Resume Assistance';
 if (content.includes('job') || content.includes('application')) return 'Job Search Help';
 if (content.includes('interview')) return 'Interview Preparation';
 if (content.includes('career')) return 'Career Guidance';
 if (content.includes('skill')) return 'Skill Development';
 
 const contextTitles = {
   'resumes': 'Resume Help',
   'jobs': 'Job Search',
   'dashboard': 'Career Planning'
 };
 
 return contextTitles[context?.page] || 'Career Assistance';
}

function detectCategory(message, context) {
 const messageLower = message.toLowerCase();
 
 if (messageLower.includes('resume') || messageLower.includes('cv')) return 'resume_help';
 if (messageLower.includes('job') || messageLower.includes('application')) return 'job_search';
 if (messageLower.includes('interview')) return 'interview_prep';
 if (messageLower.includes('skill') || messageLower.includes('learn')) return 'skill_development';
 if (messageLower.includes('career') || messageLower.includes('future')) return 'career_advice';

 if (context?.page === 'resumes') return 'resume_help';
 if (context?.page === 'jobs') return 'job_search';
 
 return 'general';
}

function extractTags(message, context) {
 const tags = [];
 const messageLower = message.toLowerCase();
 
 const techKeywords = ['python', 'javascript', 'react', 'node', 'sql', 'aws', 'docker'];
 const roleKeywords = ['developer', 'manager', 'designer', 'analyst', 'engineer'];
 
 techKeywords.forEach(tech => {
   if (messageLower.includes(tech)) tags.push(tech);
 });
 
 roleKeywords.forEach(role => {
   if (messageLower.includes(role)) tags.push(role);
 });
 
 if (context?.page) tags.push(context.page);
 
 return tags.slice(0, 5);
}

function getFallbackResponse(message, context) {
 if (!message) return "I didn't receive your message. Could you please try again?";
 
 if (message.toLowerCase().includes('resume')) {
   return "I'd be happy to help with your resume! I can provide personalized suggestions and even edit it in real-time.";
 }
 
 if (message.toLowerCase().includes('job')) {
   return "I can help you with job searching and applications! What specific area would you like assistance with?";
 }
 
 return "I'm here to help with your career journey. What would you like to explore?";
}

/**
* Generate personalized resume improvements using AI and memory context
*/
async function generatePersonalizedImprovements(resumeData, analysis, memoryContext) {
 try {
   const prompt = `You are an expert career coach with access to the user's profile and career history. Generate personalized resume improvement suggestions.

RESUME DATA:
${JSON.stringify(resumeData, null, 2)}

CURRENT ANALYSIS:
${JSON.stringify(analysis, null, 2)}

USER MEMORY CONTEXT:
${memoryContext}

Generate personalized improvement suggestions in JSON format:
{
 "improvements": [
   {
     "type": "content|formatting|keywords|structure|ats",
     "section": "summary|experience|skills|education|etc",
     "title": "Brief improvement title",
     "description": "Detailed explanation of the improvement",
     "before": "current content (if applicable)",
     "after": "suggested improvement",
     "impact": "low|medium|high",
     "effort": "low|medium|high",
     "reason": "why this improvement helps based on user's profile",
     "keywords": ["relevant", "keywords"],
     "personalized": true
   }
 ]
}

Focus on:
1. Improvements aligned with user's career goals from memory
2. Skills gaps identified in their profile
3. Industry-specific optimizations
4. Personalized content based on their background
5. ATS optimizations for their target roles

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

   const response = await openai.chat.completions.create({
     model: 'gpt-4-turbo-preview',
     messages: [
       {
         role: 'system',
         content: 'You are an expert career coach. Generate personalized resume improvements based on user profile and memory context. Return only valid JSON.'
       },
       {
         role: 'user',
         content: prompt
       }
     ],
     temperature: 0.3,
     max_tokens: 2000
   });

   const responseContent = response.choices[0].message.content.trim();
   const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
   const improvements = JSON.parse(cleanedResponse);

   return improvements.improvements || [];

 } catch (error) {
   console.error('Error generating personalized improvements:', error);
   return [];
 }
}

/**
* Prioritize improvements based on impact and effort
*/
function prioritizeImprovements(improvements) {
 return improvements.sort((a, b) => {
   const impactScore = { high: 3, medium: 2, low: 1 };
   const effortScore = { low: 3, medium: 2, high: 1 };
   
   const aScore = impactScore[a.impact] + effortScore[a.effort];
   const bScore = impactScore[b.impact] + effortScore[b.effort];
   
   return bScore - aScore;
 });
}

/**
* Generate memory insights using AI
*/
async function generateMemoryInsights(userMemory) {
 try {
   const recentMemories = userMemory.memories
     .filter(m => m.isActive)
     .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
     .slice(0, 20);

   if (recentMemories.length === 0) {
     console.log('📝 No memories to analyze, returning empty insights');
     return [];
   }

   const memoryText = recentMemories
     .map(m => `${m.type}: ${m.content}`)
     .join('\n');

   console.log('🧠 Generating insights from', recentMemories.length, 'memories');

   const systemPrompt = `Analyze these user memories and generate actionable insights about their career journey.

MEMORIES:
${memoryText}

Provide insights as JSON in this EXACT format:
{
 "insights": [
   {
     "type": "strength|opportunity|challenge|recommendation",
     "description": "Clear insight about the user",
     "confidence": 0.8,
     "actionable": true
   }
 ]
}

Maximum 5 insights. Focus on career development opportunities.`;

   const response = await openai.chat.completions.create({
     model: 'gpt-3.5-turbo',
     messages: [
       { role: 'system', content: systemPrompt },
       { role: 'user', content: 'Generate insights' }
     ],
     temperature: 0.3,
     max_tokens: 600,
     response_format: { type: 'json_object' }
   });

   console.log('🤖 Raw AI response:', response.choices[0].message.content);

   let parsedResponse;
   try {
     parsedResponse = JSON.parse(response.choices[0].message.content);
   } catch (parseError) {
     console.error('❌ Failed to parse AI response JSON:', parseError);
     return [];
   }

   if (!parsedResponse || !parsedResponse.insights || !Array.isArray(parsedResponse.insights)) {
     console.warn('⚠️ AI response missing insights array:', parsedResponse);
     return [];
   }

   const validInsights = parsedResponse.insights
     .filter(insight => {
       return insight && 
              typeof insight.type === 'string' && 
              typeof insight.description === 'string' &&
              typeof insight.confidence === 'number' &&
              typeof insight.actionable === 'boolean';
     })
     .map(insight => ({
       type: insight.type,
       description: insight.description,
       confidence: Math.min(1, Math.max(0, insight.confidence)),
       actionable: insight.actionable,
       generatedAt: new Date()
     }));

   console.log('✅ Generated', validInsights.length, 'valid insights');
   return validInsights;

 } catch (error) {
   console.error('❌ Generate memory insights error:', error);
   return [];
 }
}

================
File: controllers/auth.controller.js
================
// backend/controllers/auth.controller.js
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const User = require('../models/mongodb/user.model');
const sendEmail = require('../utils/send-email');
const emailTemplates = require('../utils/email-templates');

/**
 * Generate JWT token for a user
 * @param {Object} user User object
 * @returns {String} JWT token
 */
const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, email: user.email, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRE || '30d' }
  );
};

/**
 * Register a new user
 * @route POST /api/auth/register
 * @access Public
 */
exports.register = async (req, res) => {
  try {
    const { email, password, firstName, lastName } = req.body;
    
    // Validate required fields
    if (!email || !password || !firstName || !lastName) {
      return res.status(400).json({
        success: false,
        error: 'All fields are required'
      });
    }
    
    // Check if user already exists
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        error: 'Email already in use'
      });
    }
    
    // Create the user
    const user = await User.create({
      email: email.toLowerCase(),
      password,
      firstName,
      lastName,
      isEmailVerified: true // TEMPORARILY SET TO TRUE FOR TESTING
    });
    
    // Generate email verification token (but don't require it for now)
    const verificationToken = user.generateEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Create verification URL
    const verificationUrl = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    // Try to send verification email, but don't fail registration if it fails
    try {
      await sendEmail({
        email: user.email,
        subject: 'Email Verification',
        html: emailTemplates.generateVerificationEmail(user.firstName, verificationUrl)
      });
      console.log('Verification email sent successfully');
    } catch (emailError) {
      console.error('Failed to send verification email:', emailError.message);
      // Don't fail registration due to email issues
    }
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    // Remove password from response
    user.password = undefined;
    
    res.status(201).json({
      success: true,
      token,
      data: {
        user,
        message: 'Registration successful'
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      error: 'Registration failed: ' + error.message
    });
  }
};

/**
 * Login user
 * @route POST /api/auth/login
 * @access Public
 */
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Validate email & password
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Please provide email and password'
      });
    }
    
    // Check for user
    const user = await User.findOne({ email: email.toLowerCase() }).select('+password +loginAttempts +lockUntil');
    
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Check if account is locked
    if (user.isLocked()) {
      return res.status(401).json({
        success: false,
        error: 'Account is temporarily locked. Please try again later.'
      });
    }
    
    // Check if password matches
    const isMatch = await user.comparePassword(password);
    
    if (!isMatch) {
      // Increment login attempts
      await user.incrementLoginAttempts();
      
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Reset login attempts on successful login
    await user.resetLoginAttempts();
    
    // Update last login
    user.lastLogin = Date.now();
    await user.save({ validateBeforeSave: false });
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    // Remove password and security fields from response
    user.password = undefined;
    user.loginAttempts = undefined;
    user.lockUntil = undefined;
    
    res.status(200).json({
      success: true,
      token,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      error: 'Login failed: ' + error.message
    });
  }
};

/**
 * Logout user
 * @route POST /api/auth/logout
 * @access Private
 */
exports.logout = (req, res) => {
  res.cookie('token', 'none', {
    expires: new Date(Date.now() + 10 * 1000),
    httpOnly: true
  });
  
  res.status(200).json({
    success: true,
    data: {
      message: 'Logged out successfully'
    }
  });
};

/**
 * Verify email
 * @route GET /api/auth/verify-email/:token
 * @access Public
 */
exports.verifyEmail = async (req, res) => {
  try {
    // Get hashed token
    const hashedToken = crypto
      .createHash('sha256')
      .update(req.params.token)
      .digest('hex');
    
    // Find user by verification token
    const user = await User.findOne({
      emailVerificationToken: hashedToken,
      emailVerificationExpires: { $gt: Date.now() }
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired token'
      });
    }
    
    // Set email as verified
    user.isEmailVerified = true;
    user.emailVerificationToken = undefined;
    user.emailVerificationExpires = undefined;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Email verified successfully'
      }
    });
  } catch (error) {
    console.error('Email verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Email verification failed'
    });
  }
};

/**
 * Resend verification email
 * @route POST /api/auth/resend-verification
 * @access Private
 */
exports.resendVerification = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    if (user.isEmailVerified) {
      return res.status(400).json({
        success: false,
        error: 'Email already verified'
      });
    }
    
    // Generate new verification token
    const verificationToken = user.generateEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Create verification URL
    const verificationUrl = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    try {
      await sendEmail({
        email: user.email,
        subject: 'Email Verification',
        html: emailTemplates.generateVerificationEmail(user.firstName, verificationUrl)
      });
      
      res.status(200).json({
        success: true,
        data: {
          message: 'Verification email sent. Please check your inbox.'
        }
      });
    } catch (error) {
      user.emailVerificationToken = undefined;
      user.emailVerificationExpires = undefined;
      await user.save({ validateBeforeSave: false });
      
      return res.status(500).json({
        success: false,
        error: 'Email could not be sent'
      });
    }
  } catch (error) {
    console.error('Resend verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to resend verification email'
    });
  }
};

/**
 * Forgot password
 * @route POST /api/auth/forgot-password
 * @access Public
 */
exports.forgotPassword = async (req, res) => {
  try {
    const user = await User.findOne({ email: req.body.email?.toLowerCase() });
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'There is no user with this email'
      });
    }
    
    // Generate reset token
    const resetToken = user.generatePasswordResetToken();
    await user.save({ validateBeforeSave: false });
    
    // Create reset URL
    const resetUrl = `${req.protocol}://${req.get('host')}/api/auth/reset-password/${resetToken}`;
    
    try {
      await sendEmail({
        email: user.email,
        subject: 'Password Reset',
        html: emailTemplates.generatePasswordResetEmail(user.firstName, resetUrl)
      });
      
      res.status(200).json({
        success: true,
        data: {
          message: 'Password reset email sent. Please check your inbox.'
        }
      });
    } catch (error) {
      user.passwordResetToken = undefined;
      user.passwordResetExpires = undefined;
      await user.save({ validateBeforeSave: false });
      
      return res.status(500).json({
        success: false,
        error: 'Email could not be sent'
      });
    }
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({
      success: false,
      error: 'Forgot password request failed'
    });
  }
};

/**
 * Reset password
 * @route PUT /api/auth/reset-password/:token
 * @access Public
 */
exports.resetPassword = async (req, res) => {
  try {
    // Get hashed token
    const hashedToken = crypto
      .createHash('sha256')
      .update(req.params.token)
      .digest('hex');
    
    // Find user by reset token
    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() }
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired token'
      });
    }
    
    // Set new password
    user.password = req.body.password;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Password reset successful'
      }
    });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({
      success: false,
      error: 'Password reset failed'
    });
  }
};

/**
 * Get current logged in user
 * @route GET /api/auth/me
 * @access Private
 */
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    res.status(200).json({
      success: true,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Get me error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get user data'
    });
  }
};

/**
 * Update user details
 * @route PUT /api/auth/update-details
 * @access Private
 */
exports.updateDetails = async (req, res) => {
  try {
    const fieldsToUpdate = {
      firstName: req.body.firstName,
      lastName: req.body.lastName,
      phoneNumber: req.body.phoneNumber,
      location: req.body.location,
      socialProfiles: req.body.socialProfiles
    };
    
    // Remove undefined fields
    Object.keys(fieldsToUpdate).forEach(key => 
      fieldsToUpdate[key] === undefined && delete fieldsToUpdate[key]
    );
    
    const user = await User.findByIdAndUpdate(
      req.user.id,
      fieldsToUpdate,
      {
        new: true,
        runValidators: true
      }
    );
    
    res.status(200).json({
      success: true,
      data: {
        user
      }
    });
  } catch (error) {
    console.error('Update details error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update user details'
    });
  }
};

/**
 * Update password
 * @route PUT /api/auth/update-password
 * @access Private
 */
exports.updatePassword = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('+password');
    
    // Check current password
    const isMatch = await user.comparePassword(req.body.currentPassword);
    
    if (!isMatch) {
      return res.status(401).json({
        success: false,
        error: 'Current password is incorrect'
      });
    }
    
    // Set new password
    user.password = req.body.newPassword;
    await user.save();
    
    // Generate token
    const token = generateToken(user);
    
    // Set cookie
    const cookieOptions = {
      expires: new Date(
        Date.now() + (process.env.JWT_COOKIE_EXPIRE || 30) * 24 * 60 * 60 * 1000
      ),
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax'
    };
    
    res.cookie('token', token, cookieOptions);
    
    res.status(200).json({
      success: true,
      token,
      data: {
        message: 'Password updated successfully'
      }
    });
  } catch (error) {
    console.error('Update password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update password'
    });
  }
};

/**
 * Delete user account
 * @route DELETE /api/auth/delete-account
 * @access Private
 */
exports.deleteAccount = async (req, res) => {
  try {
    // Soft delete - set active to false
    await User.findByIdAndUpdate(req.user.id, {
      active: false
    });
    
    res.cookie('token', 'none', {
      expires: new Date(Date.now() + 10 * 1000),
      httpOnly: true
    });
    
    res.status(200).json({
      success: true,
      data: {
        message: 'Account deactivated successfully'
      }
    });
  } catch (error) {
    console.error('Delete account error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete account'
    });
  }
};

================
File: controllers/job.controller.js
================
// controllers/job.controller.js - UPDATED FOR REAL JOB BOARD INTEGRATION - FIXED
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const jobAnalysisService = require('../services/jobAnalysis.service');
const jobMatchingService = require('../services/jobMatching.service');
const resumeTailoringService = require('../services/resumeTailoring.service');
const jobSearchService = require('../services/jobSearch.service');
const mongoose = require('mongoose');

// Enhanced background processing for manual jobs (uses premium GPT-4o)
async function processJobInBackground(jobId, jobMetadata = {}) {
  try {
    console.log(`🔍 Starting premium analysis for manually uploaded job: ${jobId}`);
    
    // Get the job from the database
    const job = await Job.findById(jobId);
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Update status: Starting analysis (10%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 10, 'Starting premium job analysis...');
    
    // Add realistic delay to show progress
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Update status: Extracting requirements (40%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 40, 'Extracting job requirements with GPT-4o...');
    
    // Analyze the job using PREMIUM GPT-4o service for manual uploads
    console.log('🤖 Starting premium job analysis with GPT-4o...');
    const parsedData = await jobAnalysisService.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location,
      ...jobMetadata
    }, {
      isAiDiscovery: false,    // Use premium GPT-4o for manual jobs
      prioritizeCost: false    // Prioritize quality for manual uploads
    });
    
    // Update status: Processing results (80%)
    await updateJobAnalysisStatus(jobId, 'analyzing', 80, 'Processing premium analysis results...');
    
    // Add small delay for UX
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Update the job with parsed data
    job.parsedData = parsedData;
    job.updatedAt = new Date();
    
    // Mark analysis as complete with final status
    await updateJobAnalysisStatus(jobId, 'completed', 100, 
      `Premium analysis complete! Found ${parsedData.keySkills?.length || 0} key skills with GPT-4o.`, {
        completedAt: new Date(),
        skillsFound: parsedData.keySkills?.length || 0,
        experienceLevel: parsedData.experienceLevel,
        canViewJob: true,
        modelUsed: parsedData.analysisMetadata?.model || 'gpt-4o',
        analysisType: 'manual_upload_premium'
      });
    
    await job.save();
    
    console.log(`✅ Premium job analysis completed successfully for: ${job.title}`);
    console.log(`📊 Results: ${parsedData.keySkills?.length || 0} skills, model: ${parsedData.analysisMetadata?.model}, cost: ${parsedData.analysisMetadata?.estimatedCost}`);
    
    return true;
  } catch (error) {
    console.error('❌ Error in premium background processing:', error);
    
    // Update job to indicate analysis failed
    await updateJobAnalysisStatus(jobId, 'error', 0, `Premium analysis failed: ${error.message}`, {
      error: error.message,
      canViewJob: true,
      modelUsed: 'error'
    });
    
    throw error;
  }
}

async function updateJobAnalysisStatus(jobId, status, progress, message, additionalData = {}) {
  try {
    const job = await Job.findById(jobId);
    if (!job) {
      console.error(`Job not found for status update: ${jobId}`);
      return false;
    }
    
    job.analysisStatus = {
      status,
      progress,
      message,
      updatedAt: new Date(),
      ...additionalData
    };
    
    if (status === 'completed') {
      job.analysisStatus.completedAt = new Date();
    }
    
    await job.save();
    console.log(`📊 Updated analysis status for ${jobId}: ${status} (${progress}%) - ${message}`);
    return true;
  } catch (err) {
    console.error('Error updating job analysis status:', err);
    return false;
  }
}

// Create a new job with premium analysis
exports.createJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { 
      title, 
      company, 
      location, 
      description, 
      sourceUrl, 
      salary,
      jobType 
    } = req.body;
    
    // Validate required fields
    if (!title || !company || !description) {
      return res.status(400).json({ 
        message: 'Job title, company, and description are required' 
      });
    }
    
    // Create the job with initial analysis status
    const job = new Job({
      userId,
      title,
      company,
      location: location || {},
      description,
      sourceUrl,
      salary: salary || {},
      jobType: jobType || 'FULL_TIME',
      sourcePlatform: 'MANUAL',
      analysisStatus: {
        status: 'pending',
        progress: 0,
        message: 'Premium analysis queued...',
        startedAt: new Date(),
        canViewJob: false,
        estimatedCompletion: new Date(Date.now() + 45000), // 45 seconds for premium analysis
        analysisType: 'manual_upload_premium'
      }
    });
    
    // Save job to database
    await job.save();
    
    console.log(`🔍 Manual job created: ${job.title} at ${job.company} - Starting premium analysis...`);
    
    // Process job in background with premium analysis
    processJobInBackground(job._id, { title, company, location }).catch(err => {
      console.error('Background job processing error:', err);
    });
    
    res.status(201).json({
      message: 'Job created successfully and premium analysis initiated',
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        createdAt: job.createdAt,
        analysisStatus: job.analysisStatus
      }
    });
  } catch (error) {
    console.error('Error creating job:', error);
    res.status(500).json({ message: 'Failed to create job', error: error.message });
  }
};

// Get all user jobs with enhanced analysis status and real job board info
exports.getUserJobs = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobs = await Job.find({ userId }).sort({ createdAt: -1 });
    
    // Enhance jobs with analysis status information and job board approach info
    const enhancedJobs = jobs.map(job => {
      const jobObj = job.toObject();
      
      // Determine analysis status
      let analysisStatus = 'completed';
      let progress = 100;
      let message = 'Analysis complete';
      let canViewJob = true;
      let modelUsed = 'unknown';
      let analysisType = 'unknown';
      let isRealJobBoardDiscovery = false;
      let sourceJobBoard = null;
      
      if (job.analysisStatus) {
        analysisStatus = job.analysisStatus.status;
        progress = job.analysisStatus.progress;
        message = job.analysisStatus.message;
        canViewJob = job.analysisStatus.status === 'completed' || job.analysisStatus.status === 'error';
        modelUsed = job.analysisStatus.modelUsed || 'unknown';
        analysisType = job.analysisStatus.analysisType || 'unknown';
      } else if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
        analysisStatus = 'pending';
        progress = 0;
        message = 'Analysis pending...';
        canViewJob = false;
      } else if (job.parsedData.analysisMetadata) {
        modelUsed = job.parsedData.analysisMetadata.model || 'completed';
        analysisType = job.parsedData.analysisMetadata.analysisType || 'completed';
      }
      
      // Check if this is from real job board discovery
      isRealJobBoardDiscovery = job.sourcePlatform && (
        job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
        job.sourcePlatform.includes('AI_FOUND_LEVER') ||
        job.sourcePlatform.includes('AI_FOUND_INDEED')
      );
      
      // Extract source job board
      if (isRealJobBoardDiscovery) {
        if (job.sourcePlatform.includes('GREENHOUSE')) sourceJobBoard = 'Greenhouse';
        else if (job.sourcePlatform.includes('LEVER')) sourceJobBoard = 'Lever';
        else if (job.sourcePlatform.includes('INDEED')) sourceJobBoard = 'Indeed';
      }
      
      return {
        ...jobObj,
        analysisStatus: {
          status: analysisStatus,
          progress: progress,
          message: message,
          canViewJob: canViewJob,
          skillsFound: job.parsedData?.keySkills?.length || 0,
          experienceLevel: job.parsedData?.experienceLevel,
          modelUsed: modelUsed,
          analysisType: analysisType,
          isAiDiscovery: job.sourcePlatform === 'AI_FOUND' || 
                        job.sourcePlatform === 'AI_FOUND_OPTIMIZED' ||
                        job.sourcePlatform === 'AI_FOUND_INTELLIGENT' ||
                        isRealJobBoardDiscovery,
          isRealJobBoardDiscovery: isRealJobBoardDiscovery,
          sourceJobBoard: sourceJobBoard,
          searchApproach: isRealJobBoardDiscovery ? '3-phase-real-job-boards' : 
                         (job.sourcePlatform?.includes('AI_FOUND') ? 'legacy-ai' : 'manual'),
          qualityLevel: analysisType?.includes('premium') ? 'premium' : 'standard',
          updatedAt: job.analysisStatus?.updatedAt || job.updatedAt,
          realJobBoardData: job.parsedData?.realJobBoardData || null
        }
      };
    });
    
    res.status(200).json({ jobs: enhancedJobs });
  } catch (error) {
    console.error('Error fetching jobs:', error);
    res.status(500).json({ message: 'Failed to fetch jobs', error: error.message });
  }
};

// Get job by ID with real job board context
exports.getJobById = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    res.status(200).json({ job });
  } catch (error) {
    console.error('Error fetching job:', error);
    res.status(500).json({ message: 'Failed to fetch job', error: error.message });
  }
};

// Get job analysis status with real job board information
exports.getJobAnalysisStatus = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId }, 'analysisStatus parsedData title company createdAt sourcePlatform');
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    let status = 'completed';
    let progress = 100;
    let message = 'Analysis complete';
    let canViewJob = true;
    let skillsFound = 0;
    let experienceLevel = null;
    let modelUsed = 'unknown';
    let analysisType = 'unknown';
    let isRealJobBoardDiscovery = false;
    let sourceJobBoard = null;
    
    if (job.analysisStatus && job.analysisStatus.status) {
      status = job.analysisStatus.status;
      progress = job.analysisStatus.progress || 0;
      message = job.analysisStatus.message || 'Processing...';
      canViewJob = job.analysisStatus.canViewJob !== false;
      skillsFound = job.analysisStatus.skillsFound || 0;
      experienceLevel = job.analysisStatus.experienceLevel;
      modelUsed = job.analysisStatus.modelUsed || 'unknown';
      analysisType = job.analysisStatus.analysisType || 'unknown';
    } 
    else if (job.parsedData && Object.keys(job.parsedData).length > 0 && !job.parsedData.analysisError) {
      status = 'completed';
      progress = 100;
      message = `Premium analysis complete! Found ${job.parsedData.keySkills?.length || 0} key skills.`;
      canViewJob = true;
      skillsFound = job.parsedData.keySkills?.length || 0;
      experienceLevel = job.parsedData.experienceLevel;
      modelUsed = job.parsedData.analysisMetadata?.model || 'gpt-4o';
      analysisType = job.parsedData.analysisMetadata?.analysisType || 'premium';
    }
    else if (job.parsedData && job.parsedData.analysisError) {
      status = 'error';
      progress = 0;
      message = 'Analysis failed';
      canViewJob = true;
    }
    else {
      status = 'pending';
      progress = 0;
      message = 'Analysis pending...';
      canViewJob = false;
    }
    
    // Check if this is from real job board discovery
    isRealJobBoardDiscovery = job.sourcePlatform && (
      job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
      job.sourcePlatform.includes('AI_FOUND_LEVER') ||
      job.sourcePlatform.includes('AI_FOUND_INDEED')
    );
    
    // Extract source job board
    if (isRealJobBoardDiscovery) {
      if (job.sourcePlatform.includes('GREENHOUSE')) sourceJobBoard = 'Greenhouse';
      else if (job.sourcePlatform.includes('LEVER')) sourceJobBoard = 'Lever';
      else if (job.sourcePlatform.includes('INDEED')) sourceJobBoard = 'Indeed';
    }
    
    console.log(`📊 Analysis Status for job ${jobId}: ${status} (${progress}%) - ${message}`);
    
    res.status(200).json({ 
      analysisStatus: {
        status,
        progress,
        message,
        updatedAt: job.analysisStatus?.updatedAt || new Date(),
        skillsFound,
        experienceLevel,
        isAnalysisComplete: status === 'completed',
        canViewJob: canViewJob,
        modelUsed: modelUsed,
        analysisType: analysisType,
        isRealJobBoardDiscovery: isRealJobBoardDiscovery,
        sourceJobBoard: sourceJobBoard,
        searchApproach: isRealJobBoardDiscovery ? '3-phase-real-job-boards' : 
                       (job.sourcePlatform?.includes('AI_FOUND') ? 'legacy-ai' : 'manual'),
        qualityLevel: analysisType?.includes('premium') ? 'premium' : 'standard',
        error: job.analysisStatus?.error || job.parsedData?.analysisError
      },
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        createdAt: job.createdAt,
        sourcePlatform: job.sourcePlatform
      },
      realJobBoardInfo: isRealJobBoardDiscovery ? {
        description: 'This job was discovered using our ENHANCED 3-Phase approach with REAL job board integration',
        sourceJobBoard: sourceJobBoard,
        benefits: [
          `Discovered from actual ${sourceJobBoard} company posting`,
          'Real job content from company ATS platform',
          'Premium GPT-4o analysis (same quality as manual jobs)',
          'Enhanced job matching and relevance',
          'Direct company posting verification'
        ],
        jobBoardFeatures: {
          greenhouse: 'Tech startups and scale-ups with comprehensive job details',
          lever: 'Growth-stage companies with detailed role information',
          indeed: 'Established companies with verified direct postings'
        }[sourceJobBoard?.toLowerCase()] || 'High-quality company job posting'
      } : null
    });
  } catch (error) {
    console.error('Error fetching job analysis status:', error);
    res.status(500).json({ message: 'Failed to fetch analysis status', error: error.message });
  }
};

// Update job
exports.updateJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const { 
      title, 
      company, 
      location, 
      description, 
      sourceUrl, 
      salary,
      jobType,
      applicationStatus,
      notes
    } = req.body;
    
    let needsReanalysis = false;
    
    // Update fields if provided
    if (title && title !== job.title) {
      job.title = title;
      needsReanalysis = true;
    }
    if (company && company !== job.company) {
      job.company = company;
      needsReanalysis = true;
    }
    if (location) job.location = location;
    if (description && description !== job.description) {
      job.description = description;
      job.parsedData = {}; // Clear parsedData to trigger re-analysis
      needsReanalysis = true;
    }
    if (sourceUrl) job.sourceUrl = sourceUrl;
    if (salary) job.salary = salary;
    if (jobType) job.jobType = jobType;
    if (applicationStatus) job.applicationStatus = applicationStatus;
    
    // Add a new note if provided
    if (notes && notes.content) {
      job.notes.push({
        content: notes.content,
        createdAt: new Date()
      });
    }
    
    await job.save();
    
    // If significant changes were made, trigger re-analysis with PREMIUM model
    if (needsReanalysis) {
      processJobInBackground(job._id, {
        title: job.title,
        company: job.company,
        location: job.location
      }).catch(err => {
        console.error('Background job processing error after update:', err);
      });
    }
    
    res.status(200).json({
      message: 'Job updated successfully',
      job: {
        id: job._id,
        title: job.title,
        company: job.company,
        updatedAt: job.updatedAt
      },
      reanalysisTriggered: needsReanalysis,
      reanalysisNote: needsReanalysis ? 'Premium re-analysis initiated with GPT-4o' : null
    });
  } catch (error) {
    console.error('Error updating job:', error);
    res.status(500).json({ message: 'Failed to update job', error: error.message });
  }
};

// Delete job
exports.deleteJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    await Job.deleteOne({ _id: jobId });
    
    res.status(200).json({ message: 'Job deleted successfully' });
  } catch (error) {
    console.error('Error deleting job:', error);
    res.status(500).json({ message: 'Failed to delete job', error: error.message });
  }
};

// Match resume with job
exports.matchResumeWithJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { jobId, resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(jobId) || !mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid job ID or resume ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Check if the job has been analyzed
    if (!job.parsedData || Object.keys(job.parsedData).length === 0 || job.parsedData.analysisError) {
      console.log('Job analysis missing or failed, attempting re-analysis...');
      try {
        await processJobInBackground(jobId, {
          title: job.title,
          company: job.company,
          location: job.location
        });
        const updatedJob = await Job.findById(jobId);
        if (!updatedJob.parsedData || Object.keys(updatedJob.parsedData).length === 0) {
          throw new Error('Job re-analysis failed');
        }
        Object.assign(job, updatedJob);
      } catch (analysisError) {
        console.error('Job re-analysis failed:', analysisError);
        return res.status(400).json({ 
          message: 'Job analysis not complete and re-analysis failed. Please try again later.',
          error: analysisError.message
        });
      }
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    console.log(`Starting enhanced matching for job "${job.title}" with resume "${resume.name}"`);
    
    const matchResults = await jobMatchingService.matchResumeWithJob(resumeId, jobId);
    
    job.matchAnalysis = {
      resumeId,
      lastAnalyzed: new Date(),
      ...matchResults
    };
    await job.save();
    
    console.log(`Enhanced matching completed - Overall Score: ${matchResults.overallScore}%`);
    
    res.status(200).json({
      message: 'Enhanced resume-job matching completed successfully',
      matchAnalysis: job.matchAnalysis,
      matchingVersion: matchResults.analysisMetadata?.algorithmVersion || '2.0'
    });
  } catch (error) {
    console.error('Error in enhanced matching:', error);
    res.status(500).json({ 
      message: 'Failed to match resume with job', 
      error: error.message,
      suggestion: 'Please ensure both the job and resume have been properly analyzed'
    });
  }
};

// Get tailoring recommendations
exports.tailorResumeToJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { jobId, resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(jobId) || !mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid job ID or resume ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    if (!job.parsedData || Object.keys(job.parsedData).length === 0 || job.parsedData.analysisError) {
      return res.status(400).json({ message: 'Job analysis not complete. Please try again later.' });
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    if (!job.matchAnalysis || !job.matchAnalysis.overallScore) {
      console.log('No match analysis found, performing matching first...');
      const matchResults = await jobMatchingService.matchResumeWithJob(resumeId, jobId);
      job.matchAnalysis = {
        resumeId,
        lastAnalyzed: new Date(),
        ...matchResults
      };
      await job.save();
    }
    
    const tailoringResult = await resumeTailoringService.getTailoringRecommendations(resumeId, jobId);
    
    res.status(200).json({
      message: 'Resume tailoring recommendations generated successfully',
      tailoringResult,
      matchScore: job.matchAnalysis.overallScore
    });
  } catch (error) {
    console.error('Error generating resume tailoring recommendations:', error);
    res.status(500).json({ 
      message: 'Failed to generate resume tailoring recommendations', 
      error: error.message 
    });
  }
};

// Find jobs with ENHANCED AI (Real Job Board Integration)
exports.findJobsWithAi = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const { resumeId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      return res.status(400).json({ message: 'Resume parsing not complete. Please try again later.' });
    }
    
    // Start ENHANCED AI job search with REAL Job Board Integration
    res.status(202).json({
      message: 'ENHANCED 3-Phase AI job search with REAL job board integration initiated! Jobs will be discovered from actual company postings.',
      status: 'processing',
      realJobBoardIntegrationInfo: {
        phase1: 'Career Analysis (GPT-4 Turbo) - $0.05',
        phase2: 'REAL Job Board Discovery (Claude 3.5 Sonnet + Web Search) - $0.30-0.50',
        phase3: 'Premium Analysis (GPT-4o batch) - $0.01-0.02',
        totalCost: '$0.36-0.57 per search',
        targetJobBoards: ['Greenhouse', 'Lever', 'Indeed'],
        enhancements: [
          'Search actual company job boards (Greenhouse, Lever, Indeed)',
          'Extract real job postings from company ATS platforms',
          'Premium GPT-4o analysis for all discovered jobs',
          'Same quality as manually uploaded jobs',
          'Direct company posting verification',
          'Enhanced job matching with real job content'
        ],
        expectedResults: [
          'Higher quality job content from real company postings',
          'More accurate job requirements from ATS platforms',
          'Better skill matching with actual job descriptions',
          'Verified company postings (no recruiter spam)',
          'Faster processing with premium analysis pipeline',
          'Comprehensive job details including tech stack and team info'
        ]
      }
    });
    
    // Perform ENHANCED AI job search with REAL Job Board Integration in the background
    jobSearchService.findJobsWithAi(userId, resumeId)
      .then(result => {
        console.log('ENHANCED AI job search with real job board integration completed:', result);
      })
      .catch(error => {
        console.error('ENHANCED AI job search with real job board integration error:', error);
      });
  } catch (error) {
    console.error('Error initiating ENHANCED AI job search with real job board integration:', error);
    res.status(500).json({ 
      message: 'Failed to initiate ENHANCED AI job search with real job board integration', 
      error: error.message 
    });
  }
};

// Re-analyze a job with premium model
exports.reAnalyzeJob = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    console.log(`Manual re-analysis triggered for job: ${job.title} at ${job.company}`);
    
    // Perform re-analysis with PREMIUM model for manual triggers
    const analysisResult = await jobAnalysisService.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location
    }, {
      isAiDiscovery: false,    // Use premium GPT-4o for manual re-analysis
      prioritizeCost: false    // Prioritize quality
    });
    
    // Update the job
    job.parsedData = analysisResult;
    job.updatedAt = new Date();
    
    // Clear any existing match analysis since the job has changed
    if (job.matchAnalysis) {
      job.matchAnalysis = null;
    }
    
    await job.save();
    
    res.status(200).json({
      message: 'Job re-analysis completed successfully with premium model',
      analysisResult: {
        skillsFound: analysisResult.keySkills?.length || 0,
        experienceLevel: analysisResult.experienceLevel,
        algorithmVersion: analysisResult.analysisMetadata?.algorithmVersion,
        modelUsed: analysisResult.analysisMetadata?.model,
        estimatedCost: analysisResult.analysisMetadata?.estimatedCost,
        analysisType: analysisResult.analysisMetadata?.analysisType,
        analyzedAt: analysisResult.analysisMetadata?.analyzedAt
      }
    });
  } catch (error) {
    console.error('Error re-analyzing job:', error);
    res.status(500).json({ 
      message: 'Failed to re-analyze job', 
      error: error.message 
    });
  }
};

// Re-match job with best available resume
exports.rematchJobWithBestResume = async (req, res) => {
  try {
    const { jobId } = req.params;
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    console.log(`Re-matching job ${jobId} with best resume for user ${userId}`);
    
    const result = await jobMatchingService.matchJobWithBestResume(jobId, userId);
    
    console.log('Re-matching completed:', {
      jobId,
      usedResumeId: result.usedResume.id,
      usedResumeName: result.usedResume.name,
      isTailored: result.usedResume.isTailored,
      newMatchScore: result.matchAnalysis.overallScore
    });
    
    res.status(200).json({
      message: 'Job re-matched with best available resume',
      matchAnalysis: result.matchAnalysis,
      usedResume: result.usedResume
    });
    
  } catch (error) {
    console.error('Error re-matching job:', error);
    res.status(500).json({ 
      message: 'Failed to re-match job with best resume', 
      error: error.message 
    });
  }
};

// Get resume match status for a specific job
exports.getResumeMatchStatus = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const jobId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(jobId)) {
      return res.status(400).json({ message: 'Invalid job ID' });
    }
    
    const resumes = await Resume.find({ userId });
    const job = await Job.findOne({ _id: jobId, userId });
    
    if (!job) {
      return res.status(404).json({ message: 'Job not found' });
    }
    
    const tailoredResumes = await Resume.find({ 
      userId, 
      isTailored: true, 
      'tailoredForJob.jobId': jobId 
    });
    
    const resumeStatusMap = {};
    
    resumes.forEach(resume => {
      const resumeId = resume._id.toString();
      resumeStatusMap[resumeId] = {
        id: resume._id,
        name: resume.name,
        isMatched: job.matchAnalysis && job.matchAnalysis.resumeId && 
                   job.matchAnalysis.resumeId.toString() === resumeId,
        isTailored: false,
        tailoredVersions: []
      };
    });
    
    tailoredResumes.forEach(tailoredResume => {
      const originalResumeId = tailoredResume.tailoredForJob?.originalResumeId?.toString();
      
      if (originalResumeId && resumeStatusMap[originalResumeId]) {
        resumeStatusMap[originalResumeId].isTailored = true;
        resumeStatusMap[originalResumeId].tailoredVersions.push({
          id: tailoredResume._id,
          name: tailoredResume.name,
          createdAt: tailoredResume.createdAt
        });
      } else {
        console.log('Found tailored resume without clear original reference:', tailoredResume.name);
      }
    });
    
    res.status(200).json({ 
      resumeStatusMap,
      jobMatchedResumeId: job.matchAnalysis?.resumeId?.toString() || null
    });
  } catch (error) {
    console.error('Error fetching resume match status:', error);
    res.status(500).json({ message: 'Failed to fetch resume match status', error: error.message });
  }
};

// Get job analysis insights with real job board statistics
exports.getJobAnalysisInsights = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    // Get all user's jobs with analysis data
    const jobs = await Job.find({ 
      userId,
      parsedData: { $exists: true, $ne: {} }
    });
    
    // Calculate insights with model usage breakdown and real job board stats
    const insights = {
      totalJobsAnalyzed: jobs.length,
      experienceLevels: {},
      topSkillsRequired: {},
      industryDistribution: {},
      averageSkillsPerJob: 0,
      recentAnalyses: [],
      modelUsageStats: {
        'gpt-4o': 0,           // Premium for both manual and AI discovery
        'gpt-4o-mini': 0,      // Legacy (now deprecated)
        'fallback': 0,         // Fallback analyses
        'unknown': 0
      },
      costBreakdown: {
        manualJobs: { count: 0, estimatedCost: 0 },
        aiDiscoveryJobs: { count: 0, estimatedCost: 0 },
        totalEstimatedCost: 0
      },
      // ENHANCED: Real job board statistics
      realJobBoardStats: {
        totalRealJobBoardJobs: 0,
        jobBoardBreakdown: {
          greenhouse: 0,
          lever: 0,
          indeed: 0
        },
        averageContentQuality: 'unknown',
        realVsLegacyAI: {
          realJobBoards: 0,
          legacyAI: 0,
          manual: 0
        }
      }
    };
    
    let totalSkills = 0;
    
    jobs.forEach(job => {
      if (job.parsedData && !job.parsedData.analysisError) {
        // Experience levels
        const expLevel = job.parsedData.experienceLevel || 'unknown';
        insights.experienceLevels[expLevel] = (insights.experienceLevels[expLevel] || 0) + 1;
        
        // Industry distribution
        const industry = job.parsedData.industryContext || 'unknown';
        insights.industryDistribution[industry] = (insights.industryDistribution[industry] || 0) + 1;
        
        // Skills aggregation
        if (job.parsedData.keySkills && Array.isArray(job.parsedData.keySkills)) {
          totalSkills += job.parsedData.keySkills.length;
          job.parsedData.keySkills.forEach(skill => {
            const skillName = skill.name || skill;
            insights.topSkillsRequired[skillName] = (insights.topSkillsRequired[skillName] || 0) + 1;
          });
        }
        
        // Model usage tracking
        const model = job.parsedData.analysisMetadata?.model || 'unknown';
        const modelKey = model.includes('mini') ? 'gpt-4o-mini' : 
                        model.includes('gpt-4o') ? 'gpt-4o' : 
                        model.includes('fallback') ? 'fallback' : 'unknown';
        insights.modelUsageStats[modelKey]++;
        
        // Enhanced job classification with real job board detection
        const isRealJobBoard = job.sourcePlatform && (
          job.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
          job.sourcePlatform.includes('AI_FOUND_LEVER') ||
          job.sourcePlatform.includes('AI_FOUND_INDEED')
        );
        
        const isAiDiscovery = job.sourcePlatform === 'AI_FOUND' || 
                             job.sourcePlatform === 'AI_FOUND_OPTIMIZED' ||
                             job.sourcePlatform === 'AI_FOUND_INTELLIGENT' ||
                             isRealJobBoard;
        
        if (isRealJobBoard) {
          insights.realJobBoardStats.totalRealJobBoardJobs++;
          insights.realJobBoardStats.realVsLegacyAI.realJobBoards++;
          
          // Track specific job board
          if (job.sourcePlatform.includes('GREENHOUSE')) {
            insights.realJobBoardStats.jobBoardBreakdown.greenhouse++;
          } else if (job.sourcePlatform.includes('LEVER')) {
            insights.realJobBoardStats.jobBoardBreakdown.lever++;
          } else if (job.sourcePlatform.includes('INDEED')) {
            insights.realJobBoardStats.jobBoardBreakdown.indeed++;
          }
        } else if (isAiDiscovery) {
          insights.realJobBoardStats.realVsLegacyAI.legacyAI++;
        } else {
          insights.realJobBoardStats.realVsLegacyAI.manual++;
        }
        
        // Cost tracking
        if (isAiDiscovery) {
          insights.costBreakdown.aiDiscoveryJobs.count++;
          insights.costBreakdown.aiDiscoveryJobs.estimatedCost += 0.02; // Premium analysis cost
        } else {
          insights.costBreakdown.manualJobs.count++;
          insights.costBreakdown.manualJobs.estimatedCost += 0.02; // Premium analysis cost
        }
        
        // Recent analyses with job board info
        if (job.parsedData.analysisMetadata?.analyzedAt) {
          insights.recentAnalyses.push({
            jobId: job._id,
            title: job.title,
            company: job.company,
            analyzedAt: job.parsedData.analysisMetadata.analyzedAt,
            skillsFound: job.parsedData.keySkills?.length || 0,
            model: job.parsedData.analysisMetadata.model,
            analysisType: job.parsedData.analysisMetadata.analysisType,
            sourcePlatform: job.sourcePlatform,
            isRealJobBoardDiscovery: isRealJobBoard,
            sourceJobBoard: isRealJobBoard ? (
              job.sourcePlatform.includes('GREENHOUSE') ? 'Greenhouse' :
              job.sourcePlatform.includes('LEVER') ? 'Lever' :
              job.sourcePlatform.includes('INDEED') ? 'Indeed' : 'Unknown'
            ) : null
          });
        }
      }
    });
    
    // Calculate totals and averages
    insights.averageSkillsPerJob = jobs.length > 0 ? Math.round(totalSkills / jobs.length) : 0;
    insights.costBreakdown.totalEstimatedCost = 
      insights.costBreakdown.manualJobs.estimatedCost + 
      insights.costBreakdown.aiDiscoveryJobs.estimatedCost;
    
    // Calculate real job board average content quality
    if (insights.realJobBoardStats.totalRealJobBoardJobs > 0) {
      insights.realJobBoardStats.averageContentQuality = 'high'; // Real job boards typically have high quality
    }
    
    // Sort top skills by frequency
    insights.topSkillsRequired = Object.entries(insights.topSkillsRequired)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .reduce((obj, [skill, count]) => {
        obj[skill] = count;
        return obj;
      }, {});
    
    // Sort recent analyses by date
    insights.recentAnalyses = insights.recentAnalyses
      .sort((a, b) => new Date(b.analyzedAt) - new Date(a.analyzedAt))
      .slice(0, 5);
    
    res.status(200).json({ 
      insights,
      enhancedRealJobBoardInfo: {
        description: 'ENHANCED 3-Phase Approach with REAL Job Board Integration: Career Analysis → Real Job Board Discovery → Premium Analysis',
        improvements: [
          'Phase 1: Enhanced career targeting with GPT-4 Turbo',
          'Phase 2: REAL job board discovery from Greenhouse, Lever, and Indeed',
          'Phase 3: Premium job analysis with GPT-4o (same quality for all jobs)',
          'Direct company posting verification',
          'Enhanced job content quality from ATS platforms'
        ],
        realJobBoardBenefits: [
          'Search actual company job boards (no recruiter spam)',
          'Extract comprehensive job details from ATS platforms',
          'Verify direct company postings with enhanced metadata',
          'Access to tech stack, team info, and hiring manager details',
          'Higher quality job content and requirements'
        ],
        costStructure: {
          phase1: 'Career Analysis: $0.05 (GPT-4 Turbo)',
          phase2: 'Real Job Board Discovery: $0.30-0.50 (Claude 3.5 Sonnet)',
          phase3: 'Premium Analysis: $0.01-0.02 (GPT-4o batch)',
          totalPerSearch: '$0.36-0.57',
          comparison: 'Same cost as previous but now searches REAL job boards'
        },
        targetJobBoards: {
          greenhouse: 'Tech startups and scale-ups with comprehensive postings',
          lever: 'Growth-stage companies with detailed role information',
          indeed: 'Established companies with verified direct postings'
        }
      }
    });
  } catch (error) {
    console.error('Error getting job analysis insights:', error);
    res.status(500).json({ 
      message: 'Failed to get job analysis insights', 
      error: error.message 
    });
  }
};

// AI Search Management Routes

// Get user AI searches
exports.getUserAiSearches = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const searches = await jobSearchService.getUserAiSearches(userId);
    
    res.status(200).json({ searches });
  } catch (error) {
    console.error('Error fetching AI searches:', error);
    res.status(500).json({ 
      message: 'Failed to fetch AI job searches', 
      error: error.message 
    });
  }
};

// Pause AI search
exports.pauseAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.pauseAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error pausing AI search:', error);
    res.status(500).json({ 
      message: 'Failed to pause AI search', 
      error: error.message 
    });
  }
};

// Resume AI search
exports.resumeAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.resumeAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error resuming AI search:', error);
    res.status(500).json({ 
      message: 'Failed to resume AI search', 
      error: error.message 
    });
  }
};

// Delete AI search
exports.deleteAiSearch = async (req, res) => {
  try {
    const userId = req.user?._id || req.userId;
    const { searchId } = req.params;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const result = await jobSearchService.deleteAiSearch(userId, searchId);
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Error deleting AI search:', error);
    res.status(500).json({ 
      message: 'Failed to delete AI search', 
      error: error.message 
    });
  }
};

================
File: controllers/recruiter.controller.js
================
// backend/controllers/recruiter.controller.js - COMPLETE UPDATED VERSION
const { Pool } = require('pg');
const Outreach = require('../models/mongodb/outreach.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const { openai } = require('../config/openai');

// PostgreSQL connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

/**
 * Search recruiters with simplified filtering (no experience or sort filters)
 */
exports.searchRecruiters = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      query = '',
      company = '',
      industry = '',
      location = '',
      title = '',
      limit = 20,
      offset = 0
    } = req.query;

    console.log(`🔍 Searching recruiters for user ${userId}:`, {
      query, company, industry, location, title, limit: parseInt(limit)
    });

    // Build the SQL query dynamically
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone as phone,
        r.title,
        r.linkedin_profile_url as linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        i.name as industry_name,
        l.city,
        l.state,
        l.country,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    // Add search filters with COALESCE to handle NULL values
    if (query) {
      sqlQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${paramIndex} OR
        COALESCE(r.title, '') ILIKE $${paramIndex} OR
        COALESCE(c.name, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${query.toLowerCase()}%`);
      paramIndex++;
    }

    if (company) {
      sqlQuery += ` AND COALESCE(c.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${company.toLowerCase()}%`);
      paramIndex++;
    }

    if (industry) {
      sqlQuery += ` AND COALESCE(i.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${industry.toLowerCase()}%`);
      paramIndex++;
    }

    if (location) {
      sqlQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${paramIndex} OR
        COALESCE(l.state, '') ILIKE $${paramIndex} OR
        COALESCE(l.country, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${location.toLowerCase()}%`);
      paramIndex++;
    }

    if (title) {
      sqlQuery += ` AND COALESCE(r.title, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${title.toLowerCase()}%`);
      paramIndex++;
    }

    // Simple ordering by ID (most recent recruiters first)
    sqlQuery += ` ORDER BY r.id DESC`;
    
    // Add pagination
    sqlQuery += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    queryParams.push(parseInt(limit), parseInt(offset));

    console.log('🗄️ Executing SQL query with params:', queryParams);

    // Execute the query
    const result = await pool.query(sqlQuery, queryParams);

    // Get total count for pagination
    let countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;
    
    const countParams = [userId.toString()];
    let countParamIndex = 2;

    // Apply same filters to count query
    if (query) {
      countQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${countParamIndex} OR
        COALESCE(r.title, '') ILIKE $${countParamIndex} OR
        COALESCE(c.name, '') ILIKE $${countParamIndex}
      )`;
      countParams.push(`%${query.toLowerCase()}%`);
      countParamIndex++;
    }

    if (company) {
      countQuery += ` AND COALESCE(c.name, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${company.toLowerCase()}%`);
      countParamIndex++;
    }

    if (industry) {
      countQuery += ` AND COALESCE(i.name, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${industry.toLowerCase()}%`);
      countParamIndex++;
    }

    if (location) {
      countQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${countParamIndex} OR
        COALESCE(l.state, '') ILIKE $${countParamIndex} OR
        COALESCE(l.country, '') ILIKE $${countParamIndex}
      )`;
      countParams.push(`%${location.toLowerCase()}%`);
      countParamIndex++;
    }

    if (title) {
      countQuery += ` AND COALESCE(r.title, '') ILIKE $${countParamIndex}`;
      countParams.push(`%${title.toLowerCase()}%`);
      countParamIndex++;
    }

    const countResult = await pool.query(countQuery, countParams);

    const recruiters = result.rows.map(row => ({
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      fullName: `${row.first_name || ''} ${row.last_name || ''}`.trim(),
      email: row.email,
      phone: row.phone,
      title: row.title,
      linkedinUrl: row.linkedin_url,
      experienceYears: row.experience_years,
      lastActiveDate: row.last_active_date,
      rating: row.rating,
      company: {
        name: row.company_name,
        website: row.company_website,
        size: row.company_size,
        logo: row.company_logo
      },
      industry: row.industry_name,
      location: {
        city: row.city,
        state: row.state,
        country: row.country
      },
      outreach: {
        hasContacted: !!row.last_contact_date,
        lastContactDate: row.last_contact_date,
        status: row.outreach_status
      }
    }));

    console.log(`✅ Found ${recruiters.length} recruiters (Total: ${countResult.rows[0].count})`);

    res.json({
      success: true,
      recruiters,
      pagination: {
        total: parseInt(countResult.rows[0].count),
        limit: parseInt(limit),
        offset: parseInt(offset),
        hasMore: parseInt(offset) + parseInt(limit) < parseInt(countResult.rows[0].count)
      }
    });

  } catch (error) {
    console.error('Search recruiters error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to search recruiters',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get recruiter details by ID
 */
exports.getRecruiterById = async (req, res) => {
  try {
    const userId = req.user._id;
    const { recruiterId } = req.params;

    console.log(`👤 Getting recruiter details for ID: ${recruiterId}`);

    const sqlQuery = `
      SELECT 
        r.*,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        c.description as company_description,
        c.founded_year,
        i.name as industry_name,
        i.description as industry_description,
        l.city,
        l.state,
        l.country,
        l.postal_code,
        -- Outreach history
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.id = $2
    `;

    const result = await pool.query(sqlQuery, [userId.toString(), recruiterId]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const row = result.rows[0];
    
    // Get recruiter's skills
    const skillsQuery = `
      SELECT s.name, s.category
      FROM recruiter_skills rs
      JOIN skills s ON rs.skill_id = s.id
      WHERE rs.recruiter_id = $1
    `;
    const skillsResult = await pool.query(skillsQuery, [recruiterId]);

    // Get outreach history from MongoDB
    const outreachHistory = await Outreach.find({
      userId,
      recruiterId: recruiterId
    }).sort({ createdAt: -1 }).limit(10);

    const recruiter = {
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      fullName: `${row.first_name || ''} ${row.last_name || ''}`.trim(),
      email: row.email,
      phone: row.direct_phone,
      title: row.title,
      linkedinUrl: row.linkedin_profile_url,
      otherSocialUrls: row.other_social_urls,
      experienceYears: row.experience_years,
      lastActiveDate: row.last_active_date,
      rating: row.rating,
      notes: row.notes,
      specializations: row.specializations,
      company: {
        name: row.company_name,
        website: row.company_website,
        size: row.company_size,
        logo: row.company_logo,
        description: row.company_description,
        foundedYear: row.founded_year
      },
      industry: {
        name: row.industry_name,
        description: row.industry_description
      },
      location: {
        city: row.city,
        state: row.state,
        country: row.country,
        postalCode: row.postal_code
      },
      skills: skillsResult.rows.map(skill => ({
        name: skill.name,
        category: skill.category
      })),
      outreach: {
        hasContacted: !!row.last_contact_date,
        lastContactDate: row.last_contact_date,
        status: row.outreach_status,
        history: outreachHistory
      },
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };

    console.log(`✅ Retrieved recruiter: ${recruiter.fullName} at ${recruiter.company.name}`);

    res.json({
      success: true,
      recruiter
    });

  } catch (error) {
    console.error('Get recruiter details error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get recruiter details',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get filter options for recruiter search (simplified - no experience ranges)
 */
exports.getFilterOptions = async (req, res) => {
  try {
    console.log('📊 Getting filter options for recruiter search');

    // Get top companies
    const companiesQuery = `
      SELECT c.name, COUNT(r.id) as recruiter_count
      FROM companies c
      JOIN recruiters r ON c.id = r.current_company_id
      WHERE r.is_active = true
      GROUP BY c.id, c.name
      ORDER BY recruiter_count DESC
      LIMIT 50
    `;

    // Get industries
    const industriesQuery = `
      SELECT i.name, COUNT(r.id) as recruiter_count
      FROM industries i
      JOIN recruiters r ON i.id = r.industry_id
      WHERE r.is_active = true
      GROUP BY i.id, i.name
      ORDER BY recruiter_count DESC
      LIMIT 30
    `;

    // Get locations
    const locationsQuery = `
      SELECT 
        CASE 
          WHEN l.state IS NOT NULL THEN l.city || ', ' || l.state || ', ' || l.country
          ELSE l.city || ', ' || l.country
        END as location,
        COUNT(r.id) as recruiter_count
      FROM locations l
      JOIN recruiters r ON l.id = r.location_id
      WHERE r.is_active = true
      GROUP BY l.city, l.state, l.country
      ORDER BY recruiter_count DESC
      LIMIT 50
    `;

    const [companies, industries, locations] = await Promise.all([
      pool.query(companiesQuery),
      pool.query(industriesQuery),
      pool.query(locationsQuery)
    ]);

    const filterOptions = {
      companies: companies.rows.map(row => ({
        name: row.name,
        count: parseInt(row.recruiter_count)
      })),
      industries: industries.rows.map(row => ({
        name: row.name,
        count: parseInt(row.recruiter_count)
      })),
      locations: locations.rows.map(row => ({
        name: row.location,
        count: parseInt(row.recruiter_count)
      }))
    };

    console.log(`✅ Retrieved filter options - ${filterOptions.companies.length} companies, ${filterOptions.industries.length} industries`);

    res.json({
      success: true,
      filterOptions
    });

  } catch (error) {
    console.error('Get filter options error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get filter options',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Create outreach campaign
 */
exports.createOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      recruiterId,
      jobId,
      messageContent,
      messageTemplate,
      sentVia = 'linkedin',
      customizations = []
    } = req.body;

    console.log(`📧 Creating outreach for recruiter ${recruiterId} by user ${userId}`);

    // Validate inputs
    if (!recruiterId || !messageContent) {
      return res.status(400).json({
        success: false,
        error: 'Recruiter ID and message content are required'
      });
    }

    // Get recruiter details for validation
    const recruiterQuery = `SELECT id, first_name, last_name, email FROM recruiters WHERE id = $1`;
    const recruiterResult = await pool.query(recruiterQuery, [recruiterId]);

    if (recruiterResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const recruiter = recruiterResult.rows[0];

    // Create outreach record in MongoDB
    const outreach = new Outreach({
      userId,
      recruiterId: recruiterId.toString(),
      jobId,
      messageContent,
      messageTemplate,
      customizations,
      sentVia,
      status: 'drafted',
      createdAt: new Date()
    });

    await outreach.save();

    // Update PostgreSQL outreach history
    const upsertQuery = `
      INSERT INTO outreach_history (recruiter_id, mongodb_outreach_id, mongodb_user_id, status, last_contact_date)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (recruiter_id, mongodb_user_id) 
      DO UPDATE SET 
        mongodb_outreach_id = $2,
        status = $4,
        last_contact_date = $5,
        updated_at = NOW()
    `;

    await pool.query(upsertQuery, [
      recruiterId,
      outreach._id.toString(),
      userId.toString(),
      'drafted',
      new Date()
    ]);

    console.log(`✅ Created outreach campaign: ${outreach._id}`);

    res.json({
      success: true,
      outreach: {
        id: outreach._id,
        recruiterId: outreach.recruiterId,
        recruiterName: `${recruiter.first_name} ${recruiter.last_name}`,
        messageContent: outreach.messageContent,
        status: outreach.status,
        createdAt: outreach.createdAt
      },
      message: 'Outreach campaign created successfully'
    });

  } catch (error) {
    console.error('Create outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Update outreach campaign - NEW METHOD
 */
exports.updateOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;
    const updates = req.body;

    console.log(`📝 Updating outreach ${outreachId} for user ${userId}`);

    // Find and update outreach
    const outreach = await Outreach.findOneAndUpdate(
      { _id: outreachId, userId },
      { ...updates, updatedAt: new Date() },
      { new: true }
    );

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    // Update PostgreSQL record if status changed
    if (updates.status) {
      await pool.query(
        'UPDATE outreach_history SET status = $1, updated_at = NOW() WHERE mongodb_outreach_id = $2',
        [updates.status, outreachId]
      );
    }

    console.log(`✅ Outreach updated successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach campaign updated successfully',
      outreach: {
        id: outreach._id,
        status: outreach.status,
        messageContent: outreach.messageContent,
        updatedAt: outreach.updatedAt
      }
    });

  } catch (error) {
    console.error('Update outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Delete outreach campaign - NEW METHOD
 */
exports.deleteOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;

    console.log(`🗑️ Deleting outreach ${outreachId} for user ${userId}`);

    // Find and delete outreach from MongoDB
    const outreach = await Outreach.findOneAndDelete({ _id: outreachId, userId });

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    // Delete from PostgreSQL outreach history
    await pool.query(
      'DELETE FROM outreach_history WHERE mongodb_outreach_id = $1 AND mongodb_user_id = $2',
      [outreachId, userId.toString()]
    );

    console.log(`✅ Outreach deleted successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach campaign deleted successfully',
      deletedId: outreachId
    });

  } catch (error) {
    console.error('Delete outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete outreach campaign',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Send outreach message
 */
exports.sendOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { outreachId } = req.params;

    console.log(`📤 Sending outreach ${outreachId} for user ${userId}`);

    // Find and update outreach
    const outreach = await Outreach.findOne({ _id: outreachId, userId });

    if (!outreach) {
      return res.status(404).json({
        success: false,
        error: 'Outreach campaign not found'
      });
    }

    if (outreach.status !== 'drafted') {
      return res.status(400).json({
        success: false,
        error: 'Outreach has already been sent'
      });
    }

    // Update outreach status
    outreach.status = 'sent';
    outreach.sentAt = new Date();
    await outreach.save();

    // Update PostgreSQL record
    await pool.query(
      'UPDATE outreach_history SET status = $1, last_contact_date = $2 WHERE mongodb_outreach_id = $3',
      ['sent', new Date(), outreachId]
    );

    console.log(`✅ Outreach sent successfully: ${outreachId}`);

    res.json({
      success: true,
      message: 'Outreach sent successfully',
      outreach: {
        id: outreach._id,
        status: outreach.status,
        sentAt: outreach.sentAt
      }
    });

  } catch (error) {
    console.error('Send outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send outreach',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get user's outreach campaigns
 */
exports.getUserOutreach = async (req, res) => {
  try {
    const userId = req.user._id;
    const { status, limit = 20, offset = 0 } = req.query;

    console.log(`📋 Getting outreach campaigns for user ${userId}`);

    // Build filter
    const filter = { userId };
    if (status) {
      filter.status = status;
    }

    // Get outreach campaigns
    const outreaches = await Outreach.find(filter)
      .sort({ createdAt: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));

    // Get recruiter details for each outreach
    const recruiterIds = outreaches.map(o => o.recruiterId);
    
    if (recruiterIds.length > 0) {
      const recruitersQuery = `
        SELECT r.id, r.first_name, r.last_name, r.title, r.email,
               c.name as company_name, c.logo_url as company_logo
        FROM recruiters r
        LEFT JOIN companies c ON r.current_company_id = c.id
        WHERE r.id = ANY($1)
      `;
      
      const recruitersResult = await pool.query(recruitersQuery, [recruiterIds]);
      const recruitersMap = new Map(recruitersResult.rows.map(r => [r.id.toString(), r]));

      // Combine data
      const enrichedOutreaches = outreaches.map(outreach => {
        const recruiter = recruitersMap.get(outreach.recruiterId);
        return {
          id: outreach._id,
          recruiterId: outreach.recruiterId,
          recruiter: recruiter ? {
            name: `${recruiter.first_name} ${recruiter.last_name}`,
            title: recruiter.title,
            email: recruiter.email,
            company: {
              name: recruiter.company_name,
              logo: recruiter.company_logo
            }
          } : null,
          messageContent: outreach.messageContent,
          status: outreach.status,
          sentVia: outreach.sentVia,
          createdAt: outreach.createdAt,
          sentAt: outreach.sentAt,
          repliesCount: outreach.replies ? outreach.replies.length : 0,
          followUpsCount: outreach.followUps ? outreach.followUps.length : 0
        };
      });

      res.json({
        success: true,
        outreaches: enrichedOutreaches,
        pagination: {
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: outreaches.length === parseInt(limit)
        }
      });
    } else {
      res.json({
        success: true,
        outreaches: [],
        pagination: {
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: false
        }
      });
    }

  } catch (error) {
    console.error('Get user outreach error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get outreach campaigns',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Generate AI-powered personalized message
 */
exports.generatePersonalizedMessage = async (req, res) => {
  try {
    const userId = req.user._id;
    const {
      recruiterId,
      resumeId,
      jobId,
      messageType = 'introduction',
      tone = 'professional',
      customRequirements = ''
    } = req.body;

    console.log(`🤖 Generating personalized message for recruiter ${recruiterId}`);

    // Get recruiter details
    const recruiterQuery = `
      SELECT r.first_name, r.last_name, r.title, r.specializations,
             c.name as company_name, c.description as company_description,
             i.name as industry_name
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      WHERE r.id = $1
    `;
    const recruiterResult = await pool.query(recruiterQuery, [recruiterId]);

    if (recruiterResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Recruiter not found'
      });
    }

    const recruiter = recruiterResult.rows[0];

    // Get user's resume if provided
    let resume = null;
    if (resumeId) {
      resume = await Resume.findOne({ _id: resumeId, userId });
    }

    // Get job details if provided
    let job = null;
    if (jobId) {
      job = await Job.findOne({ _id: jobId, userId });
    }

    // Build AI prompt
    const prompt = buildPersonalizedMessagePrompt(recruiter, resume, job, messageType, tone, customRequirements);

    // Generate message using OpenAI
    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: 'You are an expert career coach and networking specialist. Generate professional, personalized outreach messages that are engaging and authentic.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 500
    });

    const generatedMessage = response.choices[0].message.content;

    console.log(`✅ Generated personalized message (${generatedMessage.length} characters)`);

    res.json({
      success: true,
      message: generatedMessage,
      metadata: {
        recruiterName: `${recruiter.first_name} ${recruiter.last_name}`,
        company: recruiter.company_name,
        messageType,
        tone,
        tokensUsed: response.usage?.total_tokens || 0
      }
    });

  } catch (error) {
    console.error('Generate personalized message error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to generate personalized message',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }
};

/**
 * Get outreach analytics
 */
exports.getOutreachAnalytics = async (req, res) => {
  try {
    const userId = req.user._id;
    const { timeframe = '30d' } = req.query;

    console.log(`📊 Getting outreach analytics for user ${userId}`);

    // Calculate date range
    const startDate = new Date();
    switch (timeframe) {
      case '7d':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(startDate.getDate() - 30);
        break;
      case '90d':
        startDate.setDate(startDate.getDate() - 90);
        break;
    }

    // Get analytics from MongoDB
    const analytics = await Outreach.aggregate([
      {
        $match: {
          userId: userId,
          createdAt: { $gte: startDate }
        }
      },
      {
        $group: {
          _id: null,
          totalOutreach: { $sum: 1 },
sent: { $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] } },
         replied: { $sum: { $cond: [{ $eq: ['$status', 'replied'] }, 1, 0] } },
         drafted: { $sum: { $cond: [{ $eq: ['$status', 'drafted'] }, 1, 0] } },
         totalReplies: { $sum: { $size: { $ifNull: ['$replies', []] } } },
         totalFollowUps: { $sum: { $size: { $ifNull: ['$followUps', []] } } }
       }
     }
   ]);

   const stats = analytics[0] || {
     totalOutreach: 0,
     sent: 0,
     replied: 0,
     drafted: 0,
     totalReplies: 0,
     totalFollowUps: 0
   };

   // Calculate rates
   const responseRate = stats.sent > 0 ? (stats.replied / stats.sent) * 100 : 0;
   const sendRate = stats.totalOutreach > 0 ? (stats.sent / stats.totalOutreach) * 100 : 0;

   res.json({
     success: true,
     analytics: {
       ...stats,
       responseRate: Math.round(responseRate * 100) / 100,
       sendRate: Math.round(sendRate * 100) / 100,
       timeframe
     }
   });

 } catch (error) {
   console.error('Get outreach analytics error:', error);
   res.status(500).json({
     success: false,
     error: 'Failed to get outreach analytics',
     details: process.env.NODE_ENV !== 'production' ? error.message : undefined
   });
 }
};

// Helper function to build AI prompt
function buildPersonalizedMessagePrompt(recruiter, resume, job, messageType, tone, customRequirements) {
 const recruiterName = `${recruiter.first_name} ${recruiter.last_name}`;
 const company = recruiter.company_name;
 
 let prompt = `Generate a ${tone} ${messageType} message to ${recruiterName}, a ${recruiter.title} at ${company}.\n\n`;
 
 prompt += `RECRUITER CONTEXT:\n`;
 prompt += `- Name: ${recruiterName}\n`;
 prompt += `- Title: ${recruiter.title}\n`;
 prompt += `- Company: ${company}\n`;
 if (recruiter.specializations) {
   prompt += `- Specializations: ${recruiter.specializations.join(', ')}\n`;
 }
 if (recruiter.industry_name) {
   prompt += `- Industry: ${recruiter.industry_name}\n`;
 }
 
 if (resume) {
   prompt += `\nUSER BACKGROUND:\n`;
   prompt += `- Name: ${resume.parsedData?.contactInfo?.name || 'Professional'}\n`;
   if (resume.parsedData?.summary) {
     prompt += `- Summary: ${resume.parsedData.summary}\n`;
   }
   if (resume.parsedData?.experience?.length > 0) {
     const currentRole = resume.parsedData.experience[0];
     prompt += `- Current Role: ${currentRole.title} at ${currentRole.company}\n`;
   }
   if (resume.parsedData?.skills?.length > 0) {
     const topSkills = resume.parsedData.skills.slice(0, 5).map(s => typeof s === 'string' ? s : s.name);
     prompt += `- Key Skills: ${topSkills.join(', ')}\n`;
   }
 }
 
 if (job) {
   prompt += `\nTARGET POSITION:\n`;
   prompt += `- Title: ${job.title}\n`;
   prompt += `- Company: ${job.company}\n`;
   if (job.description) {
     prompt += `- Description: ${job.description.substring(0, 200)}...\n`;
   }
 }
 
 if (customRequirements) {
   prompt += `\nCUSTOM REQUIREMENTS:\n${customRequirements}\n`;
 }
 
 prompt += `\nGUIDELINES:\n`;
 prompt += `- Keep the message concise (2-3 paragraphs)\n`;
 prompt += `- Make it personal and specific to ${recruiterName}\n`;
 prompt += `- Use a ${tone} tone\n`;
 prompt += `- Include a clear call-to-action\n`;
 prompt += `- Avoid overly salesy language\n`;
 prompt += `- Make it authentic and professional\n`;
 
 if (messageType === 'introduction') {
   prompt += `- Focus on introducing yourself and expressing interest in their company\n`;
 } else if (messageType === 'follow_up') {
   prompt += `- Reference previous contact and provide additional value\n`;
 } else if (messageType === 'application') {
   prompt += `- Express interest in a specific role and highlight relevant qualifications\n`;
 }
 
 return prompt;
}

module.exports = exports;

================
File: controllers/resume.controller.js
================
// controllers/resume.controller.js - COMPLETE FIXED VERSION
const { PutObjectCommand, GetObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const { s3Client, S3_BUCKET } = require('../config/s3');
const Resume = require('../models/mongodb/resume.model');
const resumeParserService = require('../services/resumeParser.service');
const resumeAnalysisService = require('../services/resumeAnalysis.service');
const mongoose = require('mongoose');
const path = require('path');
const uuid = require('uuid').v4;

// Helper function to generate S3 key for a resume file
const generateS3Key = (userId, originalFilename) => {
  const extension = path.extname(originalFilename);
  return `resumes/${userId}/${uuid()}${extension}`;
};

// Upload a new resume
exports.uploadResume = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Get userId from either req.user._id or req.userId (depending on how auth middleware works)
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }

    const originalFilename = req.file.originalname;
    
    // Determine file type - IMPORTANT: Use UPPERCASE to match the schema enum
    let fileType;
    if (req.file.mimetype === 'application/pdf' || originalFilename.toLowerCase().endsWith('.pdf')) {
      fileType = 'PDF'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
      originalFilename.toLowerCase().endsWith('.docx')
    ) {
      fileType = 'DOCX'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/msword' || 
      originalFilename.toLowerCase().endsWith('.doc')
    ) {
      fileType = 'DOC'; // Uppercase to match schema enum
    } else {
      return res.status(400).json({ message: 'Only PDF, DOCX, and DOC files are supported' });
    }
    
    console.log('Determined file type:', fileType); // Log for debugging
    
    const s3Key = generateS3Key(userId, originalFilename);
    
    // Create resume record in MongoDB with initial processing status
    const resume = new Resume({
      userId,
      name: req.body.name || originalFilename,
      originalFilename,
      fileUrl: s3Key,
      fileType: fileType, // Using uppercase file type to match schema enum
      processingStatus: {
        status: 'uploading',
        progress: 10,
        message: 'Uploading file to storage...',
        updatedAt: new Date()
      },
      parsedData: {}, // Will be populated after analysis
      analysis: {}, // Will be populated after analysis
      versions: []
    });

    await resume.save();
    console.log('Resume record created in MongoDB');
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: req.file.buffer,
      ContentType: req.file.mimetype
    };

    // Log the upload attempt for debugging
    console.log('Attempting S3 upload with params:', {
      Bucket: S3_BUCKET,
      Key: `${s3Key.substring(0, 20)}...`, // Don't log the full key for security
      ContentType: req.file.mimetype,
      FileSize: req.file.size
    });

    await s3Client.send(new PutObjectCommand(uploadParams));
    console.log('S3 upload successful');
    
    // Update processing status after successful upload
    resume.processingStatus = {
      status: 'parsing',
      progress: 25,
      message: 'Parsing resume content...',
      updatedAt: new Date()
    };
    await resume.save();

    // IMPORTANT: Initiate async parsing and analysis in the background
    // This way the user doesn't have to wait for the process to complete
    processResumeInBackground(resume._id, s3Key, fileType).catch(err => {
      console.error('Background resume processing error:', err);
      // Update status to error if background processing fails
      updateResumeProcessingStatus(resume._id, 'error', 0, 'Error processing resume', err.message)
        .catch(updateErr => console.error('Error updating processing status:', updateErr));
    });

    // Return response with resume data and processing status
    res.status(201).json({
      message: 'Resume uploaded successfully and processing initiated',
      resume: {
        id: resume._id,
        name: resume.name,
        originalFilename: resume.originalFilename,
        fileType: resume.fileType,
        createdAt: resume.createdAt,
        processingStatus: resume.processingStatus
      }
    });
  } catch (error) {
    console.error('Error uploading resume:', error);
    res.status(500).json({ message: 'Failed to upload resume', error: error.message });
  }
};

// Helper function to update resume processing status
async function updateResumeProcessingStatus(resumeId, status, progress, message, error = '') {
  try {
    const resume = await Resume.findById(resumeId);
    if (!resume) {
      console.error(`Resume not found for ID: ${resumeId}`);
      return false;
    }
    
    resume.processingStatus = {
      status,
      progress,
      message,
      error,
      updatedAt: new Date()
    };
    
    await resume.save();
    console.log(`Updated processing status for resume ${resumeId}: ${status} (${progress}%)`);
    return true;
  } catch (err) {
    console.error('Error updating resume processing status:', err);
    return false;
  }
}

// Background processing function - UPDATED WITH BETTER ERROR HANDLING AND LOGGING
async function processResumeInBackground(resumeId, fileUrl, fileType) {
  try {
    console.log(`Starting background processing for resume: ${resumeId}`);
    
    // Get the resume from the database
    const resume = await Resume.findById(resumeId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    // Step 1: Parse the resume using OpenAI
    console.log('Starting resume parsing...');
    // Update status to parsing (25-50%)
    await updateResumeProcessingStatus(resumeId, 'parsing', 30, 'Extracting content from resume...');
    
    const parsedData = await resumeParserService.parseResume(fileUrl, fileType);
    
    // CRITICAL FIX: Ensure parsedData is valid before saving
    if (!parsedData || typeof parsedData !== 'object') {
      throw new Error('Invalid parsed data received from parser service');
    }
    
    // Update the resume with parsed data
    resume.parsedData = parsedData;
    await resume.save();
    console.log('Resume parsing completed, data saved to database');
    
    // Update status to analyzing (50-90%)
    await updateResumeProcessingStatus(resumeId, 'analyzing', 50, 'Parsing complete. Starting AI analysis...');
    
    // Step 2: Analyze the resume using OpenAI
    console.log('Starting resume analysis...');
    const analysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // CRITICAL FIX: Validate analysis data before saving
    if (!analysis || typeof analysis !== 'object') {
      throw new Error('Invalid analysis data received from analysis service');
    }
    
    console.log('Analysis completed, data structure:', {
      overallScore: analysis.overallScore,
      atsCompatibility: analysis.atsCompatibility,
      hasProfileSummary: !!analysis.profileSummary,
      strengthsCount: analysis.strengths?.length || 0,
      weaknessesCount: analysis.weaknesses?.length || 0,
      improvementAreasCount: analysis.improvementAreas?.length || 0
    });
    
    // Update progress during analysis
    await updateResumeProcessingStatus(resumeId, 'analyzing', 75, 'AI analysis in progress...');
    
    // CRITICAL FIX: Ensure analysis data is properly assigned and saved
    resume.analysis = analysis;
    
    // Force save and verify
    const savedResume = await resume.save();
    console.log('Resume analysis saved to database:', {
      resumeId: savedResume._id,
      hasAnalysis: !!savedResume.analysis,
      overallScore: savedResume.analysis?.overallScore,
      atsCompatibility: savedResume.analysis?.atsCompatibility
    });
    
    // Double-check by re-fetching from database
    const verificationResume = await Resume.findById(resumeId);
    if (!verificationResume.analysis || !verificationResume.analysis.overallScore) {
      console.error('CRITICAL ERROR: Analysis data was not saved properly to database');
      throw new Error('Failed to save analysis data to database');
    }
    
    console.log('Database verification successful - analysis data persisted correctly');
    
    // Update status to completed (100%)
    await updateResumeProcessingStatus(resumeId, 'completed', 100, 'Resume processing completed successfully');
    console.log('Resume analyzed successfully');
    
    return true;
  } catch (error) {
    console.error('Error in background processing:', error);
    // Update status to error
    await updateResumeProcessingStatus(
      resumeId, 
      'error', 
      0, 
      'Error processing resume', 
      error.message || 'Unknown error'
    );
    throw error;
  }
}

// Create a tailored resume
exports.createTailoredResume = async (req, res) => {
  try {
    const { resumeId, jobId } = req.params;
    const { name, notes } = req.body;
    
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    // Validate input
    if (!resumeId || !jobId) {
      return res.status(400).json({ message: 'Resume ID and Job ID are required' });
    }
    
    console.log(`Creating tailored resume: resumeId=${resumeId}, jobId=${jobId}, userId=${userId}`);
    
    // Import the tailoring service
    const resumeTailoringService = require('../services/resumeTailoring.service');
    
    // Create the tailored resume with improved PDF generation and fresh analysis
    const result = await resumeTailoringService.createTailoredResume(resumeId, jobId, {
      name,
      notes
    });
    
    console.log('Tailored resume created successfully:', {
      resumeId: result.resume.id,
      hasAnalysis: !!result.resume.analysis,
      overallScore: result.resume.analysis?.overallScore,
      downloadUrl: !!result.resume.downloadUrl
    });
    
    res.status(201).json(result);
  } catch (error) {
    console.error('Error creating tailored resume:', error);
    res.status(500).json({ 
      message: 'Failed to create tailored resume', 
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// Get all resumes for a user
exports.getUserResumes = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    
    // Generate temporary signed URLs for each resume
    const resumesWithUrls = await Promise.all(resumes.map(async (resume) => {
      const getObjectParams = {
        Bucket: S3_BUCKET,
        Key: resume.fileUrl
      };
      
      const command = new GetObjectCommand(getObjectParams);
      const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 }); // URL expires in 1 hour
      
      return {
        _id: resume._id,
        name: resume.name,
        originalFilename: resume.originalFilename,
        fileType: resume.fileType,
        createdAt: resume.createdAt,
        updatedAt: resume.updatedAt,
        downloadUrl: signedUrl,
        analysis: resume.analysis,
        processingStatus: resume.processingStatus || {
          status: 'completed',
          progress: 100,
          message: 'Resume processing completed'
        },
        isTailored: resume.isTailored || false,
        tailoredForJob: resume.tailoredForJob || null,
        versions: resume.versions.map(v => ({
          id: v._id,
          versionNumber: v.versionNumber,
          createdAt: v.createdAt,
          changesDescription: v.changesDescription
        }))
      };
    }));
    
    res.status(200).json({ resumes: resumesWithUrls });
  } catch (error) {
    console.error('Error fetching resumes:', error);
    res.status(500).json({ message: 'Failed to fetch resumes', error: error.message });
  }
};

// Get a specific resume by ID
exports.getResumeById = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // CRITICAL DEBUG: Log what we're retrieving
    console.log('Retrieved resume from database:', {
      resumeId: resume._id,
      hasAnalysis: !!resume.analysis,
      hasProcessingStatus: !!resume.processingStatus,
      overallScore: resume.analysis?.overallScore,
      atsCompatibility: resume.analysis?.atsCompatibility,
      analysisKeys: resume.analysis ? Object.keys(resume.analysis) : []
    });
    
    // Generate temporary signed URL for the resume
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: resume.fileUrl
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 }); // URL expires in 1 hour
    
    // Generate URLs for all versions if they exist
    const versionsWithUrls = await Promise.all((resume.versions || []).map(async (version) => {
      const versionParams = {
        Bucket: S3_BUCKET,
        Key: version.fileUrl
      };
      
      const versionCommand = new GetObjectCommand(versionParams);
      const versionUrl = await getSignedUrl(s3Client, versionCommand, { expiresIn: 3600 });
      
      return {
        id: version._id,
        versionNumber: version.versionNumber,
        createdAt: version.createdAt,
        changesDescription: version.changesDescription,
        downloadUrl: versionUrl,
        jobId: version.jobId
      };
    }));
    
    // CRITICAL FIX: Ensure analysis data is properly structured for the frontend
    const analysisData = resume.analysis || {};
    
    const resumeData = {
      id: resume._id,
      name: resume.name,
      originalFilename: resume.originalFilename,
      fileType: resume.fileType,
      createdAt: resume.createdAt,
      updatedAt: resume.updatedAt,
      downloadUrl: signedUrl,
      parsedData: resume.parsedData || {},
      analysis: {
        overallScore: analysisData.overallScore || 0,
        atsCompatibility: analysisData.atsCompatibility || 0,
        profileSummary: analysisData.profileSummary || {
          currentRole: "Not specified",
          careerLevel: "Mid-level",
          industries: [],
          suggestedJobTitles: [],
          suggestedIndustries: []
        },
        strengths: analysisData.strengths || [],
        weaknesses: analysisData.weaknesses || [],
        keywordsSuggestions: analysisData.keywordsSuggestions || [],
        improvementAreas: analysisData.improvementAreas || []
      },
      processingStatus: resume.processingStatus || {
        status: 'completed',
        progress: 100,
        message: 'Resume processing completed'
      },
      isTailored: resume.isTailored || false,
      tailoredForJob: resume.tailoredForJob || null,
      versions: versionsWithUrls
    };
    
    // CRITICAL DEBUG: Log what we're sending to frontend
    console.log('Sending resume data to frontend:', {
      hasAnalysis: !!resumeData.analysis,
      overallScore: resumeData.analysis.overallScore,
      atsCompatibility: resumeData.analysis.atsCompatibility,
      strengthsCount: resumeData.analysis.strengths.length,
      weaknessesCount: resumeData.analysis.weaknesses.length
    });
    
    res.status(200).json({ resume: resumeData });
  } catch (error) {
    console.error('Error fetching resume:', error);
    res.status(500).json({ message: 'Failed to fetch resume', error: error.message });
  }
};

// Optimize resume for ATS with real-time progress via SSE
exports.optimizeResumeForATS = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    console.log(`🤖 AJ: Starting ATS optimization for resume ${resumeId}`);
    
    // Import the resume editor service
    const ResumeEditorService = require('../services/resumeEditor.service');
    
    // Get optional target job from request body
    const targetJob = req.body.targetJob || null;
    
    // Store original resume data for before/after comparison
    const Resume = require('../models/mongodb/resume.model');
    const originalResume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!originalResume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Store original data for comparison
    const originalData = {
      parsedData: JSON.parse(JSON.stringify(originalResume.parsedData)),
      analysis: JSON.parse(JSON.stringify(originalResume.analysis || {}))
    };
    
    // Create progress callback function
    const progressCallback = (stage, percentage, message) => {
      console.log(`📊 Backend Progress: ${percentage}% - ${message}`);
      // In a real implementation, you might store this in Redis or broadcast via WebSocket
      // For now, we'll rely on the backend logs and frontend timing
    };
    
    // Call the ATS optimization service with progress callback
    const result = await ResumeEditorService.optimizeForATSWithProgress(
      resumeId, 
      userId, 
      targetJob,
      originalData,
      progressCallback
    );
    
    console.log(`✅ AJ: ATS optimization completed. New score: ${result.newATSScore}%`);
    
    res.status(200).json({
      success: true,
      message: 'Resume optimized for ATS successfully',
      data: {
        optimizations: result.optimizations,
        previousATSScore: result.previousScore,
        newATSScore: result.newATSScore,
        improvementGain: result.newATSScore - result.previousScore,
        updatedResume: {
          id: result.updatedResume._id,
          name: result.updatedResume.name,
          analysis: result.updatedResume.analysis,
          versions: result.updatedResume.versions
        },
        // Add before/after comparison data
        comparison: result.comparison,
        // Add timing information for frontend
        processingTime: result.processingTime,
        stages: result.stages
      }
    });
  } catch (error) {
    console.error('❌ ATS optimization error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to optimize resume for ATS', 
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// 📡 SSE endpoint for real-time optimization progress - FIXED SINGLE VERSION
exports.getOptimizationProgress = async (req, res) => {
  try {
    console.log('📡 SSE optimization-progress endpoint hit:', req.params.id, 'Query:', req.query);
    
    const resumeId = req.params.id;
    let userId;
    
    // Handle authentication via token query parameter
    if (req.query.token) {
      try {
        const jwt = require('jsonwebtoken');
        const User = require('../models/mongodb/user.model');
        
        const decoded = jwt.verify(req.query.token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.id);
        
        if (!user || !user.active) {
          console.error('❌ Invalid user for SSE');
          return res.status(401).json({ error: 'Invalid user' });
        }
        
        userId = user._id;
        console.log('📡 SSE authenticated for resume:', resumeId, 'user:', userId);
        
      } catch (tokenError) {
        console.error('❌ SSE Token verification failed:', tokenError.message);
        return res.status(401).json({ error: 'Invalid token' });
      }
    } else {
      console.error('❌ SSE No token provided');
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    console.log('📡 Setting up SSE headers for resume:', resumeId);
    
    // Set SSE headers
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // Send initial connection message
    const welcomeMessage = {
      type: 'connected',
      message: 'Progress stream connected successfully',
      resumeId: resumeId,
      timestamp: new Date().toISOString()
    };
    
    res.write(`data: ${JSON.stringify(welcomeMessage)}\n\n`);
    console.log('📡 Sent welcome message:', welcomeMessage);

    // Store client for progress updates
    const clientId = `${userId}_${resumeId}_${Date.now()}`;
    
    if (!global.progressClients) {
      global.progressClients = new Map();
    }
    
    global.progressClients.set(clientId, res);
    console.log(`📡 SSE client registered: ${clientId}. Total clients: ${global.progressClients.size}`);
    
    // Send a test progress message
    setTimeout(() => {
      try {
        const testMessage = {
          type: 'progress',
          percentage: 10,
          message: 'SSE connection established, ready for progress updates',
          resumeId: resumeId,
          timestamp: new Date().toISOString()
        };
        res.write(`data: ${JSON.stringify(testMessage)}\n\n`);
        console.log('📡 Sent test progress message');
      } catch (error) {
        console.error('❌ Error sending test message:', error);
      }
    }, 1000);
    
    // Cleanup on client disconnect
    req.on('close', () => {
      console.log(`📡 SSE client disconnected: ${clientId}`);
      global.progressClients.delete(clientId);
      console.log(`📡 Remaining SSE clients: ${global.progressClients.size}`);
    });
    
    req.on('error', (err) => {
      console.error('📡 SSE connection error:', err);
      global.progressClients.delete(clientId);
    });

    // Keep connection alive with heartbeat
    const heartbeat = setInterval(() => {
      try {
        if (global.progressClients.has(clientId)) {
          res.write(`data: ${JSON.stringify({ 
            type: 'heartbeat', 
            timestamp: new Date().toISOString() 
          })}\n\n`);
        } else {
          clearInterval(heartbeat);
        }
      } catch (error) {
        console.error('❌ SSE heartbeat failed:', error);
        clearInterval(heartbeat);
        global.progressClients.delete(clientId);
      }
    }, 30000);

    // Cleanup heartbeat on disconnect
    req.on('close', () => {
      clearInterval(heartbeat);
    });

  } catch (error) {
    console.error('❌ SSE Setup Error:', error);
    try {
      res.status(500).json({ error: 'Failed to setup progress stream', details: error.message });
    } catch (responseError) {
      console.error('❌ Error sending error response:', responseError);
    }
  }
};

// Manually trigger resume analysis
exports.analyzeResume = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // If resume hasn't been parsed yet, parse it first
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      try {
        const parsedData = await resumeParserService.parseResume(resume.fileUrl, resume.fileType);
        resume.parsedData = parsedData;
        await resume.save();
      } catch (parseError) {
        console.error('Error parsing resume:', parseError);
        return res.status(500).json({ 
          message: 'Failed to parse resume',
          error: parseError.message
        });
      }
    }
    
    // Analyze the resume using OpenAI
    try {
      const analysis = await resumeAnalysisService.analyzeResume(resumeId);
      
      // Update the resume with analysis data
      resume.analysis = analysis;
      await resume.save();
      
      res.status(200).json({ 
        message: 'Resume analyzed successfully',
        analysis
      });
    } catch (analysisError) {
      console.error('Error analyzing resume:', analysisError);
      res.status(500).json({ 
        message: 'Failed to analyze resume',
        error: analysisError.message
      });
    }
  } catch (error) {
    console.error('Error in analyze resume endpoint:', error);
    res.status(500).json({ message: 'Failed to process request', error: error.message });
  }
};

// Add a new version to an existing resume
exports.addResumeVersion = async (req, res) => {
  try {
    // Check if S3 bucket is configured
    if (!S3_BUCKET) {
      return res.status(500).json({ 
        message: 'S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.' 
      });
    }

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    const originalFilename = req.file.originalname;
    
// Determine file type - IMPORTANT: Use UPPERCASE to match the schema enum
    let fileType;
    if (req.file.mimetype === 'application/pdf' || originalFilename.toLowerCase().endsWith('.pdf')) {
      fileType = 'PDF'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
      originalFilename.toLowerCase().endsWith('.docx')
    ) {
      fileType = 'DOCX'; // Uppercase to match schema enum
    } else if (
      req.file.mimetype === 'application/msword' || 
      originalFilename.toLowerCase().endsWith('.doc')
    ) {
      fileType = 'DOC'; // Uppercase to match schema enum
    } else {
      return res.status(400).json({ message: 'Only PDF, DOCX, and DOC files are supported' });
    }
    
    const s3Key = generateS3Key(userId, originalFilename);
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: req.file.buffer,
      ContentType: req.file.mimetype
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    
    // Create new version
    const versionNumber = (resume.versions || []).length + 2; // +2 because original is version 1
    const newVersion = {
      versionNumber,
      createdAt: new Date(),
      fileUrl: s3Key,
      changesDescription: req.body.changesDescription || `Version ${versionNumber}`,
      jobId: req.body.jobId || null
    };
    
    // Add to versions array
    if (!resume.versions) {
      resume.versions = [];
    }
    resume.versions.push(newVersion);
    await resume.save();
    
    // Generate signed URL for the new version
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: s3Key
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
    
    res.status(200).json({
      message: 'Resume version added successfully',
      version: {
        id: newVersion._id,
        versionNumber: newVersion.versionNumber,
        createdAt: newVersion.createdAt,
        changesDescription: newVersion.changesDescription,
        downloadUrl: signedUrl,
        jobId: newVersion.jobId
      }
    });
  } catch (error) {
    console.error('Error adding resume version:', error);
    res.status(500).json({ message: 'Failed to add resume version', error: error.message });
  }
};

// Get resume processing status
exports.getResumeProcessingStatus = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId }, 'processingStatus');
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Return just the processing status
    const processingStatus = resume.processingStatus || {
      status: 'completed',
      progress: 100,
      message: 'Resume processing completed'
    };
    
    res.status(200).json({ processingStatus });
  } catch (error) {
    console.error('Error fetching resume processing status:', error);
    res.status(500).json({ message: 'Failed to fetch processing status', error: error.message });
  }
};

// Delete a resume
exports.deleteResume = async (req, res) => {
  try {
    // Get userId from either req.user._id or req.userId
    const userId = req.user?._id || req.userId;
    
    if (!userId) {
      return res.status(401).json({ message: 'User identification missing' });
    }
    
    const resumeId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(resumeId)) {
      return res.status(400).json({ message: 'Invalid resume ID' });
    }
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    
    if (!resume) {
      return res.status(404).json({ message: 'Resume not found' });
    }
    
    // Delete resume document from MongoDB
    await Resume.deleteOne({ _id: resumeId, userId });
    
    res.status(200).json({ message: 'Resume deleted successfully' });
  } catch (error) {
    console.error('Error deleting resume:', error);
    res.status(500).json({ message: 'Failed to delete resume', error: error.message });
  }
};

================
File: controllers/search.controller.js
================
// backend/controllers/search.controller.js - FIXED VERSION
const User = require('../models/mongodb/user.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const db = require('../config/postgresql');

/**
 * Global search controller that searches across multiple data types
 */
class SearchController {
  /**
   * Unified search across jobs, resumes, and recruiters
   */
  static async globalSearch(req, res) {
    try {
      const { 
        query, 
        category = 'all', 
        limit = 20, 
        includeContent = false 
      } = req.query;
      
      const userId = req.user._id;

      if (!query || query.trim().length < 2) {
        return res.status(400).json({
          success: false,
          error: 'Search query must be at least 2 characters long'
        });
      }

      console.log(`🔍 Global search: "${query}" for user ${userId}, category: ${category}`);

      const searchResults = {
        query: query.trim(),
        category,
        results: {
          jobs: [],
          resumes: [],
          recruiters: [],
          totalCount: 0
        },
        suggestions: [],
        recentSearches: []
      };

      // Parallel search execution
      const searchPromises = [];

      if (category === 'all' || category === 'jobs') {
        searchPromises.push(SearchController.searchJobs(userId, query, limit));
      }

      if (category === 'all' || category === 'resumes') {
        searchPromises.push(SearchController.searchResumes(userId, query, limit));
      }

      if (category === 'all' || category === 'recruiters') {
        searchPromises.push(SearchController.searchRecruiters(userId, query, limit));
      }

      // Execute all searches in parallel
      const results = await Promise.allSettled(searchPromises);

      // Process results
      let resultIndex = 0;
      if (category === 'all' || category === 'jobs') {
        const jobResults = results[resultIndex];
        if (jobResults.status === 'fulfilled') {
          searchResults.results.jobs = jobResults.value || [];
        } else {
          console.error('Job search failed:', jobResults.reason);
        }
        resultIndex++;
      }

      if (category === 'all' || category === 'resumes') {
        const resumeResults = results[resultIndex];
        if (resumeResults.status === 'fulfilled') {
          searchResults.results.resumes = resumeResults.value || [];
        } else {
          console.error('Resume search failed:', resumeResults.reason);
        }
        resultIndex++;
      }

      if (category === 'all' || category === 'recruiters') {
        const recruiterResults = results[resultIndex];
        if (recruiterResults.status === 'fulfilled') {
          searchResults.results.recruiters = recruiterResults.value || [];
        } else {
          console.error('Recruiter search failed:', recruiterResults.reason);
        }
        resultIndex++;
      }

      // Calculate total count
      searchResults.results.totalCount = 
        searchResults.results.jobs.length +
        searchResults.results.resumes.length +
        searchResults.results.recruiters.length;

      // Generate suggestions if no results found
      if (searchResults.results.totalCount === 0) {
        searchResults.suggestions = await SearchController.generateSuggestions(query);
      }

      // Get recent searches
      searchResults.recentSearches = await SearchController.getRecentSearches(userId);

      // Save this search
      await SearchController.saveSearch(userId, query, category, searchResults.results.totalCount);

      console.log(`✅ Search completed: ${searchResults.results.totalCount} total results`);

      res.json({
        success: true,
        data: searchResults
      });

    } catch (error) {
      console.error('Global search error:', error);
      res.status(500).json({
        success: false,
        error: 'Search failed',
        details: error.message
      });
    }
  }

  /**
   * Search jobs
   */
  static async searchJobs(userId, query, limit = 10) {
    try {
      const searchRegex = new RegExp(query, 'i');
      
      const jobs = await Job.find({
        userId,
        $or: [
          { title: searchRegex },
          { company: searchRegex },
          { description: searchRegex },
          { 'parsedData.keySkills.name': searchRegex },
          { 'parsedData.requirements': searchRegex },
          { 'parsedData.responsibilities': searchRegex }
        ]
      })
      .select('title company description parsedData.keySkills matchAnalysis applicationStatus createdAt')
      .sort({ createdAt: -1 })
      .limit(limit)
      .lean();

      return jobs.map(job => ({
        id: job._id,
        type: 'job',
        title: job.title,
        subtitle: job.company,
        description: job.description ? job.description.substring(0, 150) + '...' : '',
        matchScore: job.matchAnalysis?.overallScore || null,
        status: job.applicationStatus || 'not_applied',
        skills: job.parsedData?.keySkills?.slice(0, 5) || [],
        createdAt: job.createdAt,
        url: `/jobs/${job._id}`
      }));

    } catch (error) {
      console.error('Job search error:', error);
      return [];
    }
  }

  /**
   * Search resumes
   */
  static async searchResumes(userId, query, limit = 10) {
    try {
      const searchRegex = new RegExp(query, 'i');
      
      const resumes = await Resume.find({
        userId,
        $or: [
          { name: searchRegex },
          { 'parsedData.summary': searchRegex },
          { 'parsedData.experience.title': searchRegex },
          { 'parsedData.experience.company': searchRegex },
          { 'parsedData.skills.name': searchRegex },
          { 'parsedData.education.institution': searchRegex },
          { 'parsedData.education.degree': searchRegex }
        ]
      })
      .select('name parsedData.summary parsedData.skills analysis isActive createdAt')
      .sort({ isActive: -1, createdAt: -1 })
      .limit(limit)
      .lean();

      return resumes.map(resume => ({
        id: resume._id,
        type: 'resume',
        title: resume.name,
        subtitle: resume.parsedData?.summary ? 
          resume.parsedData.summary.substring(0, 100) + '...' : 
          'Professional Resume',
        description: `${resume.parsedData?.skills?.length || 0} skills listed`,
        score: resume.analysis?.overallScore || null,
        isActive: resume.isActive,
        skills: resume.parsedData?.skills?.slice(0, 5) || [],
        createdAt: resume.createdAt,
        url: `/resumes/${resume._id}`
      }));

    } catch (error) {
      console.error('Resume search error:', error);
      return [];
    }
  }

  /**
   * Search recruiters
   */
  static async searchRecruiters(userId, query, limit = 10) {
    try {
      // Simplified search - just search by name and title for now
      const searchTerm = `%${query.toLowerCase()}%`;
      
      const recruitersQuery = `
        SELECT 
          r.id,
          r.first_name,
          r.last_name,
          r.title,
          r.email,
          r.linkedin_url,
          r.experience_years,
          r.last_active_date,
          companies.name as company_name,
          industries.name as industry_name,
          locations.city,
          locations.state,
          locations.country
        FROM recruiters r
        LEFT JOIN companies ON r.current_company_id = companies.id
        LEFT JOIN industries ON r.industry_id = industries.id
        LEFT JOIN locations ON r.location_id = locations.id
        WHERE r.is_active = true 
        AND (
          LOWER(r.first_name) LIKE $1 OR 
          LOWER(r.last_name) LIKE $1 OR 
          LOWER(r.title) LIKE $1 OR 
          LOWER(companies.name) LIKE $1
        )
        ORDER BY r.last_active_date DESC NULLS LAST
        LIMIT $2
      `;

      const result = await db.query(recruitersQuery, [searchTerm, limit]);

      return result.rows.map(recruiter => ({
        id: recruiter.id,
        type: 'recruiter',
        title: `${recruiter.first_name} ${recruiter.last_name}`,
        subtitle: recruiter.title || 'Recruiter',
        description: `${recruiter.company_name || 'Unknown Company'}${recruiter.industry_name ? ` • ${recruiter.industry_name}` : ''}`,
        location: recruiter.city ? 
          `${recruiter.city}${recruiter.state ? `, ${recruiter.state}` : ''}` : 
          null,
        experience: recruiter.experience_years,
        hasContact: !!(recruiter.email || recruiter.linkedin_url),
        hasBeenContacted: false, // Simplified for now
        lastActiveDate: recruiter.last_active_date,
        url: `/recruiters/${recruiter.id}`
      }));

    } catch (error) {
      console.error('Recruiter search error:', error);
      return [];
    }
  }

  /**
   * Generate search suggestions
   */
  static async generateSuggestions(query) {
    try {
      const suggestions = [];
      
      // Common job titles
      const jobTitles = [
        'Software Engineer', 'Product Manager', 'Data Scientist', 
        'Marketing Manager', 'Sales Representative', 'Business Analyst'
      ];
      
      // Common skills
      const skills = [
        'JavaScript', 'Python', 'React', 'Node.js', 'SQL', 
        'Machine Learning', 'Project Management', 'Marketing'
      ];
      
      // Common companies (you could populate this from your database)
      const companies = [
        'Google', 'Microsoft', 'Amazon', 'Apple', 'Meta', 'Netflix'
      ];

      // Find matching suggestions
      const queryLower = query.toLowerCase();
      
      jobTitles.forEach(title => {
        if (title.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: title, type: 'job_title' });
        }
      });
      
      skills.forEach(skill => {
        if (skill.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: skill, type: 'skill' });
        }
      });
      
      companies.forEach(company => {
        if (company.toLowerCase().includes(queryLower)) {
          suggestions.push({ text: company, type: 'company' });
        }
      });

      return suggestions.slice(0, 5);

    } catch (error) {
      console.error('Generate suggestions error:', error);
      return [];
    }
  }

  /**
   * Get recent searches for user
   */
  static async getRecentSearches(userId, limit = 5) {
    try {
      // You could implement a search history collection in MongoDB
      // For now, return empty array
      return [];
    } catch (error) {
      console.error('Get recent searches error:', error);
      return [];
    }
  }

  /**
   * Save search for analytics and recent searches
   */
  static async saveSearch(userId, query, category, resultCount) {
    try {
      // You could implement search analytics here
      console.log(`📊 Search saved: ${query} (${resultCount} results)`);
    } catch (error) {
      console.error('Save search error:', error);
    }
  }

  /**
   * Get search suggestions as user types
   */
  static async getSearchSuggestions(req, res) {
    try {
      const { query, limit = 5 } = req.query;
      
      if (!query || query.length < 2) {
        return res.json({
          success: true,
          data: { suggestions: [] }
        });
      }

      const suggestions = await SearchController.generateSuggestions(query);
      
      res.json({
        success: true,
        data: { suggestions: suggestions.slice(0, limit) }
      });

    } catch (error) {
      console.error('Get search suggestions error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get suggestions'
      });
    }
  }

  /**
   * Get popular searches
   */
  static async getPopularSearches(req, res) {
    try {
      // Return common search terms
      const popularSearches = [
        'Software Engineer',
        'Product Manager',
        'JavaScript',
        'Remote Jobs',
        'Data Science',
        'Marketing',
        'Google',
        'Startup'
      ];

      res.json({
        success: true,
        data: { searches: popularSearches }
      });

    } catch (error) {
      console.error('Get popular searches error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get popular searches'
      });
    }
  }
}

module.exports = SearchController;

================
File: controllers/settings.controller.js
================
// backend/controllers/settings.controller.js
const bcrypt = require('bcrypt');
const crypto = require('crypto');
const User = require('../models/mongodb/user.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');
const Outreach = require('../models/mongodb/outreach.model');
const sendEmail = require('../utils/send-email');

/**
 * Get user profile information
 */
exports.getProfile = async (req, res) => {
  try {
    console.log('📋 Getting profile for user:', req.user.id);
    
    const user = await User.findById(req.user.id).select('-password -passwordResetToken -passwordResetExpires');
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    console.log('✅ Profile retrieved successfully');
    
    res.status(200).json({
      success: true,
      data: {
        user: {
          id: user._id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          phoneNumber: user.phoneNumber,
          isEmailVerified: user.isEmailVerified,
          profilePicture: user.profilePicture,
          location: user.location,
          socialProfiles: user.socialProfiles,
          createdAt: user.createdAt,
          updatedAt: user.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('❌ Get profile error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve profile information'
    });
  }
};

/**
 * Update user profile information
 */
exports.updateProfile = async (req, res) => {
  try {
    const { firstName, lastName, email, phoneNumber, location, socialProfiles } = req.body;
    const userId = req.user.id;

    console.log('📝 Updating profile for user:', userId);
    console.log('📝 Update data:', { firstName, lastName, email, phoneNumber });

    // Validation
    if (!firstName || !lastName || !email) {
      return res.status(400).json({
        success: false,
        error: 'First name, last name, and email are required'
      });
    }

    // Email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        error: 'Please provide a valid email address'
      });
    }

    // Check if email is already taken by another user
    if (email !== req.user.email) {
      const existingUser = await User.findOne({ email, _id: { $ne: userId } });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          error: 'Email address is already in use'
        });
      }
    }

    // Prepare update data
    const updateData = {
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      email: email.toLowerCase().trim(),
      phoneNumber: phoneNumber ? phoneNumber.trim() : '',
      updatedAt: new Date()
    };

    // If email changed, mark as unverified
    if (email !== req.user.email) {
      updateData.isEmailVerified = false;
      updateData.emailVerificationToken = crypto.randomBytes(32).toString('hex');
      updateData.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours
    }

    // Update location if provided
    if (location) {
      updateData.location = location;
    }

    // Update social profiles if provided
    if (socialProfiles) {
      updateData.socialProfiles = socialProfiles;
    }

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      updateData,
      { new: true, runValidators: true }
    ).select('-password -passwordResetToken -passwordResetExpires');

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Send verification email if email changed
    if (email !== req.user.email) {
      try {
        const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${updateData.emailVerificationToken}`;
        
        await sendEmail({
          email: updatedUser.email,
          subject: 'Verify Your New Email Address - auto-job.ai',
          message: `Hi ${updatedUser.firstName},\n\nPlease verify your new email address by clicking the link below:\n\n${verificationUrl}\n\nThis link will expire in 24 hours.\n\nBest regards,\nThe auto-job.ai Team`
        });

        console.log('📧 Verification email sent to:', updatedUser.email);
      } catch (emailError) {
        console.error('📧 Failed to send verification email:', emailError);
        // Don't fail the update if email sending fails
      }
    }

    console.log('✅ Profile updated successfully');

    res.status(200).json({
      success: true,
      message: email !== req.user.email ? 'Profile updated successfully. Please check your email to verify your new email address.' : 'Profile updated successfully',
      data: {
        user: {
          id: updatedUser._id,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          email: updatedUser.email,
          phoneNumber: updatedUser.phoneNumber,
          isEmailVerified: updatedUser.isEmailVerified,
          profilePicture: updatedUser.profilePicture,
          location: updatedUser.location,
          socialProfiles: updatedUser.socialProfiles,
          createdAt: updatedUser.createdAt,
          updatedAt: updatedUser.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('❌ Update profile error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update profile'
    });
  }
};

/**
 * Change user password
 */
exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const userId = req.user.id;

    console.log('🔒 Changing password for user:', userId);

    // Validation
    if (!currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        error: 'Current password and new password are required'
      });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        error: 'New password must be at least 6 characters long'
      });
    }

    // Get user with password
    const user = await User.findById(userId).select('+password');
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Verify current password
    const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isCurrentPasswordValid) {
      return res.status(400).json({
        success: false,
        error: 'Current password is incorrect'
      });
    }

    // Check if new password is different from current
    const isSamePassword = await bcrypt.compare(newPassword, user.password);
    if (isSamePassword) {
      return res.status(400).json({
        success: false,
        error: 'New password must be different from current password'
      });
    }

    // Hash new password
    const salt = await bcrypt.genSalt(10); // Use 10 rounds to match your user model
    const hashedNewPassword = await bcrypt.hash(newPassword, salt);

    // Update password
    await User.findByIdAndUpdate(userId, {
      password: hashedNewPassword,
      updatedAt: new Date(),
      // Clear any password reset tokens
      passwordResetToken: undefined,
      passwordResetExpires: undefined
    });

    console.log('✅ Password changed successfully');

    // Send notification email
    try {
      await sendEmail({
        email: user.email,
        subject: 'Password Changed Successfully - auto-job.ai',
        message: `Hi ${user.firstName},\n\nYour password has been changed successfully.\n\nIf you did not make this change, please contact our support team immediately.\n\nBest regards,\nThe auto-job.ai Team`
      });
    } catch (emailError) {
      console.error('📧 Failed to send password change notification:', emailError);
    }

    res.status(200).json({
      success: true,
      message: 'Password changed successfully'
    });

  } catch (error) {
    console.error('❌ Change password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to change password'
    });
  }
};

/**
 * Delete user account and all associated data
 */
exports.deleteAccount = async (req, res) => {
  try {
    const userId = req.user.id;
    const { confirmationText } = req.body;

    console.log('🗑️ Deleting account for user:', userId);

    // Optional: Require confirmation text
    if (confirmationText && confirmationText !== 'DELETE') {
      return res.status(400).json({
        success: false,
        error: 'Please type DELETE to confirm account deletion'
      });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Start deletion process
    console.log('🗑️ Starting account deletion process...');

    // Delete user's resumes
    const deletedResumes = await Resume.deleteMany({ userId });
    console.log(`🗑️ Deleted ${deletedResumes.deletedCount} resumes`);

    // Delete user's jobs
    const deletedJobs = await Job.deleteMany({ userId });
    console.log(`🗑️ Deleted ${deletedJobs.deletedCount} jobs`);

    // Delete user's outreach campaigns
    const deletedOutreach = await Outreach.deleteMany({ userId });
    console.log(`🗑️ Deleted ${deletedOutreach.deletedCount} outreach campaigns`);

    // TODO: Delete from PostgreSQL tables if needed
    // This would include recruiter outreach history, etc.

    // Finally, delete the user account
    await User.findByIdAndDelete(userId);
    console.log('🗑️ User account deleted');

    // Send farewell email
    try {
      await sendEmail({
        email: user.email,
        subject: 'Account Deleted Successfully - auto-job.ai',
        message: `Hi ${user.firstName},\n\nYour auto-job.ai account has been successfully deleted along with all associated data.\n\nWe're sorry to see you go. If you have any feedback or would like to return in the future, we'd love to hear from you.\n\nBest regards,\nThe auto-job.ai Team`
      });
    } catch (emailError) {
      console.error('📧 Failed to send farewell email:', emailError);
    }

    console.log('✅ Account deletion completed successfully');

    res.status(200).json({
      success: true,
      message: 'Account deleted successfully'
    });

  } catch (error) {
    console.error('❌ Delete account error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete account'
    });
  }
};

/**
 * Send email verification
 */
exports.sendVerificationEmail = async (req, res) => {
  try {
    const userId = req.user.id;

    console.log('📧 Sending verification email for user:', userId);

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    if (user.isEmailVerified) {
      return res.status(400).json({
        success: false,
        error: 'Email is already verified'
      });
    }

    // Generate verification token
    const verificationToken = crypto.randomBytes(32).toString('hex');
    const verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 hours

    // Update user with verification token
    await User.findByIdAndUpdate(userId, {
      emailVerificationToken: verificationToken,
      emailVerificationExpires: verificationExpires
    });

    // Send verification email
    const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`;
    
    await sendEmail({
      email: user.email,
      subject: 'Verify Your Email Address - auto-job.ai',
      message: `Hi ${user.firstName},\n\nPlease verify your email address by clicking the link below:\n\n${verificationUrl}\n\nThis link will expire in 24 hours.\n\nBest regards,\nThe auto-job.ai Team`
    });

    console.log('✅ Verification email sent successfully');

    res.status(200).json({
      success: true,
      message: 'Verification email sent successfully'
    });

  } catch (error) {
    console.error('❌ Send verification email error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send verification email'
    });
  }
};

/**
 * Verify email address
 */
exports.verifyEmail = async (req, res) => {
  try {
    const { token } = req.params;

    console.log('✉️ Verifying email with token:', token);

    if (!token) {
      return res.status(400).json({
        success: false,
        error: 'Verification token is required'
      });
    }

    // Find user with valid verification token
    const user = await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: Date.now() }
    });

    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'Invalid or expired verification token'
      });
    }

    // Mark email as verified
    await User.findByIdAndUpdate(user._id, {
      isEmailVerified: true,
      emailVerificationToken: undefined,
      emailVerificationExpires: undefined,
      updatedAt: new Date()
    });

    console.log('✅ Email verified successfully for user:', user.email);

    res.status(200).json({
      success: true,
      message: 'Email verified successfully'
    });

  } catch (error) {
    console.error('❌ Verify email error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify email'
    });
  }
};

================
File: debug-controller-params.js
================
// backend/debug-controller-params.js - Debug what's happening with parameters
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugControllerParams() {
  try {
    console.log('🐛 DEBUGGING CONTROLLER PARAMETERS');
    console.log('====================================');
    
    // Simulate the exact request parameters from your log
    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';
    const company = '';
    const industry = '';
    const location = '';
    const title = '';
    const experience_min = '';
    const experience_max = '20'; // This is what's in your query string
    const limit = 20;
    const offset = 0;
    const sort_by = 'last_active_date';
    const sort_order = 'DESC';

    console.log('📋 Input Parameters:');
    console.log(`   userId: ${userId}`);
    console.log(`   query: "${query}"`);
    console.log(`   company: "${company}"`);
    console.log(`   industry: "${industry}"`);
    console.log(`   location: "${location}"`);
    console.log(`   title: "${title}"`);
    console.log(`   experience_min: "${experience_min}"`);
    console.log(`   experience_max: "${experience_max}"`);
    console.log(`   limit: ${limit}`);
    console.log(`   offset: ${offset}`);

    // Build query exactly like the controller
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone as phone,
        r.title,
        r.linkedin_profile_url as linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        c.name as company_name,
        c.website as company_website,
        c.employee_range as company_size,
        c.logo_url as company_logo,
        i.name as industry_name,
        l.city,
        l.state,
        l.country,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    console.log('\n🔧 Building Query Step by Step:');
    console.log(`1. Base query with userId: ${userId}`);

    // Add search filters with COALESCE to handle NULL values
    if (query) {
      sqlQuery += ` AND (
        (COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $${paramIndex} OR
        COALESCE(r.title, '') ILIKE $${paramIndex} OR
        COALESCE(c.name, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${query.toLowerCase()}%`);
      console.log(`2. Added query filter: %${query.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (company) {
      sqlQuery += ` AND COALESCE(c.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${company.toLowerCase()}%`);
      console.log(`3. Added company filter: %${company.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (industry) {
      sqlQuery += ` AND COALESCE(i.name, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${industry.toLowerCase()}%`);
      console.log(`4. Added industry filter: %${industry.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (location) {
      sqlQuery += ` AND (
        COALESCE(l.city, '') ILIKE $${paramIndex} OR
        COALESCE(l.state, '') ILIKE $${paramIndex} OR
        COALESCE(l.country, '') ILIKE $${paramIndex}
      )`;
      queryParams.push(`%${location.toLowerCase()}%`);
      console.log(`5. Added location filter: %${location.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    if (title) {
      sqlQuery += ` AND COALESCE(r.title, '') ILIKE $${paramIndex}`;
      queryParams.push(`%${title.toLowerCase()}%`);
      console.log(`6. Added title filter: %${title.toLowerCase()}% (param $${paramIndex})`);
      paramIndex++;
    }

    // ⚠️ CRITICAL: Check if experience filters are being applied
    console.log(`\n⚠️  EXPERIENCE FILTER CHECK:`);
    console.log(`   experience_min: "${experience_min}" (truthy: ${!!experience_min})`);
    console.log(`   experience_max: "${experience_max}" (truthy: ${!!experience_max})`);

    if (experience_min) {
      sqlQuery += ` AND r.experience_years >= $${paramIndex}`;
      queryParams.push(parseInt(experience_min));
      console.log(`7. Added experience_min filter: >= ${experience_min} (param $${paramIndex})`);
      paramIndex++;
    }

    if (experience_max) {
      sqlQuery += ` AND r.experience_years <= $${paramIndex}`;
      queryParams.push(parseInt(experience_max));
      console.log(`8. ⚠️  Added experience_max filter: <= ${experience_max} (param $${paramIndex})`);
      paramIndex++;
    }

    // Add ordering
    const validSortFields = ['last_active_date', 'rating', 'experience_years', 'first_name'];
    const sortField = validSortFields.includes(sort_by) ? sort_by : 'last_active_date';
    const sortDirection = sort_order.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
    
    sqlQuery += ` ORDER BY r.${sortField} ${sortDirection}`;
    console.log(`9. Added sorting: ORDER BY r.${sortField} ${sortDirection}`);
    
    // Add pagination
    sqlQuery += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    queryParams.push(parseInt(limit), parseInt(offset));
    console.log(`10. Added pagination: LIMIT ${limit} OFFSET ${offset} (params $${paramIndex}, $${paramIndex + 1})`);

    console.log('\n📝 FINAL QUERY:');
    console.log(sqlQuery);
    console.log('\n📋 FINAL PARAMETERS:');
    console.log(queryParams);

    // Execute the query
    console.log('\n🗄️ EXECUTING QUERY...');
    const result = await pool.query(sqlQuery, queryParams);
    console.log(`✅ Query executed successfully: ${result.rows.length} rows returned`);

    if (result.rows.length > 0) {
      console.log('\n👥 SAMPLE RESULTS:');
      result.rows.slice(0, 3).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title} (Experience: ${row.experience_years || 'N/A'} years)`);
      });
    }

    // Test without experience_max filter
    console.log('\n🧪 TESTING WITHOUT EXPERIENCE_MAX FILTER:');
    
    let testQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $2 OR
           COALESCE(r.title, '') ILIKE $2 OR
           COALESCE(c.name, '') ILIKE $2)
    `;
    
    const testResult = await pool.query(testQuery, [userId, `%${query.toLowerCase()}%`]);
    console.log(`📊 Without experience_max filter: ${testResult.rows[0].count} matches`);

    // Test with experience_max filter
    testQuery += ` AND r.experience_years <= $3`;
    const testResult2 = await pool.query(testQuery, [userId, `%${query.toLowerCase()}%`, parseInt(experience_max)]);
    console.log(`📊 With experience_max <= ${experience_max}: ${testResult2.rows[0].count} matches`);

    // Check experience_years distribution
    console.log('\n📈 EXPERIENCE YEARS DISTRIBUTION FOR SARAH:');
    const expQuery = `
      SELECT 
        r.experience_years,
        COUNT(*) as count,
        array_agg(r.first_name || ' ' || r.last_name) as names
      FROM recruiters r
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE $1)
      GROUP BY r.experience_years
      ORDER BY r.experience_years
    `;
    
    const expResult = await pool.query(expQuery, [`%${query.toLowerCase()}%`]);
    expResult.rows.forEach(row => {
      console.log(`   ${row.experience_years || 'NULL'} years: ${row.count} people`);
      if (row.count <= 3) {
        console.log(`      Names: ${row.names.join(', ')}`);
      }
    });

  } catch (error) {
    console.error('❌ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

debugControllerParams();

================
File: debug-recruiter-search.js
================
// backend/debug-recruiter-search.js - Debug script to check recruiter data
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugRecruiterSearch() {
  try {
    console.log('🔍 DEBUGGING RECRUITER SEARCH');
    console.log('================================');

    // 1. Check basic table counts
    console.log('\n1️⃣ CHECKING TABLE COUNTS:');
    const counts = await Promise.all([
      pool.query('SELECT COUNT(*) as count FROM recruiters'),
      pool.query('SELECT COUNT(*) as count FROM companies'),
      pool.query('SELECT COUNT(*) as count FROM industries'),
      pool.query('SELECT COUNT(*) as count FROM locations')
    ]);

    console.log(`   Recruiters: ${counts[0].rows[0].count}`);
    console.log(`   Companies: ${counts[1].rows[0].count}`);
    console.log(`   Industries: ${counts[2].rows[0].count}`);
    console.log(`   Locations: ${counts[3].rows[0].count}`);

    // 2. Check for active recruiters
    console.log('\n2️⃣ CHECKING ACTIVE RECRUITERS:');
    const activeCount = await pool.query('SELECT COUNT(*) as count FROM recruiters WHERE is_active = true');
    const inactiveCount = await pool.query('SELECT COUNT(*) as count FROM recruiters WHERE is_active = false OR is_active IS NULL');
    
    console.log(`   Active recruiters: ${activeCount.rows[0].count}`);
    console.log(`   Inactive/NULL recruiters: ${inactiveCount.rows[0].count}`);

    // 3. Sample recruiter data
    console.log('\n3️⃣ SAMPLE RECRUITER DATA:');
    const sampleRecruiters = await pool.query(`
      SELECT 
        r.id, r.first_name, r.last_name, r.email, r.title, r.is_active,
        c.name as company_name,
        i.name as industry_name
      FROM recruiters r 
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LIMIT 10
    `);

    sampleRecruiters.rows.forEach((recruiter, index) => {
      console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} (${recruiter.email}) - Active: ${recruiter.is_active}`);
      console.log(`      Title: ${recruiter.title}`);
      console.log(`      Company: ${recruiter.company_name}`);
      console.log(`      Industry: ${recruiter.industry_name}`);
      console.log('');
    });

    // 4. Check for "Sarah" specifically (case insensitive)
    console.log('\n4️⃣ SEARCHING FOR "SARAH" (CASE INSENSITIVE):');
    const sarahSearch = await pool.query(`
      SELECT 
        r.first_name, r.last_name, r.email, r.is_active,
        c.name as company_name
      FROM recruiters r 
      LEFT JOIN companies c ON r.current_company_id = c.id
      WHERE LOWER(r.first_name) LIKE LOWER('%sarah%') 
         OR LOWER(r.last_name) LIKE LOWER('%sarah%')
      LIMIT 5
    `);

    if (sarahSearch.rows.length > 0) {
      console.log(`   Found ${sarahSearch.rows.length} results for "Sarah":`);
      sarahSearch.rows.forEach((recruiter, index) => {
        console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} (${recruiter.email}) - Active: ${recruiter.is_active}`);
        console.log(`      Company: ${recruiter.company_name}`);
      });
    } else {
      console.log('   ❌ No results found for "Sarah"');
    }

    // 5. Check the exact search query that's failing
    console.log('\n5️⃣ TESTING EXACT SEARCH QUERY:');
    
    const testQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.title,
        r.is_active,
        c.name as company_name
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      LEFT JOIN industries i ON r.industry_id = i.id
      LEFT JOIN locations l ON r.location_id = l.id
      WHERE r.is_active = true
        AND (
          LOWER(r.first_name || ' ' || r.last_name) LIKE LOWER('%sarah%') OR
          LOWER(r.title) LIKE LOWER('%sarah%') OR
          LOWER(c.name) LIKE LOWER('%sarah%')
        )
      LIMIT 5
    `;

    const exactSearch = await pool.query(testQuery);
    
    if (exactSearch.rows.length > 0) {
      console.log(`   ✅ Found ${exactSearch.rows.length} results with exact query:`);
      exactSearch.rows.forEach((recruiter, index) => {
        console.log(`   ${index + 1}. ${recruiter.first_name} ${recruiter.last_name} - ${recruiter.title}`);
        console.log(`      Company: ${recruiter.company_name}`);
        console.log(`      Active: ${recruiter.is_active}`);
      });
    } else {
      console.log('   ❌ No results with exact search query');
    }

    // 6. Check for null values that might cause issues
    console.log('\n6️⃣ CHECKING FOR NULL VALUES:');
    const nullCheck = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(first_name) as has_first_name,
        COUNT(last_name) as has_last_name,
        COUNT(title) as has_title,
        COUNT(is_active) as has_is_active
      FROM recruiters
    `);

    const nullStats = nullCheck.rows[0];
    console.log(`   Total recruiters: ${nullStats.total}`);
    console.log(`   With first_name: ${nullStats.has_first_name}`);
    console.log(`   With last_name: ${nullStats.has_last_name}`);
    console.log(`   With title: ${nullStats.has_title}`);
    console.log(`   With is_active: ${nullStats.has_is_active}`);

    // 7. Check industry data specifically
    console.log('\n7️⃣ CHECKING INDUSTRY DATA:');
    const industryData = await pool.query(`
      SELECT i.name, COUNT(r.id) as recruiter_count
      FROM industries i
      LEFT JOIN recruiters r ON i.id = r.industry_id AND r.is_active = true
      GROUP BY i.id, i.name
      ORDER BY recruiter_count DESC
      LIMIT 10
    `);

    if (industryData.rows.length > 0) {
      console.log('   Top industries:');
      industryData.rows.forEach((industry, index) => {
        console.log(`   ${index + 1}. ${industry.name}: ${industry.recruiter_count} recruiters`);
      });
    } else {
      console.log('   ❌ No industry data found');
    }

    // 8. Test if the issue is with the is_active column
    console.log('\n8️⃣ TESTING WITHOUT is_active FILTER:');
    const noActiveFilter = await pool.query(`
      SELECT COUNT(*) as count
      FROM recruiters r
      LEFT JOIN companies c ON r.current_company_id = c.id
      WHERE LOWER(r.first_name || ' ' || r.last_name) LIKE LOWER('%sarah%')
    `);

    console.log(`   Results without is_active filter: ${noActiveFilter.rows[0].count}`);

    // 9. Check schema for is_active column
    console.log('\n9️⃣ CHECKING SCHEMA FOR is_active COLUMN:');
    const schemaCheck = await pool.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns 
      WHERE table_name = 'recruiters' AND column_name = 'is_active'
    `);

    if (schemaCheck.rows.length > 0) {
      const col = schemaCheck.rows[0];
      console.log(`   is_active column exists: ${col.data_type}, nullable: ${col.is_nullable}, default: ${col.column_default}`);
    } else {
      console.log('   ❌ is_active column does not exist!');
    }

    console.log('\n✅ Debug complete!');

  } catch (error) {
    console.error('❌ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

// Run the debug
debugRecruiterSearch();

================
File: debug-search-query.js
================
// backend/debug-search-query.js - Debug the exact search query
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function debugSearchQuery() {
  try {
    console.log('🔍 DEBUGGING SEARCH QUERY FOR "SARAH"');
    console.log('===========================================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Test 1: Basic recruiter count
    console.log('\n1️⃣ TOTAL ACTIVE RECRUITERS:');
    const totalActiveResult = await pool.query(`
      SELECT COUNT(*) as count FROM recruiters WHERE is_active = true
    `);
    console.log(`   Active recruiters: ${totalActiveResult.rows[0].count}`);

    // Test 2: Sarah search without joins
    console.log('\n2️⃣ SARAH SEARCH WITHOUT JOINS:');
    const sarahBasicResult = await pool.query(`
      SELECT COUNT(*) as count 
      FROM recruiters r
      WHERE r.is_active = true 
        AND ((r.first_name || ' ' || r.last_name) ILIKE $1 OR r.title ILIKE $1)
    `, [`%${query}%`]);
    console.log(`   Sarah matches without joins: ${sarahBasicResult.rows[0].count}`);

    // Test 3: Exact query from controller
    console.log('\n3️⃣ EXACT CONTROLLER QUERY (with outreach join):');
    const exactQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE $2 OR r.title ILIKE $2)
      ORDER BY r.first_name ASC
      LIMIT 20 OFFSET 0
    `;

    const exactResult = await pool.query(exactQuery, [userId, `%${query}%`]);
    console.log(`   Exact controller query results: ${exactResult.rows.length}`);

    if (exactResult.rows.length > 0) {
      console.log('\n   📋 Sample results:');
      exactResult.rows.slice(0, 5).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    }

    // Test 4: Check the count query specifically
    console.log('\n4️⃣ CONTROLLER COUNT QUERY:');
    const countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
      AND ((r.first_name || ' ' || r.last_name) ILIKE '%${query}%' OR r.title ILIKE '%${query}%')
    `;
    console.log('   Count query SQL:');
    console.log(`   ${countQuery}`);
    
    const countResult = await pool.query(countQuery);
    console.log(`   Count query result: ${countResult.rows[0].count}`);

    // Test 5: Check if there's a parameter binding issue
    console.log('\n5️⃣ PARAMETER BINDING TEST:');
    const parameterTestQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE $1 OR r.title ILIKE $1)
    `;
    const parameterTestResult = await pool.query(parameterTestQuery, [`%${query}%`]);
    console.log(`   Parameterized count result: ${parameterTestResult.rows[0].count}`);

    // Test 6: Check outreach_history table
    console.log('\n6️⃣ OUTREACH HISTORY CHECK:');
    const outreachHistoryResult = await pool.query(`
      SELECT COUNT(*) as count FROM outreach_history WHERE mongodb_user_id = $1
    `, [userId]);
    console.log(`   Outreach history records for user: ${outreachHistoryResult.rows[0].count}`);

    // Test 7: Check if the issue is with the name concatenation
    console.log('\n7️⃣ NAME CONCATENATION TEST:');
    const nameTestResult = await pool.query(`
      SELECT first_name, last_name, (first_name || ' ' || last_name) as full_name
      FROM recruiters 
      WHERE is_active = true
        AND LOWER(first_name) LIKE LOWER('%sarah%')
      LIMIT 5
    `);
    console.log('   Sample name concatenation results:');
    nameTestResult.rows.forEach((row, index) => {
      console.log(`   ${index + 1}. "${row.first_name}" + "${row.last_name}" = "${row.full_name}"`);
    });

    // Test 8: Check for NULL values that might break concatenation
    console.log('\n8️⃣ NULL VALUE CHECK:');
    const nullCheckResult = await pool.query(`
      SELECT 
        COUNT(*) as total,
        COUNT(first_name) as has_first_name,
        COUNT(last_name) as has_last_name,
        COUNT(CASE WHEN first_name IS NULL OR last_name IS NULL THEN 1 END) as has_null_names
      FROM recruiters 
      WHERE is_active = true
    `);
    const nullStats = nullCheckResult.rows[0];
    console.log(`   Total active: ${nullStats.total}`);
    console.log(`   Has first_name: ${nullStats.has_first_name}`);
    console.log(`   Has last_name: ${nullStats.has_last_name}`);
    console.log(`   Has NULL names: ${nullStats.has_null_names}`);

    console.log('\n✅ Debug complete!');

  } catch (error) {
    console.error('❌ Debug failed:', error);
  } finally {
    await pool.end();
  }
}

// Run the debug
debugSearchQuery();

================
File: middleware/auth.middleware.js
================
// backend/middleware/auth.middleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/mongodb/user.model');

/**
 * Middleware to protect routes that require authentication
 */
exports.protect = async (req, res, next) => {
  try {
    let token;
    
    // Check for token in Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    }
    // Also check for token in cookies
    else if (req.cookies && req.cookies.token) {
      token = req.cookies.token;
    }
    
    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to access this route - no token provided'
      });
    }
    
    try {
      // Verify the token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Find the user by ID
      const user = await User.findById(decoded.id);
      
      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'The user belonging to this token no longer exists'
        });
      }
      
      // Check if user is active
      if (!user.active) {
        return res.status(401).json({
          success: false,
          error: 'This account has been deactivated'
        });
      }
      
      // TEMPORARILY DISABLED EMAIL VERIFICATION CHECK FOR DEBUGGING
      // TODO: Re-enable this after login is working
      /*
      if (!user.isEmailVerified) {
        return res.status(403).json({
          success: false,
          error: 'Please verify your email to access this resource'
        });
      }
      */
      
      // Set user in request object
      req.user = user;
      req.userId = user._id; // Add this for compatibility
      next();
    } catch (jwtError) {
      console.error('JWT verification error:', jwtError.message);
      return res.status(401).json({
        success: false,
        error: 'Invalid token'
      });
    }
  } catch (error) {
    console.error('Auth middleware error:', error);
    return res.status(500).json({
      success: false,
      error: 'Authentication server error'
    });
  }
};

/**
 * Middleware to restrict access based on user role
 */
exports.restrictTo = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to perform this action'
      });
    }
    next();
  };
};

/**
 * Middleware to check if email is verified
 * Soft check - allows request but adds verified status to req object
 */
exports.checkEmailVerification = async (req, res, next) => {
  try {
    if (req.user && !req.user.isEmailVerified) {
      req.isEmailVerified = false;
    } else {
      req.isEmailVerified = true;
    }
    next();
  } catch (error) {
    next(error);
  }
};

/**
 * Optional authentication middleware - doesn't fail if no token
 * Useful for routes that work for both authenticated and non-authenticated users
 */
exports.optionalAuth = async (req, res, next) => {
  try {
    let token;
    
    // Check for token in Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    }
    // Also check for token in cookies
    else if (req.cookies && req.cookies.token) {
      token = req.cookies.token;
    }
    
    if (token) {
      try {
        // Verify the token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // Find the user by ID
        const user = await User.findById(decoded.id);
        
        if (user && user.active) {
          req.user = user;
          req.userId = user._id;
          req.isAuthenticated = true;
        }
      } catch (jwtError) {
        // Token is invalid, but that's okay for optional auth
        console.log('Optional auth - invalid token:', jwtError.message);
      }
    }
    
    // Always continue regardless of token validity
    next();
  } catch (error) {
    // Even if there's an error, continue (optional auth)
    console.error('Optional auth middleware error:', error);
    next();
  }
};

================
File: middleware/validation.middleware.js
================
// backend/middleware/validation.middleware.js
const { validationResult, check } = require('express-validator');

// Middleware to handle validation errors
exports.handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      errors: errors.array()
    });
  }
  next();
};

// Validation rules for registration
exports.validateRegistration = [
  check('firstName')
    .trim()
    .notEmpty()
    .withMessage('First name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters'),
  
  check('lastName')
    .trim()
    .notEmpty()
    .withMessage('Last name is required')
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters'),
  
  check('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

// Validation rules for login
exports.validateLogin = [
  check('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
];

// Validation rules for password reset
exports.validatePasswordReset = [
  check('password')
    .trim()
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

// Validation rules for update details
exports.validateUpdateDetails = [
  check('firstName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters'),
  
  check('lastName')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters'),
  
  check('phoneNumber')
    .optional()
    .trim()
    .isMobilePhone()
    .withMessage('Please provide a valid phone number'),
  
  check('location.city')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('City must be between 2 and 100 characters'),
  
  check('location.state')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('State must be between 2 and 100 characters'),
  
  check('location.country')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Country must be between 2 and 100 characters')
];

// Validation rules for update password
exports.validateUpdatePassword = [
  check('currentPassword')
    .trim()
    .notEmpty()
    .withMessage('Current password is required'),
  
  check('newPassword')
    .trim()
    .notEmpty()
    .withMessage('New password is required')
    .isLength({ min: 8 })
    .withMessage('New password must be at least 8 characters')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
];

================
File: models/mongodb/aiAgent.model.js
================
// backend/models/mongodb/aiAgent.model.js
const mongoose = require('mongoose');

const aiAgentSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true
  },
  description: String,
  type: {
    type: String,
    enum: ['ResumeAnalysis', 'JobMatching', 'ContentGeneration', 'JobDiscovery'],
    required: true
  },
  config: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  },
  api: {
    endpoint: String,
    apiKey: String,
    modelName: String,
    parameters: mongoose.Schema.Types.Mixed
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastRun: Date,
  performance: {
    averageResponseTime: Number,
    successRate: Number,
    errorRate: Number
  },
  version: String
}, {
  timestamps: true
});

// Add method to invoke the agent
aiAgentSchema.methods.invoke = async function(input, context = {}) {
  // This is a placeholder for actual API call logic
  try {
    // Implement agent-specific processing logic here based on agent type
    switch(this.type) {
      case 'ResumeAnalysis':
        return await this.analyzeResume(input, context);
      case 'JobMatching':
        return await this.matchJob(input, context);
      case 'ContentGeneration':
        return await this.generateContent(input, context);
      case 'JobDiscovery':
        return await this.discoverJobs(input, context);
      default:
        throw new Error(`Unknown agent type: ${this.type}`);
    }
  } catch (error) {
    console.error(`Error invoking AI agent ${this.name}:`, error);
    throw error;
  }
};

// Placeholder for actual implementation
aiAgentSchema.methods.analyzeResume = async function(resume, context) {
  // Implementation will involve calling an NLP service or LLM API
  return { message: 'Resume analysis not yet implemented' };
};

aiAgentSchema.methods.matchJob = async function(data, context) {
  // Implementation will compare resume and job description
  return { message: 'Job matching not yet implemented' };
};

aiAgentSchema.methods.generateContent = async function(data, context) {
  // Implementation will generate content based on input
  return { message: 'Content generation not yet implemented' };
};

aiAgentSchema.methods.discoverJobs = async function(data, context) {
  // Implementation will search for relevant jobs
  return { message: 'Job discovery not yet implemented' };
};

const AIAgent = mongoose.model('AIAgent', aiAgentSchema);

module.exports = AIAgent;

================
File: models/mongodb/aiJobSearch.model.js
================
// models/mongodb/aiJobSearch.model.js - UPDATED WITH NEW SEARCH APPROACHES
const mongoose = require('mongoose');

const aiJobSearchSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    required: true
  },
  resumeName: {
    type: String,
    required: true
  },
  searchCriteria: {
    jobTitle: String,
    skills: [String],
    location: String,
    experienceLevel: String,
    salaryRange: {
      min: Number,
      max: Number,
      currency: String
    },
    jobTypes: [String], // ['FULL_TIME', 'CONTRACT', etc.]
    industries: [String],
    companySizes: [String],
    workEnvironment: String // 'remote', 'hybrid', 'onsite', 'any'
  },
  status: {
    type: String,
    enum: ['running', 'paused', 'completed', 'failed', 'cancelled'],
    default: 'running'
  },
  searchType: {
    type: String,
    enum: ['basic', 'enhanced', 'premium', 'intelligent'],
    default: 'intelligent'
  },
  dailyLimit: {
    type: Number,
    default: 10
  },
  jobsFoundToday: {
    type: Number,
    default: 0
  },
  totalJobsFound: {
    type: Number,
    default: 0
  },
  lastSearchDate: {
    type: Date,
    default: null
  },
  
  // Enhanced tracking
  jobsFound: [{
    jobId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    },
    title: String,
    company: String,
    foundAt: Date,
    contentQuality: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    extractionSuccess: Boolean,
    matchScore: Number,
    sourceUrl: String,
    sourcePlatform: String,
    extractionMethod: String,
    premiumAnalysis: {
      type: Boolean,
      default: false
    }
  }],
  
  // Search performance metrics
  searchMetrics: {
    totalSearchesPerformed: {
      type: Number,
      default: 0
    },
    totalJobsDiscovered: {
      type: Number,
      default: 0
    },
    successfulExtractions: {
      type: Number,
      default: 0
    },
    failedExtractions: {
      type: Number,
      default: 0
    },
    premiumAnalysesCompleted: {
      type: Number,
      default: 0
    },
    avgContentQuality: String,
    avgProcessingTime: Number, // in seconds
    lastPerformanceUpdate: Date,
    // Phase specific metrics
    phase1Duration: Number, // Career analysis time
    phase2Duration: Number, // Job discovery time
    phase3Duration: Number, // Premium analysis time
    totalSearchDuration: Number,
    webSearchSuccessRate: Number, // Percentage of successful web searches
    premiumAnalysisSuccessRate: Number // Percentage of successful premium analyses
  },
  
  // Search history
  searchHistory: [{
    searchDate: Date,
    searchApproach: {
      type: String,
      enum: [
        '5-phase-legacy', 
        '3-phase-intelligent', 
        '3-phase-intelligent-real-boards',
        '3-phase-intelligent-claude-web-search'
      ],
      default: '3-phase-intelligent-claude-web-search'
    },
    phase1Results: { // Career Analysis
      jobTitles: [String],
      keywords: [String],
      experienceLevel: String,
      duration: Number
    },
    phase2Results: { // Job Discovery (Claude Web Search)
      jobUrlsFound: Number,
      successfulExtractions: Number,
      averageContentLength: Number,
      duration: Number,
      webSearchQueries: Number,
      platformsSearched: [String]
    },
    phase3Results: { // Premium Analysis
      jobsAnalyzed: Number,
      successfulAnalyses: Number,
      averageSkillsFound: Number,
      duration: Number
    },
    totalDuration: Number,
    costBreakdown: {
      phase1Cost: String, // "$0.05"
      phase2Cost: String, // "$0.30-0.50"
      phase3Cost: String, // "$0.01-0.02"
      totalCost: String   // "$0.36-0.57"
    },
    errors: [String],
    qualityMetrics: {
      averageMatchScore: Number,
      contentQualityDistribution: {
        high: Number,
        medium: Number,
        low: Number
      }
    }
  }],
  
  // Error tracking
  errors: [{
    timestamp: Date,
    errorType: {
      type: String,
      enum: [
        'career_analysis_failed', 
        'web_search_failed',
        'job_discovery_failed', 
        'premium_analysis_failed',
        'content_extraction_failed',
        'api_error', 
        'validation_error', 
        'rate_limit',
        'claude_error',
        'openai_error'
      ]
    },
    errorMessage: String,
    phase: {
      type: String,
      enum: ['career_analysis', 'web_search_discovery', 'content_extraction', 'premium_analysis', 'job_saving', 'general']
    },
    context: String,
    resolved: {
      type: Boolean,
      default: false
    }
  }],
  
  // AI Model usage tracking
  aiUsage: {
    // Phase 1: Career Analysis
    openaiCareerAnalysis: {
      type: Number,
      default: 0
    },
    // Phase 2: Claude Web Search Discovery
    claudeWebSearches: {
      type: Number,
      default: 0
    },
    claudeContentExtractions: {
      type: Number,
      default: 0
    },
    // Phase 3: Premium Analysis
    openaiPremiumAnalyses: {
      type: Number,
      default: 0
    },
    openaiBatchAnalyses: {
      type: Number,
      default: 0
    },
    totalTokensUsed: {
      type: Number,
      default: 0
    },
    estimatedCost: {
      type: Number,
      default: 0
    },
    // Cost breakdown by phase
    costBreakdown: {
      phase1Cost: Number, // Career analysis
      phase2Cost: Number, // Claude web search discovery
      phase3Cost: Number, // Premium analysis
      totalCost: Number
    }
  },
  
  // Search optimization
  optimization: {
    successRate: Number, // percentage of successful job discoveries
    avgRelevanceScore: Number,
    webSearchEfficiency: Number, // Jobs found per web search
    premiumAnalysisAccuracy: Number, // Successful analyses percentage
    bestSearchTimes: [String], // times of day with best results
    recommendedAdjustments: [String],
    // Quality metrics
    contentQualityTrend: String, // 'improving', 'stable', 'declining'
    matchScoreTrend: String,
    userSatisfactionIndicators: {
      viewedJobsRate: Number,
      appliedJobsRate: Number,
      favoriteJobsRate: Number
    }
  },
  
  // User preferences learned over time
  learnedPreferences: {
    preferredCompanies: [String],
    avoidedCompanies: [String],
    preferredLocations: [String],
    successfulKeywords: [String],
    // Learned from web search discovery
    effectiveJobTitles: [String],
    preferredWorkArrangements: [String],
    salaryExpectationLearned: {
      min: Number,
      max: Number,
      currency: String
    },
    interactionPatterns: {
      viewedJobs: Number,
      appliedJobs: Number,
      favoriteJobs: Number,
      avgTimeSpentPerJob: Number,
      preferredJobTypes: [String]
    }
  },
  
  // Schedule and automation
  schedule: {
    isScheduled: {
      type: Boolean,
      default: false
    },
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'bi-weekly', 'monthly'],
      default: 'daily'
    },
    preferredTime: String, // '09:00' format
    timezone: String,
    nextScheduledRun: Date,
    pauseUntil: Date,
    intelligentScheduling: {
      type: Boolean,
      default: false
    },
    optimalSearchDays: [String], // Days with best results
    lastSuccessfulSearchTime: Date
  },
  
  // Notification settings
  notifications: {
    emailOnNewJobs: {
      type: Boolean,
      default: true
    },
    emailOnHighMatch: {
      type: Boolean,
      default: true
    },
    emailOnErrors: {
      type: Boolean,
      default: true
    },
    matchScoreThreshold: {
      type: Number,
      default: 75
    },
    maxEmailsPerDay: {
      type: Number,
      default: 5
    },
    // Intelligent notifications
    smartNotifications: {
      type: Boolean,
      default: true
    },
    notifyOnQualityJobs: {
      type: Boolean,
      default: true
    },
    premiumAnalysisAlerts: {
      type: Boolean,
      default: true
    }
  },
  
  // AI Reasoning Logs for search process tracking
  reasoningLogs: [{
    phase: {
      type: String,
      enum: [
        'initialization', 
        'career_analysis', 
        'intelligent_discovery', // Web search + content extraction
        'web_search_discovery',  // NEW: Specific for web search
        'content_extraction',    // NEW: Specific for content extraction
        'premium_analysis',      
        'job_saving', 
        'completion', 
        'error'
      ],
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    message: {
      type: String,
      required: true
    },
    details: {
      type: mongoose.Schema.Types.Mixed,
      default: {}
    },
    success: {
      type: Boolean,
      default: true
    },
    duration: {
      type: Number, // Duration in milliseconds
      default: 0
    },
    metadata: {
      // Phase 1: Career Analysis
      targetJobTitles: [String],
      targetKeywords: [String],
      experienceLevel: String,
      
      // Phase 2: Web Search Discovery
      webSearchQueries: Number,
      jobUrlsFound: Number,
      successfulExtractions: Number,
      averageContentLength: Number,
      platformsSearched: [String],
      
      // Phase 3: Premium Analysis
      jobsAnalyzed: Number,
      successfulAnalyses: Number,
      averageSkillsFound: Number,
      
      // General metadata
      aiModel: String,
      errorDetails: String,
      companyName: String,
      jobTitle: String,
      contentLength: Number,
      extractionMethod: String,
      batchSize: Number,
      qualityLevel: String,
      
      // Cost tracking per log entry
      estimatedCost: String,
      tokenUsage: Number,
      
      // Quality indicators
      matchScore: Number,
      contentQuality: String,
      analysisAccuracy: String,
      
      // NEW: Web search specific metadata
      searchQuery: String,
      searchResultsCount: Number,
      webSearchMethod: String,
      discoveryPlatform: String
    }
  }],
  
  lastUpdateMessage: String,
  lastUpdated: {
    type: Date,
    default: Date.now
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  
  // UPDATED: Search approach metadata with new enum values
  searchApproach: {
    type: String,
    enum: [
      '5-phase-legacy', 
      '3-phase-intelligent', 
      '3-phase-intelligent-real-boards',
      '3-phase-intelligent-claude-web-search'
    ],
    default: '3-phase-intelligent-claude-web-search'
  },
  approachVersion: {
    type: String,
    default: '3.2-claude-web-search-api'
  },
  qualityLevel: {
    type: String,
    enum: ['standard', 'premium', 'intelligent', 'claude-web-search'],
    default: 'claude-web-search'
  }
});

// Indexes for better performance
aiJobSearchSchema.index({ userId: 1, status: 1 });
aiJobSearchSchema.index({ userId: 1, createdAt: -1 });
aiJobSearchSchema.index({ status: 1, 'schedule.nextScheduledRun': 1 });
aiJobSearchSchema.index({ 'jobsFound.jobId': 1 });
aiJobSearchSchema.index({ lastSearchDate: 1 });
aiJobSearchSchema.index({ 'reasoningLogs.timestamp': -1 });
aiJobSearchSchema.index({ 'reasoningLogs.phase': 1 });
// NEW: Indexes for Claude web search approach
aiJobSearchSchema.index({ searchApproach: 1 });
aiJobSearchSchema.index({ qualityLevel: 1 });
aiJobSearchSchema.index({ 'reasoningLogs.metadata.qualityLevel': 1 });
aiJobSearchSchema.index({ 'reasoningLogs.metadata.webSearchMethod': 1 });

// Middleware
aiJobSearchSchema.pre('save', function(next) {
  this.lastUpdated = Date.now();
  
  // Update performance metrics
  if (this.isModified('jobsFound')) {
    this.updatePerformanceMetrics();
  }
  
  next();
});

// Instance methods
aiJobSearchSchema.methods.updatePerformanceMetrics = function() {
  const jobs = this.jobsFound;
  if (jobs.length === 0) return;
  
  // Calculate success rate
  const successfulExtractions = jobs.filter(job => job.extractionSuccess).length;
  this.searchMetrics.successfulExtractions = successfulExtractions;
  this.searchMetrics.failedExtractions = jobs.length - successfulExtractions;
  
  // Calculate premium analyses
  const premiumAnalyses = jobs.filter(job => job.premiumAnalysis).length;
  this.searchMetrics.premiumAnalysesCompleted = premiumAnalyses;
  
  // Calculate average content quality
  const qualityScores = jobs.map(job => {
    switch(job.contentQuality) {
      case 'high': return 3;
      case 'medium': return 2;
      case 'low': return 1;
      default: return 1;
    }
  });
  
  const avgQuality = qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length;
  if (avgQuality >= 2.5) this.searchMetrics.avgContentQuality = 'high';
  else if (avgQuality >= 1.5) this.searchMetrics.avgContentQuality = 'medium';
  else this.searchMetrics.avgContentQuality = 'low';
  
  // Update optimization data
  this.optimization.successRate = (successfulExtractions / jobs.length) * 100;
  this.optimization.premiumAnalysisAccuracy = premiumAnalyses > 0 ? (premiumAnalyses / jobs.length) * 100 : 0;
  this.optimization.webSearchEfficiency = jobs.length / Math.max(this.searchMetrics.totalSearchesPerformed, 1);
  
  this.searchMetrics.lastPerformanceUpdate = new Date();
};

aiJobSearchSchema.methods.addJobFound = function(jobData) {
  this.jobsFound.push({
    jobId: jobData.jobId,
    title: jobData.title,
    company: jobData.company,
    foundAt: new Date(),
    contentQuality: jobData.contentQuality || 'medium',
    extractionSuccess: jobData.extractionSuccess !== false,
    matchScore: jobData.matchScore,
    sourceUrl: jobData.sourceUrl,
    sourcePlatform: jobData.sourcePlatform,
    extractionMethod: jobData.extractionMethod || 'claude_web_search_discovery',
    premiumAnalysis: jobData.premiumAnalysis || true
  });
  
  this.totalJobsFound += 1;
  this.jobsFoundToday += 1;
  
  return this.save();
};

aiJobSearchSchema.methods.addError = function(errorType, message, phase, context) {
  this.errors.push({
    timestamp: new Date(),
    errorType,
    errorMessage: message,
    phase: phase || 'general',
    context,
    resolved: false
  });
  
  return this.save();
};

// UPDATED: Track AI usage for Claude web search approach
aiJobSearchSchema.methods.updateAiUsage = function(phase, type, tokens = 0, cost = 0) {
  switch(phase) {
    case 'career_analysis':
      if (type === 'openai') this.aiUsage.openaiCareerAnalysis += 1;
      if (!this.aiUsage.costBreakdown.phase1Cost) this.aiUsage.costBreakdown.phase1Cost = 0;
      this.aiUsage.costBreakdown.phase1Cost += cost;
      break;
      
    case 'web_search_discovery':
    case 'intelligent_discovery':
      if (type === 'claude_web_search') this.aiUsage.claudeWebSearches += 1;
      if (type === 'claude_content_extraction') this.aiUsage.claudeContentExtractions += 1;
      if (!this.aiUsage.costBreakdown.phase2Cost) this.aiUsage.costBreakdown.phase2Cost = 0;
      this.aiUsage.costBreakdown.phase2Cost += cost;
      break;
      
    case 'premium_analysis':
      if (type === 'openai_analysis') this.aiUsage.openaiPremiumAnalyses += 1;
      if (type === 'openai_batch') this.aiUsage.openaiBatchAnalyses += 1;
      if (!this.aiUsage.costBreakdown.phase3Cost) this.aiUsage.costBreakdown.phase3Cost = 0;
      this.aiUsage.costBreakdown.phase3Cost += cost;
      break;
  }
  
  this.aiUsage.totalTokensUsed += tokens;
  this.aiUsage.estimatedCost += cost;
  this.aiUsage.costBreakdown.totalCost = 
    (this.aiUsage.costBreakdown.phase1Cost || 0) +
    (this.aiUsage.costBreakdown.phase2Cost || 0) +
    (this.aiUsage.costBreakdown.phase3Cost || 0);
  
  return this.save();
};

// UPDATED: Method to add reasoning log for Claude web search approach
aiJobSearchSchema.methods.addReasoningLog = function(phase, message, details = {}, success = true, duration = 0) {
  // Helper function to sanitize numeric values
  const sanitizeNumeric = (value) => {
    if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
      return 0;
    }
    return value;
  };
  
  // Sanitize all numeric fields in details and metadata
  const sanitizedDetails = { ...details };
  Object.keys(sanitizedDetails).forEach(key => {
    sanitizedDetails[key] = sanitizeNumeric(sanitizedDetails[key]);
  });
  
  const reasoningLog = {
    phase,
    message,
    details: sanitizedDetails,
    success,
    duration: sanitizeNumeric(duration),
    timestamp: new Date(),
    metadata: {
      aiModel: details.aiModel || this.getDefaultModelForPhase(phase),
      
      // Phase-specific metadata (sanitized)
      targetJobTitles: details.targetJobTitles,
      targetKeywords: details.targetKeywords,
      experienceLevel: details.experienceLevel,
      
      // Web search specific metadata
      webSearchQueries: sanitizeNumeric(details.webSearchQueries),
      jobUrlsFound: sanitizeNumeric(details.jobUrlsFound),
      successfulExtractions: sanitizeNumeric(details.successfulExtractions),
      averageContentLength: sanitizeNumeric(details.averageContentLength),
      platformsSearched: details.platformsSearched,
      
      // Analysis metadata
      jobsAnalyzed: sanitizeNumeric(details.jobsAnalyzed),
      successfulAnalyses: sanitizeNumeric(details.successfulAnalyses),
      averageSkillsFound: sanitizeNumeric(details.averageSkillsFound),
      
      // General metadata
      errorDetails: details.error,
      companyName: details.company || details.companyName,
      jobTitle: details.jobTitle,
      contentLength: sanitizeNumeric(details.contentLength),
      extractionMethod: details.extractionMethod,
      batchSize: sanitizeNumeric(details.batchSize),
      qualityLevel: details.qualityLevel || 'claude-web-search',
      estimatedCost: details.costEstimate || details.estimatedCost,
      tokenUsage: sanitizeNumeric(details.tokenUsage),
      matchScore: sanitizeNumeric(details.matchScore),
      contentQuality: details.contentQuality,
      analysisAccuracy: details.analysisAccuracy,
      
      // Web search specific
      searchQuery: details.searchQuery,
      searchResultsCount: sanitizeNumeric(details.searchResultsCount),
      webSearchMethod: details.webSearchMethod || 'claude_web_search_api',
      discoveryPlatform: details.discoveryPlatform || details.platform
    }
  };
  
  this.reasoningLogs.push(reasoningLog);
  
  // Keep only the last 100 logs to prevent document from growing too large
  if (this.reasoningLogs.length > 100) {
    this.reasoningLogs = this.reasoningLogs.slice(-100);
  }
  
  return this.save();
};

// UPDATED: Helper method to get default model for each phase
aiJobSearchSchema.methods.getDefaultModelForPhase = function(phase) {
  switch(phase) {
    case 'career_analysis': return 'gpt-4-turbo';
    case 'web_search_discovery':
    case 'intelligent_discovery':
    case 'content_extraction': return 'claude-3.5-sonnet';
    case 'premium_analysis': return 'gpt-4o';
    default: return 'unknown';
  }
};

// Method to get recent reasoning logs (for UI display)
aiJobSearchSchema.methods.getRecentReasoningLogs = function(limit = 10) {
  return this.reasoningLogs
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, limit);
};

// Method to get reasoning logs by phase
aiJobSearchSchema.methods.getReasoningLogsByPhase = function(phase) {
  return this.reasoningLogs
    .filter(log => log.phase === phase)
    .sort((a, b) => b.timestamp - a.timestamp);
};

// UPDATED: Method to get performance summary for Claude web search approach
aiJobSearchSchema.methods.getClaudeWebSearchPerformanceSummary = function() {
  return {
    searchApproach: this.searchApproach || '3-phase-intelligent-claude-web-search',
    approachVersion: this.approachVersion || '3.2-claude-web-search-api',
    qualityLevel: this.qualityLevel || 'claude-web-search',
    totalJobsFound: this.totalJobsFound,
    successRate: this.optimization?.successRate || 0,
    webSearchEfficiency: this.optimization?.webSearchEfficiency || 0,
    premiumAnalysisAccuracy: this.optimization?.premiumAnalysisAccuracy || 0,
    avgContentQuality: this.searchMetrics?.avgContentQuality || 'unknown',
    costBreakdown: this.aiUsage?.costBreakdown || {},
    lastSuccessfulSearch: this.lastSearchDate,
    isHighPerformance: (this.optimization?.successRate || 0) > 80 && 
                       (this.optimization?.webSearchEfficiency || 0) > 0.5
  };
};

aiJobSearchSchema.methods.scheduleNextRun = function(frequency = 'daily', preferredTime = '09:00') {
  const now = new Date();
  const nextRun = new Date();
  
  switch(frequency) {
    case 'daily':
      nextRun.setDate(now.getDate() + 1);
      break;
    case 'weekly':
      nextRun.setDate(now.getDate() + 7);
      break;
    case 'bi-weekly':
      nextRun.setDate(now.getDate() + 14);
      break;
    case 'monthly':
      nextRun.setMonth(now.getMonth() + 1);
      break;
  }
  
  const [hours, minutes] = preferredTime.split(':');
  nextRun.setHours(parseInt(hours), parseInt(minutes), 0, 0);
  
  this.schedule.nextScheduledRun = nextRun;
  this.schedule.frequency = frequency;
  this.schedule.preferredTime = preferredTime;
  this.schedule.isScheduled = true;
  
  return this.save();
};

aiJobSearchSchema.methods.pause = function(pauseUntil) {
  this.status = 'paused';
  if (pauseUntil) {
    this.schedule.pauseUntil = pauseUntil;
  }
  this.lastUpdateMessage = 'Search paused by user';
  return this.save();
};

aiJobSearchSchema.methods.resume = function() {
  this.status = 'running';
  this.schedule.pauseUntil = null;
  this.lastUpdateMessage = 'Search resumed by user - using Claude web search approach';
  return this.save();
};

// Static methods
aiJobSearchSchema.statics.findActiveClaudeWebSearches = function() {
  return this.find({ 
    status: 'running',
    searchApproach: '3-phase-intelligent-claude-web-search',
    $or: [
      { 'schedule.nextScheduledRun': { $lte: new Date() } },
      { 'schedule.isScheduled': false }
    ]
  });
};

aiJobSearchSchema.statics.findUserSearches = function(userId) {
  return this.find({ userId }).sort({ createdAt: -1 });
};

// Static method to get AI searches with reasoning logs for Claude web search approach
aiJobSearchSchema.statics.getWithReasoningLogs = function(userId, includeDeleted = false) {
  const query = { userId };
  
  if (!includeDeleted) {
    query.status = { $ne: 'cancelled' };
  }
  
  return this.find(query)
    .populate('resumeId', 'name')
    .sort({ createdAt: -1 })
    .select('+reasoningLogs');
};

// UPDATED: Get search statistics for Claude web search approach
aiJobSearchSchema.statics.getSearchStatistics = function(userId) {
  return this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId) } },
    {
      $group: {
        _id: null,
        totalSearches: { $sum: 1 },
        claudeWebSearches: { $sum: { $cond: [{ $eq: ['$searchApproach', '3-phase-intelligent-claude-web-search'] }, 1, 0] } },
        activeSearches: { $sum: { $cond: [{ $eq: ['$status', 'running'] }, 1, 0] } },
        totalJobsFound: { $sum: '$totalJobsFound' },
        avgJobsPerSearch: { $avg: '$totalJobsFound' },
        totalPremiumAnalyses: { $sum: '$searchMetrics.premiumAnalysesCompleted' },
        totalAiUsage: { $sum: '$aiUsage.totalTokensUsed' },
        estimatedTotalCost: { $sum: '$aiUsage.estimatedCost' },
        avgSuccessRate: { $avg: '$optimization.successRate' },
        avgWebSearchEfficiency: { $avg: '$optimization.webSearchEfficiency' }
      }
    }
  ]);
};

aiJobSearchSchema.statics.findScheduledSearches = function() {
  return this.find({
    'schedule.isScheduled': true,
    'schedule.nextScheduledRun': { $lte: new Date() },
    status: 'running',
    $or: [
      { 'schedule.pauseUntil': { $exists: false } },
      { 'schedule.pauseUntil': null },
      { 'schedule.pauseUntil': { $lte: new Date() } }
    ]
  });
};

// Virtual for search performance
aiJobSearchSchema.virtual('claudeWebSearchPerformanceSummary').get(function() {
  return {
    searchApproach: this.searchApproach || '3-phase-intelligent-claude-web-search',
    successRate: this.optimization?.successRate || 0,
    webSearchEfficiency: this.optimization?.webSearchEfficiency || 0,
    premiumAnalysisAccuracy: this.optimization?.premiumAnalysisAccuracy || 0,
    avgContentQuality: this.searchMetrics?.avgContentQuality || 'unknown',
    totalJobs: this.totalJobsFound,
    avgJobsPerSearch: this.totalJobsFound / Math.max(1, this.searchHistory.length),
    estimatedCost: this.aiUsage?.estimatedCost || 0,
    costBreakdown: this.aiUsage?.costBreakdown || {},
    isHighPerformance: (this.optimization?.successRate || 0) > 80 && 
                       (this.optimization?.webSearchEfficiency || 0) > 0.5,
    qualityLevel: this.qualityLevel || 'claude-web-search'
  };
});

// Virtual for recent reasoning logs (for UI)
aiJobSearchSchema.virtual('recentClaudeWebSearchLogs').get(function() {
  return this.reasoningLogs
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, 10);
});

module.exports = mongoose.model('AiJobSearch', aiJobSearchSchema);

================
File: models/mongodb/assistantSession.model.js
================
// backend/models/mongodb/assistantSession.model.js
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['user', 'assistant', 'system'],
    required: true
  },
  content: {
    type: String,
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  metadata: {
    suggestions: [String],
    resumeEdits: mongoose.Schema.Types.Mixed,
    actionItems: [String],
    confidence: Number,
    processingTime: Number,
    tokensUsed: Number
  }
});

const assistantSessionSchema = new mongoose.Schema({
  sessionId: {
    type: String,
    required: true,
    unique: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    required: false
  },
  resumeSnapshot: {
    // Store resume data at time of session start for context
    name: String,
    parsedData: mongoose.Schema.Types.Mixed,
    version: Number,
    capturedAt: Date
  },
  context: {
    type: String,
    enum: ['resume_editing', 'job_matching', 'career_advice', 'interview_prep', 'general'],
    default: 'resume_editing'
  },
  status: {
    type: String,
    enum: ['active', 'ended', 'expired'],
    default: 'active'
  },
  messages: [messageSchema],
  
  // Session analytics
  analytics: {
    totalMessages: {
      type: Number,
      default: 0
    },
    userMessages: {
      type: Number,
      default: 0
    },
    assistantMessages: {
      type: Number,
      default: 0
    },
    totalTokensUsed: {
      type: Number,
      default: 0
    },
    averageResponseTime: Number,
    sessionsLength: Number, // in seconds
    resumeChangesApplied: {
      type: Number,
      default: 0
    },
    userSatisfactionRating: Number,
    helpfulnessRating: Number
  },

  // AI Context and Memory
  aiContext: {
    userPreferences: {
      communicationStyle: String, // formal, casual, detailed, concise
      focusAreas: [String], // skills, experience, formatting, content
      careerGoals: String,
      industryFocus: String,
      experienceLevel: String
    },
    conversationSummary: String,
    keyTopicsDiscussed: [String],
    actionItemsGenerated: [String],
    improvementsImplemented: [String],
    pendingRecommendations: [String]
  },

  // Resume editing history during session
  resumeEditHistory: [{
    timestamp: Date,
    section: String,
    changeType: {
      type: String,
      enum: ['suggestion', 'applied', 'rejected', 'modified']
    },
    originalContent: String,
    suggestedContent: String,
    finalContent: String,
    aiReasoning: String
  }],

  // Session settings
  settings: {
    language: {
      type: String,
      default: 'en'
    },
    assistantPersonality: {
      type: String,
      enum: ['professional', 'friendly', 'detailed', 'concise'],
      default: 'professional'
    },
    autoApplyChanges: {
      type: Boolean,
      default: false
    },
    notificationsEnabled: {
      type: Boolean,
      default: true
    }
  },

  // Integration data
  integrations: {
    connectedJobs: [mongoose.Schema.Types.ObjectId],
    sharedWithRecruiter: Boolean,
    exportedSuggestions: [{
      timestamp: Date,
      format: String,
      destination: String
    }]
  },

  startedAt: {
    type: Date,
    default: Date.now
  },
  lastActivityAt: {
    type: Date,
    default: Date.now
  },
  endedAt: Date,
  
  // Auto-expire sessions after 24 hours of inactivity
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 24 * 60 * 60 * 1000)
  }
});

// Indexes
assistantSessionSchema.index({ sessionId: 1 }, { unique: true });
assistantSessionSchema.index({ userId: 1, status: 1 });
assistantSessionSchema.index({ resumeId: 1 });
assistantSessionSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
assistantSessionSchema.index({ lastActivityAt: 1 });

// Middleware
assistantSessionSchema.pre('save', function(next) {
  this.lastActivityAt = new Date();
  
  // Update analytics
  if (this.isModified('messages')) {
    this.analytics.totalMessages = this.messages.length;
    this.analytics.userMessages = this.messages.filter(m => m.type === 'user').length;
    this.analytics.assistantMessages = this.messages.filter(m => m.type === 'assistant').length;
    
    // Calculate total tokens used
    this.analytics.totalTokensUsed = this.messages.reduce((total, msg) => {
      return total + (msg.metadata?.tokensUsed || 0);
    }, 0);
    
    // Calculate session length if ended
    if (this.status === 'ended' && this.endedAt) {
      this.analytics.sessionsLength = Math.round((this.endedAt - this.startedAt) / 1000);
    }
  }
  
  next();
});

// Instance methods
assistantSessionSchema.methods.addMessage = function(messageData) {
  const message = {
    id: messageData.id || new mongoose.Types.ObjectId().toString(),
    type: messageData.type,
    content: messageData.content,
    timestamp: new Date(),
    metadata: messageData.metadata || {}
  };
  
  this.messages.push(message);
  this.lastActivityAt = new Date();
  
  return this.save();
};

assistantSessionSchema.methods.updateContext = function(contextUpdates) {
  Object.assign(this.aiContext, contextUpdates);
  return this.save();
};

assistantSessionSchema.methods.addResumeEdit = function(editData) {
  const edit = {
    timestamp: new Date(),
    section: editData.section,
    changeType: editData.changeType,
    originalContent: editData.originalContent,
    suggestedContent: editData.suggestedContent,
    finalContent: editData.finalContent,
    aiReasoning: editData.aiReasoning
  };
  
  this.resumeEditHistory.push(edit);
  
  if (editData.changeType === 'applied') {
    this.analytics.resumeChangesApplied += 1;
  }
  
  return this.save();
};

assistantSessionSchema.methods.endSession = function(endData = {}) {
  this.status = 'ended';
  this.endedAt = new Date();
  
  if (endData.userSatisfactionRating) {
    this.analytics.userSatisfactionRating = endData.userSatisfactionRating;
  }
  
  if (endData.helpfulnessRating) {
    this.analytics.helpfulnessRating = endData.helpfulnessRating;
  }
  
  return this.save();
};

assistantSessionSchema.methods.getRecentMessages = function(limit = 10) {
  return this.messages.slice(-limit);
};

assistantSessionSchema.methods.getContextSummary = function() {
  return {
    sessionId: this.sessionId,
    context: this.context,
    resumeName: this.resumeSnapshot?.name,
    messageCount: this.messages.length,
    keyTopics: this.aiContext.keyTopicsDiscussed,
    userPreferences: this.aiContext.userPreferences,
    conversationSummary: this.aiContext.conversationSummary
  };
};

// Static methods
assistantSessionSchema.statics.findActiveSession = function(userId, resumeId = null) {
  const query = { 
    userId, 
    status: 'active',
    expiresAt: { $gt: new Date() }
  };
  
  if (resumeId) {
    query.resumeId = resumeId;
  }
  
  return this.findOne(query).sort({ lastActivityAt: -1 });
};

// Continuation of assistantSession.model.js

assistantSessionSchema.statics.getUserSessions = function(userId, limit = 20) {
  return this.find({ userId })
    .sort({ lastActivityAt: -1 })
    .limit(limit)
    .select('sessionId context resumeSnapshot.name analytics startedAt lastActivityAt status');
};

assistantSessionSchema.statics.getSessionAnalytics = function(userId, timeframe = '30d') {
  const startDate = new Date();
  
  switch(timeframe) {
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(startDate.getDate() - 90);
      break;
  }

  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        startedAt: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: null,
        totalSessions: { $sum: 1 },
        totalMessages: { $sum: '$analytics.totalMessages' },
        totalTokensUsed: { $sum: '$analytics.totalTokensUsed' },
        totalResumeChanges: { $sum: '$analytics.resumeChangesApplied' },
        avgSessionLength: { $avg: '$analytics.sessionsLength' },
        avgSatisfactionRating: { $avg: '$analytics.userSatisfactionRating' },
        avgHelpfulnessRating: { $avg: '$analytics.helpfulnessRating' }
      }
    }
  ]);
};

assistantSessionSchema.statics.cleanupExpiredSessions = function() {
  return this.updateMany(
    { 
      status: 'active',
      expiresAt: { $lt: new Date() }
    },
    { 
      $set: { 
        status: 'expired',
        endedAt: new Date()
      }
    }
  );
};

// Virtual for session duration
assistantSessionSchema.virtual('duration').get(function() {
  if (this.endedAt) {
    return Math.round((this.endedAt - this.startedAt) / 1000);
  }
  return Math.round((new Date() - this.startedAt) / 1000);
});

// Virtual for session summary
assistantSessionSchema.virtual('summary').get(function() {
  return {
    id: this.sessionId,
    duration: this.duration,
    messageCount: this.messages.length,
    resumeName: this.resumeSnapshot?.name,
    context: this.context,
    changesApplied: this.analytics.resumeChangesApplied,
    isActive: this.status === 'active',
    lastActivity: this.lastActivityAt
  };
});

module.exports = mongoose.model('AssistantSession', assistantSessionSchema);

================
File: models/mongodb/conversation.model.js
================
// backend/models/mongodb/conversation.model.js
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true
  },
  type: {
    type: String,
    enum: ['user', 'ai', 'system'],
    required: true
  },
  content: {
    type: String,
    required: true
  },
  metadata: {
    tokens: Number,
    model: String,
    temperature: Number,
    context: {
      page: String,
      resumeId: String,
      jobId: String,
      action: String
    },
    suggestions: [String],
    actions: [{
      type: String,
      confidence: Number,
      data: mongoose.Schema.Types.Mixed
    }],
    sentiment: {
      score: Number,
      magnitude: Number,
      label: String
    }
  },
  attachments: [{
    type: String,
    name: String,
    url: String,
    size: Number
  }],
  isEdited: {
    type: Boolean,
    default: false
  },
  editHistory: [{
    originalContent: String,
    editedAt: Date,
    reason: String
  }]
}, {
  timestamps: true,
  _id: false
});

const conversationSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  category: {
    type: String,
    enum: [
      'resume_help',
      'job_search',
      'career_advice',
      'interview_prep',
      'skill_development',
      'general',
      'troubleshooting'
    ],
    default: 'general'
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  messages: [messageSchema],
  summary: {
    content: String,
    keyTopics: [String],
    actionItems: [String],
    outcomes: [String],
    generatedAt: Date,
    version: {
      type: Number,
      default: 1
    }
  },
  context: {
    primaryResumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    },
    relatedJobIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    }],
    skillsFocused: [String],
    careerGoals: [String],
    userSentiment: {
      overall: String,
      trend: String,
      lastUpdated: Date
    }
  },
  analytics: {
    messageCount: {
      type: Number,
      default: 0
    },
    tokensUsed: {
      type: Number,
      default: 0
    },
    averageResponseTime: {
      type: Number,
      default: 0
    },
    userSatisfaction: {
      rating: Number,
      feedback: String,
      ratedAt: Date
    },
    topActions: [{
      action: String,
      count: Number
    }],
    engagementScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    }
  },
  settings: {
    memoryEnabled: {
      type: Boolean,
      default: true
    },
    autoSummarize: {
      type: Boolean,
      default: true
    },
    shareWithTeam: {
      type: Boolean,
      default: false
    },
    archiveAfterDays: {
      type: Number,
      default: 90
    }
  },
  status: {
    type: String,
    enum: ['active', 'archived', 'deleted'],
    default: 'active'
  },
  lastActiveAt: {
    type: Date,
    default: Date.now
  },
  pinned: {
    type: Boolean,
    default: false
  },
  starred: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});

// Indexes for performance
conversationSchema.index({ userId: 1, status: 1, lastActiveAt: -1 });
conversationSchema.index({ userId: 1, category: 1 });
conversationSchema.index({ userId: 1, tags: 1 });
conversationSchema.index({ 'messages.type': 1, 'messages.createdAt': -1 });
conversationSchema.index({ 'summary.keyTopics': 1 });
conversationSchema.index({ lastActiveAt: -1 });

// Virtual for message count
conversationSchema.virtual('totalMessages').get(function() {
  return this.messages.length;
});

// Virtual for last message
conversationSchema.virtual('lastMessage').get(function() {
  return this.messages.length > 0 ? this.messages[this.messages.length - 1] : null;
});

// Pre-save middleware to update analytics
conversationSchema.pre('save', function(next) {
  if (this.isModified('messages')) {
    this.analytics.messageCount = this.messages.length;
    this.analytics.tokensUsed = this.messages.reduce((total, msg) => {
      return total + (msg.metadata?.tokens || 0);
    }, 0);
    this.lastActiveAt = new Date();
  }
  next();
});

// Instance methods
conversationSchema.methods.addMessage = function(messageData) {
  const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  const message = {
    id: messageId,
    type: messageData.type,
    content: messageData.content,
    metadata: messageData.metadata || {},
    attachments: messageData.attachments || [],
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  this.messages.push(message);
  this.lastActiveAt = new Date();
  
  return message;
};

conversationSchema.methods.getRecentMessages = function(limit = 10) {
  return this.messages
    .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
    .slice(0, limit);
};

conversationSchema.methods.getMessagesByType = function(type) {
  return this.messages.filter(msg => msg.type === type);
};

conversationSchema.methods.searchMessages = function(query) {
  const searchRegex = new RegExp(query, 'i');
  return this.messages.filter(msg => 
    searchRegex.test(msg.content) || 
    (msg.metadata?.suggestions && msg.metadata.suggestions.some(s => searchRegex.test(s)))
  );
};

conversationSchema.methods.updateSummary = function(summaryData) {
  this.summary = {
    ...this.summary,
    ...summaryData,
    generatedAt: new Date(),
    version: (this.summary?.version || 0) + 1
  };
};

conversationSchema.methods.calculateEngagementScore = function() {
  const messageCount = this.messages.length;
  const userMessages = this.messages.filter(m => m.type === 'user').length;
  const aiMessages = this.messages.filter(m => m.type === 'ai').length;
  
  // Base score on conversation length
  let score = Math.min(messageCount * 2, 40);
  
  // Bonus for balanced conversation
  if (userMessages > 0 && aiMessages > 0) {
    const balance = Math.min(userMessages, aiMessages) / Math.max(userMessages, aiMessages);
    score += balance * 20;
  }
  
  // Bonus for user actions taken
  const actionCount = this.messages.reduce((count, msg) => {
    return count + (msg.metadata?.actions?.length || 0);
  }, 0);
  score += Math.min(actionCount * 5, 20);
  
  // Bonus for user satisfaction
  if (this.analytics.userSatisfaction?.rating) {
    score += (this.analytics.userSatisfaction.rating / 5) * 20;
  }
  
  this.analytics.engagementScore = Math.min(Math.round(score), 100);
  return this.analytics.engagementScore;
};

// Static methods
conversationSchema.statics.findByUserId = function(userId, options = {}) {
  const query = { userId, status: { $ne: 'deleted' } };
  
  if (options.category) query.category = options.category;
  if (options.tags && options.tags.length > 0) query.tags = { $in: options.tags };
  if (options.pinned !== undefined) query.pinned = options.pinned;
  if (options.starred !== undefined) query.starred = options.starred;
  
  return this.find(query)
    .sort(options.sort || { lastActiveAt: -1 })
    .limit(options.limit || 50)
    .populate('context.primaryResumeId', 'name analysis.overallScore')
    .populate('context.relatedJobIds', 'title company');
};

conversationSchema.statics.searchConversations = function(userId, searchQuery, options = {}) {
  const searchRegex = new RegExp(searchQuery, 'i');
  
  return this.find({
    userId,
    status: { $ne: 'deleted' },
    $or: [
      { title: searchRegex },
      { description: searchRegex },
      { tags: searchRegex },
      { 'summary.keyTopics': searchRegex },
      { 'messages.content': searchRegex }
    ]
  })
  .sort({ lastActiveAt: -1 })
  .limit(options.limit || 20);
};

conversationSchema.statics.getConversationStats = function(userId) {
  return this.aggregate([
    { $match: { userId: mongoose.Types.ObjectId(userId), status: { $ne: 'deleted' } } },
    {
      $group: {
        _id: null,
        totalConversations: { $sum: 1 },
        totalMessages: { $sum: '$analytics.messageCount' },
        totalTokens: { $sum: '$analytics.tokensUsed' },
        avgEngagement: { $avg: '$analytics.engagementScore' },
        categoriesCount: { $addToSet: '$category' }
      }
    }
  ]);
};

// Text search index
conversationSchema.index({
  title: 'text',
  description: 'text',
  'messages.content': 'text',
  'summary.keyTopics': 'text'
});

const Conversation = mongoose.model('Conversation', conversationSchema);

module.exports = Conversation;

================
File: models/mongodb/job.model.js
================
// models/mongodb/job.model.js - ENHANCED FOR REAL JOB BOARD INTEGRATION
const mongoose = require('mongoose');

const jobSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    index: true
  },
  company: {
    type: String,
    required: true,
    index: true
  },
  location: {
    city: String,
    state: String,
    country: String,
    remote: Boolean,
    fullAddress: String
  },
  description: {
    type: String,
    required: true
  },
  sourceUrl: {
    type: String,
    index: true
  },
  sourcePlatform: {
    type: String,
    enum: [
      'MANUAL',
      'AI_FOUND',
      'AI_FOUND_OPTIMIZED', 
      'AI_FOUND_INTELLIGENT',
      // NEW: Real job board platforms
      'AI_FOUND_GREENHOUSE',
      'AI_FOUND_LEVER', 
      'AI_FOUND_INDEED'
    ],
    default: 'MANUAL',
    index: true
  },
  salary: {
    min: Number,
    max: Number,
    currency: {
      type: String,
      default: 'USD'
    },
    isExplicit: Boolean
  },
  jobType: {
    type: String,
    enum: ['FULL_TIME', 'PART_TIME', 'CONTRACT', 'FREELANCE', 'INTERNSHIP', 'TEMPORARY'],
    default: 'FULL_TIME'
  },
  applicationStatus: {
    type: String,
    enum: ['NOT_APPLIED', 'APPLIED', 'INTERVIEW', 'OFFER', 'REJECTED', 'WITHDRAWN'],
    default: 'NOT_APPLIED',
    index: true
  },
  applicationDate: Date,
  isAiGenerated: {
    type: Boolean,
    default: false,
    index: true
  },
  aiSearchId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'AiJobSearch',
    index: true
  },
  
  // Enhanced parsed data with real job board support
  parsedData: {
    requirements: [String],
    responsibilities: [String],
    qualifications: {
      required: [String],
      preferred: [String]
    },
    benefits: [String],
    keySkills: [{
      name: String,
      importance: {
        type: Number,
        min: 1,
        max: 10
      },
      category: {
        type: String,
        enum: ['technical', 'soft', 'domain', 'certification']
      },
      skillType: String
    }],
    experienceLevel: {
      type: String,
      enum: ['entry', 'junior', 'mid', 'senior', 'lead', 'principal', 'executive']
    },
    yearsOfExperience: {
      minimum: Number,
      preferred: Number
    },
    educationRequirements: [String],
    workArrangement: {
      type: String,
      enum: ['remote', 'hybrid', 'onsite', 'unknown']
    },
    industryContext: String,
    roleCategory: String,
    seniorityLevel: String,
    technicalComplexity: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    leadershipRequired: Boolean,
    certifications: [String],
    softSkills: [String],
    technicalSkills: [String],
    toolsAndTechnologies: [String],
    companySize: String,
    extractedAt: Date,
    extractionMethod: String,
    
    // NEW: Enhanced real job board specific data
    realJobBoardData: {
      platform: {
        type: String,
        enum: ['Greenhouse', 'Lever', 'Indeed']
      },
      originalUrl: String,
      postedDate: Date,
      applicationDeadline: Date,
      hiringManager: String,
      teamSize: String,
      techStack: [String],
      department: String,
      directCompanyPosting: {
        type: Boolean,
        default: false
      },
      atsSystem: String,
      jobBoardSpecificData: {
        // Greenhouse specific
        greenhouseJobId: String,
        greenhouseOfficeId: String,
        
        // Lever specific
        leverPostingId: String,
        leverTeam: String,
        
        // Indeed specific
        indeedJobKey: String,
        indeedCompanyId: String
      }
    },
    
    analysisMetadata: {
      analyzedAt: Date,
      algorithmVersion: String,
      model: String,
      originalLength: Number,
      extractedSkillsCount: Number,
      costOptimized: Boolean,
      analysisType: String,
      estimatedCost: String,
      qualityLevel: String,
      sourceJobBoard: String,
      realJobBoardPosting: Boolean
    }
  },
  
  // Enhanced AI search metadata for real job boards
  aiSearchMetadata: {
    searchScore: Number,
    discoveryMethod: String,
    extractionSuccess: Boolean,
    contentQuality: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    premiumAnalysis: Boolean,
    intelligentDiscovery: Boolean,
    realJobBoardDiscovery: Boolean,
    phase: String,
    originalJobBoard: String,
    postedDate: Date,
    workArrangement: String,
    experienceLevel: String,
    department: String,
    companySize: String,
    industry: String,
    keyRequirements: [String],
    matchReason: String,
    benefits: [String],
    techStack: [String],
    teamInfo: {
      hiringManager: String,
      teamSize: String,
      department: String
    },
    
    // NEW: Real job board quality metrics
    jobBoardQualityMetrics: {
      urlValidated: Boolean,
      contentLength: Number,
      hasComprehensiveDetails: Boolean,
      hasTechStack: Boolean,
      hasTeamInfo: Boolean,
      hasApplicationDeadline: Boolean,
      verifiedCompanyPosting: Boolean
    }
  },
  
  // Analysis status for tracking background processing
  analysisStatus: {
    status: {
      type: String,
      enum: ['pending', 'analyzing', 'completed', 'error'],
      default: 'pending'
    },
    progress: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    },
    message: String,
    startedAt: Date,
    completedAt: Date,
    updatedAt: Date,
    canViewJob: {
      type: Boolean,
      default: true
    },
    skillsFound: Number,
    experienceLevel: String,
    modelUsed: String,
    analysisType: String,
    error: String,
    estimatedCompletion: Date
  },
  
  // Match analysis results
  matchAnalysis: {
    resumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    },
    overallScore: Number,
    categoryScores: {
      skills: Number,
      experience: Number,
      education: Number
    },
    matchedSkills: [{
      skill: String,
      found: Boolean,
      importance: Number,
      resumeStrength: Number
    }],
    missingSkills: [{
      skill: String,
      importance: Number,
      suggestionToAdd: String
    }],
    strengthAreas: [String],
    improvementAreas: [String],
    lastAnalyzed: Date,
    analysisMetadata: {
      algorithmVersion: String,
      modelUsed: String
    }
  },
  
  // Cover letter reference
  coverLetterId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'CoverLetter'
  },
  
  // Notes and interactions
  notes: [{
    content: String,
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // User interactions
  userInteractions: {
    viewCount: {
      type: Number,
      default: 0
    },
    lastViewed: Date,
    bookmarked: {
      type: Boolean,
      default: false
    },
    bookmarkedAt: Date,
    applied: {
      type: Boolean,
      default: false
    },
    appliedAt: Date,
    rating: {
      type: Number,
      min: 1,
      max: 5
    },
    feedback: String
  }
}, {
  timestamps: true
});

// Indexes for better performance
jobSchema.index({ userId: 1, createdAt: -1 });
jobSchema.index({ userId: 1, applicationStatus: 1 });
jobSchema.index({ userId: 1, sourcePlatform: 1 });
jobSchema.index({ userId: 1, 'parsedData.experienceLevel': 1 });
jobSchema.index({ userId: 1, 'parsedData.workArrangement': 1 });
jobSchema.index({ title: 'text', company: 'text', description: 'text' });
jobSchema.index({ 'parsedData.keySkills.name': 1 });
jobSchema.index({ aiSearchId: 1 });
jobSchema.index({ sourceUrl: 1 });

// NEW: Indexes for real job board queries
jobSchema.index({ 'parsedData.realJobBoardData.platform': 1 });
jobSchema.index({ 'parsedData.realJobBoardData.directCompanyPosting': 1 });
jobSchema.index({ 'aiSearchMetadata.realJobBoardDiscovery': 1 });
jobSchema.index({ 'aiSearchMetadata.originalJobBoard': 1 });

// Compound indexes for common queries
jobSchema.index({ userId: 1, sourcePlatform: 1, createdAt: -1 });
jobSchema.index({ userId: 1, applicationStatus: 1, createdAt: -1 });
jobSchema.index({ userId: 1, 'matchAnalysis.overallScore': -1 });

// Virtual for checking if job is from real job boards
jobSchema.virtual('isFromRealJobBoard').get(function() {
  return this.sourcePlatform && (
    this.sourcePlatform.includes('AI_FOUND_GREENHOUSE') ||
    this.sourcePlatform.includes('AI_FOUND_LEVER') ||
    this.sourcePlatform.includes('AI_FOUND_INDEED')
  );
});

// Virtual for getting source job board name
jobSchema.virtual('sourceJobBoardName').get(function() {
  if (!this.isFromRealJobBoard) return null;
  
  if (this.sourcePlatform.includes('GREENHOUSE')) return 'Greenhouse';
  if (this.sourcePlatform.includes('LEVER')) return 'Lever';
  if (this.sourcePlatform.includes('INDEED')) return 'Indeed';
  return null;
});

// Virtual for enhanced job quality score
jobSchema.virtual('qualityScore').get(function() {
  let score = 50; // Base score
  
  // Real job board bonus
  if (this.isFromRealJobBoard) score += 20;
  
  // Content quality
  if (this.aiSearchMetadata?.contentQuality === 'high') score += 15;
  else if (this.aiSearchMetadata?.contentQuality === 'medium') score += 10;
  
  // Premium analysis bonus
  if (this.aiSearchMetadata?.premiumAnalysis) score += 10;
  
  // Comprehensive details bonus
  if (this.aiSearchMetadata?.jobBoardQualityMetrics?.hasComprehensiveDetails) score += 5;
  
  return Math.min(score, 100);
});

// Method to check if job analysis is complete
jobSchema.methods.isAnalysisComplete = function() {
  return this.analysisStatus?.status === 'completed' &&
         this.parsedData && 
         Object.keys(this.parsedData).length > 0 && 
         !this.parsedData.analysisError;
};

// Method to get real job board specific data
jobSchema.methods.getRealJobBoardData = function() {
  if (!this.isFromRealJobBoard) return null;
  
  return {
    platform: this.sourceJobBoardName,
    originalUrl: this.parsedData?.realJobBoardData?.originalUrl,
    postedDate: this.parsedData?.realJobBoardData?.postedDate,
    techStack: this.parsedData?.realJobBoardData?.techStack || [],
    hiringManager: this.parsedData?.realJobBoardData?.hiringManager,
    teamSize: this.parsedData?.realJobBoardData?.teamSize,
    department: this.parsedData?.realJobBoardData?.department,
    directCompanyPosting: this.parsedData?.realJobBoardData?.directCompanyPosting || false,
    qualityMetrics: this.aiSearchMetadata?.jobBoardQualityMetrics || {}
  };
};

// Method to update user interaction
jobSchema.methods.recordUserInteraction = function(interactionType, data = {}) {
  if (!this.userInteractions) {
    this.userInteractions = { viewCount: 0 };
  }
  
  switch (interactionType) {
    case 'view':
      this.userInteractions.viewCount += 1;
      this.userInteractions.lastViewed = new Date();
      break;
    case 'bookmark':
      this.userInteractions.bookmarked = true;
      this.userInteractions.bookmarkedAt = new Date();
      break;
    case 'unbookmark':
      this.userInteractions.bookmarked = false;
      this.userInteractions.bookmarkedAt = null;
      break;
    case 'apply':
      this.userInteractions.applied = true;
      this.userInteractions.appliedAt = new Date();
      this.applicationStatus = 'APPLIED';
      this.applicationDate = new Date();
      break;
    case 'rate':
      this.userInteractions.rating = data.rating;
      this.userInteractions.feedback = data.feedback;
      break;
  }
  
  return this.save();
};

// Static method to find jobs from real job boards
jobSchema.statics.findRealJobBoardJobs = function(userId, options = {}) {
  const query = {
    userId,
    sourcePlatform: {
      $in: ['AI_FOUND_GREENHOUSE', 'AI_FOUND_LEVER', 'AI_FOUND_INDEED']
    }
  };
  
  if (options.jobBoard) {
    query.sourcePlatform = `AI_FOUND_${options.jobBoard.toUpperCase()}`;
  }
  
  if (options.dateRange) {
    query.createdAt = {
      $gte: options.dateRange.start,
      $lte: options.dateRange.end
    };
  }
  
  return this.find(query).sort({ createdAt: -1 });
};

// Static method to get real job board statistics
jobSchema.statics.getRealJobBoardStats = function(userId) {
  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        sourcePlatform: {
          $in: ['AI_FOUND_GREENHOUSE', 'AI_FOUND_LEVER', 'AI_FOUND_INDEED']
        }
      }
    },
    {
      $group: {
        _id: '$sourcePlatform',
        count: { $sum: 1 },
        avgQualityScore: { $avg: '$aiSearchMetadata.searchScore' },
        totalViews: { $sum: '$userInteractions.viewCount' },
        appliedJobs: {
          $sum: {
            $cond: [{ $eq: ['$applicationStatus', 'APPLIED'] }, 1, 0]
          }
        }
      }
    },
    {
      $project: {
        jobBoard: {
          $switch: {
            branches: [
              { case: { $eq: ['$_id', 'AI_FOUND_GREENHOUSE'] }, then: 'Greenhouse' },
              { case: { $eq: ['$_id', 'AI_FOUND_LEVER'] }, then: 'Lever' },
              { case: { $eq: ['$_id', 'AI_FOUND_INDEED'] }, then: 'Indeed' }
            ],
            default: 'Unknown'
          }
        },
        count: 1,
        avgQualityScore: { $round: ['$avgQualityScore', 1] },
        totalViews: 1,
        appliedJobs: 1,
        applicationRate: {
          $round: [{ $multiply: [{ $divide: ['$appliedJobs', '$count'] }, 100] }, 1]
        }
      }
    }
  ]);
};

// Pre-save middleware
jobSchema.pre('save', function(next) {
  // Auto-detect real job board from source platform
  if (this.isModified('sourcePlatform') && this.isFromRealJobBoard) {
    if (!this.aiSearchMetadata) this.aiSearchMetadata = {};
    this.aiSearchMetadata.realJobBoardDiscovery = true;
    this.aiSearchMetadata.originalJobBoard = this.sourceJobBoardName;
  }
  
  // Ensure real job board data consistency
  if (this.isFromRealJobBoard && this.parsedData?.realJobBoardData) {
    this.parsedData.realJobBoardData.platform = this.sourceJobBoardName;
    this.parsedData.realJobBoardData.directCompanyPosting = true;
  }
  
  next();
});

// Post-save middleware for analytics
jobSchema.post('save', function(doc) {
  // Could trigger analytics events here for real job board tracking
  if (doc.isFromRealJobBoard && doc.isNew) {
    console.log(`📊 New real job board job saved: ${doc.title} from ${doc.sourceJobBoardName}`);
  }
});

module.exports = mongoose.model('Job', jobSchema);

================
File: models/mongodb/outreach.model.js
================
// backend/models/mongodb/outreach.model.js
const mongoose = require('mongoose');

const replySchema = new mongoose.Schema({
  content: {
    type: String,
    required: true
  },
  receivedAt: {
    type: Date,
    default: Date.now
  },
  sentiment: {
    type: String,
    enum: ['positive', 'neutral', 'negative'],
    default: 'neutral'
  },
  extractedInfo: {
    nextSteps: [String],
    scheduledMeeting: {
      type: Boolean,
      default: false
    },
    referralMade: {
      type: Boolean,
      default: false
    }
  }
}, {
  timestamps: true,
  _id: true
});

const followUpSchema = new mongoose.Schema({
  content: {
    type: String,
    required: true
  },
  sentAt: {
    type: Date,
    default: Date.now
  },
  status: {
    type: String,
    enum: ['drafted', 'sent', 'replied'],
    default: 'drafted'
  },
  type: {
    type: String,
    enum: ['reminder', 'additional_info', 'thank_you', 'check_in'],
    default: 'reminder'
  },
  scheduledFor: Date
}, {
  timestamps: true,
  _id: true
});

const outreachSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  recruiterId: {
    type: String, // PostgreSQL recruiter ID
    required: true,
    index: true
  },
  jobId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Job',
    index: true
  },
  resumeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Resume',
    index: true
  },
  
  // Message content
  messageContent: {
    type: String,
    required: true
  },
  messageTemplate: {
    type: String,
    enum: ['introduction', 'follow_up', 'application', 'thank_you', 'custom'],
    default: 'custom'
  },
  subject: String,
  
  // Customizations and personalization
  customizations: [{
    type: {
      type: String,
      enum: ['tone_adjustment', 'content_addition', 'length_modification', 'style_change']
    },
    description: String,
    appliedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // AI generation metadata
  aiGenerated: {
    type: Boolean,
    default: false
  },
  aiMetadata: {
    model: String,
    tokensUsed: Number,
    confidence: Number,
    generatedAt: Date,
    prompt: String
  },
  
  // Communication details
  sentVia: {
    type: String,
    enum: ['email', 'linkedin', 'phone', 'other'],
    default: 'linkedin'
  },
  status: {
    type: String,
    enum: ['drafted', 'sent', 'delivered', 'opened', 'replied', 'no_reply', 'bounced'],
    default: 'drafted'
  },
  
  // Timing
  sentAt: Date,
  deliveredAt: Date,
  openedAt: Date,
  scheduledFor: Date,
  
  // Responses and follow-ups
  replies: [replySchema],
  followUps: [followUpSchema],
  
  // Tracking and analytics
  analytics: {
    views: {
      type: Number,
      default: 0
    },
    clicks: {
      type: Number,
      default: 0
    },
    responseTime: Number, // Time to first response in hours
    engagementScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    }
  },
  
  // Campaign information
  campaignId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Campaign'
  },
  campaignName: String,
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  
  // Outcome tracking
  outcome: {
    result: {
      type: String,
      enum: ['meeting_scheduled', 'referral_received', 'application_submitted', 'no_response', 'not_interested', 'connection_made']
    },
    notes: String,
    nextSteps: [String],
    followUpDate: Date
  },
  
  // Tags and categorization
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  category: {
    type: String,
    enum: ['cold_outreach', 'warm_introduction', 'referral_request', 'application_follow_up', 'networking'],
    default: 'cold_outreach'
  },
  
  // Relationship context
  relationship: {
    connectionLevel: {
      type: String,
      enum: ['1st', '2nd', '3rd', 'none'],
      default: 'none'
    },
    mutualConnections: [String],
    previousInteractions: [{
      date: Date,
      type: String,
      notes: String
    }]
  },
  
  // Reminders and notifications
  reminders: [{
    type: {
      type: String,
      enum: ['follow_up', 'response_check', 'next_action']
    },
    scheduledFor: Date,
    completed: {
      type: Boolean,
      default: false
    },
    completedAt: Date
  }],
  
  // Integration data
  integrations: {
    linkedinMessageId: String,
    emailMessageId: String,
    crmId: String,
    externalData: mongoose.Schema.Types.Mixed
  },
  
  // Archival and cleanup
  isActive: {
    type: Boolean,
    default: true
  },
  archivedAt: Date,
  archivedReason: String,
  
  // User notes
  notes: String,
  privateNotes: String,
  
}, {
  timestamps: true
});

// Indexes for performance
outreachSchema.index({ userId: 1, status: 1 });
outreachSchema.index({ userId: 1, createdAt: -1 });
outreachSchema.index({ recruiterId: 1, userId: 1 });
outreachSchema.index({ jobId: 1 });
outreachSchema.index({ status: 1, sentAt: 1 });
outreachSchema.index({ campaignId: 1 });
outreachSchema.index({ scheduledFor: 1 });
outreachSchema.index({ 'reminders.scheduledFor': 1, 'reminders.completed': 1 });

// Text search index
outreachSchema.index({
  messageContent: 'text',
  subject: 'text',
  notes: 'text',
  tags: 'text'
});

// Virtual for response time calculation
outreachSchema.virtual('responseTimeHours').get(function() {
  if (this.sentAt && this.replies && this.replies.length > 0) {
    const firstReply = this.replies[0];
    return Math.round((firstReply.receivedAt - this.sentAt) / (1000 * 60 * 60));
  }
  return null;
});

// Virtual for days since sent
outreachSchema.virtual('daysSinceSent').get(function() {
  if (this.sentAt) {
    return Math.floor((Date.now() - this.sentAt) / (1000 * 60 * 60 * 24));
  }
  return null;
});

// Virtual for reply count
outreachSchema.virtual('replyCount').get(function() {
  return this.replies ? this.replies.length : 0;
});

// Virtual for follow-up count
outreachSchema.virtual('followUpCount').get(function() {
  return this.followUps ? this.followUps.length : 0;
});

// Pre-save middleware
outreachSchema.pre('save', function(next) {
  // Update engagement score based on interactions
  if (this.isModified('replies') || this.isModified('analytics')) {
    this.calculateEngagementScore();
  }
  
  // Update response time
  if (this.isModified('replies') && this.replies.length > 0 && this.sentAt) {
    const firstReply = this.replies[0];
    this.analytics.responseTime = (firstReply.receivedAt - this.sentAt) / (1000 * 60 * 60);
  }
  
  next();
});

// Instance methods
outreachSchema.methods.addReply = function(replyData) {
  this.replies.push({
    content: replyData.content,
    receivedAt: replyData.receivedAt || new Date(),
    sentiment: replyData.sentiment || 'neutral',
    extractedInfo: replyData.extractedInfo || {}
  });
  
  // Update status
  if (this.status === 'sent' || this.status === 'delivered') {
    this.status = 'replied';
  }
  
  return this.save();
};

outreachSchema.methods.addFollowUp = function(followUpData) {
  this.followUps.push({
    content: followUpData.content,
    type: followUpData.type || 'reminder',
    scheduledFor: followUpData.scheduledFor,
    status: followUpData.status || 'drafted'
  });
  
  return this.save();
};

outreachSchema.methods.markAsSent = function() {
  this.status = 'sent';
  this.sentAt = new Date();
  
  // Schedule follow-up reminder if not replied within 7 days
  this.reminders.push({
    type: 'follow_up',
    scheduledFor: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  });
  
  return this.save();
};

outreachSchema.methods.calculateEngagementScore = function() {
  let score = 0;
  
  // Base score for being sent
  if (this.status === 'sent' || this.status === 'delivered' || this.status === 'replied') {
    score += 20;
  }
  
  // Bonus for being opened/delivered
  if (this.status === 'delivered' || this.status === 'opened' || this.status === 'replied') {
    score += 20;
  }
  
  // Major bonus for replies
  score += Math.min(this.replies.length * 30, 60);
  
  // Bonus for positive sentiment
  const positivReplies = this.replies.filter(r => r.sentiment === 'positive').length;
  score += positiveReplies * 10;
  
  // Bonus for quick response
  if (this.analytics.responseTime && this.analytics.responseTime <= 24) {
    score += 15;
  }
  
  // Bonus for follow-ups
  score += Math.min(this.followUps.length * 5, 15);
  
  this.analytics.engagementScore = Math.min(score, 100);
  return this.analytics.engagementScore;
};

outreachSchema.methods.scheduleReminder = function(type, date) {
  this.reminders.push({
    type: type,
    scheduledFor: date,
    completed: false
  });
  
  return this.save();
};

outreachSchema.methods.markReminderComplete = function(reminderId) {
  const reminder = this.reminders.id(reminderId);
  if (reminder) {
    reminder.completed = true;
    reminder.completedAt = new Date();
  }
  
  return this.save();
};

// Static methods
outreachSchema.statics.findByRecruiter = function(recruiterId, userId, options = {}) {
  const query = { recruiterId, userId };
  
  if (options.status) {
    query.status = options.status;
  }
  
  return this.find(query)
    .sort(options.sort || { createdAt: -1 })
    .limit(options.limit || 10);
};

outreachSchema.statics.getAnalytics = function(userId, timeframe = '30d') {
  const startDate = new Date();
  
  switch(timeframe) {
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(startDate.getDate() - 90);
      break;
  }

  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        createdAt: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: null,
        totalOutreach: { $sum: 1 },
        sent: { $sum: { $cond: [{ $eq: ['$status', 'sent'] }, 1, 0] } },
        replied: { $sum: { $cond: [{ $eq: ['$status', 'replied'] }, 1, 0] } },
        avgEngagement: { $avg: '$analytics.engagementScore' },
        avgResponseTime: { $avg: '$analytics.responseTime' }
      }
    }
  ]);
};

outreachSchema.statics.findPendingReminders = function() {
  return this.find({
    'reminders.scheduledFor': { $lte: new Date() },
    'reminders.completed': false,
    isActive: true
  });
};

outreachSchema.statics.getTopPerformingTemplates = function(userId, limit = 5) {
  return this.aggregate([
    {
      $match: {
        userId: mongoose.Types.ObjectId(userId),
        status: { $in: ['sent', 'replied'] }
      }
    },
    {
      $group: {
        _id: '$messageTemplate',
        count: { $sum: 1 },
        responseRate: {
          $avg: {
            $cond: [{ $eq: ['$status', 'replied'] }, 1, 0]
          }
        },
        avgEngagement: { $avg: '$analytics.engagementScore' }
      }
    },
    {
      $sort: { responseRate: -1, avgEngagement: -1 }
    },
    {
      $limit: limit
    }
  ]);
};

const Outreach = mongoose.model('Outreach', outreachSchema);

module.exports = Outreach;

================
File: models/mongodb/resume.model.js
================
// models/mongodb/resume.model.js
const mongoose = require('mongoose');

const resumeSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  processingStatus: {
    status: {
      type: String,
      enum: ['pending', 'uploading', 'parsing', 'analyzing', 'completed', 'error'],
      default: 'pending'
    },
    progress: {
      type: Number,
      default: 0,
      min: 0,
      max: 100
    },
    message: {
      type: String,
      default: ''
    },
    error: {
      type: String,
      default: ''
    },
    updatedAt: {
      type: Date,
      default: Date.now
    }
  },
  name: {
    type: String,
    required: true
  },
  originalFilename: {
    type: String,
    required: true
  },
  fileUrl: {
    type: String,
    required: true
  },
  fileType: {
    type: String,
    enum: ['PDF', 'DOCX', 'DOC'],
    required: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  parsedData: {
    contactInfo: {
      name: String,
      email: String,
      phone: String,
      location: String,
      websites: [String]
    },
    summary: String,
    experience: [{
      company: String,
      title: String,
      location: String,
      startDate: Date,
      endDate: Date,
      description: String,
      highlights: [String],
      skills: [String]
    }],
    education: [{
      institution: String,
      degree: String,
      field: String,
      startDate: Date,
      endDate: Date,
      gpa: Number,
      highlights: [String]
    }],
    skills: [{
      name: String,
      level: String,
      yearsOfExperience: Number
    }],
    certifications: [{
      name: String,
      issuer: String,
      dateObtained: Date,
      validUntil: Date
    }],
    languages: [{
      language: String,
      proficiency: String
    }],
    projects: [{
      name: String,
      description: String,
      url: String,
      startDate: Date,
      endDate: Date,
      skills: [String]
    }]
  },
  analysis: {
    overallScore: Number,
    atsCompatibility: Number,
    profileSummary: {
      currentRole: String,
      careerLevel: String,
      industries: [String],
      suggestedJobTitles: [String],
      suggestedIndustries: [String]
    },
    strengths: [String],
    weaknesses: [String],
    keywordsSuggestions: [String],
    improvementAreas: [{
      section: String,
      suggestions: [String],
      improvedSnippets: [{
        original: String,
        improved: String
      }]
    }]
  },
  // New fields for tailored resumes
  isTailored: {
    type: Boolean,
    default: false
  },
  tailoredForJob: {
    jobId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    },
    jobTitle: String,
    company: String,
    originalResumeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    }
  },
  versions: [{
    versionNumber: Number,
    createdAt: Date,
    fileUrl: String,
    changesDescription: String,
    jobId: mongoose.Schema.Types.ObjectId
  }],
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Resume', resumeSchema);

================
File: models/mongodb/user.model.js
================
// backend/models/mongodb/user.model.js
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const crypto = require('crypto');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Please provide an email'],
    unique: true,
    trim: true,
    lowercase: true,
    match: [
      /^([\w-\.]+@([\w-]+\.)+[\w-]{2,4})?$/,
      'Please provide a valid email'
    ]
  },
  password: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: [8, 'Password should be at least 8 characters'],
    select: false // Don't return password by default
  },
  firstName: {
    type: String,
    required: [true, 'Please provide your first name'],
    trim: true
  },
  lastName: {
    type: String,
    required: [true, 'Please provide your last name'],
    trim: true
  },
  profilePicture: {
    type: String
  },
  location: {
    city: String,
    state: String,
    country: String
  },
  phoneNumber: {
    type: String,
    trim: true
  },
  socialProfiles: {
    linkedin: String,
    github: String,
    portfolio: String
  },
  preferences: {
    jobTypes: [String],
    industries: [String],
    locations: [{
      city: String,
      state: String,
      country: String,
      remote: Boolean
    }],
    salaryRange: {
      min: Number,
      max: Number,
      currency: String
    },
    notifications: {
      email: {
        type: Boolean,
        default: true
      },
      jobAlerts: {
        type: Boolean,
        default: true
      }
    }
  },
  accountType: {
    type: String,
    enum: ['Free', 'Basic', 'Premium'],
    default: 'Free'
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isEmailVerified: {
    type: Boolean,
    default: false
  },
  emailVerificationToken: String,
  emailVerificationExpires: Date,
  passwordResetToken: String,
  passwordResetExpires: Date,
  loginAttempts: {
    type: Number,
    default: 0
  },
  lockUntil: Date,
  lastLogin: Date,
  active: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  // Only hash the password if it's modified (or new)
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

// Generate email verification token
userSchema.methods.generateEmailVerificationToken = function() {
  // Create a token
  const token = crypto.randomBytes(32).toString('hex');
  
  // Hash token and set to emailVerificationToken field
  this.emailVerificationToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Set expiration (24 hours)
  this.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000;
  
  return token;
};

// Generate password reset token
userSchema.methods.generatePasswordResetToken = function() {
  // Create a token
  const token = crypto.randomBytes(32).toString('hex');
  
  // Hash token and set to passwordResetToken field
  this.passwordResetToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Set expiration (10 minutes)
  this.passwordResetExpires = Date.now() + 10 * 60 * 1000;
  
  return token;
};

// Check if account is locked
userSchema.methods.isLocked = function() {
  return !!(this.lockUntil && this.lockUntil > Date.now());
};

// Increment login attempts and lock account if needed
userSchema.methods.incrementLoginAttempts = async function() {
  // If previous lock has expired, restart at 1
  if (this.lockUntil && this.lockUntil < Date.now()) {
    return this.updateOne({
      $set: { loginAttempts: 1 },
      $unset: { lockUntil: 1 }
    });
  }
  
  // Otherwise increment login attempts
  const updates = { $inc: { loginAttempts: 1 } };
  
  // Lock the account if we've reached max attempts (5) and it's not locked
  if (this.loginAttempts + 1 >= 5 && !this.isLocked()) {
    // Lock for 1 hour
    updates.$set = { lockUntil: Date.now() + 60 * 60 * 1000 };
  }
  
  return this.updateOne(updates);
};

// Reset login attempts
userSchema.methods.resetLoginAttempts = function() {
  return this.updateOne({
    $set: { loginAttempts: 0 },
    $unset: { lockUntil: 1 }
  });
};

const User = mongoose.model('User', userSchema);

module.exports = User;

================
File: models/mongodb/userMemory.model.js
================
// backend/models/mongodb/userMemory.model.js - FIXED SCHEMA FOR INSIGHTS
const mongoose = require('mongoose');

const memoryEntrySchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true
  },
  type: {
    type: String,
    enum: [
      'preference',
      'skill',
      'career_goal',
      'experience',
      'achievement',
      'challenge',
      'personality_trait',
      'communication_style',
      'work_style',
      'industry_knowledge',
      'tool_preference',
      'feedback_pattern',
      'education',           // ADDED: For degrees, certifications, etc.
      'learning_goal',       // ADDED: For things like "want to learn Python"
      'weakness'             // ADDED: For challenges like "system design interviews"
    ],
    required: true
  },
  category: {
    type: String,
    enum: [
      'personal',
      'professional',
      'technical',
      'behavioral',
      'contextual'
    ],
    required: true
  },
  content: {
    type: String,
    required: true,
    trim: true
  },
  confidence: {
    type: Number,
    min: 0,
    max: 1,
    default: 0.8
  },
  importance: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  source: {
    conversationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Conversation'
    },
    messageId: String,
    extractionMethod: {
      type: String,
      enum: [
        'explicit', 
        'inferred', 
        'pattern_detected', 
        'user_confirmed',
        'ai_extracted',
        'summary_extracted',
        'user_added'
      ],
      default: 'inferred'
    },
    model: String,
    timestamp: {
      type: Date,
      default: Date.now
    }
  },
  context: {
    resumeIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Resume'
    }],
    jobIds: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Job'
    }],
    timeframe: {
      from: Date,
      to: Date
    },
    situation: String
  },
  verification: {
    isVerified: {
      type: Boolean,
      default: false
    },
    verifiedAt: Date,
    verificationMethod: {
      type: String,
      enum: ['user_confirmed', 'repeated_observation', 'cross_referenced']
    },
    verificationCount: {
      type: Number,
      default: 0
    }
  },
  usage: {
    accessCount: {
      type: Number,
      default: 0
    },
    lastAccessedAt: Date,
    effectivenessRating: {
      type: Number,
      min: 1,
      max: 5
    },
    userFeedback: String
  },
  relationships: [{
    relatedMemoryId: String,
    relationshipType: {
      type: String,
      enum: ['reinforces', 'contradicts', 'builds_on', 'specifies', 'generalizes']
    },
    strength: {
      type: Number,
      min: 0,
      max: 1
    }
  }],
  decay: {
    lastReinforced: {
      type: Date,
      default: Date.now
    },
    reinforcementCount: {
      type: Number,
      default: 1
    },
    decayRate: {
      type: Number,
      default: 0.1
    }
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true,
  _id: false
});

const userMemorySchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    unique: true,
    index: true
  },
  memories: [memoryEntrySchema],
  
  // User profile intelligence derived from memories
  profile: {
    careerStage: {
      type: String,
      enum: ['student', 'entry_level', 'mid_level', 'senior_level', 'executive', 'career_changer', 'returning_professional'],
      confidence: Number
    },
    industries: [{
      name: String,
      experience_level: String,
      interest_level: Number,
      confidence: Number
    }],
    skills: [{
      name: String,
      level: {
        type: String,
        enum: ['beginner', 'intermediate', 'advanced', 'expert']
      },
      confidence: Number,
      lastMentioned: Date
    }],
    personalityTraits: [{
      trait: String,
      strength: Number,
      confidence: Number
    }],
    communicationStyle: {
      formality: {
        type: String,
        enum: ['very_formal', 'formal', 'neutral', 'casual', 'very_casual']
      },
      detail_preference: {
        type: String,
        enum: ['brief', 'moderate', 'detailed', 'comprehensive']
      },
      learning_style: {
        type: String,
        enum: ['visual', 'auditory', 'kinesthetic', 'reading']
      },
      feedback_preference: {
        type: String,
        enum: ['direct', 'gentle', 'detailed', 'actionable']
      }
    },
    goals: [{
      type: {
        type: String,
        enum: ['short_term', 'medium_term', 'long_term']
      },
      category: {
        type: String,
        enum: ['career', 'skill', 'personal', 'financial']
      },
      description: String,
      priority: Number,
      deadline: Date,
      progress: Number,
      confidence: Number
    }],
    preferences: {
      work_environment: [{
        type: String,
        preference_level: Number
      }],
      company_size: {
        type: String,
        enum: ['startup', 'small', 'medium', 'large', 'enterprise']
      },
      work_style: {
        type: String,
        enum: ['independent', 'collaborative', 'mixed']
      },
      communication_frequency: {
        type: String,
        enum: ['minimal', 'regular', 'frequent', 'constant']
      }
    }
  },

  // FIXED: Memory analytics with proper object schemas
  analytics: {
    totalMemories: {
      type: Number,
      default: 0
    },
    // FIXED: Array of objects with proper schema definition
    memoriesByType: [{
      _id: false,  // Disable _id for subdocuments
      type: {
        type: String,
        required: true
      },
      count: {
        type: Number,
        required: true
      }
    }],
    // FIXED: Array of objects with proper schema definition
    memoriesByCategory: [{
      _id: false,  // Disable _id for subdocuments
      category: {
        type: String,
        required: true
      },
      count: {
        type: Number,
        required: true
      }
    }],
    averageConfidence: {
      type: Number,
      default: 0
    },
    memoryAccuracy: {
      type: Number,
      default: 0
    },
    lastAnalyzedAt: Date,
    // FIXED: Array of insight objects with proper schema definition
    insights: [{
      _id: false,  // Disable _id for subdocuments
      type: {
        type: String,
        enum: ['pattern', 'opportunity', 'strength', 'challenge', 'recommendation'],
        required: true
      },
      description: {
        type: String,
        required: true
      },
      confidence: {
        type: Number,
        min: 0,
        max: 1,
        required: true
      },
      actionable: {
        type: Boolean,
        required: true
      },
      generatedAt: {
        type: Date,
        default: Date.now
      }
    }]
  },

  // Memory management settings
  settings: {
    memoryRetention: {
      type: String,
      enum: ['aggressive', 'normal', 'conservative'],
      default: 'normal'
    },
    autoDecay: {
      type: Boolean,
      default: true
    },
    requireVerification: {
      type: Boolean,
      default: false
    },
    shareInsights: {
      type: Boolean,
      default: true
    },
    maxMemories: {
      type: Number,
      default: 1000
    }
  },

  lastUpdated: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Indexes for efficient querying
userMemorySchema.index({ userId: 1 });
userMemorySchema.index({ 'memories.type': 1 });
userMemorySchema.index({ 'memories.category': 1 });
userMemorySchema.index({ 'memories.importance': 1 });
userMemorySchema.index({ 'memories.tags': 1 });
userMemorySchema.index({ 'memories.isActive': 1 });
userMemorySchema.index({ 'memories.confidence': -1 });

// Instance methods
userMemorySchema.methods.addMemory = function(memoryData) {
  const memoryId = `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  const memory = {
    id: memoryId,
    type: memoryData.type,
    category: memoryData.category,
    content: memoryData.content,
    confidence: memoryData.confidence || 0.8,
    importance: memoryData.importance || 'medium',
    source: {
      ...memoryData.source,
      timestamp: new Date()
    },
    context: memoryData.context || {},
    tags: memoryData.tags || [],
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  // Check for similar memories to avoid duplicates
  const similarMemory = this.findSimilarMemory(memory);
  if (similarMemory) {
    return this.reinforceMemory(similarMemory.id, memory);
  }
  
  this.memories.push(memory);
  this.analytics.totalMemories = this.memories.length;
  this.lastUpdated = new Date();
  
  return memory;
};

userMemorySchema.methods.findSimilarMemory = function(newMemory) {
  return this.memories.find(existing => 
    existing.type === newMemory.type &&
    existing.category === newMemory.category &&
    this.calculateSimilarity(existing.content, newMemory.content) > 0.8
  );
};

userMemorySchema.methods.calculateSimilarity = function(content1, content2) {
  const words1 = content1.toLowerCase().split(' ');
  const words2 = content2.toLowerCase().split(' ');
  const commonWords = words1.filter(word => words2.includes(word));
  return commonWords.length / Math.max(words1.length, words2.length);
};

userMemorySchema.methods.reinforceMemory = function(memoryId, reinforcementData) {
  const memory = this.memories.find(m => m.id === memoryId);
  if (memory) {
    memory.decay.lastReinforced = new Date();
    memory.decay.reinforcementCount += 1;
    memory.confidence = Math.min(1, memory.confidence + 0.1);
    
    if (reinforcementData) {
      memory.content = reinforcementData.content || memory.content;
      memory.tags = [...new Set([...memory.tags, ...(reinforcementData.tags || [])])];
    }
    
    this.lastUpdated = new Date();
    return memory;
  }
  return null;
};

userMemorySchema.methods.getMemoriesByType = function(type, options = {}) {
  let memories = this.memories.filter(m => m.type === type && m.isActive);
  
  if (options.minConfidence) {
    memories = memories.filter(m => m.confidence >= options.minConfidence);
  }
  
  if (options.importance) {
    memories = memories.filter(m => m.importance === options.importance);
  }
  
  return memories.sort((a, b) => {
    if (options.sortBy === 'confidence') return b.confidence - a.confidence;
    if (options.sortBy === 'recent') return new Date(b.updatedAt) - new Date(a.updatedAt);
    return b.decay.reinforcementCount - a.decay.reinforcementCount;
  });
};

userMemorySchema.methods.searchMemories = function(query, options = {}) {
  const searchRegex = new RegExp(query, 'i');
  
  let memories = this.memories.filter(m => 
    m.isActive && (
      searchRegex.test(m.content) ||
      m.tags.some(tag => searchRegex.test(tag)) ||
      searchRegex.test(m.type) ||
      searchRegex.test(m.category)
    )
  );
  
  if (options.minConfidence) {
    memories = memories.filter(m => m.confidence >= options.minConfidence);
  }
  
  return memories.sort((a, b) => b.confidence - a.confidence);
};

userMemorySchema.methods.getRelevantMemories = function(context, limit = 10) {
  let relevantMemories = [];
  
  // Get memories by context tags
  if (context.tags && context.tags.length > 0) {
    const taggedMemories = this.memories.filter(m => 
      m.isActive && m.tags.some(tag => context.tags.includes(tag))
    );
    relevantMemories.push(...taggedMemories);
  }
  
  // Get memories by type/category
  if (context.types && context.types.length > 0) {
    const typedMemories = this.memories.filter(m => 
      m.isActive && context.types.includes(m.type)
    );
    relevantMemories.push(...typedMemories);
  }
  
  // Get high-importance memories
  const importantMemories = this.memories.filter(m => 
    m.isActive && ['high', 'critical'].includes(m.importance)
  );
  relevantMemories.push(...importantMemories);
  
  // Remove duplicates and sort by relevance
  const uniqueMemories = Array.from(new Set(relevantMemories.map(m => m.id)))
    .map(id => relevantMemories.find(m => m.id === id))
    .sort((a, b) => {
      const aScore = this.calculateRelevanceScore(a, context);
      const bScore = this.calculateRelevanceScore(b, context);
      return bScore - aScore;
    });
  
  return uniqueMemories.slice(0, limit);
};

userMemorySchema.methods.calculateRelevanceScore = function(memory, context) {
  let score = memory.confidence;
  
  // Boost score for importance
  const importanceBoost = {
    'critical': 0.4,
    'high': 0.3,
    'medium': 0.1,
    'low': 0
  };
  score += importanceBoost[memory.importance] || 0;
  
  // Boost score for recent reinforcement
  const daysSinceReinforced = (Date.now() - memory.decay.lastReinforced) / (1000 * 60 * 60 * 24);
  score += Math.max(0, 0.2 - (daysSinceReinforced * 0.01));
  
  // Boost score for tag matches
  if (context.tags) {
    const tagMatches = memory.tags.filter(tag => context.tags.includes(tag)).length;
    score += tagMatches * 0.1;
  }
  
  return Math.min(1, score);
};

// FIXED: Update profile method with correct object structure - PROPER VERSION
userMemorySchema.methods.updateProfile = function() {
  // Initialize analytics if it doesn't exist
  if (!this.analytics) {
    this.analytics = {
      totalMemories: 0,
      memoriesByType: [],
      memoriesByCategory: [],
      averageConfidence: 0,
      insights: []
    };
  }

  const activeMemories = this.memories.filter(m => m.isActive);
  
  // Update basic analytics
  this.analytics.totalMemories = activeMemories.length;
  this.analytics.averageConfidence = activeMemories.length > 0 
    ? activeMemories.reduce((sum, m) => sum + m.confidence, 0) / activeMemories.length 
    : 0;
  
  // FIXED: Clear existing arrays before rebuilding
  this.analytics.memoriesByType = [];
  this.analytics.memoriesByCategory = [];
  
  // Update memory counts by type as objects
  const typeGroups = activeMemories.reduce((groups, memory) => {
    groups[memory.type] = (groups[memory.type] || 0) + 1;
    return groups;
  }, {});
  
  // FIXED: Build new array properly
  for (const [type, count] of Object.entries(typeGroups)) {
    this.analytics.memoriesByType.push({ type, count });
  }
  
  // Update memory counts by category as objects  
  const categoryGroups = activeMemories.reduce((groups, memory) => {
    groups[memory.category] = (groups[memory.category] || 0) + 1;
    return groups;
  }, {});
  
  // FIXED: Build new array properly
  for (const [category, count] of Object.entries(categoryGroups)) {
    this.analytics.memoriesByCategory.push({ category, count });
  }
  
  this.analytics.lastAnalyzedAt = new Date();
  this.lastUpdated = new Date();
  
  // Mark the analytics as modified to ensure Mongoose saves it
  this.markModified('analytics');
};

userMemorySchema.methods.decayMemories = function() {
  const now = Date.now();
  let decayedCount = 0;
  
  this.memories.forEach(memory => {
    if (!memory.isActive) return;
    
    const daysSinceReinforced = (now - memory.decay.lastReinforced) / (1000 * 60 * 60 * 24);
    const decayAmount = daysSinceReinforced * memory.decay.decayRate;
    
    memory.confidence = Math.max(0.1, memory.confidence - decayAmount);
    
    // Deactivate memories with very low confidence
    if (memory.confidence < 0.2) {
      memory.isActive = false;
      decayedCount++;
    }
  });
  
  if (decayedCount > 0) {
    this.updateProfile();
  }
  
  return decayedCount;
};

// Static methods
userMemorySchema.statics.findByUserId = function(userId) {
  return this.findOne({ userId });
};

userMemorySchema.statics.createForUser = function(userId) {
  return this.create({
    userId,
    memories: [],
    profile: {},
    analytics: {
      totalMemories: 0,
      memoriesByType: [],
      memoriesByCategory: [],
      averageConfidence: 0,
      memoryAccuracy: 0,
      insights: []
    },
    settings: {
      memoryRetention: 'normal',
      autoDecay: true,
      requireVerification: false,
      shareInsights: true,
      maxMemories: 1000
    }
  });
};

const UserMemory = mongoose.model('UserMemory', userMemorySchema);

module.exports = UserMemory;

================
File: models/postgresql/schema.js
================
// backend/models/postgresql/schema.js
const db = require('../../config/postgresql');

const createTables = async () => {
  try {
    console.log('Creating PostgreSQL tables...');
    
    // Industries Table with additional classification codes
    await db.query(`
      CREATE TABLE IF NOT EXISTS industries (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        description TEXT,
        sic_codes TEXT[],
        naics_codes TEXT[],
        primary_category VARCHAR(255),
        sub_category VARCHAR(255),
        hierarchical_category VARCHAR(255),
        all_industries TEXT[],
        all_sub_industries TEXT[],
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Locations Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS locations (
        id SERIAL PRIMARY KEY,
        street_address TEXT,
        city VARCHAR(100),
        state VARCHAR(100),
        postal_code VARCHAR(20),
        country VARCHAR(100) NOT NULL,
        is_remote BOOLEAN DEFAULT FALSE,
        full_address TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Companies Table with expanded fields
    await db.query(`
      CREATE TABLE IF NOT EXISTS companies (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        website VARCHAR(255),
        industry_id INTEGER REFERENCES industries(id),
        company_size VARCHAR(50),
        employee_count INTEGER,
        employee_range VARCHAR(50),
        founded_year INTEGER,
        headquarters_location_id INTEGER REFERENCES locations(id),
        description TEXT,
        logo_url VARCHAR(255),
        phone VARCHAR(50),
        fax VARCHAR(50),
        email_domain VARCHAR(255),
        revenue DECIMAL(15,2),
        revenue_range VARCHAR(50),
        revenue_usd_thousands INTEGER,
        ownership_type VARCHAR(50),
        business_model VARCHAR(50),
        stock_ticker VARCHAR(20),
        alexa_rank INTEGER,
        zoominfo_id VARCHAR(50),
        zoominfo_url TEXT,
        linkedin_url TEXT,
        facebook_url TEXT,
        twitter_url TEXT,
        funding_total DECIMAL(15,2),
        funding_total_usd_thousands INTEGER,
        recent_funding DECIMAL(15,2),
        recent_funding_usd_thousands INTEGER,
        recent_funding_round VARCHAR(50),
        recent_funding_date DATE,
        recent_investors TEXT[],
        all_investors TEXT[],
        location_count INTEGER,
        sic_codes TEXT[],
        naics_codes TEXT[],
        is_certified_active BOOLEAN DEFAULT FALSE,
        certification_date DATE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Add missing columns to companies table if they don't exist
    console.log('Checking and adding missing columns to companies table...');
    
    const companyColumnsToAdd = [
      { name: 'revenue_usd_thousands', type: 'INTEGER' },
      { name: 'funding_total_usd_thousands', type: 'INTEGER' },
      { name: 'recent_funding_usd_thousands', type: 'INTEGER' },
      { name: 'sic_codes', type: 'TEXT[]' },
      { name: 'naics_codes', type: 'TEXT[]' },
      { name: 'recent_investors', type: 'TEXT[]' },
      { name: 'all_investors', type: 'TEXT[]' },
      { name: 'is_certified_active', type: 'BOOLEAN DEFAULT FALSE' },
      { name: 'certification_date', type: 'DATE' },
      { name: 'zoominfo_id', type: 'VARCHAR(50)' },
      { name: 'zoominfo_url', type: 'TEXT' },
      { name: 'stock_ticker', type: 'VARCHAR(20)' },
      { name: 'alexa_rank', type: 'INTEGER' },
      { name: 'location_count', type: 'INTEGER' },
      { name: 'recent_funding_round', type: 'VARCHAR(50)' },
      { name: 'recent_funding_date', type: 'DATE' }
    ];

    for (const column of companyColumnsToAdd) {
      try {
        await db.query(`
          ALTER TABLE companies ADD COLUMN IF NOT EXISTS ${column.name} ${column.type};
        `);
        console.log(`✅ Added column ${column.name} to companies table`);
      } catch (error) {
        console.log(`Column ${column.name} already exists or cannot be added: ${error.message}`);
      }
    }

    // Add unique constraint to companies if it doesn't exist
    try {
      await db.query(`
        ALTER TABLE companies ADD CONSTRAINT companies_name_website_unique UNIQUE (name, website);
      `);
    } catch (error) {
      // Constraint might already exist, that's okay
      console.log('Companies unique constraint already exists or cannot be added');
    }
    
    // Recruiters Table with expanded fields for CSV data
    await db.query(`
      CREATE TABLE IF NOT EXISTS recruiters (
        id SERIAL PRIMARY KEY,
        first_name VARCHAR(100) NOT NULL,
        last_name VARCHAR(100) NOT NULL,
        middle_name VARCHAR(100),
        salutation VARCHAR(20),
        suffix VARCHAR(20),
        email VARCHAR(255),
        email_domain VARCHAR(255),
        supplemental_email VARCHAR(255),
        direct_phone VARCHAR(50),
        mobile_phone VARCHAR(50),
        current_company_id INTEGER REFERENCES companies(id),
        title VARCHAR(255),
        job_title_hierarchy_level INTEGER,
        management_level VARCHAR(50),
        job_start_date DATE,
        job_function VARCHAR(100),
        department VARCHAR(100),
        company_division VARCHAR(100),
        education_level VARCHAR(100),
        highest_education VARCHAR(100),
        accuracy_score INTEGER,
        accuracy_grade VARCHAR(10),
        contact_accuracy_score INTEGER,
        contact_accuracy_grade VARCHAR(10),
        zoominfo_url TEXT,
        linkedin_url TEXT,
        zoominfo_profile_url TEXT,
        linkedin_profile_url TEXT,
        notice_provided_date DATE,
        location_id INTEGER REFERENCES locations(id),
        industry_id INTEGER REFERENCES industries(id),
        specializations VARCHAR(255)[],
        experience_years INTEGER,
        last_active_date DATE,
        rating DECIMAL(3,2),
        notes TEXT,
        is_active BOOLEAN DEFAULT TRUE,
        last_contacted DATE,
        contact_attempts INTEGER DEFAULT 0,
        response_rate DECIMAL(5,2) DEFAULT 0,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    // Add missing columns to recruiters table if they don't exist
    console.log('Checking and adding missing columns to recruiters table...');
    
    const recruiterColumnsToAdd = [
      { name: 'person_street', type: 'VARCHAR(255)' },
      { name: 'person_city', type: 'VARCHAR(100)' },
      { name: 'person_state', type: 'VARCHAR(100)' },
      { name: 'person_zip_code', type: 'VARCHAR(20)' },
      { name: 'person_country', type: 'VARCHAR(100)' },
      { name: 'is_active', type: 'BOOLEAN DEFAULT TRUE' }
    ];

    for (const column of recruiterColumnsToAdd) {
      try {
        await db.query(`
          ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS ${column.name} ${column.type};
        `);
        console.log(`✅ Added column ${column.name} to recruiters table`);
      } catch (error) {
        console.log(`Column ${column.name} already exists or cannot be added`);
      }
    }

    // Add unique constraint to recruiters email if it doesn't exist
    try {
      await db.query(`
        ALTER TABLE recruiters ADD CONSTRAINT recruiters_email_unique UNIQUE (email);
      `);
    } catch (error) {
      // Constraint might already exist, that's okay
      console.log('Recruiters email unique constraint already exists or cannot be added');
    }
    
    // Skills Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS skills (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        category VARCHAR(100),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // RecruiterSkills Table (Junction)
    await db.query(`
      CREATE TABLE IF NOT EXISTS recruiter_skills (
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        skill_id INTEGER REFERENCES skills(id) ON DELETE CASCADE,
        PRIMARY KEY (recruiter_id, skill_id)
      );
    `);
    
    // Outreach Campaigns Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_campaigns (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(50) NOT NULL,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        status VARCHAR(50) DEFAULT 'active',
        target_job_title VARCHAR(255),
        target_companies TEXT[],
        target_locations TEXT[],
        message_template TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);

    // Outreach Messages Table
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_messages (
        id SERIAL PRIMARY KEY,
        user_id VARCHAR(50) NOT NULL,
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        campaign_id INTEGER REFERENCES outreach_campaigns(id) ON DELETE SET NULL,
        subject VARCHAR(255),
        message_content TEXT NOT NULL,
        sent_via VARCHAR(50) DEFAULT 'email',
        sent_at TIMESTAMP,
        status VARCHAR(50) DEFAULT 'draft',
        response_received BOOLEAN DEFAULT FALSE,
        response_content TEXT,
        response_received_at TIMESTAMP,
        follow_up_scheduled DATE,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      );
    `);
    
    // OutreachHistory Table (Connecting MongoDB to PostgreSQL)
    await db.query(`
      CREATE TABLE IF NOT EXISTS outreach_history (
        id SERIAL PRIMARY KEY,
        recruiter_id INTEGER REFERENCES recruiters(id) ON DELETE CASCADE,
        mongodb_outreach_id VARCHAR(24) NOT NULL,
        mongodb_user_id VARCHAR(24) NOT NULL,
        status VARCHAR(50) NOT NULL,
        last_contact_date TIMESTAMP,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // EmailTemplates Table for outreach
    await db.query(`
      CREATE TABLE IF NOT EXISTS email_templates (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        subject_template TEXT NOT NULL,
        body_template TEXT NOT NULL,
        context_variables JSONB,
        category VARCHAR(100),
        tags VARCHAR(50)[],
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    // Job Boards Table for scraping
    await db.query(`
      CREATE TABLE IF NOT EXISTS job_boards (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        url TEXT NOT NULL,
        scraping_config JSONB,
        is_active BOOLEAN DEFAULT TRUE,
        last_scraped_at TIMESTAMP,
        scraping_frequency_hours INTEGER DEFAULT 24,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);
    
    console.log('✅ Tables created successfully');
    
    // Create Indexes in a separate step to ensure all columns exist
    console.log('Creating indexes...');
    
    // Helper function to check if column exists before creating index
    const columnExists = async (tableName, columnName) => {
      try {
        const result = await db.query(`
          SELECT column_name 
          FROM information_schema.columns 
          WHERE table_name = $1 AND column_name = $2
        `, [tableName, columnName]);
        return result.rows.length > 0;
      } catch (error) {
        return false;
      }
    };

    // Basic indexes that should always work
    const basicIndexes = [
      'CREATE INDEX IF NOT EXISTS idx_recruiters_company ON recruiters(current_company_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_industry ON recruiters(industry_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_location ON recruiters(location_id)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_name ON recruiters(last_name, first_name)',
      'CREATE INDEX IF NOT EXISTS idx_recruiters_email ON recruiters(email)',
      'CREATE INDEX IF NOT EXISTS idx_companies_industry ON companies(industry_id)',
      'CREATE INDEX IF NOT EXISTS idx_companies_name ON companies(name)',
      'CREATE INDEX IF NOT EXISTS idx_companies_domain ON companies(email_domain)',
      'CREATE INDEX IF NOT EXISTS idx_companies_website ON companies(website)',
      'CREATE INDEX IF NOT EXISTS idx_recruiter_skills ON recruiter_skills(skill_id)',
      'CREATE INDEX IF NOT EXISTS idx_skills_name ON skills(name)',
      'CREATE INDEX IF NOT EXISTS idx_skills_category ON skills(category)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_recruiter ON outreach_history(recruiter_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_mongodb_ids ON outreach_history(mongodb_outreach_id, mongodb_user_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_user ON outreach_messages(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_recruiter ON outreach_messages(recruiter_id)',
      'CREATE INDEX IF NOT EXISTS idx_outreach_messages_status ON outreach_messages(status)'
    ];

    for (const indexQuery of basicIndexes) {
      try {
        await db.query(indexQuery);
      } catch (error) {
        console.log(`Index creation failed (this is usually okay): ${error.message}`);
      }
    }

    // Conditional indexes that depend on specific columns
    if (await columnExists('recruiters', 'title')) {
      try {
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_recruiters_title ON recruiters USING gin(to_tsvector('english', title));
        `);
      } catch (error) {
        console.log('Title index creation failed (this is usually okay)');
      }
    }

    if (await columnExists('recruiters', 'person_city') && await columnExists('recruiters', 'person_state')) {
      try {
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_recruiters_city_state ON recruiters(person_city, person_state);
        `);
        console.log('✅ Created city/state index');
      } catch (error) {
        console.log('City/state index creation failed (this is usually okay)');
      }
    } else {
      console.log('⚠️ Skipping city/state index - columns do not exist yet');
    }

    if (await columnExists('recruiters', 'is_active')) {
      try {
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_recruiters_active ON recruiters(is_active);
        `);
        console.log('✅ Created is_active index');
      } catch (error) {
        console.log('is_active index creation failed (this is usually okay)');
      }
    }
    
    console.log('✅ Indexes created successfully');
    console.log('✅ PostgreSQL tables setup completed successfully');
    
  } catch (error) {
    console.error('Error creating PostgreSQL tables:', error);
    throw error;
  }
};

// Function to seed some initial data for testing
const seedInitialData = async () => {
  try {
    // Minimal seeding for now - we'll add the recruiter import utility later
    const industryCount = await db.query('SELECT COUNT(*) FROM industries');
    
    if (parseInt(industryCount.rows[0].count) === 0) {
      console.log('Seeding initial industry data...');
      
      await db.query(`
        INSERT INTO industries (name, description, primary_category, sub_category) VALUES
        ('Business Services', 'Business consulting, professional services', 'Business Services', 'Custom Software & IT Services'),
        ('Technology', 'Software, hardware, and IT services', 'Business Services', 'Custom Software & IT Services'),
        ('Healthcare', 'Medical services, pharmaceuticals, and healthcare technology', 'Healthcare', 'Healthcare Services'),
        ('Finance', 'Banking, investments, and financial services', 'Financial Services', 'Banking & Financial Services'),
        ('Education', 'Schools, universities, and educational technology', 'Education', 'Education Services'),
        ('Manufacturing', 'Production of goods and related services', 'Manufacturing', 'General Manufacturing'),
        ('Telecommunications', 'Telecom infrastructure and services', 'Telecommunications', 'Telephony & Wireless'),
        ('HR & Staffing', 'Human resources and staffing services', 'Business Services', 'HR & Staffing')
        ON CONFLICT (name) DO NOTHING;
      `);
      
      console.log('Initial industry data seeded successfully');
    }
    
    // Add skills data
    const skillCount = await db.query('SELECT COUNT(*) FROM skills');
    
    if (parseInt(skillCount.rows[0].count) === 0) {
      console.log('Seeding initial skill data...');
      
      await db.query(`
        INSERT INTO skills (name, category) VALUES
        ('JavaScript', 'Programming Languages'),
        ('Python', 'Programming Languages'),
        ('Java', 'Programming Languages'),
        ('React', 'Frontend Development'),
        ('Node.js', 'Backend Development'),
        ('AWS', 'Cloud Computing'),
        ('SQL', 'Database'),
        ('Machine Learning', 'Data Science'),
        ('Product Management', 'Management'),
        ('Technical Recruiting', 'Recruiting'),
        ('Business Development', 'Sales'),
        ('Talent Acquisition', 'Recruiting'),
        ('HR Specialist', 'Human Resources'),
        ('ERP Support', 'Technical Support')
        ON CONFLICT (name) DO NOTHING;
      `);
      
      console.log('Initial skill data seeded successfully');
    }
    
    console.log('Basic initial data seeded successfully');
  } catch (error) {
    console.error('Error seeding initial data:', error);
    throw error;
  }
};

module.exports = { createTables, seedInitialData };

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.52.0",
    "@aws-sdk/client-s3": "^3.817.0",
    "@aws-sdk/s3-request-presigner": "^3.803.0",
    "aws-sdk": "^2.1692.0",
    "axios": "^1.9.0",
    "bcrypt": "^5.1.1",
    "cheerio": "^1.0.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "csv-parse": "^5.6.0",
    "csv-parser": "^3.2.0",
    "docx": "^8.5.0",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "fs": "^0.0.1-security",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mammoth": "^1.9.0",
    "mongoose": "^8.14.1",
    "multer": "^1.4.5-lts.2",
    "multer-s3": "^3.0.1",
    "natural": "^8.0.1",
    "nodemailer": "^6.10.1",
    "openai": "^4.97.0",
    "pdf-parse": "^1.1.1",
    "pdfkit": "^0.17.1",
    "pg": "^8.15.6",
    "puppeteer": "^24.10.0",
    "uuid": "^11.1.0",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

================
File: routes/assistant.routes.js
================
// backend/routes/assistant.routes.js - COMPLETE WITH RESUME EDITING ROUTES
const express = require('express');
const router = express.Router();
const assistantController = require('../controllers/assistant.controller');
const { protect } = require('../middleware/auth.middleware'); // FIXED: Proper import
const rateLimit = require('express-rate-limit');

// All assistant routes require authentication
router.use(protect);

// ===================================================================
// RATE LIMITING SETUP
// ===================================================================

// Rate limiting for AI operations (more restrictive due to cost)
const aiLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 50, // limit each IP to 50 AI operations per windowMs
  message: {
    success: false,
    error: 'AI operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting for memory operations
const memoryLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 memory operations per windowMs
  message: {
    success: false,
    error: 'Memory operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting for resume operations (moderate)
const resumeLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 20, // limit each IP to 20 resume operations per windowMs
  message: {
    success: false,
    error: 'Resume operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// ===================================================================
// ENHANCED CHAT & CONVERSATION MANAGEMENT
// ===================================================================

// Enhanced main chat endpoint with conversation management
router.post('/chat', aiLimiter, assistantController.chat);

// Conversation management
router.get('/conversations', assistantController.getConversations);
router.get('/conversations/:conversationId', assistantController.getConversation);
router.put('/conversations/:conversationId', assistantController.updateConversation);
router.delete('/conversations/:conversationId', assistantController.deleteConversation);

// Conversation utilities (placeholders - implement if needed)
router.post('/conversations/:conversationId/summary', assistantController.generateSummary);
router.get('/conversations/:conversationId/insights', assistantController.getConversationInsights);
router.get('/conversations/:conversationId/export', assistantController.exportConversation);

// Bulk operations
router.post('/conversations/bulk-update', assistantController.bulkUpdateConversations);

// ===================================================================
// MEMORY MANAGEMENT (with rate limiting)
// ===================================================================

// Memory CRUD operations
router.get('/memories', memoryLimiter, assistantController.getMemories);
router.post('/memories', memoryLimiter, assistantController.updateMemory);
router.delete('/memories/:memoryId', memoryLimiter, assistantController.deleteMemory);

// Memory insights and analytics
router.get('/memory-insights', memoryLimiter, assistantController.getMemoryInsights);
router.post('/memory-maintenance', memoryLimiter, assistantController.performMemoryMaintenance);

// ===================================================================
// ENHANCED RESUME OPERATIONS - FULL IMPLEMENTATION
// ===================================================================

// Core resume editing operations (with rate limiting) - THESE EXIST
router.post('/apply-resume-changes', resumeLimiter, assistantController.applyResumeChanges);
router.post('/optimize-ats', resumeLimiter, assistantController.optimizeForATS);
router.post('/analyze-resume', resumeLimiter, assistantController.analyzeResume);

// Real-time resume editing (PLACEHOLDER IMPLEMENTATIONS)
router.post('/resume/quick-edit', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Quick edit feature coming soon',
    suggestion: 'Use the apply-resume-changes endpoint for now'
  });
});

router.post('/resume/bulk-update', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Bulk update feature coming soon',
    suggestion: 'Use multiple apply-resume-changes calls for now'
  });
});

router.post('/resume/improvements', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Improvement suggestions feature coming soon',
    suggestion: 'Use the analyze-resume endpoint for detailed analysis'
  });
});

// Resume-specific AI operations (PLACEHOLDERS)
router.post('/resume/tailor-for-job', resumeLimiter, (req, res) => {
  res.json({
    success: true,
    message: 'Resume tailoring feature coming soon',
    suggestion: 'Use the apply-resume-changes endpoint for now'
  });
});

router.post('/resume/version-compare', (req, res) => {
  res.json({
    success: true,
    message: 'Version comparison feature coming soon',
    suggestion: 'Check the versions array in your resume data'
  });
});

// ===================================================================
// UNIVERSAL SEARCH
// ===================================================================

// Search across conversations and memories
router.get('/search', assistantController.search);

// ===================================================================
// ANALYTICS & INSIGHTS
// ===================================================================

// User analytics
router.get('/analytics', assistantController.getAnalytics);

// ===================================================================
// JOB MATCHING & CAREER GUIDANCE
// ===================================================================

// Job matching with memory context
router.post('/analyze-job-match', aiLimiter, assistantController.analyzeJobMatch);
router.post('/generate-cover-letter', aiLimiter, assistantController.generateCoverLetter);

// Career guidance with memory context
router.post('/career-advice', aiLimiter, assistantController.getCareerAdvice);
router.post('/contextual-suggestions', assistantController.getContextualSuggestions);
router.post('/personalized-tips', assistantController.getPersonalizedTips);

// ===================================================================
// SYSTEM & HEALTH
// ===================================================================

// Enhanced system endpoints
router.get('/capabilities', assistantController.getCapabilities);
router.get('/health', assistantController.healthCheck);
router.get('/usage-stats', assistantController.getUsageStats);
router.post('/track-interaction', assistantController.trackInteraction);
router.post('/reset-context', assistantController.resetContext);

// ===================================================================
// PLACEHOLDER ROUTES REMOVED - ALREADY DEFINED ABOVE
// ===================================================================

// ===================================================================
// ERROR HANDLING MIDDLEWARE
// ===================================================================

// Enhanced error handling for all operations
router.use((error, req, res, next) => {
  console.error('Assistant route error:', {
    error: error.message,
    stack: error.stack,
    route: req.route?.path,
    method: req.method,
    userId: req.user?._id,
    timestamp: new Date().toISOString()
  });

  // Resume-specific errors
  if (error.message.includes('resume') || error.message.includes('Resume')) {
    return res.status(500).json({
      success: false,
      error: 'Resume processing error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try refreshing the page or uploading the resume again'
    });
  }

  // Memory-specific errors
  if (error.message.includes('memory') || error.message.includes('Memory')) {
    return res.status(500).json({
      success: false,
      error: 'Memory system error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try refreshing the page or contact support if the issue persists'
    });
  }

  // Conversation-specific errors
  if (error.message.includes('conversation') || error.message.includes('Conversation')) {
    return res.status(500).json({
      success: false,
      error: 'Conversation system error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try starting a new conversation or contact support'
    });
  }

  // OpenAI API errors
  if (error.message.includes('OpenAI') || error.status === 429) {
    return res.status(503).json({
      success: false,
      error: 'AI service temporarily unavailable',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Please try again in a few moments'
    });
  }

  // Rate limiting errors
  if (error.status === 429 || error.message.includes('rate limit')) {
    return res.status(429).json({
      success: false,
      error: 'Too many requests',
      details: 'Rate limit exceeded for AI operations',
      suggestion: 'Please wait a few minutes before trying again',
      retryAfter: error.retryAfter || 300
    });
  }

  // File/upload errors
  if (error.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({
      success: false,
      error: 'File too large',
      suggestion: 'Please upload a file smaller than 10MB'
    });
  }

  // Authentication errors
  if (error.status === 401) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required',
      suggestion: 'Please log in again'
    });
  }

  // Default error response
  res.status(error.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : error.message,
    ...(process.env.NODE_ENV !== 'production' && { 
      stack: error.stack,
      timestamp: new Date().toISOString()
    })
  });
});

module.exports = router;

================
File: routes/auth.routes.js
================
// backend/routes/auth.routes.js (updated)
const express = require('express');
const authController = require('../controllers/auth.controller');
const { protect } = require('../middleware/auth.middleware');
const { 
  validateRegistration, 
  validateLogin, 
  validatePasswordReset,
  validateUpdateDetails,
  validateUpdatePassword,
  handleValidationErrors
} = require('../middleware/validation.middleware');

const router = express.Router();

// Public routes
router.post('/register', validateRegistration, handleValidationErrors, authController.register);
router.post('/login', validateLogin, handleValidationErrors, authController.login);
router.post('/forgot-password', authController.forgotPassword);
router.put('/reset-password/:token', validatePasswordReset, handleValidationErrors, authController.resetPassword);
router.get('/verify-email/:token', authController.verifyEmail);

// Protected routes
router.use(protect); // All routes below this require authentication
router.get('/me', authController.getMe);
router.post('/logout', authController.logout);
router.post('/resend-verification', authController.resendVerification);
router.put('/update-details', validateUpdateDetails, handleValidationErrors, authController.updateDetails);
router.put('/update-password', validateUpdatePassword, handleValidationErrors, authController.updatePassword);
router.delete('/delete-account', authController.deleteAccount);

module.exports = router;

================
File: routes/job.routes.js
================
// routes/job.routes.js
const express = require('express');
const router = express.Router();
const jobController = require('../controllers/job.controller');
const authMiddleware = require('../middleware/auth.middleware');

// All job routes require authentication
router.use(authMiddleware.protect);

// Create a new job
router.post('/', jobController.createJob);

// Get all user jobs
router.get('/', jobController.getUserJobs);

// IMPORTANT: Place specific routes BEFORE parameterized routes

// Get analysis insights (must be before /:id)
router.get('/analysis-insights', jobController.getJobAnalysisInsights);

// AI Search Management Routes (must be before /:id)
router.get('/ai-searches', jobController.getUserAiSearches);
router.post('/ai-search/:searchId/pause', jobController.pauseAiSearch);
router.post('/ai-search/:searchId/resume', jobController.resumeAiSearch);
router.delete('/ai-search/:searchId', jobController.deleteAiSearch);

// Re-analyze job (must be before /:id)
router.post('/re-analyze/:id', jobController.reAnalyzeJob);

// Re-match job with best available resume (NEW - must be before /:id)
router.post('/rematch-best/:jobId', jobController.rematchJobWithBestResume);

// NEW: Get job analysis status (must be before /:id)
router.get('/analysis-status/:id', jobController.getJobAnalysisStatus);

// Get job by ID (this catches all /jobs/:id patterns, so it must come after specific routes)
router.get('/:id', jobController.getJobById);

// Get resume match status for a specific job
router.get('/:id/resume-match-status', jobController.getResumeMatchStatus);

// Update job
router.put('/:id', jobController.updateJob);

// Delete job
router.delete('/:id', jobController.deleteJob);

// Match resume with job
router.post('/match/:jobId/:resumeId', jobController.matchResumeWithJob);

// Get tailoring recommendations
router.post('/tailor/:jobId/:resumeId', jobController.tailorResumeToJob);

// Find jobs with AI
router.post('/find-with-ai/:resumeId', jobController.findJobsWithAi);

module.exports = router;

================
File: routes/recruiter.routes.js
================
// backend/routes/recruiter.routes.js - FIXED ROUTE ORDERING
const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/auth.middleware');
const recruiterController = require('../controllers/recruiter.controller');

// Simple validation middleware (since we don't have express-validator setup)
const validate = (req, res, next) => {
  // For now, just pass through - we can add validation later
  next();
};

// ===================================================================
// VALIDATION MIDDLEWARE (Simplified for now)
// ===================================================================

const validateSearch = [validate];
const validateRecruiterParams = [validate];
const validateOutreachCreation = [validate];
const validateMessageGeneration = [validate];
const validateOutreachParams = [validate];

// ===================================================================
// SPECIFIC ROUTES (MUST COME BEFORE PARAMETERIZED ROUTES)
// ===================================================================

/**
 * @route   GET /api/recruiters/search
 * @desc    Search recruiters with advanced filtering
 * @access  Private
 */
router.get('/search', protect, validateSearch, recruiterController.searchRecruiters);

/**
 * @route   GET /api/recruiters/filters
 * @desc    Get available filter options for recruiter search
 * @access  Private
 */
router.get('/filters', protect, recruiterController.getFilterOptions);

/**
 * @route   GET /api/recruiters/analytics
 * @desc    Get outreach analytics and performance metrics
 * @access  Private
 */
router.get('/analytics', protect, recruiterController.getOutreachAnalytics);

/**
 * @route   POST /api/recruiters/generate-message
 * @desc    Generate AI-powered personalized message
 * @access  Private
 */
router.post('/generate-message', protect, validateMessageGeneration, recruiterController.generatePersonalizedMessage);

// ===================================================================
// OUTREACH MANAGEMENT ROUTES (SPECIFIC PATHS)
// ===================================================================

/**
 * @route   GET /api/recruiters/outreach
 * @desc    Get user's outreach campaigns
 * @access  Private
 */
router.get('/outreach', protect, recruiterController.getUserOutreach);

/**
 * @route   POST /api/recruiters/outreach
 * @desc    Create a new outreach campaign
 * @access  Private
 */
router.post('/outreach', protect, validateOutreachCreation, recruiterController.createOutreach);

/**
 * @route   PUT /api/recruiters/outreach/:outreachId/send
 * @desc    Send a drafted outreach message
 * @access  Private
 */
router.put('/outreach/:outreachId/send', protect, validateOutreachParams, recruiterController.sendOutreach);

/**
 * @route   PUT /api/recruiters/outreach/:outreachId
 * @desc    Update an outreach campaign
 * @access  Private
 */
router.put('/outreach/:outreachId', protect, validateOutreachParams, recruiterController.updateOutreach);

/**
 * @route   DELETE /api/recruiters/outreach/:outreachId
 * @desc    Delete an outreach campaign
 * @access  Private
 */
router.delete('/outreach/:outreachId', protect, validateOutreachParams, recruiterController.deleteOutreach);

// ===================================================================
// FUTURE IMPLEMENTATION ROUTES (SPECIFIC PATHS)
// ===================================================================

/**
 * @route   GET /api/recruiters/campaigns
 * @desc    Get outreach campaigns
 * @access  Private
 * @note    Future implementation for campaign management
 */
router.get('/campaigns', protect, (req, res) => {
  res.json({
    success: true,
    message: 'Campaign management feature coming soon',
    feature: 'campaign_management'
  });
});

/**
 * @route   POST /api/recruiters/bulk-outreach
 * @desc    Create bulk outreach to multiple recruiters
 * @access  Private
 * @note    Future implementation for bulk messaging
 */
router.post('/bulk-outreach', protect, (req, res) => {
  res.json({
    success: true,
    message: 'Bulk outreach feature coming soon',
    feature: 'bulk_messaging'
  });
});

/**
 * @route   GET /api/recruiters/recommendations
 * @desc    Get AI-recommended recruiters based on user profile
 * @access  Private
 * @note    Future implementation for AI recommendations
 */
router.get('/recommendations', protect, (req, res) => {
  res.json({
    success: true,
    message: 'AI recruiter recommendations coming soon',
    feature: 'ai_recommendations'
  });
});

// ===================================================================
// PARAMETERIZED ROUTES (MUST COME AFTER ALL SPECIFIC ROUTES)
// ===================================================================

/**
 * @route   GET /api/recruiters/:recruiterId
 * @desc    Get detailed recruiter information
 * @access  Private
 */
router.get('/:recruiterId', protect, validateRecruiterParams, recruiterController.getRecruiterById);

// ===================================================================
// ADVANCED OUTREACH FEATURES (Future Implementation)
// ===================================================================

/**
 * @route   POST /api/recruiters/outreach/:outreachId/reply
 * @desc    Record a reply to an outreach message
 * @access  Private
 * @note    Future implementation for reply tracking
 */
router.post('/outreach/:outreachId/reply', protect, validateOutreachParams, (req, res) => {
  res.json({
    success: true,
    message: 'Reply tracking feature coming soon',
    feature: 'reply_tracking'
  });
});

/**
 * @route   POST /api/recruiters/outreach/:outreachId/follow-up
 * @desc    Create a follow-up message
 * @access  Private
 * @note    Future implementation for automated follow-ups
 */
router.post('/outreach/:outreachId/follow-up', protect, validateOutreachParams, (req, res) => {
  res.json({
    success: true,
    message: 'Automated follow-up feature coming soon',
    feature: 'automated_follow_ups'
  });
});

// ===================================================================
// ERROR HANDLING
// ===================================================================

// Handle 404 for recruiter routes
router.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Recruiter API endpoint not found',
    suggestion: 'Check the API documentation for available recruiter endpoints',
    requestedPath: req.path,
    method: req.method,
    availableEndpoints: [
      'GET /api/recruiters/search - Search recruiters',
      'GET /api/recruiters/filters - Get filter options',
      'GET /api/recruiters/analytics - Get analytics',
      'POST /api/recruiters/generate-message - Generate AI message',
      'GET /api/recruiters/outreach - Get outreach campaigns',
      'POST /api/recruiters/outreach - Create outreach',
      'PUT /api/recruiters/outreach/:id - Update outreach',
      'DELETE /api/recruiters/outreach/:id - Delete outreach',
      'PUT /api/recruiters/outreach/:id/send - Send outreach',
      'GET /api/recruiters/:id - Get recruiter details'
    ]
  });
});

module.exports = router;

================
File: routes/resume.routes.js
================
// backend/routes/resume.routes.js - FINAL WORKING VERSION
const express = require('express');
const router = express.Router();
const resumeController = require('../controllers/resume.controller');
const authMiddleware = require('../middleware/auth.middleware');
const multer = require('multer');
const upload = multer({ storage: multer.memoryStorage() });

console.log('🔧 Setting up resume routes...');



// 📡 REAL SSE endpoint - MUST be before auth middleware
console.log('📡 Registering SSE endpoint: /:id/optimization-progress');
router.get('/:id/optimization-progress', resumeController.getOptimizationProgress);

// 🔒 Apply auth middleware to all other routes
console.log('🔒 Applying auth middleware to remaining routes');
router.use(authMiddleware.protect);

// 📁 Other routes (all require authentication)
router.post('/upload', upload.single('file'), resumeController.uploadResume);
router.get('/', resumeController.getUserResumes);

// Specific routes BEFORE generic /:id
router.get('/status/:id', resumeController.getResumeProcessingStatus);
router.post('/:id/optimize-ats', resumeController.optimizeResumeForATS);
router.post('/analyze/:id', resumeController.analyzeResume);
router.post('/versions/:id', upload.single('file'), resumeController.addResumeVersion);
router.post('/tailor/:resumeId/:jobId', resumeController.createTailoredResume);
router.delete('/:id', resumeController.deleteResume);

// Generic /:id route LAST
router.get('/:id', resumeController.getResumeById);

console.log('✅ Resume routes setup complete');

module.exports = router;

================
File: routes/search.routes.js
================
// backend/routes/search.routes.js
const express = require('express');
const router = express.Router();
const SearchController = require('../controllers/search.controller');
const { protect } = require('../middleware/auth.middleware');

/**
 * Search Routes
 * All routes require authentication
 */

// @desc    Global search across all content types
// @route   GET /api/search
// @access  Private
// @params  query (required), category (optional: all|jobs|resumes|recruiters), limit (optional)
router.get('/', protect, SearchController.globalSearch);

// @desc    Get search suggestions as user types
// @route   GET /api/search/suggestions
// @access  Private
// @params  query (required), limit (optional)
router.get('/suggestions', protect, SearchController.getSearchSuggestions);

// @desc    Get popular/trending searches
// @route   GET /api/search/popular
// @access  Private
router.get('/popular', protect, SearchController.getPopularSearches);

module.exports = router;

================
File: routes/settings.routes.js
================
// backend/routes/settings.routes.js
const express = require('express');
const router = express.Router();
const settingsController = require('../controllers/settings.controller');
const { protect } = require('../middleware/auth.middleware');

// All routes require authentication
router.use(protect);

// Profile management routes
router.get('/profile', settingsController.getProfile);
router.put('/profile', settingsController.updateProfile);

// Security routes
router.put('/change-password', settingsController.changePassword);
router.delete('/delete-account', settingsController.deleteAccount);

// Account verification routes
router.post('/send-verification-email', settingsController.sendVerificationEmail);
router.get('/verify-email/:token', settingsController.verifyEmail);

module.exports = router;

================
File: routes/test.routes.js
================
// backend/routes/test.routes.js
const express = require('express');
const sendEmail = require('../utils/send-email');
const emailTemplates = require('../utils/email-templates');

const router = express.Router();

router.post('/test-email', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({
        success: false,
        error: 'Please provide an email address'
      });
    }
    
    const testUrl = 'http://localhost:3000/test';
    
    await sendEmail({
      email,
      subject: 'Test Email',
      html: emailTemplates.generateVerificationEmail('Test User', testUrl)
    });
    
    res.status(200).json({
      success: true,
      message: 'Test email sent successfully'
    });
  } catch (error) {
    console.error('Error sending test email:', error);
    res.status(500).json({
      success: false,
      error: 'Email could not be sent'
    });
  }
});

module.exports = router;

================
File: scripts/fix-missing-columns.js
================
// backend/scripts/fix-missing-columns.js
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const db = require('../config/postgresql');

async function addMissingColumns() {
  try {
    console.log('Adding missing columns to recruiters table...');
    
    const columnsToAdd = [
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS highest_education VARCHAR(100);',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS contact_accuracy_score INTEGER;',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS contact_accuracy_grade VARCHAR(10);',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS zoominfo_profile_url TEXT;',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS linkedin_profile_url TEXT;'
    ];
    
    for (const sql of columnsToAdd) {
      try {
        await db.query(sql);
        console.log(`✅ Executed: ${sql}`);
      } catch (error) {
        console.log(`Column might already exist: ${error.message}`);
      }
    }
    
    console.log('✅ All missing columns added to recruiters table');
    process.exit(0);
  } catch (error) {
    console.error('❌ Error adding columns:', error);
    process.exit(1);
  }
}

addMissingColumns();

================
File: scripts/fix-outreach-history.js
================
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const db = require('../config/postgresql');

async function fixOutreachHistory() {
  try {
    console.log('🔧 Fixing outreach_history table...');
    
    // Check if constraint exists
    const constraintCheck = await db.query(`
      SELECT constraint_name 
      FROM information_schema.table_constraints 
      WHERE table_name = 'outreach_history' 
      AND constraint_type = 'UNIQUE'
      AND constraint_name = 'outreach_history_recruiter_user_unique'
    `);
    
    if (constraintCheck.rows.length === 0) {
      console.log('📊 Adding unique constraint...');
      
      await db.query(`
        ALTER TABLE outreach_history 
        ADD CONSTRAINT outreach_history_recruiter_user_unique 
        UNIQUE (recruiter_id, mongodb_user_id)
      `);
      
      console.log('✅ Unique constraint added successfully');
    } else {
      console.log('✅ Unique constraint already exists');
    }
    
    // Verify table structure
    const tableInfo = await db.query(`
      SELECT column_name, data_type, is_nullable
      FROM information_schema.columns 
      WHERE table_name = 'outreach_history'
      ORDER BY ordinal_position
    `);
    
    console.log('📋 Current table structure:');
    tableInfo.rows.forEach(row => {
      console.log(`  ${row.column_name}: ${row.data_type} (${row.is_nullable === 'YES' ? 'nullable' : 'not null'})`);
    });
    
    console.log('✅ Outreach history table is ready');
    
  } catch (error) {
    console.error('❌ Error fixing outreach history:', error);
  } finally {
    process.exit(0);
  }
}

fixOutreachHistory();

================
File: scripts/import-recruiters.js
================
// backend/scripts/import-recruiters.js
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const { createTables, seedInitialData } = require('../models/postgresql/schema');
const RecruiterImportService = require('../services/recruiterImport.service');

async function main() {
  try {
    console.log('🚀 Starting recruiter database setup...');
    
    // Create/update tables
    await createTables();
    
    // Seed initial data
    await seedInitialData();
    
    // Import from CSV if file exists
    const csvPath = process.argv[2];
    if (csvPath) {
      if (!require('fs').existsSync(csvPath)) {
        console.error('❌ CSV file not found:', csvPath);
        process.exit(1);
      }
      
      console.log(`📥 Importing from CSV: ${csvPath}`);
      const result = await RecruiterImportService.importFromCSV(csvPath);
      
      console.log('✅ Import Results:');
      console.log(`   Companies: ${result.companiesImported}`);
      console.log(`   Recruiters: ${result.recruitersImported}`);
      console.log(`   Total Processed: ${result.totalProcessed}`);
      console.log(`   Errors: ${result.errors}`);
    } else {
      console.log('ℹ️  Tables created. To import data, run:');
      console.log('   node scripts/import-recruiters.js /path/to/your/csv/file.csv');
    }
    
    process.exit(0);
  } catch (error) {
    console.error('❌ Setup failed:', error);
    process.exit(1);
  }
}

main();

================
File: scripts/update-recruiter-industries.js
================
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const db = require('../config/postgresql');

async function updateRecruiterIndustries() {
  try {
    console.log('🔍 Checking current state...');
    
    // Check current state
    const beforeCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters 
      WHERE industry_id IS NULL
    `);
    
    console.log(`📊 Recruiters without industry: ${beforeCount.rows[0].count}`);
    
    // Check how many can be updated
    const canUpdateCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters r
      JOIN companies c ON r.current_company_id = c.id
      WHERE r.industry_id IS NULL 
      AND c.industry_id IS NOT NULL
    `);
    
    console.log(`📊 Recruiters that can get industry from company: ${canUpdateCount.rows[0].count}`);
    
    // Perform the update
    console.log('🔄 Updating recruiter industries...');
    
    const updateResult = await db.query(`
      UPDATE recruiters 
      SET 
        industry_id = companies.industry_id,
        updated_at = NOW()
      FROM companies 
      WHERE recruiters.current_company_id = companies.id 
        AND recruiters.industry_id IS NULL
        AND companies.industry_id IS NOT NULL
    `);
    
    console.log(`✅ Updated ${updateResult.rowCount} recruiters with industries`);
    
    // Check final state
    const afterCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters 
      WHERE industry_id IS NOT NULL
    `);
    
    console.log(`📊 Recruiters with industry after update: ${afterCount.rows[0].count}`);
    
    // Show sample results
    console.log('📋 Sample results:');
    const sampleResults = await db.query(`
      SELECT 
        r.first_name,
        r.last_name,
        r.title,
        c.name as company_name,
        i.name as industry_name
      FROM recruiters r
      JOIN companies c ON r.current_company_id = c.id
      JOIN industries i ON r.industry_id = i.id
      LIMIT 5
    `);
    
    sampleResults.rows.forEach((row, index) => {
      console.log(`${index + 1}. ${row.first_name} ${row.last_name} (${row.title}) at ${row.company_name} - Industry: ${row.industry_name}`);
    });
    
    console.log('✅ Update completed successfully!');
    
  } catch (error) {
    console.error('❌ Error updating recruiter industries:', error);
  } finally {
    process.exit(0);
  }
}

updateRecruiterIndustries();

================
File: server.js
================
// backend/server.js - UPDATED WITH SETTINGS ROUTES
const express = require('express');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Database connections
const connectMongoDB = require('./config/mongodb');
const { createTables, seedInitialData } = require('./models/postgresql/schema');

// Import routes
const authRoutes = require('./routes/auth.routes');
const resumeRoutes = require('./routes/resume.routes');
const jobRoutes = require('./routes/job.routes');
const assistantRoutes = require('./routes/assistant.routes');
const recruiterRoutes = require('./routes/recruiter.routes');
const searchRoutes = require('./routes/search.routes');
const settingsRoutes = require('./routes/settings.routes'); // NEW: Settings routes

// Initialize Express
const app = express();

console.log('🚀 Starting Job Application Platform API...');

// Trust proxy for production
if (process.env.NODE_ENV === 'production') {
  app.set('trust proxy', 1);
}

// CORS configuration (simplified - the complex version wasn't the issue)
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.FRONTEND_URL || 'https://yourproductiondomain.com'
    : 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: [
    'Content-Type',
    'Authorization', 
    'X-Requested-With',
    'Accept',
    'Origin'
  ]
}));

// Security middleware
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: false // Disable CSP for development
}));

// Body parser middleware
app.use(express.json({ 
  limit: '10mb',
  strict: true
}));
app.use(express.urlencoded({ 
  extended: true, 
  limit: '10mb' 
}));

// Cookie parser middleware
app.use(cookieParser());

// Request sanitization middleware - FIXED VERSION
const sanitizeRequest = (req, res, next) => {
  const sanitize = (obj) => {
    if (!obj) return obj;
    
    if (typeof obj === 'object' && obj !== null) {
      // Handle arrays
      if (Array.isArray(obj)) {
        return obj.map(sanitize);
      }
      
      // Handle objects - FIXED: Use Object.prototype.hasOwnProperty.call()
      const sanitized = {};
      for (const key in obj) {
        // FIXED: Use Object.prototype.hasOwnProperty.call instead of obj.hasOwnProperty
        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
        
        // Check for MongoDB injection patterns
        if (key.startsWith('$') || key.includes('.')) {
          console.warn(`Potentially malicious key detected and removed: ${key}`);
          continue;
        }
        
        sanitized[key] = sanitize(obj[key]);
      }
      return sanitized;
    }
    return obj;
  };
  
  // Sanitize request data
  try {
    if (req.body) req.body = sanitize(req.body);
    if (req.query) req.query = sanitize(req.query);
    if (req.params) req.params = sanitize(req.params);
  } catch (error) {
    console.warn('Sanitization error:', error);
    // Continue without sanitization if there's an error
  }
  
  next();
};

app.use(sanitizeRequest);

// Rate limiting (more lenient for AI Assistant)
const generalLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: 'Too many requests from this IP, please try again later.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for AI Assistant (more restrictive due to cost)
const aiLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 50, // limit AI requests to 50 per 10 minutes
  message: {
    success: false,
    error: 'AI Assistant rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for Recruiter API (moderate limits)
const recruiterLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 150, // Higher limit for recruiter searches
  message: {
    success: false,
    error: 'Recruiter API rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for Search API (moderate limits)
const searchLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 100, // Allow frequent searches
  message: {
    success: false,
    error: 'Search rate limit exceeded. Please wait before searching again.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// NEW: Special rate limiter for Settings API (moderate limits)
const settingsLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 30, // Allow reasonable settings updates
  message: {
    success: false,
    error: 'Settings rate limit exceeded. Please wait before making more changes.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', generalLimiter);
app.use('/api/assistant', aiLimiter);
app.use('/api/recruiters', recruiterLimiter);
app.use('/api/search', searchLimiter);
app.use('/api/settings', settingsLimiter); // NEW: Settings-specific rate limiting

// Request logging middleware (development only)
if (process.env.NODE_ENV !== 'production') {
  app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.originalUrl}`);
    next();
  });
}

// Database initialization
const initializeDatabases = async () => {
  try {
    console.log('🔌 Initializing databases...');
    
    // Connect to MongoDB
    await connectMongoDB();
    console.log('✅ MongoDB connected successfully');
    
    // Set up PostgreSQL tables
    await createTables();
    console.log('✅ PostgreSQL tables created successfully');
    
    // Seed initial data
    await seedInitialData();
    console.log('✅ Initial data seeded successfully');
    
    console.log('🎉 All database connections completed successfully');
  } catch (error) {
    console.error('❌ Database initialization error:', error.message);
    
    // In production, exit on database failure
    if (process.env.NODE_ENV === 'production') {
      process.exit(1);
    } else {
      console.log('⚠️ Continuing in development mode without full database setup...');
    }
  }
};

// Initialize databases
initializeDatabases();

// API Routes
app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'Job Application Platform API is running',
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString(),
    features: [
      'User Authentication',
      'Resume Management', 
      'Job Tracking',
      'AI Career Assistant',
      'Job Matching',
      'AI Job Search',
      'Recruiter Outreach',
      'Global Search',
      'User Settings & Security' // NEW: Added settings feature
    ]
  });
});

app.get('/api/health', (req, res) => {
  res.status(200).json({ 
    success: true,
    status: 'OK', 
    message: 'API is healthy',
    timestamp: new Date().toISOString(),
    uptime: Math.floor(process.uptime()),
    memory: process.memoryUsage(),
    environment: process.env.NODE_ENV || 'development',
    ai_status: process.env.OPENAI_API_KEY ? 'configured' : 'not_configured',
    database_status: {
      mongodb: 'connected',
      postgresql: 'connected'
    }
  });
});

// Mount API routes
app.use('/api/auth', authRoutes);
app.use('/api/resumes', resumeRoutes);
app.use('/api/jobs', jobRoutes);
app.use('/api/assistant', assistantRoutes);
app.use('/api/recruiters', recruiterRoutes);
app.use('/api/search', searchRoutes);
app.use('/api/settings', settingsRoutes); // NEW: Mount settings routes

// FIXED: Catch-all route with named parameter (this was the problem!)
// Changed from '/api/*' to '/api/*path' - the wildcard MUST be named
app.all('/api/*path', (req, res) => {
  res.status(404).json({
    success: false,
    error: `API endpoint ${req.originalUrl} not found`,
    suggestion: 'Check the API documentation for available endpoints',
    availableEndpoints: {
      auth: [
        'POST /api/auth/login',
        'POST /api/auth/register',
        'GET /api/auth/me',
        'POST /api/auth/logout'
      ],
      resumes: [
        'GET /api/resumes',
        'POST /api/resumes/upload',
        'GET /api/resumes/:id'
      ],
      jobs: [
        'GET /api/jobs',
        'POST /api/jobs',
        'GET /api/jobs/:id'
      ],
      assistant: [
        'POST /api/assistant/chat',
        'POST /api/assistant/analyze-resume',
        'POST /api/assistant/analyze-job-match',
        'GET /api/assistant/health'
      ],
      recruiters: [
        'GET /api/recruiters/search',
        'GET /api/recruiters/filters',
        'GET /api/recruiters/:id',
        'POST /api/recruiters/outreach',
        'GET /api/recruiters/outreach',
        'POST /api/recruiters/generate-message',
        'GET /api/recruiters/analytics'
      ],
      search: [
        'GET /api/search?query={query}&category={category}',
        'GET /api/search/suggestions?query={query}',
        'GET /api/search/popular'
      ],
      settings: [ // NEW: Settings endpoints
        'GET /api/settings/profile',
        'PUT /api/settings/profile',
        'PUT /api/settings/change-password',
        'DELETE /api/settings/delete-account',
        'POST /api/settings/send-verification-email',
        'GET /api/settings/verify-email/:token'
      ]
    }
  });
});

// Global error handling middleware
app.use((err, req, res, next) => {
  console.error('Global error handler triggered:', {
    message: err.message,
    stack: process.env.NODE_ENV !== 'production' ? err.stack : undefined,
    url: req.originalUrl,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  // OpenAI API error handling
  if (err.message && err.message.includes('OpenAI')) {
    return res.status(503).json({
      success: false,
      error: 'AI service temporarily unavailable',
      details: process.env.NODE_ENV !== 'production' ? err.message : undefined
    });
  }
  
  // PostgreSQL error handling
  if (err.code && err.code.startsWith('23')) { // PostgreSQL constraint violations
    return res.status(400).json({
      success: false,
      error: 'Database constraint violation',
      details: process.env.NODE_ENV !== 'production' ? err.message : undefined
    });
  }
  
  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(val => val.message);
    return res.status(400).json({
      success: false,
      error: 'Validation Error',
      details: errors
    });
  }
  
  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue || {})[0] || 'field';
    return res.status(400).json({
      success: false,
      error: `${field} already exists`
    });
  }
  
  // JWT error
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
  
  // MongoDB connection error
  if (err.name === 'MongoNetworkError') {
    return res.status(503).json({
      success: false,
      error: 'Database connection error'
    });
  }
  
  // Default error response
  res.status(err.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal Server Error' 
      : err.message,
    ...(process.env.NODE_ENV !== 'production' && { 
      stack: err.stack,
      timestamp: new Date().toISOString()
    })
  });
});

// Start the server
const PORT = process.env.PORT || 5000;
const server = app.listen(PORT, () => {
  console.log(`🚀 Server running successfully on port ${PORT}`);
  console.log(`📍 Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`🌐 CORS enabled for: ${process.env.NODE_ENV === 'production' ? 'production domain' : 'http://localhost:3000'}`);
  console.log(`📊 Health check available at: http://localhost:${PORT}/api/health`);
  console.log(`🔗 API documentation: http://localhost:${PORT}/`);
  console.log(`🤖 AI Assistant: ${process.env.OPENAI_API_KEY ? '✅ Configured' : '❌ Not configured - add OPENAI_API_KEY to .env'}`);
  console.log(`🎯 Recruiter API: ✅ Configured with PostgreSQL database`);
  console.log(`🔍 Global Search: ✅ Configured with cross-platform search`);
  console.log(`⚙️ Settings API: ✅ Configured with profile & security management`); // NEW
});

// Graceful shutdown handlers
process.on('SIGTERM', () => {
  console.log('🛑 SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    console.log('✅ HTTP server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('🛑 SIGINT received. Shutting down gracefully...');
  server.close(() => {
    console.log('✅ HTTP server closed');
    process.exit(0);
  });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err, promise) => {
  console.error('🔥 UNHANDLED REJECTION:', {
    message: err.message,
    stack: err.stack,
    promise: promise
  });
  
  if (process.env.NODE_ENV === 'production') {
    console.log('🛑 Shutting down server due to unhandled promise rejection');
    server.close(() => {
      process.exit(1);
    });
  }
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('🔥 UNCAUGHT EXCEPTION:', {
    message: err.message,
    stack: err.stack
  });
  
  console.log('🛑 Shutting down server due to uncaught exception');
  process.exit(1);
});

================
File: services/assistant.service.js
================
// src/utils/assistantService.js - ENHANCED WITH MEMORY & CONVERSATIONS
import api from './axios';

const assistantService = {
  // ===================================================================
  // ENHANCED CHAT WITH CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Send message to AI Assistant with enhanced context and conversation management
   */
  sendMessage: async (requestData) => {
    try {
      const {
        message,
        context = {},
        conversationId,
        newConversation = false,
        conversationHistory = []
      } = requestData;

      const response = await api.post('/assistant/chat', {
        message,
        context: {
          page: context.page || 'unknown',
          currentResume: context.currentResume || null,
          currentJob: context.currentJob || null,
          resumeCount: context.resumeCount || 0,
          jobCount: context.jobCount || 0,
          userProfile: context.userProfile || null
        },
        conversationId,
        newConversation,
        conversationHistory: conversationHistory.slice(-10) // Last 10 messages
      });

      return {
        message: response.data.message,
        suggestions: response.data.suggestions || [],
        actions: response.data.actions || [],
        confidence: response.data.confidence || 0.8,
        conversationId: response.data.conversationId,
        conversationTitle: response.data.conversationTitle,
        memoryInsights: response.data.memoryInsights || [],
        usage: response.data.usage || {}
      };

    } catch (error) {
      console.error('Enhanced AI Assistant Service Error:', error);
      
      // Enhanced fallback responses based on context
      const fallbackResponse = this.getContextualFallback(requestData.message, requestData.context);
      
      if (error.response?.status === 503) {
        throw new Error('AI service temporarily unavailable. Please try again in a moment.');
      } else if (error.response?.status === 429) {
        throw new Error('Rate limit exceeded. Please wait before sending another message.');
      } else {
        throw new Error(fallbackResponse.error || 'AI service temporarily unavailable');
      }
    }
  },

  // ===================================================================
  // CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Get user's conversations
   */
  getConversations: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.category) params.append('category', options.category);
      if (options.tags && options.tags.length > 0) params.append('tags', options.tags.join(','));
      if (options.search) params.append('search', options.search);
      if (options.pinned !== undefined) params.append('pinned', options.pinned);
      if (options.starred !== undefined) params.append('starred', options.starred);
      if (options.limit) params.append('limit', options.limit);
      if (options.offset) params.append('offset', options.offset);
      if (options.sortBy) params.append('sortBy', options.sortBy);

      const response = await api.get(`/assistant/conversations?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching conversations:', error);
      throw error;
    }
  },

  /**
   * Get specific conversation
   */
  getConversation: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}`);
      return response.data.conversation;
    } catch (error) {
      console.error('Error fetching conversation:', error);
      throw error;
    }
  },

  /**
   * Create new conversation
   */
  createConversation: async (conversationData) => {
    try {
      const response = await api.post('/assistant/conversations', conversationData);
      return response.data.conversation;
    } catch (error) {
      console.error('Error creating conversation:', error);
      throw error;
    }
  },

  /**
   * Update conversation
   */
  updateConversation: async (conversationId, updates) => {
    try {
      const response = await api.put(`/assistant/conversations/${conversationId}`, updates);
      return response.data.conversation;
    } catch (error) {
      console.error('Error updating conversation:', error);
      throw error;
    }
  },

  /**
   * Delete conversation
   */
  deleteConversation: async (conversationId, permanent = false) => {
    try {
      const params = permanent ? '?permanent=true' : '';
      const response = await api.delete(`/assistant/conversations/${conversationId}${params}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting conversation:', error);
      throw error;
    }
  },

  /**
   * Generate conversation summary
   */
  generateSummary: async (conversationId) => {
    try {
      const response = await api.post(`/assistant/conversations/${conversationId}/summary`);
      return response.data.summary;
    } catch (error) {
      console.error('Error generating summary:', error);
      throw error;
    }
  },

  /**
   * Get conversation insights
   */
  getConversationInsights: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/insights`);
      return response.data.insights;
    } catch (error) {
      console.error('Error getting insights:', error);
      throw error;
    }
  },

  /**
   * Export conversation
   */
  exportConversation: async (conversationId, format = 'json') => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/export?format=${format}`);
      return response.data.export;
    } catch (error) {
      console.error('Error exporting conversation:', error);
      throw error;
    }
  },

  /**
   * Bulk update conversations
   */
  bulkUpdateConversations: async (conversationIds, updates) => {
    try {
      const response = await api.post('/assistant/conversations/bulk-update', {
        conversationIds,
        updates
      });
      return response.data.result;
    } catch (error) {
      console.error('Error bulk updating conversations:', error);
      throw error;
    }
  },

  // ===================================================================
  // MEMORY MANAGEMENT
  // ===================================================================

  /**
   * Get user memories
   */
  getMemories: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.type) params.append('type', options.type);
      if (options.category) params.append('category', options.category);
      if (options.search) params.append('search', options.search);
      if (options.minConfidence) params.append('minConfidence', options.minConfidence);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/memories?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching memories:', error);
      throw error;
    }
  },

  /**
   * Add or update memory
   */
  updateMemory: async (memoryData) => {
    try {
      const response = await api.post('/assistant/memories', { memoryData });
      return response.data;
    } catch (error) {
      console.error('Error updating memory:', error);
      throw error;
    }
  },

  /**
   * Delete memory
   */
  deleteMemory: async (memoryId) => {
    try {
      const response = await api.delete(`/assistant/memories/${memoryId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting memory:', error);
      throw error;
    }
  },

  /**
   * Get memory insights
   */
  getMemoryInsights: async () => {
    try {
      const response = await api.get('/assistant/memory-insights');
      return response.data;
    } catch (error) {
      console.error('Error getting memory insights:', error);
      throw error;
    }
  },

  /**
   * Perform memory maintenance
   */
  performMemoryMaintenance: async () => {
    try {
      const response = await api.post('/assistant/memory-maintenance');
      return response.data.maintenance;
    } catch (error) {
      console.error('Error performing memory maintenance:', error);
      throw error;
    }
  },

  // ===================================================================
  // SEARCH & ANALYTICS
  // ===================================================================

  /**
   * Search across conversations and memories
   */
  search: async (query, options = {}) => {
    try {
      const params = new URLSearchParams();
      params.append('query', query);
      
      if (options.searchType) params.append('searchType', options.searchType);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/search?${params}`);
      return response.data.results;

    } catch (error) {
      console.error('Error searching:', error);
      return { conversations: [], memories: [] };
    }
  },

  /**
   * Get analytics
   */
  getAnalytics: async (timeframe = '30d') => {
    try {
      const response = await api.get(`/assistant/analytics?timeframe=${timeframe}`);
      return response.data.analytics;
    } catch (error) {
      console.error('Error getting analytics:', error);
      throw error;
    }
  },

  // ===================================================================
  // ENHANCED RESUME OPERATIONS
  // ===================================================================

  /**
   * Analyze resume with memory context
   */
  analyzeResume: async (resumeId, analysisType = 'comprehensive') => {
    try {
      const response = await api.post('/assistant/analyze-resume', {
        resumeId,
        analysisType,
        includeImprovements: true,
        includeKeywords: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing resume:', error);
      throw error;
    }
  },

  /**
   * Apply resume changes suggested by AI
   */
  applyResumeChanges: async (changes) => {
    try {
      const response = await api.post('/assistant/apply-resume-changes', {
        resumeId: changes.resumeId,
        changes: changes.modifications,
        changeType: changes.type || 'enhancement'
      });

      return response.data;

    } catch (error) {
      console.error('Error applying resume changes:', error);
      throw error;
    }
  },

  /**
   * Optimize resume for ATS
   */
  optimizeForATS: async (resumeId, jobId = null) => {
    try {
      const response = await api.post('/assistant/optimize-ats', {
        resumeId,
        targetJobId: jobId,
        optimizationLevel: 'aggressive',
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error optimizing for ATS:', error);
      throw error;
    }
  },

  // ===================================================================
  // JOB MATCHING & CAREER GUIDANCE
  // ===================================================================

  /**
   * Get job matching insights with memory context
   */
  analyzeJobMatch: async (resumeId, jobId) => {
    try {
      const response = await api.post('/assistant/analyze-job-match', {
        resumeId,
        jobId,
        includeImprovements: true,
        includeTailoringAdvice: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing job match:', error);
      throw error;
    }
  },

/**
   * Generate personalized cover letter
   */
  generateCoverLetter: async (resumeId, jobId, style = 'professional') => {
    try {
      const response = await api.post('/assistant/generate-cover-letter', {
        resumeId,
        jobId,
        style,
        customization: 'high',
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error generating cover letter:', error);
      throw error;
    }
  },

  /**
   * Get career advice and guidance with memory context
   */
  getCareerAdvice: async (userProfile, specificQuestion = null) => {
    try {
      const response = await api.post('/assistant/career-advice', {
        userProfile,
        question: specificQuestion,
        includeJobSuggestions: true,
        includeSkillGaps: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error getting career advice:', error);
      throw error;
    }
  },

  /**
   * Get contextual suggestions for current page
   */
  getContextualSuggestions: async (page, contextData = {}) => {
    try {
      const response = await api.post('/assistant/contextual-suggestions', {
        page,
        contextData,
        maxSuggestions: 5,
        useMemoryContext: true
      });

      return response.data.suggestions || [];

    } catch (error) {
      console.error('Error getting contextual suggestions:', error);
      return this.getFallbackSuggestions(page, contextData);
    }
  },

  /**
   * Get personalized tips based on user profile and memory
   */
  getPersonalizedTips: async (category = 'general') => {
    try {
      const response = await api.post('/assistant/personalized-tips', {
        category,
        includeActions: true,
        useMemoryContext: true
      });

      return response.data.tips || [];

    } catch (error) {
      console.error('Error getting personalized tips:', error);
      return this.getFallbackTips(category);
    }
  },

  // ===================================================================
  // SYSTEM & HEALTH
  // ===================================================================

  /**
   * Get AI Assistant capabilities and status
   */
  getCapabilities: async () => {
    try {
      const response = await api.get('/assistant/capabilities');
      return response.data;
    } catch (error) {
      console.error('Error getting AI capabilities:', error);
      return {
        available: false,
        features: ['basic_chat', 'contextual_suggestions'],
        limitations: ['Full AI features unavailable in test mode'],
        memory_features: {
          available: false
        }
      };
    }
  },

  /**
   * Check AI Assistant health
   */
  checkHealth: async () => {
    try {
      const response = await api.get('/assistant/health');
      return response.data;
    } catch (error) {
      console.error('Health check failed:', error);
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  },

  /**
   * Get user's AI usage statistics
   */
  getUsageStats: async () => {
    try {
      const response = await api.get('/assistant/usage-stats');
      return response.data;
    } catch (error) {
      console.error('Error getting usage stats:', error);
      return {
        messagesThisMonth: 0,
        resumeAnalyses: 0,
        jobMatches: 0,
        careerAdviceRequests: 0,
        conversationsCreated: 0,
        memoriesStored: 0
      };
    }
  },

  /**
   * Track user interaction
   */
  trackInteraction: async (interactionType, data) => {
    try {
      await api.post('/assistant/track-interaction', {
        type: interactionType,
        data,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      // Non-critical, just log
      console.warn('Failed to track interaction:', error);
    }
  },

  /**
   * Reset AI conversation context
   */
  resetContext: async () => {
    try {
      await api.post('/assistant/reset-context');
      return { success: true };
    } catch (error) {
      console.error('Error resetting context:', error);
      return { success: false };
    }
  },

  // ===================================================================
  // CONVERSATION UTILITIES
  // ===================================================================

  /**
   * Auto-generate conversation title based on content
   */
  generateConversationTitle: async (messages, context = {}) => {
    try {
      if (!messages || messages.length === 0) return 'New Conversation';

      // Use the first user message to generate title
      const firstUserMessage = messages.find(m => m.type === 'user');
      if (!firstUserMessage) return 'New Conversation';

      // Simple client-side title generation for immediate feedback
      const content = firstUserMessage.content.toLowerCase();
      
      if (content.includes('resume')) return 'Resume Assistance';
      if (content.includes('job') || content.includes('application')) return 'Job Search Help';
      if (content.includes('interview')) return 'Interview Preparation';
      if (content.includes('career')) return 'Career Guidance';
      if (content.includes('skill')) return 'Skill Development';
      
      // Fallback based on context
      const contextTitles = {
        'resumes': 'Resume Help',
        'jobs': 'Job Search',
        'dashboard': 'Career Planning'
      };
      
      return contextTitles[context.page] || 'Career Assistance';

    } catch (error) {
      console.error('Error generating conversation title:', error);
      return 'New Conversation';
    }
  },

  /**
   * Format conversation for display
   */
  formatConversation: (conversation) => {
    if (!conversation) return null;

    return {
      ...conversation,
      formattedDate: new Date(conversation.createdAt).toLocaleDateString(),
      formattedTime: new Date(conversation.lastActiveAt).toLocaleTimeString(),
      preview: conversation.messages && conversation.messages.length > 0
        ? conversation.messages[conversation.messages.length - 1].content.substring(0, 100) + '...'
        : conversation.description || 'No messages yet',
      messageCount: conversation.messages ? conversation.messages.length : 0,
      isRecent: Date.now() - new Date(conversation.lastActiveAt).getTime() < 24 * 60 * 60 * 1000
    };
  },

  /**
   * Format memory for display
   */
  formatMemory: (memory) => {
    if (!memory) return null;

    return {
      ...memory,
      formattedDate: new Date(memory.createdAt).toLocaleDateString(),
      confidencePercentage: Math.round(memory.confidence * 100),
      isHighConfidence: memory.confidence >= 0.8,
      isRecentlyAccessed: memory.usage?.lastAccessedAt && 
        Date.now() - new Date(memory.usage.lastAccessedAt).getTime() < 7 * 24 * 60 * 60 * 1000,
      typeLabel: this.getMemoryTypeLabel(memory.type),
      categoryLabel: this.getCategoryLabel(memory.category)
    };
  },

  /**
   * Get human-readable memory type labels
   */
  getMemoryTypeLabel: (type) => {
    const labels = {
      'preference': 'Preference',
      'skill': 'Skill',
      'career_goal': 'Career Goal',
      'experience': 'Experience',
      'achievement': 'Achievement',
      'challenge': 'Challenge',
      'personality_trait': 'Personality',
      'communication_style': 'Communication Style',
      'work_style': 'Work Style',
      'industry_knowledge': 'Industry Knowledge',
      'tool_preference': 'Tool Preference',
      'feedback_pattern': 'Feedback Pattern'
    };
    return labels[type] || type;
  },

  /**
   * Get human-readable category labels
   */
  getCategoryLabel: (category) => {
    const labels = {
      'personal': 'Personal',
      'professional': 'Professional',
      'technical': 'Technical',
      'behavioral': 'Behavioral',
      'contextual': 'Contextual'
    };
    return labels[category] || category;
  },

  // ===================================================================
  // ENHANCED FALLBACK RESPONSES
  // ===================================================================

  /**
   * Enhanced fallback responses based on context
   */
  getContextualFallback: (message, context) => {
    const lowercaseMessage = message.toLowerCase();

    // Resume-related queries
    if (lowercaseMessage.includes('resume') || lowercaseMessage.includes('cv')) {
      if (context?.page === 'resumes' && context?.currentResume) {
        return {
          message: `I can see you're working on "${context.currentResume.name}". While I can't access my full AI capabilities right now, I suggest focusing on: quantifying achievements with metrics, using action verbs, and ensuring ATS compatibility. I remember our previous discussions about your career goals and can provide personalized suggestions once I'm back online.`,
          suggestions: [
            'Help improve work experience section',
            'Suggest better action verbs',
            'Check ATS compatibility',
            'Add missing skills based on your profile'
          ]
        };
      }
      return {
        message: "I'd love to help improve your resume! I remember our previous conversations about your career goals and preferences. Common improvements include quantifying achievements, using strong action verbs, optimizing for ATS systems, and tailoring to specific jobs. Which resume would you like to work on?",
        suggestions: [
          'Analyze my best resume',
          'Create new resume',
          'Compare my resumes',
          'ATS optimization tips'
        ]
      };
    }

    // Job-related queries
    if (lowercaseMessage.includes('job') || lowercaseMessage.includes('application') || lowercaseMessage.includes('interview')) {
      if (context?.page === 'jobs' && context?.currentJob) {
        return {
          message: `Looking at "${context.currentJob.title}" at ${context.currentJob.company}. Based on what I remember about your background and preferences, I can help you understand how well your resume matches this position and suggest improvements to increase your chances.`,
          suggestions: [
            'Match my best resume to this job',
            'What skills am I missing?',
            'Help tailor my resume',
            'Write a personalized cover letter'
          ]
        };
      }
      return {
        message: "I can help you with job searching, application optimization, and interview preparation! I remember your career goals and can provide personalized advice. What specific aspect would you like assistance with?",
        suggestions: [
          'Find matching jobs for my profile',
          'Improve application materials',
          'Interview preparation tips',
          'Salary negotiation advice'
        ]
      };
    }

    // Career guidance queries
    if (lowercaseMessage.includes('career') || lowercaseMessage.includes('advice') || lowercaseMessage.includes('guidance')) {
      return {
        message: "I'm here to provide personalized career guidance! I remember our previous conversations about your goals and challenges. I can help with career planning, skill development, industry insights, and strategic job search approaches. What's your biggest career challenge right now?",
        suggestions: [
          'Plan my next career move',
          'Identify skill gaps for my goals',
          'Industry insights for my field',
          'Job search strategy review'
        ]
      };
    }

    // Memory-related queries
    if (lowercaseMessage.includes('remember') || lowercaseMessage.includes('memory') || lowercaseMessage.includes('previous')) {
      return {
        message: "I maintain a memory of our conversations to provide better assistance! I remember your preferences, goals, and career journey. While I'm currently in test mode, I can still access some of our conversation history and provide personalized advice.",
        suggestions: [
          'Show my conversation history',
          'What do you remember about me?',
          'Review my career progress',
          'Update my preferences'
        ]
      };
    }

    // Default fallback
    return {
      message: "I'm currently running in test mode while my full AI capabilities are being set up, but I can still access our conversation history and provide personalized career advice. I remember your goals and preferences from our previous discussions. What would you like to explore?",
      suggestions: [
        'Review my career progress',
        'Resume improvement tips',
        'Job search strategy',
        'Show conversation history'
      ],
      error: 'AI service temporarily in test mode'
    };
  },

  /**
   * Get fallback suggestions based on page context
   */
  getFallbackSuggestions: (page, contextData) => {
    const suggestions = {
      dashboard: [
        'Review my career progress',
        'What should I focus on today?',
        'Find new job opportunities',
        'Show my conversation history'
      ],
      resumes: [
        'Improve this resume with memory context',
        'Check ATS compatibility',
        'Compare with other resumes',
        'Add missing keywords for my goals'
      ],
      jobs: [
        'Match resume to this job',
        'Find similar positions for my profile',
        'Improve match score',
        'Create tailored resume version'
      ],
      'ai-searches': [
        'Optimize search criteria for my goals',
        'Review found opportunities',
        'Adjust search parameters',
        'Set up new automated searches'
      ]
    };

    return suggestions[page] || [
      'Help with resume using my profile',
      'Find job opportunities that match me',
      'Career guidance based on my goals',
      'Review my conversation history'
    ];
  },

  /**
   * Get fallback tips based on category
   */
  getFallbackTips: (category) => {
    const fallbackTips = {
      resume: [
        'Use action verbs to start each bullet point',
        'Quantify achievements with specific numbers',
        'Tailor keywords to match job descriptions',
        'Keep formatting clean and ATS-friendly',
        'Highlight achievements relevant to your career goals'
      ],
      job_search: [
        'Apply to jobs within 24-48 hours of posting',
        'Customize your resume for each application',
        'Research company culture before applying',
        'Follow up professionally after 1-2 weeks',
        'Leverage your network for referrals'
      ],
      career: [
        'Set SMART career goals every quarter',
        'Build your professional network consistently',
        'Stay updated with industry trends',
        'Invest in learning new skills regularly',
        'Seek feedback and mentorship opportunities'
      ],
      interview: [
        'Practice common interview questions',
        'Research the company and role thoroughly',
        'Prepare specific examples using STAR method',
        'Ask thoughtful questions about the role',
        'Follow up with a thank-you message'
      ],
      general: [
        'Keep your LinkedIn profile updated',
        'Track your job applications systematically',
        'Practice interviewing regularly',
        'Maintain a professional online presence',
        'Document your achievements for future reference'
      ]
    };

    return fallbackTips[category] || fallbackTips.general;
  },

  // ===================================================================
  // VALIDATION & UTILITIES
  // ===================================================================

  /**
   * Validate message content before sending
   */
  validateMessage: (message) => {
    if (!message || typeof message !== 'string') {
      return { valid: false, error: 'Message must be a non-empty string' };
    }

    if (message.trim().length === 0) {
      return { valid: false, error: 'Message cannot be empty' };
    }

    if (message.length > 3000) {
      return { valid: false, error: 'Message too long (max 3000 characters)' };
    }

    // Check for potential harmful content
    const harmfulPatterns = [
      /password/i,
      /credit card/i,
      /social security/i,
      /ssn/i
    ];

    for (const pattern of harmfulPatterns) {
      if (pattern.test(message)) {
        return { 
          valid: false, 
          error: 'Please avoid sharing sensitive personal information' 
        };
      }
    }

    return { valid: true };
  },

  /**
   * Format AI response for display
   */
  formatResponse: (response) => {
    if (!response || typeof response !== 'string') {
      return 'I encountered an issue processing that request. Please try again.';
    }

    // Clean up common AI response artifacts
    let formatted = response
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove markdown bold
      .replace(/\*(.*?)\*/g, '$1')     // Remove markdown italic
      .replace(/\n\n+/g, '\n\n')      // Normalize line breaks
      .trim();

    // Ensure proper sentence structure
    if (formatted && !formatted.endsWith('.') && !formatted.endsWith('!') && !formatted.endsWith('?')) {
      formatted += '.';
    }

    return formatted;
  },

  /**
   * Check if AI service is available
   */
  isAvailable: async () => {
    try {
      const response = await api.get('/assistant/health');
      return response.data.status === 'healthy';
    } catch (error) {
      console.warn('AI Assistant service unavailable:', error.message);
      return false;
    }
  },

  /**
   * Get conversation statistics
   */
  getConversationStats: async () => {
    try {
      const analytics = await this.getAnalytics('30d');
      return {
        totalConversations: analytics.totalConversations || 0,
        totalMessages: analytics.totalMessages || 0,
        avgEngagement: analytics.avgEngagement || 0,
        mostActiveCategory: analytics.categoryDistribution ? 
          Object.keys(analytics.categoryDistribution)[0] : 'general'
      };
    } catch (error) {
      console.error('Error getting conversation stats:', error);
      return {
        totalConversations: 0,
        totalMessages: 0,
        avgEngagement: 0,
        mostActiveCategory: 'general'
      };
    }
  },

  /**
   * Estimate tokens for message
   */
  estimateTokens: (text) => {
    // Rough estimation: ~4 characters per token
    return Math.ceil(text.length / 4);
  },

  /**
   * Calculate estimated cost
   */
  estimateCost: (tokens) => {
    // GPT-4 Turbo pricing estimate
    const inputCost = 0.01 / 1000;
    const outputCost = 0.03 / 1000;
    return ((tokens * 0.5 * inputCost) + (tokens * 0.5 * outputCost)).toFixed(4);
  }
};

export default assistantService;

================
File: services/conversationService.js
================
// backend/services/conversationService.js
const Conversation = require('../models/mongodb/conversation.model');
const MemoryService = require('./memoryService');
const { openai } = require('../config/openai');

class ConversationService {
  /**
   * Create a new conversation
   */
  static async createConversation(userId, conversationData) {
    try {
      const conversation = new Conversation({
        userId,
        title: conversationData.title || 'New Conversation',
        description: conversationData.description || '',
        category: conversationData.category || 'general',
        tags: conversationData.tags || [],
        context: conversationData.context || {},
        settings: {
          memoryEnabled: true,
          autoSummarize: true,
          ...conversationData.settings
        }
      });

      await conversation.save();

      // Add initial system message if provided
      if (conversationData.initialMessage) {
        await this.addMessage(conversation._id, {
          type: 'system',
          content: conversationData.initialMessage,
          metadata: {
            context: conversationData.context
          }
        });
      }

      return conversation;

    } catch (error) {
      console.error('Create conversation error:', error);
      throw error;
    }
  }

  /**
   * Get user's conversations with filtering and pagination
   */
  static async getUserConversations(userId, options = {}) {
    try {
      const {
        category,
        tags,
        search,
        pinned,
        starred,
        status = 'active',
        limit = 20,
        offset = 0,
        sortBy = 'lastActiveAt',
        sortOrder = 'desc'
      } = options;

      let query = { userId, status };

      // Apply filters
      if (category) query.category = category;
      if (tags && tags.length > 0) query.tags = { $in: tags };
      if (pinned !== undefined) query.pinned = pinned;
      if (starred !== undefined) query.starred = starred;

      // Handle search
      if (search) {
        query.$or = [
          { title: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } },
          { tags: { $regex: search, $options: 'i' } },
          { 'summary.keyTopics': { $regex: search, $options: 'i' } }
        ];
      }

      const sortOptions = {};
      sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;

      const conversations = await Conversation.find(query)
        .sort(sortOptions)
        .limit(limit)
        .skip(offset)
        .populate('context.primaryResumeId', 'name analysis.overallScore')
        .populate('context.relatedJobIds', 'title company')
        .lean();

      // Add computed fields
      const enrichedConversations = conversations.map(conv => ({
        ...conv,
        messageCount: conv.messages ? conv.messages.length : 0,
        lastMessage: conv.messages && conv.messages.length > 0 
          ? conv.messages[conv.messages.length - 1] 
          : null,
        unreadCount: this.calculateUnreadCount(conv.messages),
        preview: this.generatePreview(conv)
      }));

      return {
        conversations: enrichedConversations,
        total: await Conversation.countDocuments(query),
        hasMore: (offset + limit) < await Conversation.countDocuments(query)
      };

    } catch (error) {
      console.error('Get user conversations error:', error);
      throw error;
    }
  }

  /**
   * Get a specific conversation with full message history
   */
  static async getConversation(conversationId, userId) {
    try {
      const conversation = await Conversation.findOne({
        _id: conversationId,
        userId,
        status: { $ne: 'deleted' }
      })
      .populate('context.primaryResumeId', 'name analysis.overallScore parsedData.skills')
      .populate('context.relatedJobIds', 'title company parsedData.keySkills');

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      // Update last active time
      conversation.lastActiveAt = new Date();
      await conversation.save();

      return conversation;

    } catch (error) {
      console.error('Get conversation error:', error);
      throw error;
    }
  }

  /**
   * Add a message to a conversation
   */
  static async addMessage(conversationId, messageData) {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) {
        throw new Error('Conversation not found');
      }

      const message = conversation.addMessage(messageData);
      await conversation.save();

      // Extract memories from user messages
      if (messageData.type === 'user' && conversation.settings.memoryEnabled) {
        try {
          await MemoryService.extractMemoriesFromMessage(
            conversation.userId,
            messageData.content,
            {
              conversationId: conversationId,
              messageId: message.id,
              page: messageData.metadata?.context?.page,
              category: conversation.category,
              tags: conversation.tags
            }
          );
        } catch (memoryError) {
          console.warn('Memory extraction failed:', memoryError);
          // Don't fail the message addition if memory extraction fails
        }
      }

      // Auto-summarize if needed
      if (conversation.settings.autoSummarize && 
          conversation.messages.length % 20 === 0) {
        try {
          await MemoryService.generateConversationSummary(conversationId);
        } catch (summaryError) {
          console.warn('Auto-summarization failed:', summaryError);
        }
      }

      return message;

    } catch (error) {
      console.error('Add message error:', error);
      throw error;
    }
  }

  /**
   * Update conversation metadata
   */
  static async updateConversation(conversationId, userId, updates) {
    try {
      const allowedUpdates = [
        'title', 'description', 'category', 'tags', 'pinned', 'starred', 'settings'
      ];
      
      const filteredUpdates = {};
      Object.keys(updates).forEach(key => {
        if (allowedUpdates.includes(key)) {
          filteredUpdates[key] = updates[key];
        }
      });

      const conversation = await Conversation.findOneAndUpdate(
        { _id: conversationId, userId },
        { $set: filteredUpdates },
        { new: true, runValidators: true }
      );

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      return conversation;

    } catch (error) {
      console.error('Update conversation error:', error);
      throw error;
    }
  }

  /**
   * Delete or archive a conversation
   */
  static async deleteConversation(conversationId, userId, permanent = false) {
    try {
      const update = permanent ? 
        { status: 'deleted' } : 
        { status: 'archived' };

      const conversation = await Conversation.findOneAndUpdate(
        { _id: conversationId, userId },
        { $set: update },
        { new: true }
      );

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      return conversation;

    } catch (error) {
      console.error('Delete conversation error:', error);
      throw error;
    }
  }

  /**
   * Generate intelligent conversation title
   */
  static async generateConversationTitle(messages, context = {}) {
    try {
      if (!messages || messages.length === 0) {
        return 'New Conversation';
      }

      const recentMessages = messages.slice(0, 5); // First 5 messages
      const messageText = recentMessages
        .map(m => `${m.type}: ${m.content}`)
        .join('\n');

      const systemPrompt = `Generate a concise, descriptive title for this conversation. The title should:
1. Be 3-6 words long
2. Capture the main topic or purpose
3. Be specific and actionable
4. Use professional language

Context: This is a career assistance conversation on page "${context.page || 'unknown'}"

Return only the title, nothing else.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: messageText }
        ],
        temperature: 0.5,
        max_tokens: 50
      });

      const title = response.choices[0].message.content.trim();
      return title || 'Career Assistance';

    } catch (error) {
      console.error('Generate conversation title error:', error);
      
      // Fallback titles based on context
      const fallbackTitles = {
        'resumes': 'Resume Assistance',
        'jobs': 'Job Search Help',
        'career': 'Career Guidance',
        'interview': 'Interview Preparation'
      };

      return fallbackTitles[context.page] || 'Career Assistance';
    }
  }

/**
   * Get conversation analytics
   */
  static async getConversationAnalytics(userId, timeframe = '30d') {
    try {
      const dateThreshold = new Date();
      if (timeframe === '7d') {
        dateThreshold.setDate(dateThreshold.getDate() - 7);
      } else if (timeframe === '30d') {
        dateThreshold.setDate(dateThreshold.getDate() - 30);
      } else if (timeframe === '90d') {
        dateThreshold.setDate(dateThreshold.getDate() - 90);
      }

      const analytics = await Conversation.aggregate([
        {
          $match: {
            userId: mongoose.Types.ObjectId(userId),
            status: { $ne: 'deleted' },
            createdAt: { $gte: dateThreshold }
          }
        },
        {
          $group: {
            _id: null,
            totalConversations: { $sum: 1 },
            totalMessages: { $sum: '$analytics.messageCount' },
            totalTokens: { $sum: '$analytics.tokensUsed' },
            avgEngagement: { $avg: '$analytics.engagementScore' },
            pinnedCount: {
              $sum: { $cond: [{ $eq: ['$pinned', true] }, 1, 0] }
            },
            starredCount: {
              $sum: { $cond: [{ $eq: ['$starred', true] }, 1, 0] }
            },
            categoryCounts: { $push: '$category' }
          }
        },
        {
          $project: {
            totalConversations: 1,
            totalMessages: 1,
            totalTokens: 1,
            avgEngagement: { $round: ['$avgEngagement', 1] },
            pinnedCount: 1,
            starredCount: 1,
            categoryCounts: 1
          }
        }
      ]);

      const result = analytics[0] || {
        totalConversations: 0,
        totalMessages: 0,
        totalTokens: 0,
        avgEngagement: 0,
        pinnedCount: 0,
        starredCount: 0,
        categoryCounts: []
      };

      // Calculate category distribution
      const categoryDistribution = result.categoryCounts.reduce((acc, category) => {
        acc[category] = (acc[category] || 0) + 1;
        return acc;
      }, {});

      // Get most active conversations
      const mostActiveConversations = await Conversation.find({
        userId,
        status: { $ne: 'deleted' },
        createdAt: { $gte: dateThreshold }
      })
      .sort({ 'analytics.messageCount': -1 })
      .limit(5)
      .select('title analytics.messageCount analytics.engagementScore lastActiveAt')
      .lean();

      return {
        ...result,
        categoryDistribution,
        mostActiveConversations,
        timeframe
      };

    } catch (error) {
      console.error('Get conversation analytics error:', error);
      throw error;
    }
  }

  /**
   * Search across all user conversations
   */
  static async searchAllConversations(userId, query, options = {}) {
    try {
      const {
        limit = 20,
        includeMessages = false,
        categories = [],
        dateRange = null
      } = options;

      let matchQuery = {
        userId,
        status: { $ne: 'deleted' },
        $text: { $search: query }
      };

      if (categories.length > 0) {
        matchQuery.category = { $in: categories };
      }

      if (dateRange) {
        matchQuery.createdAt = {
          $gte: new Date(dateRange.from),
          $lte: new Date(dateRange.to)
        };
      }

      const pipeline = [
        { $match: matchQuery },
        { $addFields: { score: { $meta: 'textScore' } } },
        { $sort: { score: { $meta: 'textScore' }, lastActiveAt: -1 } },
        { $limit: limit }
      ];

      if (!includeMessages) {
        pipeline.push({
          $project: {
            messages: 0
          }
        });
      }

      const results = await Conversation.aggregate(pipeline);

      // Highlight matching content
      const enrichedResults = await Promise.all(
        results.map(async (conv) => {
          const highlights = await this.findQueryHighlights(conv, query);
          return {
            ...conv,
            highlights,
            preview: this.generateSearchPreview(conv, query)
          };
        })
      );

      return enrichedResults;

    } catch (error) {
      console.error('Search all conversations error:', error);
      throw error;
    }
  }

  /**
   * Get conversation insights using AI
   */
  static async getConversationInsights(conversationId) {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) {
        throw new Error('Conversation not found');
      }

      const messages = conversation.messages.slice(-30); // Last 30 messages
      const messageText = messages
        .map(m => `${m.type.toUpperCase()}: ${m.content}`)
        .join('\n');

      const systemPrompt = `Analyze this conversation and provide insights about:
1. User's communication patterns
2. Progress made toward their goals
3. Areas where they need more help
4. Suggestions for improvement
5. Key topics and themes

Format as JSON:
{
  "communicationPatterns": ["pattern1", "pattern2"],
  "progressMade": ["achievement1", "achievement2"],
  "areasNeedingHelp": ["area1", "area2"],
  "suggestions": ["suggestion1", "suggestion2"],
  "keyThemes": ["theme1", "theme2"],
  "sentiment": "positive|neutral|negative",
  "engagementLevel": "high|medium|low",
  "nextSteps": ["step1", "step2"]
}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: messageText }
        ],
        temperature: 0.3,
        max_tokens: 800,
        response_format: { type: 'json_object' }
      });

      const insights = JSON.parse(response.choices[0].message.content);

      // Store insights in conversation
      conversation.analytics.insights = {
        ...insights,
        generatedAt: new Date()
      };

      await conversation.save();

      return insights;

    } catch (error) {
      console.error('Get conversation insights error:', error);
      throw error;
    }
  }

  /**
   * Export conversation data
   */
  static async exportConversation(conversationId, userId, format = 'json') {
    try {
      const conversation = await Conversation.findOne({
        _id: conversationId,
        userId,
        status: { $ne: 'deleted' }
      })
      .populate('context.primaryResumeId', 'name')
      .populate('context.relatedJobIds', 'title company')
      .lean();

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      if (format === 'json') {
        return {
          conversation: conversation,
          exportedAt: new Date(),
          format: 'json'
        };
      }

      if (format === 'markdown') {
        return this.convertToMarkdown(conversation);
      }

      if (format === 'txt') {
        return this.convertToPlainText(conversation);
      }

      throw new Error('Unsupported export format');

    } catch (error) {
      console.error('Export conversation error:', error);
      throw error;
    }
  }

  /**
   * Bulk operations on conversations
   */
  static async bulkUpdateConversations(userId, conversationIds, updates) {
    try {
      const allowedUpdates = ['category', 'tags', 'pinned', 'starred', 'status'];
      const filteredUpdates = {};

      Object.keys(updates).forEach(key => {
        if (allowedUpdates.includes(key)) {
          filteredUpdates[key] = updates[key];
        }
      });

      const result = await Conversation.updateMany(
        {
          _id: { $in: conversationIds },
          userId,
          status: { $ne: 'deleted' }
        },
        { $set: filteredUpdates }
      );

      return {
        modifiedCount: result.modifiedCount,
        matchedCount: result.matchedCount
      };

    } catch (error) {
      console.error('Bulk update conversations error:', error);
      throw error;
    }
  }

  // ===================================================================
  // PRIVATE HELPER METHODS
  // ===================================================================

  /**
   * Calculate unread count for a conversation
   */
  static calculateUnreadCount(messages) {
    if (!messages || messages.length === 0) return 0;

    // Simple implementation - in real app, track read status
    const lastMessage = messages[messages.length - 1];
    return lastMessage && lastMessage.type === 'ai' ? 1 : 0;
  }

  /**
   * Generate conversation preview
   */
  static generatePreview(conversation) {
    if (conversation.summary && conversation.summary.content) {
      return conversation.summary.content.substring(0, 100) + '...';
    }

    if (conversation.messages && conversation.messages.length > 0) {
      const lastMessage = conversation.messages[conversation.messages.length - 1];
      return lastMessage.content.substring(0, 100) + '...';
    }

    return conversation.description || 'No content yet';
  }

  /**
   * Find query highlights in conversation content
   */
  static async findQueryHighlights(conversation, query) {
    const highlights = [];
    const queryLower = query.toLowerCase();

    // Check title
    if (conversation.title.toLowerCase().includes(queryLower)) {
      highlights.push({
        type: 'title',
        text: conversation.title,
        position: conversation.title.toLowerCase().indexOf(queryLower)
      });
    }

    // Check summary
    if (conversation.summary && conversation.summary.content) {
      const summaryLower = conversation.summary.content.toLowerCase();
      if (summaryLower.includes(queryLower)) {
        const position = summaryLower.indexOf(queryLower);
        const start = Math.max(0, position - 50);
        const end = Math.min(conversation.summary.content.length, position + 100);
        
        highlights.push({
          type: 'summary',
          text: conversation.summary.content.substring(start, end),
          position: position
        });
      }
    }

    // Check recent messages
    if (conversation.messages) {
      conversation.messages.slice(-10).forEach((message, index) => {
        const contentLower = message.content.toLowerCase();
        if (contentLower.includes(queryLower)) {
          const position = contentLower.indexOf(queryLower);
          const start = Math.max(0, position - 30);
          const end = Math.min(message.content.length, position + 70);
          
          highlights.push({
            type: 'message',
            text: message.content.substring(start, end),
            messageType: message.type,
            position: position,
            messageIndex: index
          });
        }
      });
    }

    return highlights.slice(0, 3); // Limit to 3 highlights
  }

  /**
   * Generate search preview with highlighted terms
   */
  static generateSearchPreview(conversation, query) {
    const queryLower = query.toLowerCase();
    
    // Try summary first
    if (conversation.summary && conversation.summary.content) {
      const content = conversation.summary.content;
      const contentLower = content.toLowerCase();
      
      if (contentLower.includes(queryLower)) {
        const position = contentLower.indexOf(queryLower);
        const start = Math.max(0, position - 50);
        const end = Math.min(content.length, position + 100);
        
        return content.substring(start, end) + (end < content.length ? '...' : '');
      }
    }

    // Try last message
    if (conversation.messages && conversation.messages.length > 0) {
      const lastMessage = conversation.messages[conversation.messages.length - 1];
      const content = lastMessage.content;
      const contentLower = content.toLowerCase();
      
      if (contentLower.includes(queryLower)) {
        const position = contentLower.indexOf(queryLower);
        const start = Math.max(0, position - 50);
        const end = Math.min(content.length, position + 100);
        
        return content.substring(start, end) + (end < content.length ? '...' : '');
      }
      
      // Fallback to beginning of last message
      return content.substring(0, 100) + (content.length > 100 ? '...' : '');
    }

    return conversation.description || 'No preview available';
  }

  /**
   * Convert conversation to Markdown format
   */
  static convertToMarkdown(conversation) {
    let markdown = `# ${conversation.title}\n\n`;
    
    if (conversation.description) {
      markdown += `**Description:** ${conversation.description}\n\n`;
    }

    markdown += `**Created:** ${conversation.createdAt.toISOString()}\n`;
    markdown += `**Category:** ${conversation.category}\n`;
    
    if (conversation.tags && conversation.tags.length > 0) {
      markdown += `**Tags:** ${conversation.tags.join(', ')}\n`;
    }

    markdown += `\n---\n\n`;

    if (conversation.summary && conversation.summary.content) {
      markdown += `## Summary\n\n${conversation.summary.content}\n\n`;
      
      if (conversation.summary.keyTopics && conversation.summary.keyTopics.length > 0) {
        markdown += `**Key Topics:** ${conversation.summary.keyTopics.join(', ')}\n\n`;
      }
      
      markdown += `---\n\n`;
    }

    markdown += `## Messages\n\n`;

    if (conversation.messages && conversation.messages.length > 0) {
      conversation.messages.forEach((message, index) => {
        const timestamp = message.createdAt ? 
          new Date(message.createdAt).toLocaleString() : 
          'Unknown time';
        
        markdown += `### ${message.type.toUpperCase()} (${timestamp})\n\n`;
        markdown += `${message.content}\n\n`;
        
        if (message.metadata && message.metadata.suggestions && message.metadata.suggestions.length > 0) {
          markdown += `**Suggestions:** ${message.metadata.suggestions.join(', ')}\n\n`;
        }
        
        markdown += `---\n\n`;
      });
    }

    return {
      content: markdown,
      filename: `conversation_${conversation._id}.md`,
      exportedAt: new Date(),
      format: 'markdown'
    };
  }

  /**
   * Convert conversation to plain text format
   */
  static convertToPlainText(conversation) {
    let text = `${conversation.title}\n${'='.repeat(conversation.title.length)}\n\n`;
    
    if (conversation.description) {
      text += `Description: ${conversation.description}\n\n`;
    }

    text += `Created: ${conversation.createdAt.toISOString()}\n`;
    text += `Category: ${conversation.category}\n`;
    
    if (conversation.tags && conversation.tags.length > 0) {
      text += `Tags: ${conversation.tags.join(', ')}\n`;
    }

    text += `\n${'-'.repeat(50)}\n\n`;

    if (conversation.summary && conversation.summary.content) {
      text += `SUMMARY\n${conversation.summary.content}\n\n`;
      
      if (conversation.summary.keyTopics && conversation.summary.keyTopics.length > 0) {
        text += `Key Topics: ${conversation.summary.keyTopics.join(', ')}\n\n`;
      }
      
      text += `${'-'.repeat(50)}\n\n`;
    }

    text += `MESSAGES\n\n`;

    if (conversation.messages && conversation.messages.length > 0) {
      conversation.messages.forEach((message, index) => {
        const timestamp = message.createdAt ? 
          new Date(message.createdAt).toLocaleString() : 
          'Unknown time';
        
        text += `[${message.type.toUpperCase()}] ${timestamp}\n`;
        text += `${message.content}\n`;
        
        if (message.metadata && message.metadata.suggestions && message.metadata.suggestions.length > 0) {
          text += `Suggestions: ${message.metadata.suggestions.join(', ')}\n`;
        }
        
        text += `\n${'-'.repeat(30)}\n\n`;
      });
    }

    return {
      content: text,
      filename: `conversation_${conversation._id}.txt`,
      exportedAt: new Date(),
      format: 'text'
    };
  }
}

module.exports = ConversationService;

================
File: services/jobAnalysis.service.js
================
// services/jobAnalysis.service.js - HYBRID APPROACH WITH BATCH ANALYSIS
const { openai } = require('../config/openai');

/**
 * Enhanced job analysis with hybrid model selection + NEW BATCH ANALYSIS
 * - GPT-4o for manual jobs (quality-critical, low volume)
 * - GPT-4o for AI discovery (now same quality as manual!)
 * - Batch processing for efficiency
 * 
 * @param {string} jobDescription - Raw job description text
 * @param {Object} jobMetadata - Additional job metadata (title, company, etc.)
 * @param {Object} options - Analysis options
 * @param {boolean} options.isAiDiscovery - Whether this is from AI discovery (now uses GPT-4o!)
 * @param {boolean} options.prioritizeCost - Force use of Mini model (deprecated)
 * @returns {Object} Parsed job data with detailed analysis
 */
exports.analyzeJob = async (jobDescription, jobMetadata = {}, options = {}) => {
  try {
    // NEW: Use GPT-4o for both manual and AI discovery for consistent quality
    const model = "gpt-4o";
    const maxTokens = 3500;
    
    console.log(`Starting premium job analysis with ${model} (same quality for all jobs)...`);
    
    if (!jobDescription || jobDescription.trim().length < 50) {
      throw new Error('Job description is too short for meaningful analysis');
    }

    const prompt = createPromptForModel(jobDescription, jobMetadata, false); // Always use premium prompt

    // Call OpenAI API with GPT-4o
    const response = await openai.chat.completions.create({
      model: model,
      messages: [
        {
          role: "system",
          content: createSystemPromptForModel(false) // Always use premium system prompt
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Low for consistent extraction
      max_tokens: maxTokens,
    });

    const content = response.choices[0].message.content.trim();
    console.log(`Job analysis response received from ${model}, parsing...`);

    let parsedData;
    try {
      // Clean up the response to extract JSON
      let jsonStr = content;
      
      // Remove any markdown code blocks
      if (content.includes('```')) {
        const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          jsonStr = jsonMatch[1];
        }
      }
      
      // Clean up and ensure valid JSON structure
      jsonStr = jsonStr.trim();
      if (!jsonStr.startsWith('{')) {
        const startIndex = jsonStr.indexOf('{');
        if (startIndex !== -1) {
          jsonStr = jsonStr.substring(startIndex);
        }
      }
      if (!jsonStr.endsWith('}')) {
        const endIndex = jsonStr.lastIndexOf('}');
        if (endIndex !== -1) {
          jsonStr = jsonStr.substring(0, endIndex + 1);
        }
      }

      parsedData = JSON.parse(jsonStr);
      
      // Validate and enhance the parsed data
      parsedData = validateAndEnhanceJobData(parsedData, jobDescription, false); // Always use premium validation
      
      console.log(`Job analysis completed successfully with ${model}. Found ${parsedData.keySkills?.length || 0} skills.`);
      
    } catch (parseError) {
      console.error(`Error parsing job analysis response from ${model}:`, parseError);
      console.log('Raw response:', content);
      throw new Error(`Failed to parse job analysis response from ${model}`);
    }

    // Add analysis metadata
    parsedData.analysisMetadata = {
      analyzedAt: new Date(),
      algorithmVersion: options.isAiDiscovery ? '3.0-ai-discovery-premium' : '3.0-manual-premium',
      model: model,
      originalLength: jobDescription.length,
      extractedSkillsCount: parsedData.keySkills?.length || 0,
      costOptimized: false, // Now using premium for all
      analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium',
      estimatedCost: '$0.01-0.02',
      qualityLevel: 'premium'
    };

    return parsedData;

  } catch (error) {
    console.error('Error in premium job analysis:', error);
    
    // Intelligent fallback analysis
    return generateJobAnalysisFallback(jobDescription, jobMetadata, error, options);
  }
};

/**
 * NEW: Batch job analysis for AI discovery efficiency
 * Analyzes multiple jobs in a single API call for cost efficiency
 * 
 * @param {Array} jobBatch - Array of job objects with title, company, fullContent
 * @returns {Array} Array of analysis results matching input order
 */
exports.analyzeBatchJobs = async (jobBatch) => {
  try {
    console.log(`🔬 Starting batch analysis of ${jobBatch.length} jobs with GPT-4o...`);
    
    if (!jobBatch || jobBatch.length === 0) {
      return [];
    }
    
    // Limit batch size to prevent token overflow
    const maxBatchSize = 3;
    if (jobBatch.length > maxBatchSize) {
      console.log(`Batch size ${jobBatch.length} exceeds maximum ${maxBatchSize}, processing in chunks...`);
      
      const results = [];
      for (let i = 0; i < jobBatch.length; i += maxBatchSize) {
        const chunk = jobBatch.slice(i, i + maxBatchSize);
        const chunkResults = await this.analyzeBatchJobs(chunk);
        results.push(...chunkResults);
      }
      return results;
    }
    
    // Prepare batch content for analysis
    const batchContent = jobBatch.map((job, index) => 
      `JOB ${index + 1}:
Title: ${job.title}
Company: ${job.company}
Location: ${job.location || 'Not specified'}
Content: ${(job.fullContent || job.description || '').substring(0, 2500)}
---`
    ).join('\n\n');
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert job analyst providing premium batch analysis. Analyze multiple job postings and return detailed structured data for each. Focus on extracting comprehensive requirements, responsibilities, and skills with high accuracy. Return valid JSON array with exactly ${jobBatch.length} objects.`
        },
        {
          role: "user",
          content: `Analyze these ${jobBatch.length} job postings and return detailed analysis for each:

${batchContent}

Return JSON array with exactly ${jobBatch.length} objects in this EXACT format:
[
  {
    "requirements": ["Specific requirement 1", "Specific requirement 2"],
    "responsibilities": ["Key responsibility 1", "Key responsibility 2"],
    "qualifications": {
      "required": ["Must-have qualification 1", "Must-have qualification 2"],
      "preferred": ["Nice-to-have qualification 1", "Nice-to-have qualification 2"]
    },
    "keySkills": [
      {
        "name": "Python",
        "importance": 9,
        "category": "technical",
        "skillType": "programming"
      },
      {
        "name": "Leadership",
        "importance": 7,
        "category": "soft",
        "skillType": "management"
      }
    ],
    "experienceLevel": "mid/senior/lead",
    "yearsOfExperience": {
      "minimum": 3,
      "preferred": 5
    },
    "educationRequirements": ["Bachelor's degree in relevant field"],
    "benefits": ["Health insurance", "401k", "Remote work"],
    "salary": {
      "min": 120000,
      "max": 150000,
      "currency": "USD"
    },
    "workArrangement": "remote/hybrid/onsite",
    "industryContext": "technology/finance/healthcare",
    "roleCategory": "software-engineering/product-management",
    "technicalComplexity": "high/medium/low",
    "leadershipRequired": true/false,
    "companyStage": "startup/growth/enterprise"
  }
]

CRITICAL REQUIREMENTS:
- Skills importance: 9-10=critical, 7-8=very important, 5-6=important, 3-4=nice to have
- Extract comprehensive information from each job posting
- Maintain high accuracy and detail level
- Return exactly ${jobBatch.length} analysis objects in the same order
- Each analysis must be complete and detailed`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    let jsonStr = content;
    
    // Clean JSON extraction
    if (content.includes('```')) {
      const jsonMatch = content.match(/```(?:json)?\s*(\[[\s\S]*?\])\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    const analyses = JSON.parse(jsonStr);
    
    // Ensure we have the right number of analyses
    if (!Array.isArray(analyses)) {
      throw new Error('Response is not an array');
    }
    
    if (analyses.length !== jobBatch.length) {
      console.warn(`Expected ${jobBatch.length} analyses, got ${analyses.length}. Padding or trimming...`);
      
      // Pad with fallback analyses if too few
      while (analyses.length < jobBatch.length) {
        analyses.push(createFallbackSingleAnalysis());
      }
      
      // Trim if too many
      if (analyses.length > jobBatch.length) {
        analyses.splice(jobBatch.length);
      }
    }
    
    // Enhance analyses with metadata
    const enhancedAnalyses = analyses.map((analysis, index) => ({
      ...analysis,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-batch-premium',
        model: 'gpt-4o',
        analysisType: 'ai_discovery_batch_premium',
        qualityLevel: 'premium',
        batchIndex: index,
        batchSize: jobBatch.length
      }
    }));
    
    console.log(`✅ Batch analysis completed: ${enhancedAnalyses.length} jobs analyzed with GPT-4o`);
    return enhancedAnalyses;
    
  } catch (error) {
    console.error('Error in batch job analysis:', error);
    
    // Return fallback analyses for all jobs in batch
    return jobBatch.map((job, index) => ({
      ...createFallbackSingleAnalysis(),
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-batch-fallback',
        model: 'gpt-4o-fallback',
        analysisType: 'ai_discovery_batch_fallback',
        error: error.message,
        batchIndex: index,
        batchSize: jobBatch.length
      }
    }));
  }
};

/**
 * Content analysis with premium quality
 * @param {string} jobContent - Raw job content from URL
 * @param {Object} jobInfo - Job metadata
 * @param {boolean} isAiDiscovery - Whether this is from AI discovery (now uses GPT-4o regardless)
 * @returns {Object} Analyzed job content
 */
exports.analyzeJobContent = async (jobContent, jobInfo, isAiDiscovery = false) => {
  if (!jobContent) return null;
  
  try {
    // NEW: Always use GPT-4o for consistent premium quality
    const model = "gpt-4o";
    const maxTokens = 2000;
    
    console.log(`🤖 Analyzing job content with premium ${model}: "${jobInfo.title}"`);
    
    // Create optimized prompt
    const prompt = createContentAnalysisPrompt(jobContent, jobInfo, false); // Always use premium prompt

    const response = await openai.chat.completions.create({
      model: model,
      messages: [
        {
          role: "system",
          content: "You are an expert job analyst. Extract comprehensive job data and return valid JSON only."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0,
      max_tokens: maxTokens
    });

    const analysisText = response.choices[0].message.content.trim();
    let jsonStr = analysisText;
    
    // Clean JSON extraction
    if (analysisText.includes('```')) {
      const jsonMatch = analysisText.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    const analysis = JSON.parse(jsonStr);
    
    // Validate work arrangement
    if (analysis.workArrangement) {
      analysis.workArrangement = normalizeWorkArrangement(analysis.workArrangement);
    }
    
    // Add metadata
    analysis.analysisMetadata = {
      model: model,
      analysisType: isAiDiscovery ? 'ai_discovery_content_premium' : 'manual_content_premium',
      qualityLevel: 'premium',
      analyzedAt: new Date()
    };
    
    console.log(`✅ Premium content analysis completed with ${model} for "${jobInfo.title}"`);
    return analysis;
    
  } catch (error) {
    console.error(`Error analyzing job content with premium approach:`, error);
    return generateBasicContentAnalysis(jobContent, jobInfo, isAiDiscovery);
  }
};

/**
 * Create model-specific prompts (now always premium)
 */
function createPromptForModel(jobDescription, jobMetadata, useMinimModel) {
  // Always use comprehensive prompt for premium quality
  const contentLength = 4000;
  const truncatedDescription = jobDescription.length > contentLength ? 
    jobDescription.substring(0, contentLength) + '...' : jobDescription;

  return `
    Analyze this job posting and extract detailed information. Be thorough and accurate in your analysis.

    **JOB POSTING:**
    ${truncatedDescription}

    **ADDITIONAL CONTEXT:**
    ${jobMetadata.title ? `Title: ${jobMetadata.title}` : ''}
    ${jobMetadata.company ? `Company: ${jobMetadata.company}` : ''}
    ${jobMetadata.location ? `Location: ${JSON.stringify(jobMetadata.location)}` : ''}

    Extract and categorize information into this EXACT JSON structure:

    {
      "requirements": [
        "specific requirement 1",
        "specific requirement 2"
      ],
      "responsibilities": [
        "key responsibility 1",
        "key responsibility 2"
      ],
      "qualifications": {
        "required": [
          "must-have qualification 1",
          "must-have qualification 2"
        ],
        "preferred": [
          "nice-to-have qualification 1",
          "nice-to-have qualification 2"
        ]
      },
      "keySkills": [
        {
          "name": "Python",
          "importance": 9,
          "category": "technical",
          "skillType": "programming"
        },
        {
          "name": "Project Management",
          "importance": 7,
          "category": "soft",
          "skillType": "management"
        }
      ],
      "experienceLevel": "mid-senior",
      "yearsOfExperience": {
        "minimum": 3,
        "preferred": 5
      },
      "educationRequirements": [
        "Bachelor's degree in Computer Science or related field",
        "Master's degree preferred"
      ],
      "benefits": [
        "Health insurance",
        "401k matching",
        "Remote work options"
      ],
      "industryContext": "technology",
      "roleCategory": "product-management",
      "seniorityLevel": "mid",
      "technicalComplexity": "high",
      "leadershipRequired": true,
      "certifications": [
        "PMP certification preferred",
        "Agile certification a plus"
      ],
      "softSkills": [
        "Communication",
        "Leadership",
        "Problem-solving"
      ],
      "technicalSkills": [
        "SQL",
        "Python",
        "Data Analysis"
      ],
      "toolsAndTechnologies": [
        "Jira",
        "Confluence",
        "Tableau"
      ],
      "companySize": "medium",
      "workArrangement": "hybrid"
    }

    **EXTRACTION GUIDELINES:**

    1. **Skills Importance Scale (1-10):**
       - 9-10: Critical/Must-have (mentioned multiple times, essential)
       - 7-8: Very Important (clearly stated as required)
       - 5-6: Important (mentioned in requirements)
       - 3-4: Nice to have (preferred qualifications)
       - 1-2: Bonus (mentioned casually)

    2. **Experience Level Mapping:**
       - "entry": 0-2 years
       - "junior": 1-3 years
       - "mid": 3-6 years
       - "senior": 5-10 years
       - "lead": 7-12 years
       - "principal": 10+ years
       - "executive": 12+ years

    3. **Work Arrangement (use exact values):**
       - "remote": Fully remote work
       - "hybrid": Mix of remote and office work
       - "onsite": Must work from office/physical location
       - "unknown": Work arrangement not specified

    **IMPORTANT:** Extract only information explicitly mentioned in the job posting. Don't infer or add generic requirements.

    Return ONLY the JSON object without any markdown formatting or explanations.
    `;
}

/**
 * Create model-specific system prompts (now always premium)
 */
function createSystemPromptForModel(useMinimModel) {
  return "You are an expert HR technology analyst specializing in job posting analysis. You extract precise, detailed information from job descriptions without adding assumptions. You return only valid JSON without markdown formatting. For workArrangement field, use ONLY these exact values: 'remote', 'hybrid', 'onsite', or 'unknown'.";
}

/**
 * Create content analysis prompt (now always premium)
 */
function createContentAnalysisPrompt(jobContent, jobInfo, isAiDiscovery) {
  const contentLength = 3000;
  const truncatedContent = jobContent.length > contentLength ? 
    jobContent.substring(0, contentLength) + '...' : jobContent;

  return `
    Analyze this job content and extract structured data:

    Job: ${jobInfo.title} at ${jobInfo.company}
    Content: ${truncatedContent}

    Return JSON:
    {
      "requirements": ["Required skill 1", "Required skill 2"],
      "responsibilities": ["Responsibility 1", "Responsibility 2"],
      "qualifications": {
        "required": ["Must have 1", "Must have 2"],
        "preferred": ["Nice to have 1", "Nice to have 2"]
      },
      "salary": {
        "min": 120000,
        "max": 150000,
        "currency": "USD"
      },
      "benefits": ["Benefit 1", "Benefit 2"],
      "jobType": "FULL_TIME",
      "experienceLevel": "mid/senior/lead",
      "workArrangement": "remote/hybrid/onsite/unknown"
    }

    Extract comprehensive information. Be thorough with requirements and qualifications.
    `;
}

/**
 * Enhanced validation for premium quality
 */
function validateAndEnhanceJobData(parsedData, originalDescription, useMinimModel) {
  // Ensure required fields exist
  if (!parsedData.requirements) parsedData.requirements = [];
  if (!parsedData.responsibilities) parsedData.responsibilities = [];
  if (!parsedData.qualifications) {
    parsedData.qualifications = { required: [], preferred: [] };
  }
  if (!parsedData.keySkills) parsedData.keySkills = [];
  if (!parsedData.benefits) parsedData.benefits = [];
  if (!parsedData.educationRequirements) parsedData.educationRequirements = [];

  // Validate and normalize skill importance scores
  if (parsedData.keySkills && Array.isArray(parsedData.keySkills)) {
    parsedData.keySkills = parsedData.keySkills.map(skill => {
      if (typeof skill === 'string') {
        return {
          name: skill,
          importance: 5,
          category: 'technical',
          skillType: 'general'
        };
      }
      
      // Validate importance score
      if (!skill.importance || skill.importance < 1 || skill.importance > 10) {
        skill.importance = 5;
      }
      
      // Ensure required fields
      if (!skill.category) skill.category = 'technical';
      if (!skill.skillType) skill.skillType = 'general';
      
      return skill;
    });
  }

  // Enhanced skill extraction (now always comprehensive)
  const skillLimit = 15; // Increased for premium quality
  const additionalSkills = extractSkillsFromText(originalDescription);
  const existingSkillNames = parsedData.keySkills.map(s => s.name.toLowerCase());
  
  additionalSkills.slice(0, skillLimit).forEach(skill => {
    if (!existingSkillNames.includes(skill.toLowerCase())) {
      parsedData.keySkills.push({
        name: skill,
        importance: 4,
        category: 'technical',
        skillType: 'extracted'
      });
    }
  });

  // Apply standard validations
  const validExperienceLevels = ['entry', 'junior', 'mid', 'senior', 'lead', 'principal', 'executive'];
  if (!parsedData.experienceLevel || !validExperienceLevels.includes(parsedData.experienceLevel)) {
    parsedData.experienceLevel = inferExperienceLevel(originalDescription);
  }

  if (!parsedData.yearsOfExperience) {
    parsedData.yearsOfExperience = inferYearsOfExperience(originalDescription, parsedData.experienceLevel);
  }

  if (!parsedData.industryContext) {
    parsedData.industryContext = inferIndustryContext(originalDescription);
  }

  if (!parsedData.roleCategory) {
    parsedData.roleCategory = inferRoleCategory(originalDescription, parsedData.keySkills);
  }

  // Normalize workArrangement
  if (parsedData.workArrangement) {
    parsedData.workArrangement = normalizeWorkArrangement(parsedData.workArrangement);
  } else {
    parsedData.workArrangement = inferWorkArrangement(originalDescription);
  }

  return parsedData;
}

/**
 * Create fallback single analysis for batch processing
 */
function createFallbackSingleAnalysis() {
  return {
    requirements: ['Relevant experience in the field'],
    responsibilities: ['Perform assigned duties effectively'],
    qualifications: {
      required: ['Relevant education or experience'],
      preferred: ['Additional qualifications preferred']
    },
    keySkills: [
      {
        name: 'Communication',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      },
      {
        name: 'Problem Solving',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      }
    ],
    experienceLevel: 'mid',
    yearsOfExperience: { minimum: 3, preferred: 5 },
    educationRequirements: ['Bachelor\'s degree preferred'],
    benefits: ['Competitive benefits package'],
    workArrangement: 'unknown',
    industryContext: 'general',
    roleCategory: 'general',
    technicalComplexity: 'medium',
    leadershipRequired: false,
    companyStage: 'unknown'
  };
}

/**
 * Generate fallback analysis with premium approach awareness
 */
function generateJobAnalysisFallback(jobDescription, jobMetadata, error, options = {}) {
  console.log('Generating premium fallback job analysis...');
  
  try {
    const extractedSkills = extractSkillsFromText(jobDescription);
    const experienceLevel = inferExperienceLevel(jobDescription);
    const workArrangement = inferWorkArrangement(jobDescription);
    
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      keySkills: extractedSkills.map(skill => ({
        name: skill,
        importance: 5,
        category: 'technical',
        skillType: 'extracted'
      })),
      experienceLevel,
      yearsOfExperience: inferYearsOfExperience(jobDescription, experienceLevel),
      educationRequirements: [],
      benefits: [],
      industryContext: inferIndustryContext(jobDescription),
      roleCategory: inferRoleCategory(jobDescription, extractedSkills),
      seniorityLevel: experienceLevel,
      technicalComplexity: 'medium',
      leadershipRequired: jobDescription.toLowerCase().includes('lead'),
      certifications: [],
      softSkills: ['Communication', 'Problem-solving'],
      technicalSkills: extractedSkills,
      toolsAndTechnologies: [],
      companySize: 'unknown',
      workArrangement: workArrangement,
      fallbackReason: error.message,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-premium-fallback',
        model: 'gpt-4o-fallback',
        originalLength: jobDescription.length,
        extractedSkillsCount: extractedSkills.length,
        fallback: true,
        analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium'
      }
    };
    
  } catch (fallbackError) {
    console.error('Error in premium fallback analysis:', fallbackError);
    
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      keySkills: [],
      experienceLevel: 'mid',
      yearsOfExperience: { minimum: 3, preferred: 5 },
      educationRequirements: [],
      benefits: [],
      industryContext: 'general',
      roleCategory: 'general',
      workArrangement: 'unknown',
      errorDetails: error.message,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-premium-error',
        model: 'error-fallback-premium',
        originalLength: jobDescription.length,
        error: true,
        analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium'
      }
    };
  }
}

/**
 * Generate basic content analysis with premium awareness
 */
function generateBasicContentAnalysis(jobContent, jobInfo, isAiDiscovery = false) {
  console.log('Generating premium content analysis fallback...');
  
  try {
    const lowerContent = jobContent.toLowerCase();
    
    // Basic salary extraction
    const salaryMatch = jobContent.match(/\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*-?\s*\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)?/);
    let salary = {};
    if (salaryMatch) {
      salary.min = parseInt(salaryMatch[1].replace(/,/g, ''));
      if (salaryMatch[2]) {
        salary.max = parseInt(salaryMatch[2].replace(/,/g, ''));
      }
      salary.currency = 'USD';
    }
    
    // Basic work arrangement detection
    let workArrangement = 'unknown';
    if (lowerContent.includes('remote')) {
      workArrangement = lowerContent.includes('hybrid') ? 'hybrid' : 'remote';
    } else if (lowerContent.includes('onsite') || lowerContent.includes('on-site')) {
      workArrangement = 'onsite';
    }
    
    return {
      requirements: ['Experience in relevant field'],
      responsibilities: ['Perform job duties as assigned'],
      qualifications: {
        required: ['Relevant experience'],
        preferred: []
      },
      salary: Object.keys(salary).length > 0 ? salary : null,
      benefits: [],
      jobType: 'FULL_TIME',
      experienceLevel: 'mid',
      workArrangement: workArrangement,
      fallbackReason: 'Premium model analysis failed',
      analysisMetadata: {
        model: 'gpt-4o-basic-fallback',
        analysisType: isAiDiscovery ? 'ai_discovery_premium' : 'manual_content_premium',
        qualityLevel: 'basic_fallback'
      }
    };
    
  } catch (error) {
    console.error('Error in basic premium content analysis:', error);
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      salary: null,
      benefits: [],
      jobType: 'FULL_TIME',
      experienceLevel: 'mid',
      workArrangement: 'unknown',
      error: true,
      analysisMetadata: {
        model: 'error-premium',
        analysisType: isAiDiscovery ? 'ai_discovery_premium' : 'manual_content_premium',
        qualityLevel: 'error_fallback'
      }
    };
  }
}

// Keep all existing helper functions unchanged
function normalizeWorkArrangement(workArrangement) {
  if (!workArrangement || typeof workArrangement !== 'string') {
    return 'unknown';
  }
  
  const normalized = workArrangement.toLowerCase().trim();
  
  const mappings = {
    'remote': 'remote',
    'fully remote': 'remote',
    'work from home': 'remote',
    'wfh': 'remote',
    '100% remote': 'remote',
    
    'hybrid': 'hybrid',
    'flex': 'hybrid',
    'flexible': 'hybrid',
    'mix': 'hybrid',
    'part remote': 'hybrid',
    'partial remote': 'hybrid',
    
    'onsite': 'onsite',
    'on-site': 'onsite',
    'on site': 'onsite',
    'office': 'onsite',
    'in-office': 'onsite',
    'in office': 'onsite',
    'on-premise': 'onsite',
    'on premise': 'onsite',
    'physical location': 'onsite',
    'in-person': 'onsite',
    'in person': 'onsite'
  };
  
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  
  for (const [key, value] of Object.entries(mappings)) {
    if (normalized.includes(key)) {
      return value;
    }
  }
  
  return 'unknown';
}

function extractSkillsFromText(description) {
  const commonSkills = [
    'JavaScript', 'Python', 'Java', 'C++', 'C#', 'PHP', 'Ruby', 'Go', 'Rust', 'Swift',
    'TypeScript', 'Kotlin', 'Scala', 'R', 'MATLAB', 'Perl', 'Shell', 'PowerShell',
    'React', 'Vue.js', 'Angular', 'Node.js', 'Express', 'Django', 'Flask', 'Spring',
    'Laravel', 'Rails', 'ASP.NET', 'HTML', 'CSS', 'SASS', 'LESS', 'Bootstrap',
    'SQL', 'MySQL', 'PostgreSQL', 'MongoDB', 'Redis', 'Elasticsearch', 'Oracle',
    'AWS', 'Azure', 'GCP', 'Docker', 'Kubernetes', 'Jenkins', 'GitLab CI', 'CircleCI',
    'Git', 'GitHub', 'GitLab', 'Bitbucket', 'Jira', 'Confluence', 'Slack',
    'Machine Learning', 'Data Analysis', 'Tableau', 'Power BI', 'Excel', 'Pandas',
    'Figma', 'Sketch', 'Adobe XD', 'Photoshop', 'Illustrator',
    'Agile', 'Scrum', 'Kanban', 'Waterfall', 'PMP', 'PRINCE2',
    'Project Management', 'Leadership', 'Communication', 'Problem Solving'
  ];
  
  const foundSkills = [];
  const lowerDescription = description.toLowerCase();
  
  commonSkills.forEach(skill => {
    const skillVariations = [
      skill.toLowerCase(),
      skill.toLowerCase().replace(/\./g, ''),
      skill.toLowerCase().replace(/\s+/g, ''),
      skill.toLowerCase().replace(/-/g, ''),
      skill.toLowerCase().replace(/\//g, ' ')
    ];
    
    if (skillVariations.some(variation => lowerDescription.includes(variation))) {
      foundSkills.push(skill);
    }
  });
  
  return foundSkills;
}

function inferExperienceLevel(description) {
  const lowerDesc = description.toLowerCase();
  
  if (lowerDesc.includes('entry level') || lowerDesc.includes('0-2 years') || 
      lowerDesc.includes('new grad') || lowerDesc.includes('graduate') ||
      lowerDesc.includes('junior developer') || lowerDesc.includes('associate')) {
    return 'entry';
  }
  
  if (lowerDesc.includes('junior') && !lowerDesc.includes('senior')) {
    return 'junior';
  }
  
  if (lowerDesc.includes('3-5 years') || lowerDesc.includes('mid level') ||
      lowerDesc.includes('3+ years') || lowerDesc.includes('4+ years')) {
    return 'mid';
  }
  
  if (lowerDesc.includes('senior') || lowerDesc.includes('5+ years') ||
      lowerDesc.includes('6+ years') || lowerDesc.includes('7+ years')) {
    return 'senior';
  }
  
  if (lowerDesc.includes('lead') || lowerDesc.includes('tech lead') ||
      lowerDesc.includes('team lead') || lowerDesc.includes('8+ years')) {
    return 'lead';
  }
  
  if (lowerDesc.includes('principal') || lowerDesc.includes('10+ years') ||
      lowerDesc.includes('architect') || lowerDesc.includes('staff')) {
    return 'principal';
  }
  
  if (lowerDesc.includes('director') || lowerDesc.includes('vp') ||
      lowerDesc.includes('executive') || lowerDesc.includes('15+ years') ||
      lowerDesc.includes('chief')) {
    return 'executive';
  }
  
  if (lowerDesc.includes('manage') || lowerDesc.includes('supervise') ||
      lowerDesc.includes('oversee')) {
    return 'senior';
  }
  
  return 'mid'; // Default fallback
}

function inferYearsOfExperience(description, experienceLevel) {
  // Try to extract explicit years mentioned
  const yearMatches = description.match(/(\d+)[\s\-\+]*years?/gi);
  if (yearMatches && yearMatches.length > 0) {
    const years = yearMatches.map(match => parseInt(match.match(/\d+/)[0]));
    const maxYears = Math.max(...years);
    const minYears = Math.min(...years);
    
    return {
      minimum: minYears,
      preferred: maxYears > minYears ? maxYears : minYears + 2
    };
  }
  
  // Fall back to level-based inference
  const levelMappings = {
    'entry': { minimum: 0, preferred: 2 },
    'junior': { minimum: 1, preferred: 3 },
    'mid': { minimum: 3, preferred: 5 },
    'senior': { minimum: 5, preferred: 8 },
    'lead': { minimum: 7, preferred: 10 },
    'principal': { minimum: 10, preferred: 15 },
    'executive': { minimum: 12, preferred: 20 }
  };
  
  return levelMappings[experienceLevel] || { minimum: 3, preferred: 5 };
}

function inferWorkArrangement(description) {
  const lowerDesc = description.toLowerCase();
  
  if (lowerDesc.includes('remote') || lowerDesc.includes('work from home') || 
      lowerDesc.includes('wfh') || lowerDesc.includes('telecommute') ||
      lowerDesc.includes('distributed team')) {
    
    if (lowerDesc.includes('office') || lowerDesc.includes('hybrid') || 
        lowerDesc.includes('flexible') || lowerDesc.includes('mix')) {
      return 'hybrid';
    }
    
    return 'remote';
  }
  
  if (lowerDesc.includes('hybrid') || lowerDesc.includes('flexible') || 
      lowerDesc.includes('mix of remote') || lowerDesc.includes('part remote')) {
    return 'hybrid';
  }
  
  if (lowerDesc.includes('on-site') || lowerDesc.includes('onsite') || 
      lowerDesc.includes('on site') || lowerDesc.includes('in office') ||
      lowerDesc.includes('office location') || lowerDesc.includes('headquarters') ||
      lowerDesc.includes('in-person') || lowerDesc.includes('physical presence')) {
    return 'onsite';
  }
  
  return 'unknown';
}

function inferIndustryContext(description) {
  const lowerDesc = description.toLowerCase();
  
  const industryKeywords = {
    'technology': ['software', 'tech', 'startup', 'saas', 'platform', 'api', 'cloud', 'digital'],
    'finance': ['financial', 'bank', 'investment', 'trading', 'fintech', 'insurance', 'credit'],
    'healthcare': ['health', 'medical', 'hospital', 'pharmaceutical', 'biotech', 'clinical'],
    'retail': ['retail', 'ecommerce', 'e-commerce', 'shopping', 'consumer', 'marketplace'],
    'education': ['education', 'university', 'school', 'learning', 'training', 'academic'],
    'manufacturing': ['manufacturing', 'production', 'factory', 'industrial', 'automotive'],
    'consulting': ['consulting', 'advisory', 'professional services', 'strategy'],
    'media': ['media', 'entertainment', 'publishing', 'content', 'journalism', 'broadcasting'],
    'government': ['government', 'public sector', 'federal', 'state', 'municipal'],
    'nonprofit': ['nonprofit', 'ngo', 'foundation', 'charity', 'social impact']
  };
  
  for (const [industry, keywords] of Object.entries(industryKeywords)) {
    if (keywords.some(keyword => lowerDesc.includes(keyword))) {
      return industry;
    }
  }
  
  return 'general';
}

function inferRoleCategory(description, skills) {
  const lowerDesc = description.toLowerCase();
  const skillNames = skills.map(s => s.name ? s.name.toLowerCase() : s.toLowerCase());
  
  // Direct role mentions
  if (lowerDesc.includes('software engineer') || lowerDesc.includes('developer') ||
      lowerDesc.includes('programmer')) {
    return 'software-engineering';
  }
  
  if (lowerDesc.includes('product manager') || lowerDesc.includes('product owner')) {
    return 'product-management';
  }
  
  if (lowerDesc.includes('data scientist') || lowerDesc.includes('data analyst') ||
      lowerDesc.includes('machine learning')) {
    return 'data-science';
  }
  
  if (lowerDesc.includes('designer') || lowerDesc.includes('ux') || lowerDesc.includes('ui')) {
    return 'design';
  }
  
  if (lowerDesc.includes('marketing') || lowerDesc.includes('growth')) {
    return 'marketing';
  }
  
  if (lowerDesc.includes('sales') || lowerDesc.includes('account executive')) {
    return 'sales';
  }
  
  // Infer from skills
  const techSkills = ['javascript', 'python', 'java', 'react', 'node.js'];
  const dataSkills = ['sql', 'tableau', 'python', 'r', 'machine learning'];
  const designSkills = ['figma', 'sketch', 'photoshop', 'prototyping'];
  
  if (techSkills.some(skill => skillNames.includes(skill))) {
    return 'software-engineering';
  }
  
  if (dataSkills.some(skill => skillNames.includes(skill))) {
    return 'data-science';
  }
  
  if (designSkills.some(skill => skillNames.includes(skill))) {
    return 'design';
  }
  
  return 'general';
}

/**
 * Re-analyze a job with updated algorithm (always premium now)
 * @param {string} jobId - Job ID to re-analyze
 * @returns {Object} Updated job analysis
 */
exports.reAnalyzeJob = async (jobId) => {
  try {
    const Job = require('../models/mongodb/job.model');
    const job = await Job.findById(jobId);
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    console.log(`Re-analyzing job with premium quality: ${job.title} at ${job.company}`);
    
    // Re-analyze with premium GPT-4o for all re-analysis
    const updatedAnalysis = await this.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location
    }, { 
      isAiDiscovery: false,  // Use premium approach for all re-analysis
      prioritizeCost: false 
    });
    
    // Update the job with new analysis
    job.parsedData = updatedAnalysis;
    job.updatedAt = new Date();
    await job.save();
    
    console.log('Premium job re-analysis completed successfully');
    return updatedAnalysis;
    
  } catch (error) {
    console.error('Error re-analyzing job:', error);
    throw error;
  }
};

/**
 * Batch analyze multiple jobs with premium quality
 * @param {Array} jobIds - Array of job IDs to analyze
 * @param {boolean} isAiDiscovery - Whether this is AI discovery (now uses premium regardless)
 * @returns {Object} Batch analysis results
 */
exports.batchAnalyzeJobs = async (jobIds, isAiDiscovery = false) => {
  const results = {
    successful: [],
    failed: [],
    total: jobIds.length,
    modelUsed: 'gpt-4o', // Always premium now
    qualityLevel: 'premium',
    estimatedCost: '$0.01-0.02 per job'
  };
  
  console.log(`Starting premium batch analysis of ${jobIds.length} jobs with ${results.modelUsed}...`);
  
  for (const jobId of jobIds) {
    try {
      const Job = require('../models/mongodb/job.model');
      const job = await Job.findById(jobId);
      
      if (!job) {
        throw new Error('Job not found');
      }
      
      const analysis = await this.analyzeJob(job.description, {
        title: job.title,
        company: job.company,
        location: job.location
      }, { 
        isAiDiscovery: isAiDiscovery,
        prioritizeCost: false  // Always premium quality
      });
      
      job.parsedData = analysis;
      job.updatedAt = new Date();
      await job.save();
      
      results.successful.push({ jobId, analysis });
      
    } catch (error) {
      console.error(`Failed to analyze job ${jobId}:`, error);
      results.failed.push({ jobId, error: error.message });
    }
  }
  
  console.log(`Premium batch analysis completed: ${results.successful.length} successful, ${results.failed.length} failed`);
  return results;
};

================
File: services/jobMatching.service.js
================
// services/jobMatching.service.js - UPDATED TO AUTO-SELECT BEST RESUME
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');

/**
 * Find the best resume for a user to match against a job
 * @param {string} userId - User ID
 * @param {string} jobId - Job ID (optional, for tailored resume detection)
 * @returns {Object} Best resume for matching
 */
async function findBestResumeForMatching(userId, jobId = null) {
  try {
    // Get all user's resumes
    const allResumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    
    if (!allResumes || allResumes.length === 0) {
      throw new Error('No resumes found for user');
    }
    
    // First, check if there's a tailored resume specifically for this job
    if (jobId) {
      const tailoredResume = allResumes.find(resume => 
        resume.isTailored && 
        resume.tailoredForJob?.jobId && 
        resume.tailoredForJob.jobId.toString() === jobId.toString()
      );
      
      if (tailoredResume) {
        console.log(`Found tailored resume for job ${jobId}:`, {
          resumeId: tailoredResume._id,
          name: tailoredResume.name,
          overallScore: tailoredResume.analysis?.overallScore
        });
        return tailoredResume;
      }
    }
    
    // If no job-specific tailored resume, find the highest scoring resume
    const resumesWithScores = allResumes
      .filter(resume => resume.analysis && resume.analysis.overallScore)
      .sort((a, b) => b.analysis.overallScore - a.analysis.overallScore);
    
    if (resumesWithScores.length > 0) {
      const bestResume = resumesWithScores[0];
      console.log(`Selected best resume by score:`, {
        resumeId: bestResume._id,
        name: bestResume.name,
        overallScore: bestResume.analysis.overallScore,
        isTailored: bestResume.isTailored
      });
      return bestResume;
    }
    
    // Fallback to most recent resume
    const fallbackResume = allResumes[0];
    console.log(`Fallback to most recent resume:`, {
      resumeId: fallbackResume._id,
      name: fallbackResume.name
    });
    return fallbackResume;
    
  } catch (error) {
    console.error('Error finding best resume for matching:', error);
    throw error;
  }
}

/**
 * Enhanced job matching with automatic best resume selection
 * @param {string} jobId - MongoDB ID of the job
 * @param {string} resumeId - MongoDB ID of the resume (optional - will auto-select if not provided)
 * @param {string} userId - User ID (for auto-selection)
 * @returns {Object} Match analysis results with accurate scoring
 */
exports.matchJobWithBestResume = async (jobId, userId, specificResumeId = null) => {
  try {
    console.log(`Starting intelligent job matching for job ${jobId}, user ${userId}`);
    
    // Get the job
    const job = await Job.findById(jobId);
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Find the best resume to use for matching
    let resume;
    if (specificResumeId) {
      // Use specific resume if provided
      resume = await Resume.findOne({ _id: specificResumeId, userId });
      if (!resume) {
        throw new Error('Specified resume not found');
      }
      console.log(`Using specified resume: ${resume.name}`);
    } else {
      // Auto-select best resume
      resume = await findBestResumeForMatching(userId, jobId);
    }
    
    console.log(`Starting enhanced matching for job "${job.title}" with resume "${resume.name}"`);
    
    // Perform the actual matching
    const matchAnalysis = await this.matchResumeWithJob(resume._id, jobId);
    
    // Update the job with the new match analysis
    job.matchAnalysis = {
      ...matchAnalysis,
      resumeId: resume._id,
      lastAnalyzed: new Date(),
      analysisVersion: '2.0-auto-best'
    };
    
    await job.save();
    
    console.log(`Job match updated with best resume. Score: ${matchAnalysis.overallScore}%`);
    
    return {
      matchAnalysis,
      usedResume: {
        id: resume._id,
        name: resume.name,
        isTailored: resume.isTailored,
        overallScore: resume.analysis?.overallScore
      }
    };
    
  } catch (error) {
    console.error('Error in enhanced job matching:', error);
    throw error;
  }
};

/**
 * Enhanced job matching with more intelligent scoring
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @returns {Object} Match analysis results with accurate scoring
 */
exports.matchResumeWithJob = async (resumeId, jobId) => {
  try {
    console.log(`Starting enhanced matching for resume ${resumeId} with job ${jobId}`);
    
    // Get the resume and job from the database
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Check if parsed data is available for both
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      throw new Error('Resume parsing data not available for matching');
    }
    
    if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
      throw new Error('Job analysis data not available for matching');
    }
    
    console.log('Performing intelligent job-resume matching with OpenAI...');
    
    // Create detailed prompts for more accurate analysis
    const resumeSkills = extractSkillsFromResume(resume.parsedData);
    const jobSkills = extractSkillsFromJob(job.parsedData);
    const resumeExperience = extractExperienceFromResume(resume.parsedData);
    const jobRequirements = extractRequirementsFromJob(job.parsedData);
    
    // Check if this is a tailored resume for bonus consideration
    const isTailoredForThisJob = resume.isTailored && 
      resume.tailoredForJob?.jobId && 
      resume.tailoredForJob.jobId.toString() === jobId.toString();
    
    // Enhanced prompt for more precise matching
    const prompt = `
    You are an expert ATS (Applicant Tracking System) and recruitment analyst. Perform a detailed match analysis between this resume and job posting.

    IMPORTANT: Provide realistic and accurate scores based on actual content matching. ${isTailoredForThisJob ? 'This resume has been AI-tailored specifically for this job, so it should score higher than a generic resume.' : 'Avoid giving inflated scores.'}

    **JOB POSTING:**
    Title: ${job.title}
    Company: ${job.company}
    Description: ${job.description}
    
    **JOB REQUIREMENTS ANALYSIS:**
    Required Skills: ${JSON.stringify(jobSkills.required)}
    Preferred Skills: ${JSON.stringify(jobSkills.preferred)}
    Experience Level: ${job.parsedData.experienceLevel || 'Not specified'}
    Education Requirements: ${JSON.stringify(job.parsedData.educationRequirements)}
    Key Requirements: ${JSON.stringify(jobRequirements)}

    **CANDIDATE RESUME:**
    Summary: ${resume.parsedData.summary || 'No summary provided'}
    Skills: ${JSON.stringify(resumeSkills)}
    Experience: ${JSON.stringify(resumeExperience)}
    Education: ${JSON.stringify(resume.parsedData.education)}
    ${isTailoredForThisJob ? 'NOTE: This resume has been specifically tailored for this job posting.' : ''}

    **MATCHING CRITERIA:**
    1. **Skills Match (40% weight)**: Compare required vs candidate skills
    2. **Experience Match (35% weight)**: Evaluate relevant experience depth and breadth
    3. **Education Match (25% weight)**: Check education requirements vs candidate background

    **SCORING GUIDELINES:**
    - 95-100%: Perfect match, candidate exceeds all requirements ${isTailoredForThisJob ? '(expected for tailored resumes)' : ''}
    - 85-94%: Excellent match, candidate meets all core requirements with strong alignment
    - 75-84%: Very good match, candidate meets most requirements
    - 65-74%: Good match, candidate meets core requirements with some gaps
    - 55-64%: Moderate match, candidate has potential but significant gaps
    - Below 55%: Poor match, major misalignment

    ${isTailoredForThisJob ? 'TAILORED RESUME BONUS: This resume should score 10-15 points higher than the original due to optimization.' : ''}

    Provide analysis in this EXACT JSON format:
    {
      "overallScore": <realistic number 0-100>,
      "categoryScores": {
        "skills": <realistic number 0-100>,
        "experience": <realistic number 0-100>,
        "education": <realistic number 0-100>
      },
      "matchedSkills": [
        {
          "skill": "exact skill name from job",
          "found": true/false,
          "importance": <1-10 scale>,
          "matchQuality": "exact|partial|related|none",
          "resumeEvidence": "where found in resume or null"
        }
      ],
      "missingSkills": [
        {
          "skill": "missing skill name",
          "importance": <1-10 scale>,
          "category": "required|preferred",
          "suggestionToAdd": "specific advice"
        }
      ],
      "experienceAnalysis": {
        "totalYearsExperience": <number>,
        "relevantYearsExperience": <number>,
        "seniorityMatch": "junior|mid|senior|executive",
        "industryAlignment": "high|medium|low",
        "roleAlignment": "high|medium|low"
      },
      "educationAnalysis": {
        "degreeMatch": "exceeds|meets|partial|none",
        "fieldAlignment": "high|medium|low",
        "certificationBonus": true/false
      },
      "improvementSuggestions": [
        "specific actionable suggestion 1",
        "specific actionable suggestion 2",
        "specific actionable suggestion 3"
      ],
      "strengthsHighlight": [
        "key strength 1",
        "key strength 2",
        "key strength 3"
      ]
    }

    **IMPORTANT**: ${isTailoredForThisJob ? 'This is a tailored resume - expect scores in the 85-95% range due to optimization.' : 'Base scores on actual content analysis, not generic assumptions. Be critical and realistic in scoring.'}
    `;

    // Call OpenAI API with enhanced model settings
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: `You are an expert ATS system and senior recruitment analyst with 15+ years of experience. You provide realistic, accurate match scores based on detailed analysis. ${isTailoredForThisJob ? 'You recognize when resumes have been optimized for specific jobs and score them appropriately higher.' : 'You never inflate scores and always provide evidence-based assessments.'} Return ONLY valid JSON without markdown formatting.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Lower temperature for more consistent scoring
      max_tokens: 4000,
    });

    // Parse and validate the response
    const content = response.choices[0].message.content.trim();
    console.log('OpenAI Response received, parsing...');
    
    let matchAnalysis;
    try {
      // Clean up the response to extract JSON
      let jsonStr = content;
      
      // Remove any markdown code blocks
      if (content.includes('```')) {
        const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          jsonStr = jsonMatch[1];
        }
      }
      
      // Clean up and ensure valid JSON structure
      jsonStr = jsonStr.trim();
      if (!jsonStr.startsWith('{')) {
        const startIndex = jsonStr.indexOf('{');
        if (startIndex !== -1) {
          jsonStr = jsonStr.substring(startIndex);
        }
      }
      if (!jsonStr.endsWith('}')) {
        const endIndex = jsonStr.lastIndexOf('}');
        if (endIndex !== -1) {
          jsonStr = jsonStr.substring(0, endIndex + 1);
        }
      }
      
      matchAnalysis = JSON.parse(jsonStr);
      
      // Validate and ensure realistic scoring
      matchAnalysis = validateAndNormalizeScores(matchAnalysis);
      
      console.log(`Enhanced matching completed - Overall Score: ${matchAnalysis.overallScore}%`);
      
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.log('Raw response:', content);
      throw new Error('Failed to parse AI response');
    }

    // Add additional metadata
    matchAnalysis.analysisMetadata = {
      resumeId,
      jobId,
      analyzedAt: new Date(),
      algorithmVersion: '2.0',
      isTailoredResume: isTailoredForThisJob
    };

    return matchAnalysis;
    
  } catch (error) {
    console.error('Error in enhanced job matching:', error);
    
    // More intelligent fallback based on available data
    return generateIntelligentFallback(resume, job, error);
  }
};

/**
 * Extract skills from resume data
 */
function extractSkillsFromResume(parsedData) {
  const skills = [];
  
  // From skills section
  if (parsedData.skills && Array.isArray(parsedData.skills)) {
    parsedData.skills.forEach(skill => {
      if (typeof skill === 'string') {
        skills.push(skill);
      } else if (skill && skill.name) {
        skills.push(skill.name);
      }
    });
  }
  
  // From experience highlights
  if (parsedData.experience && Array.isArray(parsedData.experience)) {
    parsedData.experience.forEach(exp => {
      if (exp.skills && Array.isArray(exp.skills)) {
        skills.push(...exp.skills);
      }
    });
  }
  
  return [...new Set(skills)]; // Remove duplicates
}

/**
 * Extract skills from job data
 */
function extractSkillsFromJob(parsedData) {
  const required = [];
  const preferred = [];
  
  // From key skills
  if (parsedData.keySkills && Array.isArray(parsedData.keySkills)) {
    parsedData.keySkills.forEach(skill => {
      if (typeof skill === 'string') {
        required.push(skill);
      } else if (skill && skill.name) {
        const importance = skill.importance || 5;
        if (importance >= 7) {
          required.push(skill.name);
        } else {
          preferred.push(skill.name);
        }
      }
    });
  }
  
  // From qualifications
  if (parsedData.qualifications) {
    if (parsedData.qualifications.required) {
      required.push(...parsedData.qualifications.required);
    }
    if (parsedData.qualifications.preferred) {
      preferred.push(...parsedData.qualifications.preferred);
    }
  }
  
  return {
    required: [...new Set(required)],
    preferred: [...new Set(preferred)]
  };
}

/**
 * Extract experience from resume
 */
function extractExperienceFromResume(parsedData) {
  if (!parsedData.experience || !Array.isArray(parsedData.experience)) {
    return [];
  }
  
  return parsedData.experience.map(exp => ({
    company: exp.company,
    title: exp.title,
    duration: calculateDuration(exp.startDate, exp.endDate),
    description: exp.description,
    highlights: exp.highlights || []
  }));
}

/**
 * Extract requirements from job
 */
function extractRequirementsFromJob(parsedData) {
  const requirements = [];
  
  if (parsedData.requirements && Array.isArray(parsedData.requirements)) {
    requirements.push(...parsedData.requirements);
  }
  
  if (parsedData.responsibilities && Array.isArray(parsedData.responsibilities)) {
    requirements.push(...parsedData.responsibilities);
  }
  
  return requirements;
}

/**
 * Calculate duration between two dates
 */
function calculateDuration(startDate, endDate) {
  if (!startDate) return 0;
  
  const start = new Date(startDate);
  const end = endDate ? new Date(endDate) : new Date();
  
  const diffTime = Math.abs(end - start);
  const diffMonths = Math.ceil(diffTime / (1000 * 60 * 60 * 24 * 30));
  
  return diffMonths;
}

/**
 * Validate and normalize scores to ensure realistic ranges
 */
function validateAndNormalizeScores(analysis) {
  // Ensure overall score is reasonable based on category scores
  if (analysis.categoryScores) {
    const { skills, experience, education } = analysis.categoryScores;
    
    // Weighted average: Skills 40%, Experience 35%, Education 25%
    const calculatedOverall = Math.round((skills * 0.4) + (experience * 0.35) + (education * 0.25));
    
    // If provided overall score is significantly different, use calculated
    if (Math.abs(analysis.overallScore - calculatedOverall) > 10) {
      analysis.overallScore = calculatedOverall;
    }
  }
  
  // Ensure scores are within valid range
  analysis.overallScore = Math.max(0, Math.min(100, analysis.overallScore));
  if (analysis.categoryScores) {
    analysis.categoryScores.skills = Math.max(0, Math.min(100, analysis.categoryScores.skills));
    analysis.categoryScores.experience = Math.max(0, Math.min(100, analysis.categoryScores.experience));
    analysis.categoryScores.education = Math.max(0, Math.min(100, analysis.categoryScores.education));
  }
  
  return analysis;
}

/**
 * Generate intelligent fallback when AI analysis fails
 */
function generateIntelligentFallback(resume, job, error) {
  console.log('Generating intelligent fallback analysis...');
  
  try {
    // Basic skills matching
    const resumeSkills = extractSkillsFromResume(resume.parsedData);
    const jobSkills = extractSkillsFromJob(job.parsedData);
    
    // Calculate basic skill match percentage
    const allJobSkills = [...jobSkills.required, ...jobSkills.preferred];
    const matchedSkills = resumeSkills.filter(skill => 
      allJobSkills.some(jobSkill => 
        skill.toLowerCase().includes(jobSkill.toLowerCase()) ||
        jobSkill.toLowerCase().includes(skill.toLowerCase())
      )
    );
    
    const skillsScore = allJobSkills.length > 0 ? 
      Math.round((matchedSkills.length / allJobSkills.length) * 100) : 50;
    
    // Basic experience scoring
    const experienceYears = resume.parsedData.experience ? 
      resume.parsedData.experience.length * 2 : 0; // Rough estimate
    
    let experienceScore = 40;
    if (experienceYears >= 5) experienceScore = 75;
    if (experienceYears >= 8) experienceScore = 85;
    if (experienceYears >= 12) experienceScore = 95;
    
    // Basic education scoring
    const hasEducation = resume.parsedData.education && 
      resume.parsedData.education.length > 0;
    const educationScore = hasEducation ? 70 : 40;
    
    // Calculate weighted overall score
    const overallScore = Math.round(
      (skillsScore * 0.4) + (experienceScore * 0.35) + (educationScore * 0.25)
    );
    
    return {
      overallScore,
      categoryScores: {
        skills: skillsScore,
        experience: experienceScore,
        education: educationScore
      },
      matchedSkills: matchedSkills.map(skill => ({
        skill,
        found: true,
        importance: 5,
        matchQuality: 'partial',
        resumeEvidence: 'Skills section'
      })),
      missingSkills: allJobSkills
        .filter(skill => !matchedSkills.includes(skill))
        .slice(0, 5)
        .map(skill => ({
          skill,
          importance: 6,
          category: 'required',
          suggestionToAdd: `Consider highlighting experience with ${skill} if you have it`
        })),
      improvementSuggestions: [
        'Analysis temporarily unavailable - basic matching performed',
        'Consider highlighting relevant skills mentioned in the job posting',
        'Quantify your achievements with specific metrics and results'
      ],
      strengthsHighlight: [
        'Resume structure is well-organized',
        'Relevant work experience present',
        'Skills section is comprehensive'
      ],
      fallbackReason: error.message,
      analysisMetadata: {
        resumeId: resume._id,
        jobId: job._id,
        analyzedAt: new Date(),
        algorithmVersion: '2.0-fallback'
      }
    };
    
  } catch (fallbackError) {
    console.error('Error in fallback analysis:', fallbackError);
    
    // Final fallback with very basic scores
    return {
      overallScore: 45,
      categoryScores: {
        skills: 40,
        experience: 50,
        education: 45
      },
      matchedSkills: [],
      missingSkills: [],
      improvementSuggestions: [
        'Unable to complete detailed analysis at this time',
        'Please ensure your resume includes relevant skills for this position',
        'Try the analysis again later for more detailed insights'
      ],
      strengthsHighlight: [
        'Resume uploaded successfully',
        'Basic profile information captured'
      ],
      errorDetails: error.message,
      analysisMetadata: {
        resumeId: resume._id,
        jobId: job._id,
        analyzedAt: new Date(),
        algorithmVersion: '2.0-error-fallback'
      }
    };
  }
}

================
File: services/jobSearch.service.js
================
// services/jobSearch.service.js - ENHANCED WITH CLAUDE WEB SEARCH LIKE GENERAL CHAT
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const AiJobSearch = require('../models/mongodb/aiJobSearch.model');
const { anthropic } = require('../config/anthropic');
const { openai } = require('../config/openai');
const jobAnalysisService = require('./jobAnalysis.service');

/**
 * ENHANCED 3-Phase AI Job Search - Now with Claude Web Search like General Chat
 * Phase 1: Career Analysis ($0.05) - GPT-4 Turbo
 * Phase 2: ENHANCED Job Discovery & Extraction ($0.30-0.50) - Claude 3.5 Sonnet with web search API
 * Phase 3: Premium Job Analysis ($0.01-0.02) - GPT-4o batch processing
 * 
 * Uses Claude's web search API exactly like the general chat example
 * Total Cost: $0.36-0.57 per search
 */
exports.findJobsWithAi = async (userId, resumeId) => {
  try {
    console.log(`🚀 Starting ENHANCED 3-Phase AI job search with Claude web search API for user ${userId}`);
    
    const resume = await Resume.findById(resumeId);
    if (!resume || !resume.parsedData) {
      throw new Error('Resume not found or not parsed');
    }
    
    // Create search record with CORRECT enum values
    const aiJobSearch = new AiJobSearch({
      userId,
      resumeId,
      resumeName: resume.name,
      searchCriteria: extractSearchCriteria(resume.parsedData),
      status: 'running',
      dailyLimit: 10,
      jobsFoundToday: 0,
      totalJobsFound: 0,
      searchApproach: '3-phase-intelligent-claude-web-search',  // FIXED: Use correct enum value
      approachVersion: '3.2-claude-web-search-api',
      qualityLevel: 'claude-web-search'  // FIXED: Use correct enum value
    });
    
    await aiJobSearch.save();
    
    // Add initialization reasoning log
    await aiJobSearch.addReasoningLog(
      'initialization',
      `ENHANCED 3-Phase AI job search with Claude web search API initialized for resume "${resume.name}"`,
      {
        searchCriteria: aiJobSearch.searchCriteria,
        dailyLimit: aiJobSearch.dailyLimit,
        enhancedApproach: '3-Phase: Career Analysis → Claude Web Search Discovery → Premium Analysis',
        webSearchMethod: 'Claude web search API (same as general chat)',
        qualityImprovement: 'Real job URLs found and content extracted like general chat',
        costEstimate: '$0.36-0.57 per search',
        phases: [
          'Phase 1: Career Analysis (GPT-4 Turbo)',
          'Phase 2: ENHANCED Job Discovery (Claude Web Search API)',
          'Phase 3: Premium Job Analysis (GPT-4o batch)'
        ]
      }
    );
    
    // Start background search
    performEnhancedJobSearch(aiJobSearch._id, userId, resume).catch(error => {
      console.error('Enhanced job search error:', error);
      updateSearchStatus(aiJobSearch._id, 'failed', error.message);
    });
    
    return {
      success: true,
      message: 'ENHANCED AI job search with Claude web search API started successfully',
      searchId: aiJobSearch._id,
      searchMethod: 'Claude web search API (same as general chat)'
    };
    
  } catch (error) {
    console.error('Error initiating enhanced job search:', error);
    throw error;
  }
};

async function addSearchError(search, errorType, message, phase = 'general', context = '') {
  // Map old error types to new enum values if needed
  const errorTypeMapping = {
    'intelligent_discovery_failed': 'web_search_failed',
    'job_search_failed': 'job_discovery_failed',
    'content_extraction_failed': 'content_extraction_failed'
  };
  
  const mappedErrorType = errorTypeMapping[errorType] || errorType;
  
  await search.addError(mappedErrorType, message, phase, context);
}

/**
 * ENHANCED 3-Phase Job Search with Claude Web Search API
 */
async function performEnhancedJobSearch(searchId, userId, resume) {
  const searchStartTime = Date.now();
  let search;
  
  try {
    search = await AiJobSearch.findById(searchId);
    if (!search || search.status !== 'running') return;
    
    // Check daily limits
    if (await isDailyLimitReached(search)) {
      await search.addReasoningLog(
        'completion',
        `Daily limit of ${search.dailyLimit} jobs reached. Search paused until tomorrow.`,
        { 
          dailyLimit: search.dailyLimit, 
          jobsFoundToday: search.jobsFoundToday,
          reason: 'daily_limit_reached'
        }
      );
      await updateSearchStatus(searchId, 'paused', 'Daily limit reached');
      return;
    }
    
    // PHASE 1: Career Analysis (Unchanged - GPT-4 Turbo)
    console.log(`📊 Phase 1: Career Analysis...`);
    const phase1Start = Date.now();
    
    await search.addReasoningLog(
      'career_analysis',
      'Starting enhanced career trajectory analysis using GPT-4 Turbo for optimal job targeting',
      { 
        phase: 'career_analysis_start',
        model: 'gpt-4-turbo',
        costEstimate: '$0.05'
      }
    );
    
    const careerProfile = await analyzeCareerTrajectoryEnhanced(resume.parsedData);
    const phase1Duration = Date.now() - phase1Start;
    
    await search.addReasoningLog(
      'career_analysis',
      `Career analysis completed. Generated ${careerProfile.targetJobTitles?.length || 0} target job titles and ${careerProfile.targetKeywords?.length || 0} search keywords.`,
      {
        phase: 'career_analysis_complete',
        targetJobTitles: careerProfile.targetJobTitles || [],
        targetKeywords: careerProfile.targetKeywords || [],
        experienceLevel: careerProfile.experienceLevel,
        preferredLocations: careerProfile.preferredLocations || [],
        model: 'gpt-4-turbo',
        duration: phase1Duration
      },
      true,
      phase1Duration
    );
    
    if (!careerProfile.targetJobTitles || careerProfile.targetJobTitles.length === 0) {
      await search.addReasoningLog(
        'error',
        'Career analysis failed to identify target job titles. Cannot proceed with job search.',
        { 
          phase: 'career_analysis_failed',
          suggestion: 'Resume may need more detailed experience information'
        },
        false,
        phase1Duration
      );
      await updateSearchStatus(searchId, 'completed', 'Career analysis insufficient');
      return;
    }
    
    // PHASE 2: ENHANCED Job Discovery & Extraction (CLAUDE WEB SEARCH API)
    console.log(`🎯 Phase 2: ENHANCED Job Discovery with Claude Web Search API...`);
    const phase2Start = Date.now();
    
    await search.addReasoningLog(
      'intelligent_discovery',
      'Starting ENHANCED job discovery using Claude web search API (same method as general chat)',
      { 
        phase: 'enhanced_job_discovery_start',
        model: 'claude-3.5-sonnet',
        approach: 'Step 1: Find job URLs with web search → Step 2: Extract content from URLs',
        webSearchMethod: 'Claude web search API (same as general chat)',
        costEstimate: '$0.30-0.50'
      }
    );
    
    const discoveredJobs = await performRealJobBoardDiscovery(careerProfile, search);
    const phase2Duration = Date.now() - phase2Start;
    
    if (discoveredJobs.length === 0) {
      await search.addReasoningLog(
        'completion',
        'Enhanced job discovery found no matching opportunities using Claude web search API. Search criteria may need adjustment.',
        { 
          phase: 'enhanced_discovery_no_results',
          searchMethod: 'Claude web search API',
          searchedTitles: careerProfile.targetJobTitles,
          suggestion: 'Try again tomorrow or broaden search criteria'
        },
        false,
        phase2Duration
      );
      await updateSearchStatus(searchId, 'completed', 'No job opportunities found with Claude web search');
      return;
    }
    
    await search.addReasoningLog(
      'intelligent_discovery',
      `Enhanced job discovery completed successfully. Found ${discoveredJobs.length} high-quality job opportunities using Claude web search API.`,
      {
        phase: 'enhanced_job_discovery_complete',
        totalJobsFound: discoveredJobs.length,
        searchMethod: 'Claude web search API',
        platformsFound: [...new Set(discoveredJobs.map(job => job.sourcePlatform))],
        averageContentLength: discoveredJobs.length > 0 ? 
          Math.round(discoveredJobs.reduce((sum, job) => sum + (job.fullContent?.length || 0), 0) / discoveredJobs.length) : 0,
        qualityJobs: discoveredJobs.filter(job => job.contentQuality === 'high').length,
        companiesFound: [...new Set(discoveredJobs.map(job => job.company))].length,
        model: 'claude-3.5-sonnet',
        duration: phase2Duration
      },
      true,
      phase2Duration
    );
    
// PHASE 3: Premium Job Analysis (Unchanged - GPT-4o Quality)
    console.log(`🔬 Phase 3: Premium Job Analysis...`);
    const phase3Start = Date.now();
    
    await search.addReasoningLog(
      'premium_analysis',
      'Starting premium job analysis using GPT-4o for same quality as manual job uploads',
      { 
        phase: 'premium_analysis_start',
        jobsToAnalyze: discoveredJobs.length,
        model: 'gpt-4o',
        quality: 'Same as manual job uploads',
        costEstimate: '$0.01-0.02'
      }
    );
    
    const analyzedJobs = await performPremiumJobAnalysis(discoveredJobs, search);
    const phase3Duration = Date.now() - phase3Start;
    
    const successfulAnalyses = analyzedJobs.filter(job => job.analysis && !job.analysisError).length;
    
    await search.addReasoningLog(
      'premium_analysis',
      `Premium job analysis completed. Successfully analyzed ${successfulAnalyses}/${analyzedJobs.length} jobs with GPT-4o quality.`,
      {
        phase: 'premium_analysis_complete',
        totalJobs: analyzedJobs.length,
        successfulAnalyses: successfulAnalyses,
        averageSkillsFound: successfulAnalyses > 0 ? 
          Math.round(analyzedJobs
            .filter(job => job.analysis?.keySkills)
            .reduce((sum, job) => sum + (job.analysis.keySkills.length || 0), 0) / successfulAnalyses) : 0,
        model: 'gpt-4o',
        quality: 'Premium analysis (same as manual)',
        duration: phase3Duration
      },
      successfulAnalyses > 0,
      phase3Duration
    );

    function getPhaseForLogging(originalPhase) {
  const phaseMapping = {
    'intelligent_discovery': 'web_search_discovery',
    'content_extraction': 'content_extraction',
    'job_search': 'web_search_discovery'
  };
  
  return phaseMapping[originalPhase] || originalPhase;
}

    
    // Save Jobs with Enhanced Metadata
    console.log(`💾 Saving ${analyzedJobs.length} analyzed jobs from Claude web search...`);
    const saveStart = Date.now();
    
    await search.addReasoningLog(
      'job_saving',
      `Saving ${analyzedJobs.length} premium-analyzed jobs from Claude web search with enhanced metadata and deduplication`,
      { 
        phase: 'job_saving_start',
        jobsToSave: analyzedJobs.length,
        discoveryMethod: 'Claude web search API'
      }
    );
    
    const savedCount = await saveJobsWithEnhancedMetadata(analyzedJobs, userId, searchId, search);
    const saveDuration = Date.now() - saveStart;
    
    await search.addReasoningLog(
      'job_saving',
      `Job saving completed. Saved ${savedCount} new premium jobs from Claude web search, skipped ${analyzedJobs.length - savedCount} duplicates.`,
      {
        phase: 'job_saving_complete',
        savedJobs: savedCount,
        duplicatesSkipped: analyzedJobs.length - savedCount,
        discoveryMethod: 'Claude web search API',
        duration: saveDuration
      },
      savedCount > 0,
      saveDuration
    );
    
    // Final completion with Claude web search summary
    const totalDuration = Date.now() - searchStartTime;
    const searchSummary = {
      phase1: 'GPT-4 Turbo - $0.05',
      phase2: 'Claude 3.5 Sonnet + Web Search API - $0.30-0.50', 
      phase3: 'GPT-4o Premium Analysis - $0.01-0.02',
      totalCost: '$0.36-0.57',
      qualityLevel: 'Real job postings found via Claude web search API',
      searchMethod: 'Same as Claude general chat',
      enhancement: 'Claude web search API + Premium analysis'
    };
    
    await search.addReasoningLog(
      'completion',
      `ENHANCED 3-Phase AI job search with Claude web search API completed in ${Math.round(totalDuration / 1000)}s. Found ${savedCount} premium jobs using the same method as general chat.`,
      {
        phase: 'search_complete',
        totalDuration: totalDuration,
        jobsSaved: savedCount,
        searchSummary: searchSummary,
        webSearchMethod: 'Claude web search API (same as general chat)',
        intelligence: 'Claude for job discovery + GPT-4o for analysis',
        nextRun: 'Will continue tomorrow with fresh opportunities via Claude web search'
      }
    );
    
    await updateSearchStatus(searchId, savedCount > 0 ? 'running' : 'completed', 
      `Found ${savedCount} premium jobs via Claude web search API`);
    console.log(`✅ ENHANCED 3-Phase AI job search complete: ${savedCount} jobs saved via Claude web search, cost: $0.36-0.57`);
    
  } catch (error) {
    console.error('Error in enhanced Claude web search:', error);
    
    if (search) {
      await search.addReasoningLog(
        'error',
        `Enhanced job search failed: ${error.message}`,
        { 
          phase: 'search_error',
          errorType: error.name,
          errorMessage: error.message,
          searchMethod: 'Claude web search API',
          suggestion: 'Try running the search again'
        },
        false
      );
    }
    
    await updateSearchStatus(searchId, 'failed', error.message);
  }
}

async function updateAiUsageForPhase(search, phase, type, tokens = 0, cost = 0) {
  // Map phases to match new enum values
  const phaseMapping = {
    'intelligent_discovery': 'web_search_discovery',
    'job_search': 'web_search_discovery',
    'content_extraction': 'web_search_discovery'
  };
  
  const mappedPhase = phaseMapping[phase] || phase;
  await search.updateAiUsage(mappedPhase, type, tokens, cost);
}

/**
 * ENHANCED PHASE 2: Real Job Board Discovery & Extraction
 * Uses Claude's web search API exactly like the general chat example
 */
async function performRealJobBoardDiscovery(careerProfile, search) {
  try {
    console.log(`🎯 Starting ENHANCED job discovery using Claude web search for ${careerProfile.targetJobTitles?.length || 0} target roles...`);
    
    // Step 1: Find job URLs using web search (like your general chat example)
    const jobUrls = await findJobUrlsWithWebSearch(careerProfile, search);
    
    if (jobUrls.length === 0) {
      await search.addReasoningLog(
        'web_search_discovery',
        'No job URLs found with Claude web search. May need to adjust search criteria.',
        { 
          searchTargets: careerProfile.targetJobTitles,
          searchKeywords: careerProfile.targetKeywords,
          searchMethod: 'Claude web search API'
        },
        false
      );
      return [];
    }
    
    // Step 2: Extract content from each job URL (like your URL extraction example)
const discoveredJobs = await extractJobContentFromUrls(jobUrls, search, careerProfile);
    
    await search.addReasoningLog(
      'web_search_discovery',
      `Enhanced job discovery completed. Found ${discoveredJobs.length} high-quality jobs using Claude web search API.`,
      {
        jobUrlsFound: jobUrls.length,
        successfulExtractions: discoveredJobs.length,
        jobBoards: [...new Set(discoveredJobs.map(job => job.sourcePlatform))],
        averageContentLength: discoveredJobs.length > 0 ? 
          Math.round(discoveredJobs.reduce((sum, job) => sum + (job.fullContent?.length || 0), 0) / discoveredJobs.length) : 0,
        searchMethod: 'Claude web search API (same as general chat)'
      }
    );
    
    return discoveredJobs;
    
  } catch (error) {
    console.error('Error in enhanced job discovery:', error);
    await search.addReasoningLog(
      'web_search_discovery',
      `Enhanced job discovery failed: ${error.message}`,
      { error: error.message, searchMethod: 'Claude web search API' },
      false
    );
    return [];
  }
}


/**
 * Step 1: Find Job URLs using Claude Web Search
 * Mimics the approach from your general chat example
 */
async function findJobUrlsWithWebSearch(careerProfile, search) {
  try {
    await search.addReasoningLog(
      'web_search_discovery',  // FIXED: Use correct phase enum
      'Starting job URL discovery using Claude web search API',
      { 
        targetTitles: careerProfile.targetJobTitles,
        searchApproach: 'Claude web search like general chat',
        webSearchMethod: 'claude_web_search_api'
      }
    );
    
    const response = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 4000,
      temperature: 0.2,
      messages: [
        {
          role: "user",
          content: `I am looking for ${careerProfile.experienceLevel || 'mid-level'} ${careerProfile.targetJobTitles?.[0] || 'Software Engineer'} jobs at companies that are hiring. 

TARGET PROFILE:
- Job Titles: ${careerProfile.targetJobTitles?.join(', ')}
- Experience Level: ${careerProfile.experienceLevel}
- Preferred Skills: ${careerProfile.targetKeywords?.join(', ')}
- Work Arrangement: ${careerProfile.workArrangement || 'remote/hybrid'}
- Salary Range: $${careerProfile.salaryExpectation?.min || 100000}-${careerProfile.salaryExpectation?.max || 150000}

Please find 8-12 current job openings that match this profile. For each job, I need:
1. The company name and job title
2. The direct job application URL (especially from Greenhouse, Lever, Indeed, or company career pages)
3. Brief description of why it's a good match

Focus on:
- Direct company postings (not recruiters)
- Jobs posted in the last 30 days
- Companies with good reputations
- Remote/hybrid opportunities when possible
- Jobs from well-known ATS systems (Greenhouse, Lever, etc.)

Return the results in this format:
JOB 1: [Job Title] at [Company Name]
URL: [Direct job application URL]
Match Reason: [Why this is a good fit]

JOB 2: [Job Title] at [Company Name]  
URL: [Direct job application URL]
Match Reason: [Why this is a good fit]

etc.`
        }
      ],
      tools: [
        {
          type: "web_search_20250305",
          name: "web_search"
        }
      ],
      tool_choice: { type: "any" }
    });

    const jobUrls = [];
    
    // Process Claude's response to extract job URLs
    for (const content of response.content) {
      if (content.type === 'text') {
        const text = content.text;
        
        // Extract URLs from the response
        const urlMatches = text.match(/URL:\s*(https?:\/\/[^\s\n]+)/gi);
        
        if (urlMatches) {
          urlMatches.forEach(match => {
            const url = match.replace(/^URL:\s*/i, '').trim();
            
            // Extract job info from the surrounding text
            const lines = text.split('\n');
            const urlLineIndex = lines.findIndex(line => line.includes(url));
            
            if (urlLineIndex > 0) {
              const jobLine = lines[urlLineIndex - 1] || '';
              const matchReasonLine = lines[urlLineIndex + 1] || '';
              
              // Parse job title and company
              const jobMatch = jobLine.match(/JOB\s+\d+:\s*(.+?)\s+at\s+(.+?)$/i);
              let title = 'Unknown Title';
              let company = 'Unknown Company';
              
              if (jobMatch) {
                title = jobMatch[1].trim();
                company = jobMatch[2].trim();
              }
              
              // Extract match reason
              const matchReason = matchReasonLine.replace(/^Match Reason:\s*/i, '').trim();
              
              // Determine source platform from URL
              const sourcePlatform = determineSourcePlatform(url);
              
              if (isValidJobUrl(url)) {
                jobUrls.push({
                  url: url,
                  title: title,
                  company: company,
                  matchReason: matchReason,
                  sourcePlatform: sourcePlatform,
                  foundAt: new Date()
                });
              }
            }
          });
        }
      }
    }
    
    await search.addReasoningLog(
      'web_search_discovery',  // FIXED: Use correct phase enum
      `Found ${jobUrls.length} job URLs using Claude web search API`,
      {
        totalUrls: jobUrls.length,
        platforms: [...new Set(jobUrls.map(job => job.sourcePlatform))],
        companies: [...new Set(jobUrls.map(job => job.company))],
        searchMethod: 'claude_web_search_api',
        webSearchMethod: 'claude_web_search_api'
      }
    );
    
    console.log(`✅ Found ${jobUrls.length} job URLs using Claude web search API`);
    return jobUrls;
    
  } catch (error) {
    console.error('Error finding job URLs with web search:', error);
    
    // Add error with correct enum
    await search.addError('web_search_failed', error.message, 'web_search_discovery', 'URL discovery failed');
    throw error;
  }
}


/**
 * Step 2: Extract Job Content from URLs
 * Mimics the URL content extraction from your example
 */
async function extractJobContentFromUrls(jobUrls, search, careerProfile) {
  const discoveredJobs = [];
  
  console.log(`📄 Extracting content from ${jobUrls.length} job URLs with detailed debugging...`);
  
  for (const jobUrl of jobUrls) {
    try {
      console.log(`\n🔍 === EXTRACTION DEBUG FOR: ${jobUrl.title} at ${jobUrl.company} ===`);
      console.log(`🔗 URL: ${jobUrl.url}`);
      console.log(`🏢 Platform: ${jobUrl.sourcePlatform}`);
      console.log(`💡 Match Reason: ${jobUrl.matchReason}`);
      
      await search.addReasoningLog(
        'content_extraction',
        `Starting content extraction from ${jobUrl.title} at ${jobUrl.company}`,
        {
          url: jobUrl.url,
          platform: jobUrl.sourcePlatform,
          extractionMethod: 'claude_web_fetch_debug'
        }
      );
      
      const response = await anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 4000,
        temperature: 0.1,
        messages: [
          {
            role: "user",
            content: `Please visit this job posting URL and extract the complete content: ${jobUrl.url}

Extract all job details including:
- Complete job description and overview
- Key responsibilities and duties  
- Required qualifications and skills
- Preferred qualifications
- Salary/compensation information
- Benefits and perks
- Work location and arrangement (remote/hybrid/onsite)
- Company information and culture
- Application process

Provide the comprehensive job posting content exactly as it appears on the page.`
          }
        ],
        tools: [
          {
            type: "web_search_20250305",
            name: "web_search"
          }
        ],
        tool_choice: { type: "any" }
      });

      console.log(`📡 Claude API Response Structure:`);
      console.log(`- Response content array length: ${response.content?.length || 0}`);
      
      let fullContent = '';
      let hasTextContent = false;
      let hasToolResults = false;
      let allTextFragments = []; // NEW: Collect all text fragments
      
      // FIXED: Examine the full response structure and collect ALL text content
      for (let i = 0; i < response.content.length; i++) {
        const content = response.content[i];
        console.log(`- Content[${i}] type: ${content.type}`);
        
        if (content.type === 'text') {
          hasTextContent = true;
          allTextFragments.push(content.text); // COLLECT each text fragment
          console.log(`- Text content length: ${content.text.length} characters`);
          console.log(`- Text preview: "${content.text.substring(0, 100)}..."`);
        } else if (content.type === 'tool_use') {
          hasToolResults = true;
          console.log(`- Tool use detected: ${content.name}`);
        } else if (content.type === 'tool_result') {
          console.log(`- Tool result detected`);
        }
      }
      
      // FIXED: Concatenate ALL text fragments into one complete content
      fullContent = allTextFragments.join('').trim();
      
      console.log(`📊 Content Analysis:`);
      console.log(`- Has text content: ${hasTextContent}`);
      console.log(`- Has tool results: ${hasToolResults}`);
      console.log(`- Number of text fragments: ${allTextFragments.length}`);
      console.log(`- Total concatenated content length: ${fullContent.length}`);
      console.log(`- Full content preview: "${fullContent.substring(0, 300)}..."`);
      
      // More detailed content analysis
      if (fullContent.length > 0) {
        const lowerContent = fullContent.toLowerCase();
        const hasJobKeywords = /job|position|role|career|responsibilities|qualifications|requirements/i.test(fullContent);
        const hasCompanyInfo = /company|organization|team|culture/i.test(fullContent);
        const hasSalaryInfo = /salary|compensation|\$|pay|benefits/i.test(fullContent);
        
        console.log(`📋 Content Quality Check:`);
        console.log(`- Has job keywords: ${hasJobKeywords}`);
        console.log(`- Has company info: ${hasCompanyInfo}`);
        console.log(`- Has salary info: ${hasSalaryInfo}`);
        
        // Check if content looks like an error message
        const isErrorContent = /error|not found|404|access denied|blocked|unavailable/i.test(fullContent);
        console.log(`- Is error content: ${isErrorContent}`);
        
        if (isErrorContent) {
          console.log(`❌ ERROR: Content appears to be an error message`);
          console.log(`Error content preview: "${fullContent.substring(0, 300)}"`);
        }
      }
      
      // Only proceed if we have substantial, valid content
      if (fullContent && fullContent.length > 300 && !/error|not found|404|access denied/i.test(fullContent)) {
        console.log(`✅ EXTRACTION SUCCESSFUL - Processing content...`);
        
        // Extract structured data from the content
        const extractedData = parseJobContent(fullContent, jobUrl, careerProfile);
        
        const job = {
          title: extractedData.title || jobUrl.title,
          company: extractedData.company || jobUrl.company,
          location: extractedData.location || 'Not specified',
          salary: extractedData.salary || {},
          jobUrl: jobUrl.url,
          sourcePlatform: jobUrl.sourcePlatform,
          fullContent: fullContent,
          postedDate: extractedData.postedDate || new Date().toISOString().split('T')[0],
          workArrangement: extractedData.workArrangement || 'unknown',
          matchReason: jobUrl.matchReason,
          experienceLevel: extractedData.experienceLevel || careerProfile.experienceLevel,
          keyRequirements: extractedData.keyRequirements || [],
          department: extractedData.department || 'Not specified',
          companySize: extractedData.companySize || 'Not specified',
          industry: extractedData.industry || 'Technology',
          benefits: extractedData.benefits || [],
          techStack: extractedData.techStack || [],
          extractionMethod: 'claude_web_content_extraction',
          extractedAt: new Date(),
          matchScore: calculateEnhancedMatchScore(extractedData, careerProfile),
          contentQuality: assessContentQuality(fullContent),
          metadata: {
            discoveryMethod: 'claude_web_search_and_extract',
            platform: jobUrl.sourcePlatform,
            extractedAt: new Date(),
            contentLength: fullContent.length,
            urlValidated: true,
            directCompanyPosting: true
          }
        };
        
        discoveredJobs.push(job);
        
        await search.addReasoningLog(
          'content_extraction',
          `Successfully extracted ${fullContent.length} characters from ${job.title} at ${job.company}`,
          {
            contentLength: fullContent.length,
            qualityScore: job.contentQuality,
            matchScore: job.matchScore,
            extractionSuccess: true
          },
          true
        );
        
        console.log(`✅ JOB CREATED: ${job.title} at ${job.company} (${fullContent.length} chars)`);
        
      } else {
        console.log(`❌ EXTRACTION FAILED: Insufficient or invalid content`);
        console.log(`- Content length: ${fullContent.length}`);
        console.log(`- Content preview: "${fullContent.substring(0, 200)}"`);
        
        await search.addReasoningLog(
          'content_extraction',
          `Failed to extract sufficient content from ${jobUrl.title} at ${jobUrl.company}`,
          {
            url: jobUrl.url,
            contentLength: fullContent.length,
            extractionSuccess: false,
            failureReason: fullContent.length === 0 ? 'No content returned' : 'Content too short or invalid'
          },
          false
        );
      }
      
      console.log(`=== END EXTRACTION DEBUG ===\n`);
      
      // Delay between extractions
      await new Promise(resolve => setTimeout(resolve, 3000));
      
    } catch (error) {
      console.error(`❌ EXTRACTION ERROR for ${jobUrl.url}:`, error);
      console.error(`Error details:`, {
        name: error.name,
        message: error.message,
        stack: error.stack?.split('\n')[0]
      });
      
      await search.addReasoningLog(
        'content_extraction',
        `Error extracting content from ${jobUrl.title}: ${error.message}`,
        {
          url: jobUrl.url,
          error: error.message,
          extractionSuccess: false
        },
        false
      );
    }
  }
  
  console.log(`\n📊 FINAL EXTRACTION RESULTS:`);
  console.log(`- URLs processed: ${jobUrls.length}`);
  console.log(`- Jobs successfully created: ${discoveredJobs.length}`);
  console.log(`- Success rate: ${Math.round((discoveredJobs.length / jobUrls.length) * 100)}%`);
  
  return discoveredJobs;
}

/**
 * Helper Functions
 */

function determineSourcePlatform(url) {
  const lowerUrl = url.toLowerCase();
  
  if (lowerUrl.includes('greenhouse.io')) return 'Greenhouse';
  if (lowerUrl.includes('lever.co')) return 'Lever';
  if (lowerUrl.includes('indeed.com')) return 'Indeed';
  if (lowerUrl.includes('linkedin.com')) return 'LinkedIn';
  if (lowerUrl.includes('workday.com')) return 'Workday';
  if (lowerUrl.includes('careers.') || lowerUrl.includes('/careers/')) return 'Company Career Page';
  if (lowerUrl.includes('bamboohr.com')) return 'BambooHR';
  if (lowerUrl.includes('smartrecruiters.com')) return 'SmartRecruiters';
  if (lowerUrl.includes('jobvite.com')) return 'Jobvite';
  
  return 'Other';
}

function isValidJobUrl(url) {
  if (!url || typeof url !== 'string') return false;
  
  const lowerUrl = url.toLowerCase();
  
  // Check if it's a valid HTTP/HTTPS URL
  if (!lowerUrl.startsWith('http://') && !lowerUrl.startsWith('https://')) return false;
  
  // Check if it contains job-related keywords
  const jobKeywords = [
    'job', 'jobs', 'career', 'careers', 'apply', 'position', 'opening',
    'greenhouse.io', 'lever.co', 'indeed.com', 'linkedin.com/jobs'
  ];
  
  return jobKeywords.some(keyword => lowerUrl.includes(keyword));
}

function parseJobContent(content, jobUrl, careerProfile) {
  console.log(`🔧 Parsing job content for: ${jobUrl.title}`);
  
  const data = {
    title: jobUrl.title,
    company: jobUrl.company
  };
  
  try {
    const lowerContent = content.toLowerCase();
    
    // Extract salary with better patterns
    const salaryPatterns = [
      /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*-?\s*\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)?/g,
      /(\d{1,3}(?:,\d{3})*)\s*-\s*(\d{1,3}(?:,\d{3})*)\s*(?:per year|annually|\/year)/gi,
      /salary.*?(\d{1,3}(?:,\d{3})*)/gi
    ];
    
    for (const pattern of salaryPatterns) {
      const salaryMatches = content.match(pattern);
      if (salaryMatches && salaryMatches.length > 0) {
        const salaryMatch = salaryMatches[0].match(/(\d{1,3}(?:,\d{3})*)/g);
        if (salaryMatch) {
          data.salary = {
            min: parseInt(salaryMatch[0].replace(/,/g, '')),
            max: salaryMatch[1] ? parseInt(salaryMatch[1].replace(/,/g, '')) : undefined,
            currency: 'USD'
          };
          console.log(`💰 Found salary: $${data.salary.min}${data.salary.max ? `-$${data.salary.max}` : ''}`);
          break;
        }
      }
    }
    
    // Extract work arrangement with more patterns
    const workPatterns = [
      { pattern: /remote.*?first|fully remote|100%\s*remote/i, arrangement: 'remote' },
      { pattern: /hybrid|flexible|mix of remote/i, arrangement: 'hybrid' },
      { pattern: /on-?site|in-?office|office-?based/i, arrangement: 'onsite' }
    ];
    
    for (const wp of workPatterns) {
      if (wp.pattern.test(content)) {
        data.workArrangement = wp.arrangement;
        console.log(`🏠 Found work arrangement: ${data.workArrangement}`);
        break;
      }
    }
    
    // Extract experience level
    const expPatterns = [
      { pattern: /senior|sr\.|lead/i, level: 'senior' },
      { pattern: /principal|staff|architect/i, level: 'lead' },
      { pattern: /junior|jr\.|entry|associate/i, level: 'junior' },
      { pattern: /director|vp|head of/i, level: 'executive' }
    ];
    
    for (const ep of expPatterns) {
      if (ep.pattern.test(content)) {
        data.experienceLevel = ep.level;
        console.log(`📈 Found experience level: ${data.experienceLevel}`);
        break;
      }
    }
    
    // Extract requirements with better keyword matching
    const skillKeywords = [
      'product management', 'product strategy', 'roadmap', 'analytics', 'data analysis',
      'ai', 'machine learning', 'artificial intelligence', 'python', 'sql', 'tableau',
      'javascript', 'react', 'node.js', 'aws', 'typescript', 'java', 'kubernetes',
      'agile', 'scrum', 'jira', 'figma', 'sketch', 'user research', 'a/b testing'
    ];
    
    data.keyRequirements = skillKeywords.filter(skill => 
      lowerContent.includes(skill.toLowerCase())
    );
    console.log(`🎯 Found ${data.keyRequirements.length} skill requirements`);
    
    // Extract benefits
    const benefitKeywords = [
      'health insurance', 'dental', 'vision', '401k', 'pto', 'vacation', 
      'equity', 'stock options', 'bonus', 'flexible hours', 'remote work'
    ];
    
    data.benefits = benefitKeywords.filter(benefit => 
      lowerContent.includes(benefit.toLowerCase())
    );
    console.log(`🎁 Found ${data.benefits.length} benefits`);
    
    // Extract location from content
    const locationPatterns = [
      /location:?\s*([^\n]+)/i,
      /based in:?\s*([^\n]+)/i,
      /office:?\s*([^\n]+)/i
    ];
    
    for (const pattern of locationPatterns) {
      const locationMatch = content.match(pattern);
      if (locationMatch) {
        data.location = locationMatch[1].trim();
        console.log(`📍 Found location: ${data.location}`);
        break;
      }
    }
    
    console.log(`✅ Content parsing completed for: ${jobUrl.title}`);
    
  } catch (error) {
    console.error(`❌ Error parsing job content for ${jobUrl.title}:`, error);
  }
  
  return data;
}


function calculateEnhancedMatchScore(jobData, careerProfile) {
  let score = 70; // Base score for Claude-discovered jobs
  
  // Title matching
  const jobTitle = (jobData.title || '').toLowerCase();
  const titleMatches = careerProfile.targetJobTitles?.some(target => 
    jobTitle.includes(target.toLowerCase()) || target.toLowerCase().includes(jobTitle)
  );
  if (titleMatches) score += 20;
  
  // Keyword matching
  const content = (jobData.fullContent || '').toLowerCase();
  const keywordMatches = careerProfile.targetKeywords?.filter(keyword => 
    content.includes(keyword.toLowerCase())
  ).length || 0;
  score += Math.min(keywordMatches * 3, 15);
  
  // Experience level matching
  if (jobData.experienceLevel && jobData.experienceLevel.toLowerCase() === careerProfile.experienceLevel?.toLowerCase()) {
    score += 10;
  }
  
  // Salary matching
  if (jobData.salary?.min && careerProfile.salaryExpectation?.min) {
    if (jobData.salary.min >= careerProfile.salaryExpectation.min * 0.8) {
      score += 10;
    }
  }
  
  // Work arrangement preference
  if (jobData.workArrangement && careerProfile.workArrangement) {
    if (jobData.workArrangement === careerProfile.workArrangement || 
        (careerProfile.workArrangement === 'remote' && jobData.workArrangement === 'hybrid')) {
      score += 5;
    }
  }
  
  return Math.min(Math.max(score, 0), 100);
}

function assessContentQuality(content) {
  if (!content) return 'low';
  
  const length = content.length;
  const hasRequirements = /requirements?|qualifications?|skills?/i.test(content);
  const hasResponsibilities = /responsibilit|duties|role|job description/i.test(content);
  const hasBenefits = /benefits?|perks|compensation|salary/i.test(content);
  const hasCompanyInfo = /company|about us|culture|mission/i.test(content);
  const hasWorkArrangement = /remote|hybrid|onsite|office|location/i.test(content);
  const hasApplyInfo = /apply|application|submit|contact/i.test(content);
  
  let qualityScore = 0;
  
  // Length scoring
  if (length > 3000) qualityScore += 4;
  else if (length > 2000) qualityScore += 3;
  else if (length > 1000) qualityScore += 2;
  else if (length > 500) qualityScore += 1;
  
  // Content sections scoring
  if (hasRequirements) qualityScore += 2;
  if (hasResponsibilities) qualityScore += 2;
  if (hasBenefits) qualityScore += 1;
  if (hasCompanyInfo) qualityScore += 1;
  if (hasWorkArrangement) qualityScore += 1;
  if (hasApplyInfo) qualityScore += 1;
  
  console.log(`📊 Content quality score: ${qualityScore}/12`);
  
  if (qualityScore >= 8) return 'high';
  else if (qualityScore >= 5) return 'medium';
  else return 'low';
}

/**
 * Enhanced save jobs function with Claude web search metadata
 */
async function saveJobsWithEnhancedMetadata(analyzedJobs, userId, searchId, search) {
  let savedCount = 0;
  
  for (const jobData of analyzedJobs) {
    try {
      // Enhanced duplicate checking
      const existing = await Job.findOne({
        userId,
        $or: [
          { sourceUrl: jobData.jobUrl },
          { 
            title: jobData.title, 
            company: jobData.company,
            sourcePlatform: { $regex: jobData.sourcePlatform, $options: 'i' }
          }
        ]
      });
      
      if (existing) {
        await search.addReasoningLog(
          'job_saving',
          `Skipped duplicate: "${jobData.title}" at ${jobData.company} (${jobData.sourcePlatform})`,
          { 
            reason: 'duplicate_prevention',
            originalPlatform: jobData.sourcePlatform 
          }
        );
        continue;
      }
      
      // Fix the sourcePlatform enum issue
      let sourcePlatform = `AI_FOUND_INTELLIGENT`;
      if (jobData.sourcePlatform && jobData.sourcePlatform.toLowerCase().includes('greenhouse')) {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      } else if (jobData.sourcePlatform && jobData.sourcePlatform.toLowerCase().includes('lever')) {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      } else if (jobData.sourcePlatform && jobData.sourcePlatform.toLowerCase().includes('indeed')) {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      } else {
        sourcePlatform = 'AI_FOUND_INTELLIGENT';
      }
      
      // Create enhanced job record with Claude web search data
      const job = new Job({
        userId,
        title: jobData.title,
        company: jobData.company,
        location: parseLocationEnhanced(jobData.location),
        description: jobData.fullContent,
        sourceUrl: jobData.jobUrl,
        sourcePlatform: sourcePlatform,
        isAiGenerated: true,
        applicationStatus: 'NOT_APPLIED',
        aiSearchId: searchId,
        salary: jobData.salary || {},
        jobType: jobData.jobType || 'FULL_TIME',
        
        // FIXED: Add proper analysis status to prevent infinite analysis loop
        analysisStatus: {
          status: 'completed',
          progress: 100,
          message: `Premium analysis complete! Found ${jobData.analysis?.keySkills?.length || 0} key skills via Claude web search.`,
          updatedAt: new Date(),
          completedAt: new Date(),
          canViewJob: true,
          skillsFound: jobData.analysis?.keySkills?.length || 0,
          experienceLevel: jobData.analysis?.experienceLevel,
          modelUsed: 'gpt-4o',
          analysisType: 'claude_web_search_discovery_premium',
          searchApproach: '3-phase-intelligent-claude-web-search',
          qualityLevel: 'premium'
        },
        
        // Enhanced parsed data (premium quality)
        parsedData: {
          requirements: jobData.analysis?.requirements || [],
          responsibilities: jobData.analysis?.responsibilities || [],
          qualifications: jobData.analysis?.qualifications || { required: [], preferred: [] },
          benefits: jobData.analysis?.benefits || jobData.benefits || [],
          keySkills: jobData.analysis?.keySkills || [],
          experienceLevel: jobData.analysis?.experienceLevel || jobData.experienceLevel || 'Mid',
          yearsOfExperience: jobData.analysis?.yearsOfExperience || { minimum: 3, preferred: 5 },
          educationRequirements: jobData.analysis?.educationRequirements || [],
          workArrangement: jobData.analysis?.workArrangement || jobData.workArrangement || 'unknown',
          industryContext: jobData.analysis?.industryContext || jobData.industry || 'technology',
          roleCategory: jobData.analysis?.roleCategory || 'general',
          technicalComplexity: jobData.analysis?.technicalComplexity || 'medium',
          leadershipRequired: jobData.analysis?.leadershipRequired || false,
          companyStage: jobData.analysis?.companyStage || jobData.companySize || 'unknown',
          extractedAt: new Date(),
          extractionMethod: 'claude_web_search_premium',
          // Enhanced Claude web search specific data
          claudeWebSearchData: {
            platform: jobData.sourcePlatform,
            originalUrl: jobData.jobUrl,
            postedDate: jobData.postedDate,
            matchReason: jobData.matchReason,
            techStack: jobData.techStack || [],
            department: jobData.department,
            directCompanyPosting: true,
            discoveryMethod: 'claude_web_search_api'
          },
          analysisMetadata: jobData.analysis?.analysisMetadata || {
            analyzedAt: new Date(),
            algorithmVersion: '3.2-claude-web-search-premium',
            model: 'gpt-4o',
            analysisType: 'claude_web_search_discovery_premium',
            qualityLevel: 'same_as_manual',
            discoveryPlatform: jobData.sourcePlatform
          }
        },
        
        // Enhanced AI search metadata for Claude web search
        aiSearchMetadata: {
          searchScore: jobData.matchScore || 85,
          discoveryMethod: 'claude_web_search_discovery',
          extractionSuccess: !jobData.analysisError,
          contentQuality: jobData.contentQuality || 'high',
          premiumAnalysis: jobData.premiumAnalysis || true,
          intelligentDiscovery: true,
          claudeWebSearchDiscovery: true,
          phase: '3-phase-intelligent-claude-web-search',
          originalPlatform: jobData.sourcePlatform,
          postedDate: jobData.postedDate,
          workArrangement: jobData.workArrangement,
          experienceLevel: jobData.experienceLevel,
          department: jobData.department,
          companySize: jobData.companySize,
          industry: jobData.industry,
          keyRequirements: jobData.keyRequirements || [],
          matchReason: jobData.matchReason,
          benefits: jobData.benefits || [],
          techStack: jobData.techStack || [],
          claudeWebSearchMetadata: {
            discoveryMethod: 'claude_web_search_api',
            extractionMethod: 'claude_web_content_extraction',
            searchQuery: jobData.searchQuery,
            foundAt: jobData.foundAt
          }
        }
      });
      
      await job.save();
      savedCount++;
      
      // Update search progress with Claude web search info
      await AiJobSearch.findByIdAndUpdate(searchId, {
        $inc: { jobsFoundToday: 1, totalJobsFound: 1 },
        $push: {
          jobsFound: {
            jobId: job._id,
            title: job.title,
            company: job.company,
            foundAt: new Date(),
            extractionMethod: 'claude_web_search_discovery',
            contentQuality: jobData.contentQuality,
            matchScore: jobData.matchScore,
            premiumAnalysis: true,
            sourcePlatform: jobData.sourcePlatform,
            directCompanyPosting: true
          }
        }
      });
      
      console.log(`✅ Saved: ${job.title} at ${job.company} (${jobData.sourcePlatform} - Claude web search discovery)`);
      
    } catch (error) {
      console.error(`Error saving job ${jobData.title}:`, error);
    }
  }
  
  return savedCount;
}
/**
 * Enhanced Phase 3: Premium Job Analysis (unchanged but with Claude web search context)
 */
async function performPremiumJobAnalysis(discoveredJobs, search) {
  const analyzedJobs = [];
  
  console.log(`🔬 Starting premium analysis of ${discoveredJobs.length} jobs from Claude web search with GPT-4o...`);
  
  // Process jobs in batches of 3 for efficiency
  const batchSize = 3;
  for (let i = 0; i < discoveredJobs.length; i += batchSize) {
    const batch = discoveredJobs.slice(i, i + batchSize);
    
    try {
      console.log(`  📊 Analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(discoveredJobs.length/batchSize)}...`);
      
      await search.addReasoningLog(
        'premium_analysis',
        `Analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}: ${batch.map(job => `"${job.title}" at ${job.company} (${job.sourcePlatform})`).join(', ')}`,
        {
          batchNumber: Math.floor(i/batchSize) + 1,
          jobsInBatch: batch.length,
          model: 'gpt-4o',
          discoveryMethod: 'Claude web search API',
          sourcePlatforms: [...new Set(batch.map(job => job.sourcePlatform))]
        }
      );
      
      const batchResults = await analyzeBatchWithGPT4o(batch);
      
      // Process batch results
      for (let j = 0; j < batch.length; j++) {
        const job = batch[j];
        const analysis = batchResults[j];
        
        const hasGoodAnalysis = analysis && 
          (analysis.requirements?.length > 0 || analysis.responsibilities?.length > 0) &&
          analysis.keySkills?.length > 0;
        
        analyzedJobs.push({
          ...job,
          analysis: analysis,
          analysisError: !hasGoodAnalysis ? 'Analysis incomplete' : null,
          premiumAnalysis: true,
          analysisQuality: 'premium',
          claudeWebSearchDiscovery: true
        });
        
        await search.addReasoningLog(
          'content_extraction',
          `"${job.title}" at ${job.company} (${job.sourcePlatform}) - ${hasGoodAnalysis ? 'Premium analysis successful' : 'Analysis incomplete'}`,
          {
            jobTitle: job.title,
            companyName: job.company,
            discoveryPlatform: job.sourcePlatform,
            contentLength: job.fullContent?.length || 0,
            skillsFound: analysis?.keySkills?.length || 0,
            hasRequirements: !!(analysis?.requirements?.length > 0),
            hasResponsibilities: !!(analysis?.responsibilities?.length > 0),
            experienceLevel: analysis?.experienceLevel,
            model: 'gpt-4o',
            quality: 'premium',
            discoveryMethod: 'Claude web search'
          },
          hasGoodAnalysis
        );
      }
      
      // Small delay between batches to be respectful
      if (i + batchSize < discoveredJobs.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
    } catch (error) {
      console.error(`Error analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}:`, error);
      
      // Add failed jobs with error
      batch.forEach(job => {
        analyzedJobs.push({
          ...job,
          analysis: null,
          analysisError: error.message,
          premiumAnalysis: false,
          claudeWebSearchDiscovery: true
        });
      });
    }
  }
  
  return analyzedJobs;
}

/**
 * Batch analysis with GPT-4o specifically for Claude web search content
 */
async function analyzeBatchWithGPT4o(jobBatch) {
  try {
    // Prepare batch content for analysis with Claude web search context
    const batchContent = jobBatch.map((job, index) => 
      `JOB ${index + 1} (${job.sourcePlatform}):
Title: ${job.title}
Company: ${job.company}
Source: ${job.sourcePlatform} (Found via Claude Web Search)
Location: ${job.location || 'Not specified'}
Tech Stack: ${job.techStack ? job.techStack.join(', ') : 'Not specified'}
Match Reason: ${job.matchReason || 'Not specified'}
Content: ${job.fullContent.substring(0, 2000)}...
---`
    ).join('\n\n');
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert job analyst providing premium analysis for jobs discovered via Claude's web search API. These are real job postings found through intelligent web search, similar to how jobs are found in general chat. Analyze multiple job postings and return detailed structured data for each. Focus on extracting comprehensive requirements, responsibilities, and skills with high accuracy. Return valid JSON array.`
        },
        {
          role: "user",
          content: `Analyze these ${jobBatch.length} job postings discovered via Claude web search and return detailed analysis for each:

${batchContent}

These jobs were discovered using Claude's web search API (same method as general chat), so they should have high-quality, comprehensive content from real job postings.

Return JSON array with ${jobBatch.length} objects in this EXACT format:
[
  {
    "requirements": ["Specific requirement 1", "Specific requirement 2"],
    "responsibilities": ["Key responsibility 1", "Key responsibility 2"],
    "qualifications": {
      "required": ["Must-have qualification 1", "Must-have qualification 2"],
      "preferred": ["Nice-to-have qualification 1", "Nice-to-have qualification 2"]
    },
    "keySkills": [
      {
        "name": "Python",
        "importance": 9,
        "category": "technical",
        "skillType": "programming"
      },
      {
        "name": "Leadership",
        "importance": 7,
        "category": "soft",
        "skillType": "management"
      }
    ],
    "experienceLevel": "mid/senior/lead",
    "yearsOfExperience": {
      "minimum": 3,
      "preferred": 5
    },
    "educationRequirements": ["Bachelor's degree in relevant field"],
    "benefits": ["Health insurance", "401k", "Remote work"],
    "salary": {
      "min": 120000,
      "max": 150000,
      "currency": "USD"
    },
    "workArrangement": "remote/hybrid/onsite",
    "industryContext": "technology/finance/healthcare",
    "roleCategory": "software-engineering/product-management",
    "technicalComplexity": "high/medium/low",
    "leadershipRequired": true/false,
    "companyStage": "startup/growth/enterprise"
  }
]

IMPORTANT:
- Skills importance: 9-10=critical, 7-8=very important, 5-6=important, 3-4=nice to have
- Extract comprehensive information from each job posting discovered via Claude web search
- These are high-quality job postings so expect detailed content
- Maintain high accuracy and detail level
- Return exactly ${jobBatch.length} analysis objects`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    
    if (jsonMatch) {
      const analyses = JSON.parse(jsonMatch[0]);
      
      // Ensure we have the right number of analyses
      if (analyses.length === jobBatch.length) {
        return analyses.map((analysis, index) => ({
          ...analysis,
          analysisMetadata: {
            analyzedAt: new Date(),
            algorithmVersion: '3.2-claude-web-search-premium',
            model: 'gpt-4o',
            analysisType: 'claude_web_search_discovery_premium',
            qualityLevel: 'same_as_manual',
            discoveryPlatform: jobBatch[index].sourcePlatform,
            claudeWebSearchDiscovery: true
          }
        }));
      }
    }
    
    // Fallback: return individual analyses
    return jobBatch.map((job) => createFallbackSingleAnalysis(job.sourcePlatform));
    
  } catch (error) {
    console.error('Error in GPT-4o batch analysis for Claude web search jobs:', error);
    return jobBatch.map((job) => createFallbackSingleAnalysis(job.sourcePlatform));
  }
}

/**
 * Create fallback single analysis for Claude web search
 */
function createFallbackSingleAnalysis(sourcePlatform = 'Unknown') {
  return {
    requirements: ['Relevant experience in the field'],
    responsibilities: ['Perform assigned duties effectively'],
    qualifications: {
      required: ['Relevant education or experience'],
      preferred: ['Additional qualifications preferred']
    },
    keySkills: [
      {
        name: 'Communication',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      },
      {
        name: 'Problem Solving',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      }
    ],
    experienceLevel: 'mid',
    yearsOfExperience: { minimum: 3, preferred: 5 },
    educationRequirements: ['Bachelor\'s degree preferred'],
    benefits: ['Competitive benefits package'],
    workArrangement: 'unknown',
    industryContext: 'general',
    roleCategory: 'general',
    technicalComplexity: 'medium',
    leadershipRequired: false,
    companyStage: 'unknown',
    analysisMetadata: {
      analyzedAt: new Date(),
      algorithmVersion: '3.2-claude-web-search-fallback',
      model: 'gpt-4o-fallback',
      analysisType: 'claude_web_search_discovery_fallback',
      discoveryPlatform: sourcePlatform,
      claudeWebSearchDiscovery: true
    }
  };
}

/**
 * Enhanced career analysis for Claude web search targeting
 */
async function analyzeCareerTrajectoryEnhanced(resumeData) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert career strategist. Analyze resume data to create targeted job search criteria for AI job discovery using Claude's web search API. Focus on generating specific, searchable job titles and keywords that will find the best opportunities through web search. Return only valid JSON.`
        },
        {
          role: "user",
          content: `Analyze this career data and create targeted search criteria for Claude web search job discovery:

Experience: ${JSON.stringify(resumeData.experience?.slice(0, 3), null, 2)}
Skills: ${JSON.stringify(resumeData.skills?.slice(0, 15), null, 2)}
Education: ${JSON.stringify(resumeData.education?.slice(0, 2), null, 2)}

Create targeted search criteria in this EXACT JSON format for Claude web search:
{
  "targetJobTitles": [
    "Primary Target Title",
    "Alternative Title 1", 
    "Alternative Title 2",
    "Growth Opportunity Title"
  ],
  "targetKeywords": [
    "keyword1", "keyword2", "keyword3"
  ],
  "experienceLevel": "Mid/Senior/Lead",
  "industries": ["Industry 1", "Industry 2"],
  "preferredLocations": ["Remote", "Major City"],
  "salaryExpectation": {
    "min": 120000,
    "max": 180000,
    "currency": "USD"
  },
  "mustHaveSkills": ["Critical Skill 1", "Critical Skill 2"],
  "niceToHaveSkills": ["Bonus Skill 1", "Bonus Skill 2"],
  "avoidKeywords": ["keyword to avoid"],
  "workArrangement": "remote/hybrid/onsite",
  "careerDirection": "Brief description of career goals",
  "targetCompanyTypes": ["Startup", "Scale-up", "Enterprise"],
  "webSearchPreferences": {
    "focus": "Direct company postings and reputable job boards",
    "avoid": "Recruitment agencies and low-quality job aggregators",
    "prioritize": "Greenhouse, Lever, Indeed, LinkedIn, company career pages"
  }
}

Focus on:
1. Specific job titles that match experience level and are commonly searched
2. Keywords that companies actually use in job postings
3. Realistic salary expectations based on current market
4. Skills that are in high demand
5. Company types and job boards that typically have quality postings
6. Avoiding overqualified or underqualified positions`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    
    return createEnhancedFallbackCareerProfile(resumeData);
    
  } catch (error) {
    console.error('Error in enhanced career trajectory analysis:', error);
    return createEnhancedFallbackCareerProfile(resumeData);
  }
}

/**
 * Enhanced fallback career profile for Claude web search
 */
function createEnhancedFallbackCareerProfile(resumeData) {
  return {
    targetJobTitles: [
      resumeData.experience?.[0]?.title || 'Software Engineer',
      'Senior Software Engineer',
      'Software Developer',
      'Full Stack Developer'
    ],
    targetKeywords: [
      'software development',
      'programming',
      'engineering',
      'technology'
    ],
    experienceLevel: calculateExperienceLevel(resumeData.experience),
    industries: ['Technology', 'Software', 'SaaS'],
    preferredLocations: ['Remote', 'San Francisco', 'New York', 'Austin'],
    salaryExpectation: {
      min: 100000,
      max: 150000,
      currency: 'USD'
    },
    mustHaveSkills: resumeData.skills?.slice(0, 3).map(s => typeof s === 'string' ? s : s.name) || [],
    niceToHaveSkills: resumeData.skills?.slice(3, 6).map(s => typeof s === 'string' ? s : s.name) || [],
    workArrangement: 'remote',
    careerDirection: 'Software engineering role with growth opportunities',
    targetCompanyTypes: ['Startup', 'Scale-up', 'Enterprise'],
    webSearchPreferences: {
      focus: 'Direct company postings and reputable job boards',
      avoid: 'Recruitment agencies and low-quality job aggregators',
      prioritize: 'Greenhouse, Lever, Indeed, LinkedIn, company career pages'
    }
  };
}

function parseLocationEnhanced(locationString) {
  if (!locationString) return { remote: true };
  
  const lower = locationString.toLowerCase();
  const remote = lower.includes('remote') || lower.includes('anywhere');
  
  if (remote) {
    return {
      remote: true,
      city: lower.includes('remote') ? null : extractCity(locationString),
      country: 'USA'
    };
  }
  
  const parts = locationString.split(',').map(p => p.trim());
  return {
    city: parts[0] || null,
    state: parts[1] || null,
    country: parts[2] || 'USA',
    remote: false
  };
}

function extractCity(locationString) {
  const parts = locationString.split(',').map(p => p.trim());
  return parts.find(part => !part.toLowerCase().includes('remote')) || null;
}

// Keep all existing utility functions
function extractSearchCriteria(resumeData) {
  return {
    jobTitle: resumeData.experience?.[0]?.title || 'Software Engineer',
    skills: resumeData.skills?.slice(0, 10).map(s => typeof s === 'string' ? s : s.name) || [],
    location: resumeData.contactInfo?.location || 'Remote',
    experienceLevel: calculateExperienceLevel(resumeData.experience)
  };
}

function calculateExperienceLevel(experiences) {
  const years = calculateYearsOfExperience(experiences);
  if (years < 2) return 'Entry';
  if (years < 5) return 'Mid';
  if (years < 10) return 'Senior';
  return 'Lead';
}

function calculateYearsOfExperience(experiences) {
  if (!experiences?.length) return 0;
  
  const sorted = experiences
    .filter(exp => exp.startDate)
    .sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
  
  if (!sorted.length) return 0;
  
  const first = new Date(sorted[0].startDate);
  const last = sorted[sorted.length - 1].endDate 
    ? new Date(sorted[sorted.length - 1].endDate)
    : new Date();
  
  return Math.round((last - first) / (1000 * 60 * 60 * 24 * 365));
}

async function isDailyLimitReached(search) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  if (!search.lastSearchDate || search.lastSearchDate < today) {
    search.jobsFoundToday = 0;
    search.lastSearchDate = today;
    await search.save();
    return false;
  }
  
  return search.jobsFoundToday >= search.dailyLimit;
}

async function updateSearchStatus(searchId, status, message) {
  await AiJobSearch.findByIdAndUpdate(searchId, {
    status,
    lastUpdateMessage: message,
    lastUpdated: new Date()
  });
  console.log(`Search ${searchId}: ${status} - ${message}`);
}

// Export existing functions for compatibility
exports.getUserAiSearches = async (userId) => {
  return await AiJobSearch.find({ userId }).sort({ createdAt: -1 });
};

exports.pauseAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Claude web search paused by user request',
    { phase: 'user_pause', pausedAt: new Date() }
  );
  
  search.status = 'paused';
  search.lastUpdateMessage = 'Paused by user';
  await search.save();
  
  return { message: 'Claude web search paused successfully' };
};

exports.resumeAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'initialization',
    'Claude web search resumed by user - continuing with ENHANCED 3-Phase approach using Claude web search API',
    { 
      phase: 'user_resume', 
      resumedAt: new Date(),
      searchMethod: 'Claude web search API (same as general chat)'
    }
  );
  
  search.status = 'running';
  search.lastUpdateMessage = 'Resumed by user - Claude web search';
  await search.save();
  
  const resume = await Resume.findById(search.resumeId);
  if (resume) {
    performEnhancedJobSearch(searchId, userId, resume).catch(error => {
      console.error('Error resuming Claude web search:', error);
    });
  }
  
  return { message: 'Claude web search resumed successfully with enhanced approach' };
};

exports.deleteAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Claude web search cancelled by user request',
    { 
      phase: 'user_cancellation', 
      cancelledAt: new Date(),
      searchMethod: 'Claude web search API'
    }
  );
  
  search.status = 'cancelled';
  search.lastUpdateMessage = 'Cancelled by user';
  await search.save();
  
  return { message: 'Claude web search cancelled successfully' };
};

================
File: services/memoryService.js
================
// backend/services/memoryService.js
const { openai } = require('../config/openai');
const UserMemory = require('../models/mongodb/userMemory.model');
const Conversation = require('../models/mongodb/conversation.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');

class MemoryService {
  /**
   * Extract memories from a conversation message using AI
   */
  static async extractMemoriesFromMessage(userId, message, conversationContext = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId) || 
                        await UserMemory.createForUser(userId);

      // Get existing memories for context
      const existingMemories = userMemory.getRelevantMemories({
        types: ['preference', 'skill', 'career_goal', 'personality_trait'],
        tags: conversationContext.tags || []
      }, 5);

      const systemPrompt = this.buildMemoryExtractionPrompt(existingMemories, conversationContext);
      
      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: message }
        ],
        temperature: 0.3,
        max_tokens: 800,
        response_format: { type: 'json_object' }
      });

      const extractedData = JSON.parse(response.choices[0].message.content);
      const memories = [];

      // Process extracted memories
      if (extractedData.memories && extractedData.memories.length > 0) {
        for (const memoryData of extractedData.memories) {
          const memory = await this.addMemoryToUser(userId, {
            ...memoryData,
            source: {
              conversationId: conversationContext.conversationId,
              messageId: conversationContext.messageId,
              extractionMethod: 'ai_extracted',
              model: 'gpt-4-turbo-preview'
            },
            context: conversationContext
          });
          memories.push(memory);
        }
      }

      return {
        memories,
        insights: extractedData.insights || [],
        profileUpdates: extractedData.profileUpdates || {}
      };

    } catch (error) {
      console.error('Memory extraction error:', error);
      return { memories: [], insights: [], profileUpdates: {} };
    }
  }

  /**
   * Add a memory to user's memory system
   */
  static async addMemoryToUser(userId, memoryData) {
    try {
      let userMemory = await UserMemory.findByUserId(userId);
      
      if (!userMemory) {
        userMemory = await UserMemory.createForUser(userId);
      }

      const memory = userMemory.addMemory(memoryData);
      await userMemory.save();

      return memory;

    } catch (error) {
      console.error('Add memory error:', error);
      throw error;
    }
  }

  /**
   * Get relevant memories for AI context
   */
  static async getRelevantMemoriesForContext(userId, context) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return [];

      const relevantMemories = userMemory.getRelevantMemories(context, 15);
      
      // Update access count for retrieved memories
      relevantMemories.forEach(memory => {
        memory.usage.accessCount += 1;
        memory.usage.lastAccessedAt = new Date();
      });

      await userMemory.save();

      return relevantMemories;

    } catch (error) {
      console.error('Get relevant memories error:', error);
      return [];
    }
  }

  /**
   * Build context for AI assistant using memories
   */
  static async buildAIContext(userId, currentContext = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return '';

      // Get different types of relevant memories
      const personalityMemories = userMemory.getMemoriesByType('personality_trait', { 
        minConfidence: 0.6, 
        sortBy: 'confidence' 
      }).slice(0, 3);

      const preferenceMemories = userMemory.getMemoriesByType('preference', { 
        minConfidence: 0.6, 
        sortBy: 'recent' 
      }).slice(0, 5);

      const skillMemories = userMemory.getMemoriesByType('skill', { 
        minConfidence: 0.7, 
        sortBy: 'confidence' 
      }).slice(0, 5);

      const goalMemories = userMemory.getMemoriesByType('career_goal', { 
        minConfidence: 0.6, 
        sortBy: 'recent' 
      }).slice(0, 3);

      // Build context string
      let context = '\n=== USER MEMORY CONTEXT ===\n';

      if (personalityMemories.length > 0) {
        context += '\nPersonality & Communication Style:\n';
        personalityMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (preferenceMemories.length > 0) {
        context += '\nPreferences & Work Style:\n';
        preferenceMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (skillMemories.length > 0) {
        context += '\nSkills & Experience:\n';
        skillMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (goalMemories.length > 0) {
        context += '\nCareer Goals & Aspirations:\n';
        goalMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      // Add profile insights
      if (userMemory.profile && Object.keys(userMemory.profile).length > 0) {
        context += '\nUser Profile Insights:\n';
        
        if (userMemory.profile.careerStage) {
          context += `- Career Stage: ${userMemory.profile.careerStage}\n`;
        }
        
        if (userMemory.profile.communicationStyle) {
          const style = userMemory.profile.communicationStyle;
          context += `- Communication Preference: ${style.formality || 'neutral'} formality, ${style.detail_preference || 'moderate'} detail level\n`;
        }
      }

      context += '\n=== END MEMORY CONTEXT ===\n\n';
      context += 'IMPORTANT: Use this memory context to personalize your responses, but don\'t explicitly mention that you\'re using memory unless directly asked about it.\n';

      return context;

    } catch (error) {
      console.error('Build AI context error:', error);
      return '';
    }
  }

  /**
   * Update user profile based on conversation patterns
   */
  static async updateUserProfile(userId, conversationData) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return;

      // Analyze conversation patterns
      const analysis = await this.analyzeConversationPatterns(conversationData);
      
      // Update profile based on analysis
      if (analysis.communicationStyle) {
        userMemory.profile.communicationStyle = {
          ...userMemory.profile.communicationStyle,
          ...analysis.communicationStyle
        };
      }

      if (analysis.skills && analysis.skills.length > 0) {
        userMemory.profile.skills = userMemory.profile.skills || [];
        analysis.skills.forEach(skill => {
          const existingSkill = userMemory.profile.skills.find(s => s.name === skill.name);
          if (existingSkill) {
            existingSkill.confidence = Math.max(existingSkill.confidence, skill.confidence);
            existingSkill.lastMentioned = new Date();
          } else {
            userMemory.profile.skills.push({
              ...skill,
              lastMentioned: new Date()
            });
          }
        });
      }

      await userMemory.save();

    } catch (error) {
      console.error('Update user profile error:', error);
    }
  }

  /**
   * Generate conversation summary with memory extraction
   */
  static async generateConversationSummary(conversationId) {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) throw new Error('Conversation not found');

      const messages = conversation.messages.slice(-20); // Last 20 messages
      const messageText = messages.map(m => `${m.type.toUpperCase()}: ${m.content}`).join('\n');

      const systemPrompt = `You are an AI assistant that creates intelligent conversation summaries with memory extraction.

Analyze this conversation and provide:
1. A concise summary of what was discussed
2. Key topics covered
3. Action items or outcomes
4. Important memories that should be retained about the user
5. User preferences or patterns observed

Format your response as JSON:
{
  "summary": "Brief summary of the conversation",
  "keyTopics": ["topic1", "topic2", "topic3"],
  "actionItems": ["action1", "action2"],
  "outcomes": ["outcome1", "outcome2"],
  "memories": [
    {
      "type": "preference|skill|career_goal|personality_trait|etc",
      "category": "personal|professional|technical|behavioral|contextual",
      "content": "What you learned about the user",
      "confidence": 0.8,
      "importance": "low|medium|high|critical",
      "tags": ["tag1", "tag2"]
    }
  ],
  "insights": ["insight1", "insight2"]
}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: messageText }
        ],
        temperature: 0.3,
        max_tokens: 1000,
        response_format: { type: 'json_object' }
      });

      const summaryData = JSON.parse(response.choices[0].message.content);

      // Update conversation with summary
      conversation.updateSummary({
        content: summaryData.summary,
        keyTopics: summaryData.keyTopics || [],
        actionItems: summaryData.actionItems || [],
        outcomes: summaryData.outcomes || []
      });

      await conversation.save();

      // Extract and store memories
      if (summaryData.memories && summaryData.memories.length > 0) {
        for (const memoryData of summaryData.memories) {
          await this.addMemoryToUser(conversation.userId, {
            ...memoryData,
            source: {
              conversationId: conversationId,
              extractionMethod: 'summary_extracted',
              model: 'gpt-4-turbo-preview'
            }
          });
        }
      }

      return summaryData;

    } catch (error) {
      console.error('Generate conversation summary error:', error);
      throw error;
    }
  }

  /**
   * Search memories with intelligent ranking
   */
  static async searchMemories(userId, query, options = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return [];

      // First, do a basic text search
      let memories = userMemory.searchMemories(query, options);

      // If we have few results, use AI for semantic search
      if (memories.length < 5) {
        const semanticMemories = await this.semanticMemorySearch(userMemory, query);
        memories = [...memories, ...semanticMemories];
        
        // Remove duplicates
        memories = memories.filter((memory, index, self) => 
          index === self.findIndex(m => m.id === memory.id)
        );
      }

      // Rank memories by relevance
      return memories.sort((a, b) => {
        const aScore = this.calculateSearchRelevance(a, query);
        const bScore = this.calculateSearchRelevance(b, query);
        return bScore - aScore;
      });

    } catch (error) {
      console.error('Search memories error:', error);
      return [];
    }
  }

  /**
   * Perform memory cleanup and optimization
   */
  static async performMemoryMaintenance(userId) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return;

      // Decay old memories
      const decayedCount = userMemory.decayMemories();

      // Merge similar memories
      const mergedCount = await this.mergeSimilarMemories(userMemory);

      // Update profile
      userMemory.updateProfile();

      await userMemory.save();

      return {
        decayedMemories: decayedCount,
        mergedMemories: mergedCount,
        totalMemories: userMemory.analytics.totalMemories
      };

    } catch (error) {
      console.error('Memory maintenance error:', error);
      return null;
    }
  }

  // ===================================================================
  // PRIVATE HELPER METHODS
  // ===================================================================

  /**
   * Build system prompt for memory extraction
   */
  static buildMemoryExtractionPrompt(existingMemories, context) {
    let prompt = `You are an AI memory extraction system. Analyze user messages to extract meaningful memories about their preferences, skills, goals, personality, and work style.

EXISTING MEMORIES (to avoid duplicates):
${existingMemories.map(m => `- ${m.type}: ${m.content}`).join('\n')}

CONTEXT:
- Page: ${context.page || 'unknown'}
- Category: ${context.category || 'general'}

Extract memories in this JSON format:
{
  "memories": [
    {
      "type": "preference|skill|career_goal|experience|achievement|challenge|personality_trait|communication_style|work_style|industry_knowledge|tool_preference|feedback_pattern",
      "category": "personal|professional|technical|behavioral|contextual",
      "content": "Clear, specific statement about the user",
      "confidence": 0.1-1.0,
      "importance": "low|medium|high|critical",
      "tags": ["relevant", "tags"]
    }
  ],
  "insights": ["Observable patterns or insights about the user"],
  "profileUpdates": {
    "communicationStyle": {
      "formality": "very_formal|formal|neutral|casual|very_casual",
      "detail_preference": "brief|moderate|detailed|comprehensive"
    }
  }
}

Only extract memories that are:
1. Specific and actionable
2. Likely to be useful for future conversations
3. Not duplicating existing memories
4. Expressed with reasonable confidence

IMPORTANT: Only extract memories if the user message contains clear, specific information. Don't infer too much from brief responses.`;

    return prompt;
  }

  /**
   * Analyze conversation patterns
   */
  static async analyzeConversationPatterns(conversationData) {
    try {
      // Simple pattern analysis - can be enhanced with ML
      const analysis = {
        communicationStyle: {},
        skills: [],
        preferences: []
      };

      // Analyze message length patterns
      const avgMessageLength = conversationData.userMessages?.reduce((sum, msg) => 
        sum + msg.content.length, 0) / (conversationData.userMessages?.length || 1);

      if (avgMessageLength < 50) {
        analysis.communicationStyle.detail_preference = 'brief';
      } else if (avgMessageLength > 200) {
        analysis.communicationStyle.detail_preference = 'detailed';
      } else {
        analysis.communicationStyle.detail_preference = 'moderate';
      }

      // Analyze formality
      const formalWords = ['please', 'thank you', 'would you', 'could you'];
      const casualWords = ['hey', 'thanks', 'cool', 'awesome'];
      
      let formalCount = 0;
      let casualCount = 0;

      conversationData.userMessages?.forEach(msg => {
        const content = msg.content.toLowerCase();
        formalWords.forEach(word => {
          if (content.includes(word)) formalCount++;
        });
        casualWords.forEach(word => {
          if (content.includes(word)) casualCount++;
        });
      });

      if (formalCount > casualCount) {
        analysis.communicationStyle.formality = 'formal';
      } else if (casualCount > formalCount) {
        analysis.communicationStyle.formality = 'casual';
      } else {
        analysis.communicationStyle.formality = 'neutral';
      }

      return analysis;

    } catch (error) {
      console.error('Analyze conversation patterns error:', error);
      return {};
    }
  }

/**
 * Semantic memory search using AI - FIXED VERSION
 */
static async semanticMemorySearch(userMemory, query) {
  try {
    const allMemories = userMemory.memories.filter(m => m.isActive);
    if (allMemories.length === 0) {
      return [];
    }

    const memoryContents = allMemories.map(m => `${m.id}: ${m.content}`).join('\n');

    const systemPrompt = `Find memories that are semantically related to the user's query, even if they don't contain exact keywords.

MEMORIES:
${memoryContents}

USER QUERY: ${query}

Return ONLY a JSON array of memory IDs that are relevant: ["memory_id_1", "memory_id_2"]
If no memories are relevant, return an empty array: []`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: query }
      ],
      temperature: 0.3,
      max_tokens: 200,
      response_format: { type: 'json_object' }
    });

    console.log('🔍 Semantic search response:', response.choices[0].message.content);

    // FIXED: Proper JSON parsing and validation
    let parsedResponse;
    try {
      parsedResponse = JSON.parse(response.choices[0].message.content);
    } catch (parseError) {
      console.warn('Failed to parse semantic search response:', parseError);
      return [];
    }

    // FIXED: Handle different response formats
    let relevantIds = [];
    if (Array.isArray(parsedResponse)) {
      relevantIds = parsedResponse;
    } else if (parsedResponse.ids && Array.isArray(parsedResponse.ids)) {
      relevantIds = parsedResponse.ids;
    } else if (parsedResponse.results && Array.isArray(parsedResponse.results)) {
      relevantIds = parsedResponse.results;
    } else if (parsedResponse.relevant_memories && Array.isArray(parsedResponse.relevant_memories)) {
      // FIXED: Handle the actual response format the AI is using
      relevantIds = parsedResponse.relevant_memories;
    } else {
      console.warn('Unexpected semantic search response format:', parsedResponse);
      return [];
    }

    // FIXED: Ensure relevantIds is an array before using includes
    if (!Array.isArray(relevantIds)) {
      console.warn('relevantIds is not an array:', relevantIds);
      return [];
    }

    console.log('✅ Found relevant memory IDs:', relevantIds);
    const foundMemories = allMemories.filter(m => relevantIds.includes(m.id));
    console.log('✅ Returning', foundMemories.length, 'relevant memories');
    
    return foundMemories;

  } catch (error) {
    console.error('Semantic memory search error:', error);
    return [];
  }
}

  /**
   * Calculate search relevance score
   */
  static calculateSearchRelevance(memory, query) {
    const queryLower = query.toLowerCase();
    const contentLower = memory.content.toLowerCase();
    
    let score = memory.confidence;

    // Exact phrase match
    if (contentLower.includes(queryLower)) {
      score += 0.5;
    }

    // Word matches
    const queryWords = queryLower.split(' ');
    const contentWords = contentLower.split(' ');
    const matchedWords = queryWords.filter(word => contentWords.includes(word));
    score += (matchedWords.length / queryWords.length) * 0.3;

    // Tag matches
    const tagMatches = memory.tags.filter(tag => 
      tag.includes(queryLower) || queryLower.includes(tag)
    );
    score += tagMatches.length * 0.2;

    // Importance boost
    const importanceBoost = {
      'critical': 0.3,
      'high': 0.2,
      'medium': 0.1,
      'low': 0
    };
    score += importanceBoost[memory.importance] || 0;

    return Math.min(score, 1);
  }

  /**
   * Merge similar memories to reduce redundancy
   */
  static async mergeSimilarMemories(userMemory) {
    let mergedCount = 0;
    const memoriesToRemove = [];

    for (let i = 0; i < userMemory.memories.length; i++) {
      for (let j = i + 1; j < userMemory.memories.length; j++) {
        const memory1 = userMemory.memories[i];
        const memory2 = userMemory.memories[j];

        if (memory1.type === memory2.type && 
            memory1.category === memory2.category &&
            userMemory.calculateSimilarity(memory1.content, memory2.content) > 0.85) {
          
          // Merge the memories
          const strongerMemory = memory1.confidence >= memory2.confidence ? memory1 : memory2;
          const weakerMemory = memory1.confidence < memory2.confidence ? memory1 : memory2;

          strongerMemory.confidence = Math.min(1, strongerMemory.confidence + 0.1);
          strongerMemory.decay.reinforcementCount += weakerMemory.decay.reinforcementCount;
          strongerMemory.tags = [...new Set([...strongerMemory.tags, ...weakerMemory.tags])];

          memoriesToRemove.push(weakerMemory.id);
          mergedCount++;
        }
      }
    }

    // Remove merged memories
    userMemory.memories = userMemory.memories.filter(m => !memoriesToRemove.includes(m.id));

    return mergedCount;
  }
}

module.exports = MemoryService;

================
File: services/realJobBoard.service.js
================
// services/realJobBoard.service.js - REAL JOB BOARD INTEGRATION UTILITIES
const { anthropic } = require('../config/anthropic');

/**
 * Real Job Board Integration Service
 * Handles validation, URL extraction, and platform-specific logic
 * for Greenhouse, Lever, and Indeed integrations
 */

/**
 * Validate if a URL is from a supported real job board
 */
exports.validateJobBoardUrl = (url, expectedPlatform = null) => {
  if (!url || typeof url !== 'string') return false;
  
  const lowerUrl = url.toLowerCase();
  const validPlatforms = {
    greenhouse: [
      'greenhouse.io/jobs',
      'greenhouse.io/job',
      'boards.greenhouse.io'
    ],
    lever: [
      'jobs.lever.co',
      'lever.co/jobs'
    ],
    indeed: [
      'indeed.com/viewjob',
      'indeed.com/jobs',
      'indeed.com/job'
    ]
  };
  
  if (expectedPlatform) {
    const patterns = validPlatforms[expectedPlatform.toLowerCase()];
    return patterns ? patterns.some(pattern => lowerUrl.includes(pattern)) : false;
  }
  
  // Check all platforms
  return Object.values(validPlatforms).flat().some(pattern => lowerUrl.includes(pattern));
};

/**
 * Extract job board platform from URL
 */
exports.extractJobBoardPlatform = (url) => {
  if (!url) return null;
  
  const lowerUrl = url.toLowerCase();
  
  if (lowerUrl.includes('greenhouse.io')) return 'Greenhouse';
  if (lowerUrl.includes('lever.co')) return 'Lever';
  if (lowerUrl.includes('indeed.com')) return 'Indeed';
  
  return null;
};

/**
 * Extract platform-specific job identifiers
 */
exports.extractJobIdentifiers = (url, platform) => {
  if (!url || !platform) return {};
  
  const lowerUrl = url.toLowerCase();
  const identifiers = {};
  
  try {
    switch (platform.toLowerCase()) {
      case 'greenhouse':
        // Extract Greenhouse job ID
        const greenhouseMatch = url.match(/\/jobs\/(\d+)/i);
        if (greenhouseMatch) {
          identifiers.greenhouseJobId = greenhouseMatch[1];
        }
        
        // Extract office ID if present
        const officeMatch = url.match(/office_id=(\d+)/i);
        if (officeMatch) {
          identifiers.greenhouseOfficeId = officeMatch[1];
        }
        break;
        
      case 'lever':
        // Extract Lever posting ID
        const leverMatch = url.match(/jobs\.lever\.co\/([^\/]+)\/([^\/\?]+)/i);
        if (leverMatch) {
          identifiers.leverCompany = leverMatch[1];
          identifiers.leverPostingId = leverMatch[2];
        }
        break;
        
      case 'indeed':
        // Extract Indeed job key
        const indeedMatch = url.match(/jk=([^&]+)/i);
        if (indeedMatch) {
          identifiers.indeedJobKey = indeedMatch[1];
        }
        
        // Extract company ID if present
        const companyMatch = url.match(/cmp=([^&]+)/i);
        if (companyMatch) {
          identifiers.indeedCompanyId = companyMatch[1];
        }
        break;
    }
  } catch (error) {
    console.error('Error extracting job identifiers:', error);
  }
  
  return identifiers;
};

/**
 * Generate platform-specific search queries for Claude
 */
exports.generatePlatformSearchQueries = (careerProfile) => {
  const { targetJobTitles, targetKeywords, preferredLocations, experienceLevel } = careerProfile;
  
  const baseQueries = targetJobTitles.map(title => ({
    jobTitle: title,
    keywords: targetKeywords.slice(0, 5),
    locations: preferredLocations.slice(0, 3),
    experienceLevel
  }));
  
  return {
    greenhouse: baseQueries.map(query => ({
      ...query,
      platform: 'Greenhouse',
      searchContext: 'Tech startups and scale-ups with comprehensive job details',
      urlPattern: 'company.greenhouse.io/jobs',
      focusAreas: ['startups', 'tech companies', 'scale-ups', 'venture-backed companies']
    })),
    
    lever: baseQueries.map(query => ({
      ...query,
      platform: 'Lever',
      searchContext: 'Growth-stage companies with detailed role information',
      urlPattern: 'jobs.lever.co/company',
      focusAreas: ['growth companies', 'series A-C companies', 'expanding teams']
    })),
    
    indeed: baseQueries.map(query => ({
      ...query,
      platform: 'Indeed',
      searchContext: 'Established companies with verified direct postings',
      urlPattern: 'indeed.com/viewjob',
      focusAreas: ['established companies', 'direct postings', 'verified employers']
    }))
  };
};

/**
 * Enhanced Claude prompt for real job board discovery
 */
exports.createRealJobBoardSearchPrompt = (careerProfile) => {
  const searchQueries = this.generatePlatformSearchQueries(careerProfile);
  
  return `You are an expert job hunter with access to web search. Find 8-12 high-quality job opportunities from REAL company job boards.

TARGET PROFILE:
- Job Titles: ${careerProfile.targetJobTitles?.join(', ')}
- Keywords: ${careerProfile.targetKeywords?.join(', ')}
- Experience Level: ${careerProfile.experienceLevel}
- Industries: ${careerProfile.industries?.join(', ')}
- Locations: ${careerProfile.preferredLocations?.join(', ')}
- Salary Range: $${careerProfile.salaryExpectation?.min || 100000}-${careerProfile.salaryExpectation?.max || 150000}

SEARCH STRATEGY - TARGET THESE SPECIFIC PLATFORMS:

🌱 **GREENHOUSE JOBS** (Priority: Tech Startups & Scale-ups)
- Search for: [company].greenhouse.io/jobs URLs
- Target: VC-backed startups, tech scale-ups, innovative companies
- Look for: Comprehensive job descriptions, team info, tech stacks
- Focus companies: Well-funded startups, Series A-C companies

⚡ **LEVER JOBS** (Priority: Growth Companies)  
- Search for: jobs.lever.co/[company] URLs
- Target: Fast-growing companies, expanding teams
- Look for: Detailed role descriptions, hiring manager info
- Focus companies: Scale-ups, growth-stage companies

🔍 **INDEED** (Priority: Direct Company Postings ONLY)
- Search for: indeed.com/viewjob URLs from direct company postings
- Target: Established companies posting directly (NOT recruiters)
- Avoid: Staffing agencies, third-party recruiters
- Focus: Verified company accounts, direct employer postings

SEARCH PROCESS:
1. **Search each platform systematically** for the target job titles
2. **Verify URL authenticity** - ensure URLs match the expected patterns
3. **Extract comprehensive job content** from actual job posting pages
4. **Prioritize quality over quantity** - focus on complete, detailed postings
5. **Validate company legitimacy** - check for real companies with good reputations

CONTENT REQUIREMENTS:
- Each job MUST have substantial content (minimum 400 words)
- Include tech stack, team information when available
- Extract salary information if posted
- Capture application deadlines and hiring manager details
- Verify the job posting is recent (within 30 days)

Return JSON array with 8-12 verified jobs:
[
  {
    "title": "Senior Software Engineer",
    "company": "TechStartup Inc",
    "location": "San Francisco, CA (Remote OK)",
    "salary": {
      "min": 140000,
      "max": 190000,
      "currency": "USD"
    },
    "jobUrl": "https://techstartup.greenhouse.io/jobs/4567890",
    "sourcePlatform": "Greenhouse",
    "fullContent": "Complete job description extracted from the actual Greenhouse posting page...",
    "postedDate": "2024-01-15",
    "workArrangement": "hybrid",
    "experienceLevel": "Senior",
    "department": "Engineering",
    "techStack": ["Python", "React", "PostgreSQL", "AWS", "Docker"],
    "hiringManager": "Jane Smith, Engineering Manager",
    "teamSize": "12-person engineering team",
    "benefits": ["Equity", "Health insurance", "Unlimited PTO"],
    "applicationDeadline": "2024-02-15",
    "companySize": "Series B (50-100 employees)",
    "industry": "SaaS",
    "matchReason": "Perfect match for Python/React experience and senior level"
  }
]

CRITICAL VALIDATION:
- ✅ URL must match platform patterns exactly
- ✅ Content must be from actual job posting page
- ✅ Company must be legitimate (verify with web search if needed)
- ✅ Job must be recent and active
- ✅ Extract comprehensive details including tech stack
- ✅ Prioritize direct company postings over recruiter posts

PLATFORM-SPECIFIC NOTES:
- **Greenhouse**: Look for detailed engineering roles with team/culture info
- **Lever**: Focus on growth companies with clear role progression
- **Indeed**: ONLY direct company postings, avoid staffing agencies

Quality over quantity - return fewer jobs if needed to ensure all are high-quality, verified company postings.`;
};

/**
 * Assess job content quality from real job boards
 */
exports.assessRealJobBoardContentQuality = (jobData) => {
  if (!jobData || !jobData.fullContent) return { quality: 'low', score: 0, issues: ['No content'] };
  
  const content = jobData.fullContent;
  const issues = [];
  let score = 0;
  
  // Length assessment
  if (content.length < 200) {
    issues.push('Content too short');
  } else if (content.length >= 400) {
    score += 25;
  } else if (content.length >= 200) {
    score += 15;
  }
  
  // Section completeness
  const hasRequirements = /requirements?|qualifications?|must have/i.test(content);
  const hasResponsibilities = /responsibilit|duties|role|what you.ll do/i.test(content);
  const hasBenefits = /benefits?|perks|compensation|offer/i.test(content);
  const hasTechStack = /technologies?|tools|stack|languages?|frameworks?/i.test(content);
  const hasTeamInfo = /team|manager|reports|colleagues|hiring manager/i.test(content);
  const hasCompanyInfo = /company|about us|our mission|culture/i.test(content);
  
  if (hasRequirements) score += 15;
  else issues.push('Missing requirements section');
  
  if (hasResponsibilities) score += 15;
  else issues.push('Missing responsibilities section');
  
  if (hasBenefits) score += 10;
  if (hasTechStack) score += 15;
  if (hasTeamInfo) score += 10;
  if (hasCompanyInfo) score += 10;
  
  // Platform-specific bonuses
  if (jobData.sourcePlatform === 'Greenhouse' && (hasTechStack && hasTeamInfo)) {
    score += 5; // Greenhouse typically has good tech details
  }
  
  if (jobData.sourcePlatform === 'Lever' && hasTeamInfo) {
    score += 5; // Lever often includes good team context
  }
  
  // URL validation bonus
  if (this.validateJobBoardUrl(jobData.jobUrl, jobData.sourcePlatform)) {
    score += 5;
  } else {
    issues.push('Invalid URL for platform');
  }
  
  // Recent posting bonus
  if (jobData.postedDate) {
    const postDate = new Date(jobData.postedDate);
    const now = new Date();
    const daysDiff = (now - postDate) / (1000 * 60 * 60 * 24);
    
    if (daysDiff <= 7) score += 10;
    else if (daysDiff <= 30) score += 5;
    else issues.push('Job posting is old');
  }
  
  // Determine quality level
  let quality = 'low';
  if (score >= 85) quality = 'high';
  else if (score >= 60) quality = 'medium';
  
  return {
    quality,
    score: Math.min(score, 100),
    issues,
    strengths: [
      hasRequirements && 'Clear requirements',
      hasResponsibilities && 'Detailed responsibilities', 
      hasTechStack && 'Tech stack included',
      hasTeamInfo && 'Team information',
      hasBenefits && 'Benefits listed',
      hasCompanyInfo && 'Company details'
    ].filter(Boolean)
  };
};

/**
 * Extract enhanced metadata from real job board postings
 */
exports.extractJobBoardMetadata = (jobData) => {
  const metadata = {
    platform: jobData.sourcePlatform,
    urlValidated: this.validateJobBoardUrl(jobData.jobUrl, jobData.sourcePlatform),
    contentLength: jobData.fullContent?.length || 0,
    hasComprehensiveDetails: false,
    hasTechStack: false,
    hasTeamInfo: false,
    hasApplicationDeadline: !!jobData.applicationDeadline,
    verifiedCompanyPosting: true, // Assume verified if from target platforms
    extractedAt: new Date()
  };
  
  if (jobData.fullContent) {
    const content = jobData.fullContent.toLowerCase();
    
    // Check for comprehensive details
    const hasMultipleSections = [
      /requirements?|qualifications?/,
      /responsibilit|duties/,
      /benefits?|perks/,
      /about|company|culture/
    ].filter(regex => regex.test(content)).length >= 3;
    
    metadata.hasComprehensiveDetails = hasMultipleSections;
    metadata.hasTechStack = /tech|stack|languages?|frameworks?|tools/i.test(content);
    metadata.hasTeamInfo = /team|manager|reports|colleagues/i.test(content);
  }
  
  // Platform-specific metadata
  const platformIdentifiers = this.extractJobIdentifiers(jobData.jobUrl, jobData.sourcePlatform);
  
  return {
    ...metadata,
    platformIdentifiers,
    qualityAssessment: this.assessRealJobBoardContentQuality(jobData)
  };
};

/**
 * Generate job board specific search parameters
 */
exports.generateJobBoardSearchParams = (careerProfile, platform) => {
  const baseParams = {
    jobTitles: careerProfile.targetJobTitles?.slice(0, 3) || [],
    keywords: careerProfile.targetKeywords?.slice(0, 5) || [],
    locations: careerProfile.preferredLocations?.slice(0, 2) || ['Remote'],
    experienceLevel: careerProfile.experienceLevel || 'Mid'
  };
  
  switch (platform.toLowerCase()) {
    case 'greenhouse':
      return {
        ...baseParams,
        platformFocus: 'tech startups and scale-ups',
        companyTypes: ['startup', 'scale-up', 'venture-backed'],
        searchModifiers: ['site:greenhouse.io', 'inurl:jobs'],
        expectedFeatures: ['comprehensive job descriptions', 'team culture info', 'tech stack details']
      };
      
    case 'lever':
      return {
        ...baseParams,
        platformFocus: 'growth-stage companies',
        companyTypes: ['growth-stage', 'expanding teams', 'series A-C'],
        searchModifiers: ['site:lever.co', 'inurl:jobs'],
        expectedFeatures: ['detailed role descriptions', 'career progression', 'team structure']
      };
      
    case 'indeed':
      return {
        ...baseParams,
        platformFocus: 'established companies with direct postings',
        companyTypes: ['established', 'direct employer', 'verified company'],
        searchModifiers: ['site:indeed.com', 'inurl:viewjob', '-recruiter', '-staffing'],
        expectedFeatures: ['direct company posting', 'verified employer', 'complete job details']
      };
      
    default:
      return baseParams;
  }
};

/**
 * Validate job posting freshness
 */
exports.validateJobFreshness = (postedDate, maxDaysOld = 30) => {
  if (!postedDate) return { isValid: false, reason: 'No posted date' };
  
  const postDate = new Date(postedDate);
  const now = new Date();
  const daysDiff = (now - postDate) / (1000 * 60 * 60 * 24);
  
  if (isNaN(daysDiff)) {
    return { isValid: false, reason: 'Invalid date format' };
  }
  
  if (daysDiff > maxDaysOld) {
    return { 
      isValid: false, 
      reason: `Job is ${Math.round(daysDiff)} days old (max: ${maxDaysOld})` 
    };
  }
  
  return {
    isValid: true,
    daysOld: Math.round(daysDiff),
    freshness: daysDiff <= 7 ? 'very fresh' : 
               daysDiff <= 14 ? 'fresh' : 
               daysDiff <= 30 ? 'recent' : 'old'
  };
};

/**
 * Enhanced job matching score calculation for real job board postings
 */
exports.calculateRealJobBoardMatchScore = (jobData, careerProfile) => {
  let score = 60; // Higher base score for real job board postings
  
  // Title matching (25 points)
  const jobTitle = (jobData.title || '').toLowerCase();
  const titleMatches = careerProfile.targetJobTitles?.some(target => 
    jobTitle.includes(target.toLowerCase()) || target.toLowerCase().includes(jobTitle)
  );
  if (titleMatches) score += 25;
  
  // Content quality bonus for real job boards (10 points)
  const contentQuality = this.assessRealJobBoardContentQuality(jobData);
  if (contentQuality.quality === 'high') score += 10;
  else if (contentQuality.quality === 'medium') score += 5;
  
  // Keyword matching (20 points max)
  const content = (jobData.fullContent || '').toLowerCase();
  const keywordMatches = careerProfile.targetKeywords?.filter(keyword => 
    content.includes(keyword.toLowerCase())
  ).length || 0;
  score += Math.min(keywordMatches * 4, 20);
  
  // Experience level matching (15 points)
  if (jobData.experienceLevel && 
      jobData.experienceLevel.toLowerCase() === careerProfile.experienceLevel?.toLowerCase()) {
    score += 15;
  }
  
  // Salary matching (10 points)
  if (jobData.salary?.min && careerProfile.salaryExpectation?.min) {
    if (jobData.salary.min >= careerProfile.salaryExpectation.min * 0.8) {
      score += 10;
    }
  }
  
  // Real job board platform bonus (5 points)
  if (['Greenhouse', 'Lever'].includes(jobData.sourcePlatform)) {
    score += 5; // These typically have higher quality postings
  }
  
  // Tech stack matching bonus (15 points max)
  if (jobData.techStack && Array.isArray(jobData.techStack)) {
    const techMatches = jobData.techStack.filter(tech => 
      careerProfile.mustHaveSkills?.some(skill => 
        skill.toLowerCase().includes(tech.toLowerCase()) || 
        tech.toLowerCase().includes(skill.toLowerCase())
      )
    ).length;
    score += Math.min(techMatches * 5, 15);
  }
  
  // Comprehensive details bonus (5 points)
  if (contentQuality.strengths?.length >= 4) {
    score += 5;
  }
  
  // Recent posting bonus (5 points)
  const freshnessCheck = this.validateJobFreshness(jobData.postedDate);
  if (freshnessCheck.isValid && freshnessCheck.daysOld <= 7) {
    score += 5;
  }
  
  return Math.min(Math.max(score, 0), 100);
};

/**
 * Generate job board discovery statistics
 */
exports.generateJobBoardStats = (discoveredJobs) => {
  const stats = {
    total: discoveredJobs.length,
    byPlatform: {
      greenhouse: 0,
      lever: 0,
      indeed: 0
    },
    qualityDistribution: {
      high: 0,
      medium: 0,
      low: 0
    },
    averageMatchScore: 0,
    averageContentLength: 0,
    featuresFound: {
      techStack: 0,
      teamInfo: 0,
      salary: 0,
      benefits: 0,
      applicationDeadline: 0
    }
  };
  
  if (discoveredJobs.length === 0) return stats;
  
  let totalMatchScore = 0;
  let totalContentLength = 0;
  
  discoveredJobs.forEach(job => {
    // Platform distribution
    const platform = job.sourcePlatform?.toLowerCase();
    if (stats.byPlatform.hasOwnProperty(platform)) {
      stats.byPlatform[platform]++;
    }
    
    // Quality assessment
    const quality = this.assessRealJobBoardContentQuality(job);
    stats.qualityDistribution[quality.quality]++;
    
    // Match scores
    totalMatchScore += job.matchScore || 0;
    
    // Content length
    totalContentLength += job.fullContent?.length || 0;
    
    // Features tracking
    if (job.techStack?.length > 0) stats.featuresFound.techStack++;
    if (job.hiringManager) stats.featuresFound.teamInfo++;
    if (job.salary?.min || job.salary?.max) stats.featuresFound.salary++;
    if (job.benefits?.length > 0) stats.featuresFound.benefits++;
    if (job.applicationDeadline) stats.featuresFound.applicationDeadline++;
  });
  
  stats.averageMatchScore = Math.round(totalMatchScore / discoveredJobs.length);
  stats.averageContentLength = Math.round(totalContentLength / discoveredJobs.length);
  
  return stats;
};

/**
 * Create job board specific error messages
 */
exports.createJobBoardErrorMessage = (platform, error) => {
  const platformMessages = {
    greenhouse: 'Failed to search Greenhouse job boards. This may be due to rate limiting or access restrictions.',
    lever: 'Failed to search Lever job boards. The platform may be temporarily unavailable.',
    indeed: 'Failed to search Indeed for direct company postings. Try again later.',
    general: 'Failed to search real job boards. This may be a temporary issue.'
  };
  
  const baseMessage = platformMessages[platform?.toLowerCase()] || platformMessages.general;
  
  return {
    message: baseMessage,
    suggestion: 'The search will retry automatically. You can also try running a new search.',
    platform: platform,
    timestamp: new Date(),
    errorDetails: error.message
  };
};

/**
 * Validate complete job board discovery result
 */
exports.validateJobBoardDiscoveryResult = (discoveredJobs) => {
  const validation = {
    isValid: true,
    errors: [],
    warnings: [],
    stats: this.generateJobBoardStats(discoveredJobs),
    recommendations: []
  };
  
  if (discoveredJobs.length === 0) {
    validation.isValid = false;
    validation.errors.push('No jobs discovered from any job board');
    validation.recommendations.push('Try broadening search criteria or running search at different time');
  }
  
  // Check for platform diversity
  const platformCount = Object.values(validation.stats.byPlatform).filter(count => count > 0).length;
  if (platformCount < 2) {
    validation.warnings.push('Jobs found from only one platform - may indicate limited search scope');
    validation.recommendations.push('Ensure all target job boards (Greenhouse, Lever, Indeed) are accessible');
  }
  
  // Check quality distribution
  const highQualityPercentage = (validation.stats.qualityDistribution.high / discoveredJobs.length) * 100;
  if (highQualityPercentage < 50) {
    validation.warnings.push('Less than 50% of jobs are high quality');
    validation.recommendations.push('Consider adjusting search criteria to target higher quality postings');
  }
  
  // Check for comprehensive job details
  const withTechStack = validation.stats.featuresFound.techStack;
  if (withTechStack < discoveredJobs.length * 0.3) {
    validation.warnings.push('Few jobs include tech stack information');
  }
  
  return validation;
};

module.exports = exports;

================
File: services/recruiterImport.service.js
================
// backend/services/recruiterImport.service.js - OPTIMIZED VERSION
const csv = require('csv-parser');
const fs = require('fs');
const db = require('../config/postgresql');

class RecruiterImportService {
  static async importFromCSV(filePath) {
    const companies = new Map();
    const recruiters = [];
    let processedCount = 0;
    let errorCount = 0;

    console.log('🚀 Starting recruiter import from CSV...');

    return new Promise((resolve, reject) => {
      fs.createReadStream(filePath)
        .pipe(csv())
        .on('data', (row) => {
          try {
            // Process company data
            const companyData = this.extractCompanyData(row);
            const companyKey = `${companyData.name}_${companyData.website || 'no-website'}`;
            
            if (!companies.has(companyKey) && companyData.name) {
              companies.set(companyKey, companyData);
            }

            // Process recruiter data
            const recruiterData = this.extractRecruiterData(row, companyKey);
            if (recruiterData.firstName && recruiterData.lastName) {
              recruiters.push(recruiterData);
            }
            
            processedCount++;
            
            if (processedCount % 1000 === 0) {
              console.log(`📊 Processed ${processedCount} records...`);
            }
          } catch (error) {
            console.error(`❌ Error processing row ${processedCount}:`, error.message);
            errorCount++;
          }
        })
        .on('end', async () => {
          try {
            console.log(`📥 CSV parsing complete. Processing ${companies.size} companies and ${recruiters.length} recruiters...`);
            
            // Import to database
            const result = await this.bulkInsertData(Array.from(companies.values()), recruiters);
            
            resolve({
              companiesImported: result.companiesImported,
              recruitersImported: result.recruitersImported,
              totalProcessed: processedCount,
              errors: errorCount
            });
          } catch (error) {
            reject(error);
          }
        })
        .on('error', reject);
    });
  }

  static extractCompanyData(row) {
    return {
      name: row['Company Name'] || '',
      website: row['Website'] || '',
      foundedYear: this.parseInteger(row['Founded Year']),
      phone: row['Company HQ Phone'] || '',
      fax: row['Fax'] || '',
      stockTicker: row['Ticker'] || '',
      revenueRange: row['Revenue Range (in USD)'] || '',
      revenueUsdThousands: this.parseInteger(row['Revenue (in 000s USD)']),
      employeeCount: this.parseInteger(row['Employees']),
      employeeRange: row['Employee Range'] || '',
      ownershipType: row['Ownership Type'] || '',
      businessModel: row['Business Model'] || '',
      primaryIndustry: row['Primary Industry'] || '',
      subIndustry: row['Primary Sub-Industry'] || '',
      allIndustries: this.parseArray(row['All Industries']),
      allSubIndustries: this.parseArray(row['All Sub-Industries']),
      sicCodes: this.parseArray(row['SIC Codes']),
      naicsCodes: this.parseArray(row['NAICS Codes']),
      linkedinUrl: row['LinkedIn Company Profile URL'] || '',
      facebookUrl: row['Facebook Company Profile URL'] || '',
      twitterUrl: row['Twitter Company Profile URL'] || '',
      zoominfoUrl: row['ZoomInfo Company Profile URL'] || '',
      zoominfoId: row['ZoomInfo Company ID'] || '',
      alexaRank: this.parseInteger(row['Alexa Rank']),
      locationCount: this.parseInteger(row['Number of Locations']),
      fundingTotalUsdThousands: this.parseInteger(row['Total Funding Amount (in 000s USD)']),
      recentFundingUsdThousands: this.parseInteger(row['Recent Funding Amount (in 000s USD)']),
      recentFundingRound: row['Recent Funding Round'] || '',
      recentFundingDate: this.parseDate(row['Recent Funding Date']),
      recentInvestors: this.parseArray(row['Recent Investors']),
      allInvestors: this.parseArray(row['All Investors']),
      isCertifiedActive: row['Certified Active Company'] === 'Yes',
      certificationDate: this.parseDate(row['Certification Date'])
    };
  }

  static extractRecruiterData(row, companyKey) {
    return {
      firstName: row['First Name'] || '',
      lastName: row['Last Name'] || '',
      middleName: row['Middle Name'] || '',
      salutation: row['Salutation'] || '',
      suffix: row['Suffix'] || '',
      email: row['Email Address'] || '',
      emailDomain: row['Email Domain'] || '',
      supplementalEmail: row['Supplemental Email'] || '',
      mobilePhone: row['Mobile phone'] || '',
      directPhone: row['Direct Phone Number'] || '',
      title: row['Job Title'] || '',
      jobTitleHierarchyLevel: this.parseInteger(row['Job Title Hierarchy Level']),
      managementLevel: row['Management Level'] || '',
      jobStartDate: this.parseDate(row['Job Start Date']),
      jobFunction: row['Job Function'] || '',
      department: row['Department'] || '',
      companyDivision: row['Company Division Name'] || '',
      companyKey: companyKey,
      highestEducation: row['Highest Level of Education'] || '',
      contactAccuracyScore: this.parseInteger(row['Contact Accuracy Score']),
      contactAccuracyGrade: row['Contact Accuracy Grade'] || '',
      zoominfoProfileUrl: row['ZoomInfo Contact Profile URL'] || '',
      linkedinProfileUrl: row['LinkedIn Contact Profile URL'] || '',
      noticeProvidedDate: this.parseDate(row['Notice Provided Date']),
      personStreet: row['Person Street'] || '',
      personCity: row['Person City'] || '',
      personState: row['Person State'] || '',
      personZipCode: row['Person Zip Code'] || '',
      personCountry: row['Country'] || ''
    };
  }

  static async bulkInsertData(companies, recruiters) {
    let companiesImported = 0;
    let recruitersImported = 0;

    try {
      // First, insert/find industries in batch
      console.log('📥 Processing industries...');
      const industryMap = new Map();
      const uniqueIndustries = [...new Set(companies.map(c => c.primaryIndustry).filter(Boolean))];
      
      // Batch insert industries
      if (uniqueIndustries.length > 0) {
        const industryValues = uniqueIndustries.map((name, index) => 
          `($${index + 1}, $${index + 1})`
        ).join(', ');
        
        const industryQuery = `
          INSERT INTO industries (name, primary_category) 
          VALUES ${industryValues}
          ON CONFLICT (name) DO UPDATE SET updated_at = NOW()
          RETURNING id, name
        `;
        
        const result = await db.query(industryQuery, uniqueIndustries);
        result.rows.forEach(row => {
          industryMap.set(row.name, row.id);
        });
        
        console.log(`✅ Processed ${uniqueIndustries.length} industries`);
      }

      // Insert companies in batches
      console.log('📥 Importing companies in batches...');
      const companyMap = new Map();
      const batchSize = 100; // Reduced batch size for stability
      
      for (let i = 0; i < companies.length; i += batchSize) {
        const batch = companies.slice(i, i + batchSize);
        
        try {
          // Build batch insert query
          const values = [];
          const placeholders = [];
          let paramCount = 0;
          
          for (const company of batch) {
            const industryId = industryMap.get(company.primaryIndustry);
            const emailDomain = company.website ? 
              company.website.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] : 
              null;

            const companyValues = [
              company.name, company.website, company.foundedYear, company.phone,
              company.fax, company.stockTicker, company.revenueRange, company.revenueUsdThousands,
              company.employeeCount, company.employeeRange, company.ownershipType,
              company.businessModel, emailDomain, company.sicCodes, company.naicsCodes, 
              company.linkedinUrl, company.facebookUrl, company.twitterUrl, company.zoominfoUrl,
              company.zoominfoId, company.alexaRank, company.fundingTotalUsdThousands,
              company.recentFundingUsdThousands, company.recentFundingRound,
              company.recentFundingDate, company.recentInvestors, company.allInvestors,
              company.locationCount, company.isCertifiedActive, company.certificationDate,
              industryId
            ];

            values.push(...companyValues);
            
            const startParam = paramCount + 1;
            paramCount += companyValues.length;
            const endParam = paramCount;
            
            const placeholder = `($${Array.from({length: companyValues.length}, (_, j) => startParam + j).join(', $')})`;
            placeholders.push(placeholder);
          }

          const batchQuery = `
            INSERT INTO companies (
              name, website, founded_year, phone, fax, stock_ticker, revenue_range,
              revenue_usd_thousands, employee_count, employee_range, ownership_type,
              business_model, email_domain, sic_codes, naics_codes, linkedin_url,
              facebook_url, twitter_url, zoominfo_url, zoominfo_id, alexa_rank,
              funding_total_usd_thousands, recent_funding_usd_thousands, 
              recent_funding_round, recent_funding_date, recent_investors, 
              all_investors, location_count, is_certified_active, 
              certification_date, industry_id
            ) VALUES ${placeholders.join(', ')}
            ON CONFLICT (name, website) DO UPDATE SET 
              updated_at = NOW(),
              industry_id = EXCLUDED.industry_id,
              employee_count = EXCLUDED.employee_count,
              revenue_usd_thousands = EXCLUDED.revenue_usd_thousands
            RETURNING id, name, website
          `;

          const result = await db.query(batchQuery, values);
          
          // Map results back to company keys
          for (let j = 0; j < batch.length; j++) {
            const company = batch[j];
            const resultRow = result.rows[j];
            if (resultRow) {
              const companyKey = `${company.name}_${company.website || 'no-website'}`;
              companyMap.set(companyKey, resultRow.id);
              companiesImported++;
            }
          }

          console.log(`📊 Imported ${Math.min(i + batchSize, companies.length)} / ${companies.length} companies`);
          
        } catch (error) {
          console.error(`Error in company batch ${i}-${i + batchSize}:`, error.message);
          // Try individual inserts for this batch
          for (const company of batch) {
            try {
              const industryId = industryMap.get(company.primaryIndustry);
              const emailDomain = company.website ? 
                company.website.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] : 
                null;

              const query = `
                INSERT INTO companies (
                  name, website, founded_year, phone, fax, stock_ticker, revenue_range,
                  revenue_usd_thousands, employee_count, employee_range, ownership_type,
                  business_model, email_domain, sic_codes, naics_codes, linkedin_url,
                  facebook_url, twitter_url, zoominfo_url, zoominfo_id, alexa_rank,
                  funding_total_usd_thousands, recent_funding_usd_thousands, 
                  recent_funding_round, recent_funding_date, recent_investors, 
                  all_investors, location_count, is_certified_active, 
                  certification_date, industry_id
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31)
                ON CONFLICT (name, website) DO UPDATE SET 
                  updated_at = NOW(),
                  industry_id = EXCLUDED.industry_id,
                  employee_count = EXCLUDED.employee_count,
                  revenue_usd_thousands = EXCLUDED.revenue_usd_thousands
                RETURNING id
              `;

              const values = [
                company.name, company.website, company.foundedYear, company.phone,
                company.fax, company.stockTicker, company.revenueRange, company.revenueUsdThousands,
                company.employeeCount, company.employeeRange, company.ownershipType,
                company.businessModel, emailDomain, company.sicCodes, company.naicsCodes, 
                company.linkedinUrl, company.facebookUrl, company.twitterUrl, company.zoominfoUrl,
                company.zoominfoId, company.alexaRank, company.fundingTotalUsdThousands,
                company.recentFundingUsdThousands, company.recentFundingRound,
                company.recentFundingDate, company.recentInvestors, company.allInvestors,
                company.locationCount, company.isCertifiedActive, company.certificationDate,
                industryId
              ];

              const result = await db.query(query, values);
              const companyKey = `${company.name}_${company.website || 'no-website'}`;
              companyMap.set(companyKey, result.rows[0].id);
              companiesImported++;

            } catch (individualError) {
              // Skip this company
              console.log(`Skipping company ${company.name}: ${individualError.message}`);
            }
          }
        }
      }

      // Insert recruiters in batches
      console.log('📥 Importing recruiters in batches...');
      const recruiterBatchSize = 500;
      
      for (let i = 0; i < recruiters.length; i += recruiterBatchSize) {
        const batch = recruiters.slice(i, i + recruiterBatchSize);
        
        for (const recruiter of batch) {
          try {
            const companyId = companyMap.get(recruiter.companyKey);
            
            const query = `
              INSERT INTO recruiters (
                first_name, last_name, middle_name, salutation, suffix,
                email, email_domain, supplemental_email, mobile_phone,
                direct_phone, title, job_title_hierarchy_level,
                management_level, job_start_date, job_function, department,
                company_division, current_company_id, highest_education,
                contact_accuracy_score, contact_accuracy_grade,
                zoominfo_profile_url, linkedin_profile_url,
                notice_provided_date, person_street, person_city, person_state,
                person_zip_code, person_country
              ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29)
              ON CONFLICT (email) DO UPDATE SET 
                title = EXCLUDED.title,
                current_company_id = EXCLUDED.current_company_id,
                updated_at = NOW()
            `;

            const values = [
              recruiter.firstName, recruiter.lastName, recruiter.middleName,
              recruiter.salutation, recruiter.suffix, recruiter.email,
              recruiter.emailDomain, recruiter.supplementalEmail,
              recruiter.mobilePhone, recruiter.directPhone, recruiter.title,
              recruiter.jobTitleHierarchyLevel, recruiter.managementLevel,
              recruiter.jobStartDate, recruiter.jobFunction, recruiter.department,
              recruiter.companyDivision, companyId, recruiter.highestEducation,
              recruiter.contactAccuracyScore, recruiter.contactAccuracyGrade,
              recruiter.zoominfoProfileUrl, recruiter.linkedinProfileUrl,
              recruiter.noticeProvidedDate, recruiter.personStreet,
              recruiter.personCity, recruiter.personState, recruiter.personZipCode,
              recruiter.personCountry
            ];

            await db.query(query, values);
            recruitersImported++;

          } catch (error) {
            // Skip duplicates and other errors
            if (!error.message.includes('duplicate key')) {
              console.error(`Error inserting recruiter ${recruiter.firstName} ${recruiter.lastName}:`, error.message);
            }
          }
        }

        console.log(`📊 Imported ${Math.min(i + recruiterBatchSize, recruiters.length)} / ${recruiters.length} recruiters`);
      }

      console.log('✅ Import completed successfully');
      return { companiesImported, recruitersImported };

    } catch (error) {
      console.error('❌ Import failed:', error);
      throw error;
    }
  }

  // Helper methods
  static parseInteger(value) {
    if (!value || value === '') return null;
    const parsed = parseInt(value.toString().replace(/[^\d]/g, ''));
    return isNaN(parsed) ? null : parsed;
  }

  static parseDate(value) {
    if (!value || value === '') return null;
    const date = new Date(value);
    return isNaN(date.getTime()) ? null : date;
  }

  static parseArray(value) {
    if (!value || value === '') return [];
    return value.split(';').map(item => item.trim()).filter(item => item !== '');
  }
}

module.exports = RecruiterImportService;

================
File: services/resumeAnalysis.service.js
================
// services/resumeAnalysis.service.js - FIXED REALISTIC SCORING
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');

/**
 * Analyze a resume using OpenAI with strict, realistic scoring criteria
 * @param {string} resumeId - MongoDB ID of the resume to analyze
 * @returns {Object} Analysis results
 */
exports.analyzeResume = async (resumeId) => {
  try {
    console.log(`Analyzing resume: ${resumeId}`);
    
    // Get the resume from the database
    const resume = await Resume.findById(resumeId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    // Check if parsed data is available
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      throw new Error('Resume parsing data not available for analysis');
    }
    
    console.log('Parsed data found, proceeding with OpenAI analysis');
    
    // Check if this is a tailored resume for enhanced analysis
    const isTailoredResume = resume.isTailored || false;
    const tailoredContext = isTailoredResume ? 
      `This is an AI-tailored resume optimized for ${resume.tailoredForJob?.jobTitle || 'a specific role'} at ${resume.tailoredForJob?.company || 'a target company'}. ` : '';
    
    // Convert parsed data to string for OpenAI
    const resumeData = JSON.stringify(resume.parsedData, null, 2);
    
    // FIXED: Much stricter and more realistic scoring prompt
    const prompt = `
    You are a STRICT resume analyst and ATS expert with 15+ years of experience. You are known for being tough but fair in your evaluations. Most resumes are mediocre and should score between 50-75.

    ${tailoredContext}Analyze this resume with STRICT professional standards. Be realistic and tough in your scoring.

    CRITICAL INSTRUCTIONS FOR REALISTIC SCORING:

    **PLACEHOLDER CONTENT DETECTION:**
    - If you find placeholder text like "Bullet 1", "Bullet 2", "Generic content", etc., this is a MAJOR red flag
    - Automatically deduct 20-30 points for placeholder content
    - These resumes should score 40-60 maximum regardless of format

    **CONTENT QUALITY REQUIREMENTS:**
    - Achievements MUST have specific numbers, percentages, or metrics
    - Generic statements like "Managed projects" or "Worked with teams" are weak
    - Strong content requires: specific metrics, technologies, business impact, team sizes, revenue figures

    Provide the analysis in JSON format:
    {
      "overallScore": 0-100,
      "atsCompatibility": 0-100,
      "profileSummary": {
        "currentRole": "",
        "careerLevel": "",
        "industries": [],
        "suggestedJobTitles": [],
        "suggestedIndustries": []
      },
      "strengths": ["strength1", "strength2", "strength3"],
      "weaknesses": ["weakness1", "weakness2", "weakness3"],
      "keywordsSuggestions": ["keyword1", "keyword2", "keyword3", "keyword4", "keyword5"],
      "improvementAreas": [
        {
          "section": "section name",
          "suggestions": ["suggestion1", "suggestion2"],
          "improvedSnippets": [
            {
              "original": "original text from resume",
              "improved": "AI-enhanced version"
            }
          ]
        }
      ]
    }
    
    **STRICT SCORING GUIDELINES - BE REALISTIC:**
    
    Overall Score (0-100):
    - 90-100: EXCEPTIONAL resume with quantified achievements, perfect keyword optimization, industry leadership examples, specific metrics throughout
    - 80-89: STRONG resume with good quantification, solid keyword presence, clear career progression, some metrics
    - 70-79: DECENT resume with basic quantification, acceptable structure, some achievements shown
    - 60-69: BELOW AVERAGE resume with weak content, generic statements, poor quantification
    - 50-59: POOR resume with placeholder content, no metrics, generic bullet points
    - Below 50: TERRIBLE resume with major content/format issues
    
    ATS Compatibility (0-100):
    - 90-100: Perfect ATS format with extensive industry keywords, optimized headers, strong keyword density (8-12%)
    - 80-89: Good ATS compatibility with solid keyword presence (6-8%), proper formatting
    - 70-79: Acceptable ATS compatibility with basic keywords (4-6%), standard formatting
    - 60-69: Poor ATS compatibility with few keywords (2-4%), weak optimization
    - Below 60: Very poor ATS compatibility with minimal keywords (<2%), bad formatting

    **CONTENT QUALITY CHECKLIST - DEDUCT POINTS FOR:**
    1. PLACEHOLDER CONTENT: "Bullet 1", "Bullet 2", generic placeholders (-25 points)
    2. NO QUANTIFICATION: Lack of numbers, percentages, metrics (-15 points)
    3. GENERIC STATEMENTS: "Responsible for...", "Worked on..." without specifics (-10 points)
    4. WEAK ACHIEVEMENTS: No business impact or measurable outcomes (-10 points)
    5. POOR KEYWORD DENSITY: Less than 3% relevant keywords for the field (-10 points)
    6. FORMATTING ISSUES: Poor structure, inconsistent formatting (-5 points)

    **KEYWORD DENSITY CALCULATION:**
    - Count industry-specific terms, technologies, methodologies
    - Calculate as percentage of total words
    - Product Management: "roadmap", "stakeholder", "KPI", "user research", "product strategy"
    - Technical: "API", "cloud", "agile", "scrum", "data analysis"

    **ACHIEVEMENT QUALITY EXAMPLES:**
    - WEAK: "Managed projects" 
    - STRONG: "Led 3 cross-functional teams to deliver $2M revenue-generating product ahead of schedule"
    
    - WEAK: "Worked with customers"
    - STRONG: "Increased customer satisfaction by 40% through data-driven UX improvements affecting 50k+ users"

    IMPORTANT: 
    - Be STRICT and REALISTIC in scoring
    - Most resumes should score 50-75, not 85-95
    - Only truly exceptional resumes with perfect content and optimization should score above 85
    - Placeholder content automatically caps scores at 60 maximum

    Return ONLY the JSON object without any markdown formatting or code blocks.
    
    Resume Data:
    ${resumeData}
    `;
    
    // Call OpenAI API with enhanced parameters for stricter analysis
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: `You are a STRICT professional resume analyst with 15+ years of experience. You are known for tough, realistic evaluations. Most resumes are mediocre (50-75 range). Only exceptional resumes with perfect quantified achievements and optimization score above 85. You automatically detect and heavily penalize placeholder content like "Bullet 1, Bullet 2". You require specific metrics, technologies, and business impact for high scores. Return ONLY valid JSON without markdown.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Lower temperature for more consistent, strict scoring
      max_tokens: 3000,
    });
    
    // Get the response content
    const responseContent = response.choices[0].message.content.trim();
    
    // Clean up the response - remove any markdown code block syntax
    let cleanedResponse = responseContent;
    
    if (responseContent.startsWith('```json') || responseContent.startsWith('```')) {
      const startIndex = responseContent.indexOf('{');
      const endIndex = responseContent.lastIndexOf('}');
      
      if (startIndex !== -1 && endIndex !== -1) {
        cleanedResponse = responseContent.substring(startIndex, endIndex + 1);
      }
    }
    
    console.log('Cleaned response for parsing:', cleanedResponse.substring(0, 200) + '...');
    
    // Parse the response
    const analysisData = JSON.parse(cleanedResponse);
    console.log('Resume analysis with OpenAI completed successfully');
    
    // ENHANCED: Additional validation and scoring adjustments
    let sanitizedAnalysis = {
      overallScore: Math.max(0, Math.min(100, analysisData.overallScore || 0)),
      atsCompatibility: Math.max(0, Math.min(100, analysisData.atsCompatibility || 0)),
      profileSummary: {
        currentRole: analysisData.profileSummary?.currentRole || "Not specified",
        careerLevel: analysisData.profileSummary?.careerLevel || "Mid-level",
        industries: Array.isArray(analysisData.profileSummary?.industries) ? analysisData.profileSummary.industries : ["Technology"],
        suggestedJobTitles: Array.isArray(analysisData.profileSummary?.suggestedJobTitles) ? analysisData.profileSummary.suggestedJobTitles : ["Product Manager", "Project Manager"],
        suggestedIndustries: Array.isArray(analysisData.profileSummary?.suggestedIndustries) ? analysisData.profileSummary.suggestedIndustries : ["Technology", "Software"]
      },
      strengths: Array.isArray(analysisData.strengths) ? analysisData.strengths : [
        "Resume has a clear structure",
        "Contact information is included",
        "Work experience is detailed"
      ],
      weaknesses: Array.isArray(analysisData.weaknesses) ? analysisData.weaknesses : [
        "Could benefit from more quantifiable achievements",
        "Skills section could be more comprehensive",
        "Summary could be more impactful"
      ],
      keywordsSuggestions: Array.isArray(analysisData.keywordsSuggestions) ? analysisData.keywordsSuggestions : [
        "leadership",
        "communication",
        "problem-solving",
        "teamwork",
        "analytical"
      ],
      improvementAreas: Array.isArray(analysisData.improvementAreas) ? analysisData.improvementAreas : [
        {
          section: "Experience",
          suggestions: [
            "Add more quantifiable achievements",
            "Use more action verbs"
          ],
          improvedSnippets: [
            {
              original: "Generic bullet points need improvement",
              improved: "Specific, quantified achievements with business impact"
            }
          ]
        }
      ]
    };
    
    // CRITICAL: Detect and penalize placeholder content
    const resumeText = JSON.stringify(resume.parsedData).toLowerCase();
    const placeholderPatterns = [
      'bullet 1', 'bullet 2', 'bullet 3', 'bullet 4', 'bullet 5',
      'bullet point', 'add content', 'placeholder', 'lorem ipsum',
      'example text', 'sample text', 'generic content'
    ];
    
    let hasPlaceholders = false;
    let placeholderCount = 0;
    
    placeholderPatterns.forEach(pattern => {
      if (resumeText.includes(pattern)) {
        hasPlaceholders = true;
        placeholderCount++;
      }
    });
    
    if (hasPlaceholders) {
      console.log(`🚨 PLACEHOLDER CONTENT DETECTED: Found ${placeholderCount} placeholder patterns`);
      
      // Apply severe penalty for placeholder content
      const penalty = Math.min(30, placeholderCount * 8); // Up to 30 point penalty
      sanitizedAnalysis.overallScore = Math.max(20, sanitizedAnalysis.overallScore - penalty);
      sanitizedAnalysis.atsCompatibility = Math.max(25, sanitizedAnalysis.atsCompatibility - (penalty * 0.8));
      
      // Add to weaknesses
      sanitizedAnalysis.weaknesses.unshift("Contains placeholder content that needs to be replaced with specific achievements");
      
      // Cap maximum scores for placeholder content
      sanitizedAnalysis.overallScore = Math.min(60, sanitizedAnalysis.overallScore);
      sanitizedAnalysis.atsCompatibility = Math.min(65, sanitizedAnalysis.atsCompatibility);
      
      console.log(`Applied ${penalty} point penalty for placeholder content. New scores: ${sanitizedAnalysis.overallScore}/${sanitizedAnalysis.atsCompatibility}`);
    }
    
    // Additional content quality checks
    const experienceText = JSON.stringify(resume.parsedData.experience || []);
    
    // Check for quantification
    const hasNumbers = /\d+/.test(experienceText);
    const hasPercentages = /%/.test(experienceText);
    const hasMetrics = /\$|revenue|million|thousand|increase|decrease|improve/i.test(experienceText);
    
    if (!hasNumbers && !hasPercentages && !hasMetrics) {
      console.log('🚨 NO QUANTIFICATION DETECTED: Applying penalty');
      sanitizedAnalysis.overallScore = Math.max(30, sanitizedAnalysis.overallScore - 15);
      sanitizedAnalysis.atsCompatibility = Math.max(40, sanitizedAnalysis.atsCompatibility - 10);
      sanitizedAnalysis.weaknesses.unshift("Lacks quantified achievements and specific metrics");
    }
    
    // ENHANCED: Apply tailored resume bonus more carefully
    if (isTailoredResume && !hasPlaceholders) {
      console.log('Applying tailored resume analysis bonus...');
      
      // Check for keyword optimization indicators in the content
      const summaryText = (resume.parsedData.summary || '').toLowerCase();
      const experienceText = JSON.stringify(resume.parsedData.experience || []).toLowerCase();
      
      // Keywords that indicate technical optimization
      const techKeywords = ['api', 'cloud', 'infrastructure', 'developer', 'velocity', 'platform', 'security', 'architecture'];
      const foundKeywords = techKeywords.filter(keyword => 
        summaryText.includes(keyword) || experienceText.includes(keyword)
      );
      
      // Apply bonus based on keyword optimization (only if no placeholders)
      if (foundKeywords.length >= 3) {
        console.log(`Found ${foundKeywords.length} optimization keywords:`, foundKeywords);
        
        // Apply 3-5 point bonus for good optimization (reduced from previous)
        const bonus = Math.min(5, foundKeywords.length);
        sanitizedAnalysis.overallScore = Math.min(100, sanitizedAnalysis.overallScore + bonus);
        sanitizedAnalysis.atsCompatibility = Math.min(100, sanitizedAnalysis.atsCompatibility + bonus);
        
        console.log(`Applied ${bonus} point tailoring bonus. New scores: ${sanitizedAnalysis.overallScore}/${sanitizedAnalysis.atsCompatibility}`);
        
        // Update strengths to reflect optimization
        sanitizedAnalysis.strengths.unshift("Resume is well-optimized with relevant technical keywords");
      }
    }
    
    console.log('Final analysis scores after all adjustments:', {
      overallScore: sanitizedAnalysis.overallScore,
      atsCompatibility: sanitizedAnalysis.atsCompatibility,
      hadPlaceholders: hasPlaceholders,
      placeholderCount: placeholderCount,
      strengthsCount: sanitizedAnalysis.strengths.length,
      weaknessesCount: sanitizedAnalysis.weaknesses.length,
      isTailored: isTailoredResume
    });
    
    return sanitizedAnalysis;
  } catch (error) {
    console.error('Error analyzing resume with OpenAI:', error);
    
    // Fallback to a more realistic default analysis
    return {
      overallScore: 45, // Much lower default score
      atsCompatibility: 55,
      profileSummary: {
        currentRole: "Not identified",
        careerLevel: "Mid-level",
        industries: ["Technology"],
        suggestedJobTitles: ["Product Manager", "Project Manager"],
        suggestedIndustries: ["Technology", "Software"]
      },
      strengths: [
        "Resume has a clear structure",
        "Contact information is included"
      ],
      weaknesses: [
        "Contains placeholder content that needs specific achievements",
        "Lacks quantifiable metrics and business impact",
        "Needs more industry-specific keywords",
        "Bullet points are too generic and need improvement"
      ],
      keywordsSuggestions: [
        "leadership",
        "project management",
        "data analysis",
        "cross-functional collaboration",
        "business impact"
      ],
      improvementAreas: [
        {
          section: "Experience",
          suggestions: [
            "Replace placeholder bullets with specific quantified achievements",
            "Add metrics like percentages, dollar amounts, team sizes",
            "Include specific technologies and methodologies used"
          ],
          improvedSnippets: [
            {
              original: "Bullet 1, Bullet 2, Bullet 3",
              improved: "Led cross-functional team of 12 to deliver $2M revenue product, increasing customer satisfaction by 35% through data-driven feature improvements"
            }
          ]
        }
      ]
    };
  }
};

================
File: services/resumeEditor.service.js
================
// backend/services/resumeEditor.service.js - AI-POWERED RESUME EDITOR
const { openai } = require('../config/openai');
const Resume = require('../models/mongodb/resume.model');
const { PutObjectCommand } = require('@aws-sdk/client-s3');
const { s3Client, S3_BUCKET } = require('../config/s3');
const PDFDocument = require('pdfkit');
const { Document, Packer, Paragraph, TextRun, HeadingLevel } = require('docx');
const uuid = require('uuid').v4;

class ResumeEditorService {
  /**
   * Apply AI-suggested changes to a resume
   */
  static async applyResumeChanges(resumeId, userId, changes) {
    try {
      console.log(`🤖 AJ: Applying changes to resume ${resumeId}`);
      
      const resume = await Resume.findOne({ _id: resumeId, userId });
      if (!resume) {
        throw new Error('Resume not found');
      }

      // Parse the change request using AI
      const structuredChanges = await this.parseChangeRequest(changes, resume.parsedData);
      
      // Apply changes to resume data
      const updatedResumeData = await this.applyStructuredChanges(resume.parsedData, structuredChanges);
      
      // Update resume in database
      resume.parsedData = updatedResumeData;
      resume.updatedAt = new Date();
      
      // Add version tracking
      const versionNumber = (resume.versions || []).length + 1;
      if (!resume.versions) resume.versions = [];
      
      // Create new version entry
      const newVersion = {
        versionNumber,
        createdAt: new Date(),
        fileUrl: resume.fileUrl, // Will be updated after file generation
        changesDescription: this.summarizeChanges(structuredChanges),
        aiGenerated: true
      };

      resume.versions.push(newVersion);
      await resume.save();

      // Generate updated resume file
      const updatedFileUrl = await this.generateUpdatedResumeFile(resume, updatedResumeData);
      
      // Update the version with new file URL
      resume.versions[resume.versions.length - 1].fileUrl = updatedFileUrl;
      await resume.save();

      console.log(`✅ AJ: Successfully updated resume with ${structuredChanges.length} changes`);

      return {
        success: true,
        updatedResume: resume,
        changes: structuredChanges,
        newFileUrl: updatedFileUrl,
        changesSummary: this.summarizeChanges(structuredChanges)
      };

    } catch (error) {
      console.error('Resume update error:', error);
      throw error;
    }
  }

  /**
   * Parse natural language change request into structured changes
   */
static async parseChangeRequest(changeRequest, currentResumeData) {
  try {
    const prompt = `You are an expert resume editor. Parse this change request and convert it into structured JSON changes.

CURRENT RESUME DATA:
${JSON.stringify(currentResumeData, null, 2)}

CHANGE REQUEST:
"${changeRequest}"

CRITICAL: When updating work experience highlights/achievements, generate ONE single action that replaces the entire highlights array with 3-5 detailed bullet points.

Return JSON in this EXACT format:
{
  "changes": [
    {
      "section": "experience",
      "action": "enhance",
      "target": "0",
      "field": "highlights",
      "newValue": [
        "Detailed bullet point 1 with specific metrics and technologies",
        "Detailed bullet point 2 showcasing leadership and impact", 
        "Detailed bullet point 3 with quantifiable business results",
        "Detailed bullet point 4 highlighting technical expertise",
        "Detailed bullet point 5 demonstrating strategic thinking"
      ],
      "originalValue": "current highlights array",
      "reason": "Enhanced with multiple detailed achievements"
    }
  ]
}

IMPORTANT RULES:
- Generate EXACTLY ONE change action, not multiple separate ones
- Use action: "enhance" for updating existing experience
- Set field: "highlights" for bullet points
- newValue MUST be an array of 3-5 detailed strings
- Each bullet should be 15-25 words with specific metrics
- Use strong action verbs (Led, Developed, Achieved, Implemented, etc.)
- Include technologies, numbers, percentages, and business impact
- Make bullets relevant to the current role and industry

EXAMPLE - DO THIS:
{
  "changes": [
    {
      "section": "experience",
      "action": "enhance",
      "target": "0",
      "field": "highlights", 
      "newValue": [
        "Led development of AI-powered tax platform serving 10k+ enterprise clients with 40% faster processing",
        "Architected machine learning workflows reducing manual review time by 65% and improving accuracy to 98%",
        "Managed cross-functional team of 15 engineers delivering $3.2M in new AI product revenue",
        "Implemented automated compliance checking system preventing 200+ regulatory violations annually",
        "Drove product strategy for agentic AI features resulting in 85% customer satisfaction increase"
      ],
      "reason": "Enhanced Thomson Reuters role with specific AI achievements and quantifiable impact"
    }
  ]
}

DON'T DO THIS (multiple separate actions):
{
  "changes": [
    {"action": "add", "target": "0/highlights", "newValue": "bullet 1"},
    {"action": "add", "target": "0/highlights", "newValue": "bullet 2"},
    {"action": "add", "target": "0/highlights", "newValue": "bullet 3"}
  ]
}

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: 'You are an expert resume editor. Generate ONE comprehensive change action with an array of detailed bullet points. Return only valid JSON.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 2000
    });

    let parsedChanges;
    try {
      const responseContent = response.choices[0].message.content.trim();
      // Clean up response if it has markdown
      const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
      parsedChanges = JSON.parse(cleanedResponse);
      
      console.log('📋 Parsed changes:', JSON.stringify(parsedChanges, null, 2));
      
      // 🔧 VALIDATION: Ensure we have the right structure for experience updates
      if (parsedChanges.changes) {
        parsedChanges.changes.forEach((change, index) => {
          if (change.section === 'experience' && 
              change.action === 'enhance' && 
              change.field === 'highlights' && 
              Array.isArray(change.newValue)) {
            console.log(`✅ Valid experience enhancement found with ${change.newValue.length} bullet points`);
          }
        });
      }
      
    } catch (parseError) {
      console.error('Error parsing AI response:', parseError);
      throw new Error('Failed to parse change request');
    }

    return parsedChanges.changes || [];

  } catch (error) {
    console.error('Error parsing change request:', error);
    throw error;
  }
}

  /**
   * Apply structured changes to resume data
   */
  static async applyStructuredChanges(resumeData, changes) {
    const updatedData = JSON.parse(JSON.stringify(resumeData)); // Deep clone

    for (const change of changes) {
      try {
        console.log(`Applying change: ${change.action} to ${change.section}`);
        
        switch (change.section) {
          case 'contactInfo':
            this.updateContactInfo(updatedData, change);
            break;
          case 'summary':
            this.updateSummary(updatedData, change);
            break;
          case 'experience':
            this.updateExperience(updatedData, change);
            break;
          case 'education':
            this.updateEducation(updatedData, change);
            break;
          case 'skills':
            this.updateSkills(updatedData, change);
            break;
          case 'certifications':
            this.updateCertifications(updatedData, change);
            break;
          case 'projects':
            this.updateProjects(updatedData, change);
            break;
          case 'languages':
            this.updateLanguages(updatedData, change);
            break;
          default:
            console.warn(`Unknown section: ${change.section}`);
        }
      } catch (error) {
        console.error(`Error applying change to ${change.section}:`, error);
      }
    }

    return updatedData;
  }

  // Section-specific update methods
  static updateContactInfo(data, change) {
    if (!data.contactInfo) data.contactInfo = {};
    
    switch (change.action) {
      case 'update':
        if (change.target && change.newValue) {
          data.contactInfo[change.target] = change.newValue;
        }
        break;
      case 'add':
        if (change.target === 'websites' && change.newValue) {
          if (!data.contactInfo.websites) data.contactInfo.websites = [];
          data.contactInfo.websites.push(change.newValue);
        }
        break;
    }
  }

  static updateSummary(data, change) {
    switch (change.action) {
      case 'update':
      case 'rewrite':
      case 'enhance':
        data.summary = change.newValue;
        break;
      case 'add':
        if (!data.summary) {
          data.summary = change.newValue;
        }
        break;
    }
  }

static updateExperience(data, change) {
  if (!data.experience) data.experience = [];

  console.log(`🔧 Updating experience - Action: ${change.action}, Target: ${change.target}, Field: ${change.field}`);
  console.log(`🔧 NewValue type: ${Array.isArray(change.newValue) ? 'array' : typeof change.newValue}`);
  console.log(`🔧 NewValue content:`, change.newValue);

  switch (change.action) {
    case 'add':
      // 🎯 FIXED: Handle adding new experience vs adding to existing experience
      if (change.target && change.target.includes('/')) {
        // Adding to existing experience (e.g., "0/highlights")
        const [indexStr, field] = change.target.split('/');
        const index = parseInt(indexStr);
        
        if (data.experience[index]) {
          if (field === 'highlights') {
            // Initialize highlights array if it doesn't exist
            if (!data.experience[index].highlights) {
              data.experience[index].highlights = [];
            }
            
            if (Array.isArray(change.newValue)) {
              // 🔧 FIXED: Replace entire highlights array with new content
              console.log(`🎯 Replacing highlights array with ${change.newValue.length} items`);
              data.experience[index].highlights = change.newValue;
            } else if (typeof change.newValue === 'string') {
              // Add single highlight
              console.log(`🎯 Adding single highlight: ${change.newValue}`);
              data.experience[index].highlights.push(change.newValue);
            }
            console.log(`✅ Updated experience[${index}].highlights - now has ${data.experience[index].highlights.length} items`);
          } else {
            // Add to other fields
            data.experience[index][field] = change.newValue;
            console.log(`✅ Added to experience[${index}].${field}`);
          }
        } else {
          console.warn(`❌ Experience index ${index} not found`);
        }
      } else if (change.newValue && typeof change.newValue === 'object') {
        // Adding entirely new experience entry
        data.experience.push(change.newValue);
        console.log('✅ Added new experience entry');
      }
      break;
      
    case 'update':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        if (data.experience[index]) {
          // Update specific field or entire experience entry
          if (change.field) {
            data.experience[index][change.field] = change.newValue;
            console.log(`✅ Updated experience[${index}].${change.field}`);
          } else {
            data.experience[index] = { ...data.experience[index], ...change.newValue };
            console.log(`✅ Updated entire experience[${index}]`);
          }
        } else {
          console.warn(`❌ Experience index ${index} not found`);
        }
      }
      break;
      
    case 'delete':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        data.experience.splice(index, 1);
        console.log(`✅ Deleted experience[${index}]`);
      }
      break;
      
    case 'enhance':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        if (data.experience[index]) {
          
          // 🎯 ENHANCED: Handle highlights field specifically
          if (change.field === 'highlights' && Array.isArray(change.newValue)) {
            console.log(`🎯 Setting experience[${index}].highlights with ${change.newValue.length} bullet points`);
            data.experience[index].highlights = change.newValue;
            console.log(`✅ Enhanced experience[${index}].highlights:`, data.experience[index].highlights);
            
          } else if (change.field === 'description') {
            data.experience[index].description = change.newValue;
            console.log(`✅ Enhanced experience[${index}].description`);
            
          } else if (change.field && change.newValue) {
            // Handle other specific fields
            data.experience[index][change.field] = change.newValue;
            console.log(`✅ Enhanced experience[${index}].${change.field}`);
            
          } else if (!change.field && Array.isArray(change.newValue)) {
            // 🔧 FIXED: Default to highlights when no field specified but array provided
            console.log('🎯 No field specified, defaulting to highlights for array data');
            data.experience[index].highlights = change.newValue;
            console.log(`✅ Set experience[${index}].highlights with ${change.newValue.length} items`);
            
          } else if (!change.field && typeof change.newValue === 'object') {
            // Handle object updates
            Object.keys(change.newValue).forEach(key => {
              data.experience[index][key] = change.newValue[key];
              console.log(`✅ Updated experience[${index}].${key}`);
            });
            
          } else {
            console.warn(`❌ Cannot enhance experience[${index}] - invalid field/value combination`);
            console.warn(`Field: ${change.field}, NewValue: ${JSON.stringify(change.newValue)}`);
          }
        } else {
          console.warn(`❌ Experience index ${index} not found for enhancement`);
        }
      } else {
        console.warn('❌ No target specified for enhance action');
      }
      break;
      
    default:
      console.warn(`❌ Unknown action: ${change.action}`);
  }
}

  static updateEducation(data, change) {
    if (!data.education) data.education = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.education.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.education[index]) {
            if (change.field) {
              data.education[index][change.field] = change.newValue;
            } else {
              data.education[index] = { ...data.education[index], ...change.newValue };
            }
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.education.splice(index, 1);
        }
        break;
    }
  }

  static updateSkills(data, change) {
    if (!data.skills) data.skills = [];

    switch (change.action) {
      case 'add':
        if (change.newValue) {
          // Handle both string and object skills
          if (typeof change.newValue === 'string') {
            data.skills.push({ name: change.newValue, level: 'Intermediate' });
          } else {
            data.skills.push(change.newValue);
          }
        }
        break;
      case 'update':
        if (change.target) {
          const skillIndex = data.skills.findIndex(skill => 
            (typeof skill === 'string' ? skill : skill.name) === change.target
          );
          if (skillIndex !== -1) {
            if (typeof change.newValue === 'string') {
              data.skills[skillIndex] = { name: change.newValue, level: 'Intermediate' };
            } else {
              data.skills[skillIndex] = change.newValue;
            }
          }
        }
        break;
      case 'delete':
        if (change.target) {
          data.skills = data.skills.filter(skill => 
            (typeof skill === 'string' ? skill : skill.name) !== change.target
          );
        }
        break;
    }
  }

  static updateCertifications(data, change) {
    if (!data.certifications) data.certifications = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.certifications.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.certifications[index]) {
            data.certifications[index] = { ...data.certifications[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.certifications.splice(index, 1);
        }
        break;
    }
  }

  static updateProjects(data, change) {
    if (!data.projects) data.projects = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.projects.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.projects[index]) {
            data.projects[index] = { ...data.projects[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.projects.splice(index, 1);
        }
        break;
    }
  }

  static updateLanguages(data, change) {
    if (!data.languages) data.languages = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.languages.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.languages[index]) {
            data.languages[index] = { ...data.languages[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.languages.splice(index, 1);
        }
        break;
    }
  }

  /**
   * Generate updated resume file (PDF/DOCX)
   */
  static async generateUpdatedResumeFile(resume, updatedData) {
    try {
      const fileType = resume.fileType;
      let buffer;
      let contentType;
      let extension;

      if (fileType === 'PDF') {
        buffer = await this.generatePDF(updatedData);
        contentType = 'application/pdf';
        extension = '.pdf';
      } else if (fileType === 'DOCX') {
        buffer = await this.generateDOCX(updatedData);
        contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        extension = '.docx';
      } else {
        throw new Error(`Unsupported file type: ${fileType}`);
      }

      // Upload to S3
      const s3Key = `resumes/${resume.userId}/updated_${uuid()}${extension}`;
      
      const uploadParams = {
        Bucket: S3_BUCKET,
        Key: s3Key,
        Body: buffer,
        ContentType: contentType
      };

      await s3Client.send(new PutObjectCommand(uploadParams));
      
      console.log(`✅ Generated updated resume file: ${s3Key}`);
      return s3Key;

    } catch (error) {
      console.error('Error generating updated resume file:', error);
      throw error;
    }
  }

/**
 * Send progress update to connected SSE clients
 */
static sendProgressUpdate(resumeId, userId, stage, percentage, message) {
  try {
    if (global.progressClients) {
      const progressData = {
        type: 'progress',
        resumeId,
        stage,
        percentage,
        message,
        timestamp: new Date().toISOString()
      };
      
      // Send to all clients for this user/resume
      global.progressClients.forEach((res, clientId) => {
        if (clientId.includes(`${userId}_${resumeId}`)) {
          try {
            res.write(`data: ${JSON.stringify(progressData)}\n\n`);
            console.log(`📡 Sent progress: ${percentage}% - ${message}`);
          } catch (error) {
            console.error('Error sending SSE progress:', error);
            global.progressClients.delete(clientId);
          }
        }
      });
    }
  } catch (error) {
    console.error('Error in sendProgressUpdate:', error);
  }
}

  /**
   * Generate PDF from resume data
   */
  static async generatePDF(resumeData) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Header
        doc.fontSize(20).text(resumeData.contactInfo?.name || 'Resume', { align: 'center' });
        doc.fontSize(12);
        
        if (resumeData.contactInfo?.email) {
          doc.text(`Email: ${resumeData.contactInfo.email}`);
        }
        if (resumeData.contactInfo?.phone) {
          doc.text(`Phone: ${resumeData.contactInfo.phone}`);
        }
        if (resumeData.contactInfo?.location) {
          doc.text(`Location: ${resumeData.contactInfo.location}`);
        }

        doc.moveDown();

        // Summary
        if (resumeData.summary) {
          doc.fontSize(14).text('Professional Summary', { underline: true });
          doc.fontSize(11).text(resumeData.summary);
          doc.moveDown();
        }

        // Experience
        if (resumeData.experience && resumeData.experience.length > 0) {
          doc.fontSize(14).text('Work Experience', { underline: true });
          resumeData.experience.forEach(exp => {
            doc.fontSize(12).text(`${exp.title} at ${exp.company}`, { bold: true });
            if (exp.startDate || exp.endDate) {
              doc.fontSize(10).text(`${exp.startDate || ''} - ${exp.endDate || 'Present'}`);
            }
            if (exp.description) {
              doc.fontSize(11).text(exp.description);
            }
            if (exp.highlights && exp.highlights.length > 0) {
              exp.highlights.forEach(highlight => {
                doc.text(`• ${highlight}`);
              });
            }
            doc.moveDown();
          });
        }

        // Education
        if (resumeData.education && resumeData.education.length > 0) {
          doc.fontSize(14).text('Education', { underline: true });
          resumeData.education.forEach(edu => {
            doc.fontSize(12).text(`${edu.degree} in ${edu.field || ''}`);
            doc.fontSize(11).text(edu.institution);
            if (edu.startDate || edu.endDate) {
              doc.fontSize(10).text(`${edu.startDate || ''} - ${edu.endDate || ''}`);
            }
            doc.moveDown();
          });
        }

        // Skills
        if (resumeData.skills && resumeData.skills.length > 0) {
          doc.fontSize(14).text('Skills', { underline: true });
          const skillsText = resumeData.skills.map(skill => 
            typeof skill === 'string' ? skill : `${skill.name} (${skill.level || ''})`
          ).join(', ');
          doc.fontSize(11).text(skillsText);
          doc.moveDown();
        }

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Generate DOCX from resume data
   */
  static async generateDOCX(resumeData) {
    try {
      const children = [];

      // Header
      children.push(
        new Paragraph({
          text: resumeData.contactInfo?.name || 'Resume',
          heading: HeadingLevel.TITLE,
          alignment: 'center'
        })
      );

      if (resumeData.contactInfo?.email) {
        children.push(new Paragraph({ text: `Email: ${resumeData.contactInfo.email}` }));
      }
      if (resumeData.contactInfo?.phone) {
        children.push(new Paragraph({ text: `Phone: ${resumeData.contactInfo.phone}` }));
      }
      if (resumeData.contactInfo?.location) {
        children.push(new Paragraph({ text: `Location: ${resumeData.contactInfo.location}` }));
      }

      // Summary
      if (resumeData.summary) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Professional Summary',
            heading: HeadingLevel.HEADING_1
          }),
          new Paragraph({ text: resumeData.summary })
        );
      }

      // Experience
      if (resumeData.experience && resumeData.experience.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Work Experience',
            heading: HeadingLevel.HEADING_1
          })
        );

        resumeData.experience.forEach(exp => {
          children.push(
            new Paragraph({
              children: [
                new TextRun({ text: `${exp.title} at ${exp.company}`, bold: true })
              ]
            })
          );
          
          if (exp.startDate || exp.endDate) {
            children.push(
              new Paragraph({ text: `${exp.startDate || ''} - ${exp.endDate || 'Present'}` })
            );
          }
          
          if (exp.description) {
            children.push(new Paragraph({ text: exp.description }));
          }
          
          if (exp.highlights && exp.highlights.length > 0) {
            exp.highlights.forEach(highlight => {
              children.push(new Paragraph({ text: `• ${highlight}` }));
            });
          }
        });
      }

      // Education, Skills, etc. (similar pattern)
      if (resumeData.education && resumeData.education.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Education',
            heading: HeadingLevel.HEADING_1
          })
        );

        resumeData.education.forEach(edu => {
          children.push(
            new Paragraph({ text: `${edu.degree} in ${edu.field || ''}` }),
            new Paragraph({ text: edu.institution })
          );
        });
      }

      if (resumeData.skills && resumeData.skills.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Skills',
            heading: HeadingLevel.HEADING_1
          })
        );

        const skillsText = resumeData.skills.map(skill => 
          typeof skill === 'string' ? skill : `${skill.name} (${skill.level || ''})`
        ).join(', ');
        
        children.push(new Paragraph({ text: skillsText }));
      }

      const doc = new Document({
        sections: [{
          properties: {},
          children: children
        }]
      });

      return await Packer.toBuffer(doc);
    } catch (error) {
      console.error('Error generating DOCX:', error);
      throw error;
    }
  }

  /**
   * Summarize changes for version tracking
   */
  static summarizeChanges(changes) {
    if (!changes || changes.length === 0) return 'No changes applied';

    const summary = changes.map(change => {
      const action = change.action.charAt(0).toUpperCase() + change.action.slice(1);
      return `${action} ${change.section}${change.target ? ` (${change.target})` : ''}`;
    }).join(', ');

    return `AI Updates: ${summary}`;
  }

/**
 * Optimize resume for ATS with real progress tracking
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData, progressCallback = null) {
  const startTime = Date.now();
  const stages = [];
  
  const reportProgress = (stage, percentage, message) => {
    stages.push({ stage, percentage, message, timestamp: Date.now() - startTime });
    
    // Send real-time update via SSE
    this.sendProgressUpdate(resumeId, userId, stage, percentage, message);
    
    // Also call the callback if provided
    if (progressCallback) {
      progressCallback(stage, percentage, message);
    }
    
    console.log(`📊 Real Progress: ${percentage}% - ${message}`);
  };

  try {
    console.log(`🤖 AJ: Optimizing resume ${resumeId} for ATS with real progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    reportProgress('analyzing', 20, 'Analyzing resume for ATS optimizations...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Realistic delay
    
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress) 
    reportProgress('applying', 40, 'Generating enhancement suggestions...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    reportProgress('applying', 60, 'Applying ATS optimizations to resume...');
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    reportProgress('analyzing', 80, 'Re-analyzing optimized resume...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    reportProgress('comparing', 90, 'Generating before/after comparison...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;
    const processingTime = Date.now() - startTime;

    // Step 5: Complete (100% progress)
    reportProgress('complete', 100, `Optimization complete! ATS score improved from ${previousScore}% to ${newATSScore}%`);

    console.log(`✅ Real Progress: 100% - ATS optimization complete. Score: ${previousScore}% → ${newATSScore}% (${processingTime}ms)`);

    // Send completion message via SSE
    this.sendProgressUpdate(resumeId, userId, 'complete', 100, 'Optimization completed successfully!');

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison,
      processingTime: processingTime,
      stages: stages
    };

  } catch (error) {
    console.error('ATS optimization with real progress error:', error);
    
    // Send error via SSE
    this.sendProgressUpdate(resumeId, userId, 'error', 0, `Optimization failed: ${error.message}`);
    
    throw error;
  }
}

/**
 * Optimize resume for ATS with progress tracking and before/after comparison
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData) {
  try {
    console.log(`🤖 AJ: Optimizing resume ${resumeId} for ATS with progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    console.log(`📊 Progress: 20% - Analyzing resume for ATS optimizations...`);
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress)
    console.log(`📊 Progress: 60% - Applying ATS optimizations...`);
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    console.log(`📊 Progress: 80% - Re-analyzing optimized resume...`);
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    console.log(`📊 Progress: 90% - Generating before/after comparison...`);
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;

    console.log(`✅ Progress: 100% - ATS optimization complete. Score: ${previousScore}% → ${newATSScore}%`);

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison
    };

  } catch (error) {
    console.error('ATS optimization with progress error:', error);
    throw error;
  }
}

/**
 * Send progress update to connected SSE clients
 */
static sendProgressUpdate(resumeId, userId, stage, percentage, message) {
  try {
    if (global.progressClients) {
      const progressData = {
        type: 'progress',
        resumeId,
        stage,
        percentage,
        message,
        timestamp: new Date().toISOString()
      };
      
      // Send to all clients for this user/resume
      global.progressClients.forEach((res, clientId) => {
        if (clientId.includes(`${userId}_${resumeId}`)) {
          try {
            res.write(`data: ${JSON.stringify(progressData)}\n\n`);
            console.log(`📡 Sent progress: ${percentage}% - ${message}`);
          } catch (error) {
            console.error('Error sending SSE progress:', error);
            global.progressClients.delete(clientId);
          }
        }
      });
    } else {
      console.log('⚠️ No progress clients connected for SSE updates');
    }
  } catch (error) {
    console.error('Error in sendProgressUpdate:', error);
  }
}

/**
 * Optimize resume for ATS with real progress tracking
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData, progressCallback = null) {
  const startTime = Date.now();
  const stages = [];
  
  const reportProgress = (stage, percentage, message) => {
    stages.push({ stage, percentage, message, timestamp: Date.now() - startTime });
    
    // Send real-time update via SSE
    this.sendProgressUpdate(resumeId, userId, stage, percentage, message);
    
    // Also call the callback if provided
    if (progressCallback) {
      progressCallback(stage, percentage, message);
    }
    
    console.log(`📊 Real Progress: ${percentage}% - ${message}`);
  };

  try {
    console.log(`🤖 AJ: Optimizing resume ${resumeId} for ATS with real progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    reportProgress('analyzing', 20, 'Analyzing resume for ATS optimizations...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Realistic delay
    
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress) 
    reportProgress('applying', 40, 'Generating enhancement suggestions...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    reportProgress('applying', 60, 'Applying ATS optimizations to resume...');
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    reportProgress('analyzing', 80, 'Re-analyzing optimized resume...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    reportProgress('comparing', 90, 'Generating before/after comparison...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;
    const processingTime = Date.now() - startTime;

    // Step 5: Complete (100% progress)
    reportProgress('complete', 100, `Optimization complete! ATS score: ${previousScore}% → ${newATSScore}%`);

    console.log(`✅ Real Progress: 100% - ATS optimization complete. Score: ${previousScore}% → ${newATSScore}% (${processingTime}ms)`);

    // Send completion message via SSE
    this.sendProgressUpdate(resumeId, userId, 'complete', 100, 'Optimization completed successfully!');

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison,
      processingTime: processingTime,
      stages: stages
    };

  } catch (error) {
    console.error('ATS optimization with real progress error:', error);
    
    // Send error via SSE
    this.sendProgressUpdate(resumeId, userId, 'error', 0, `Optimization failed: ${error.message}`);
    
    throw error;
  }
}

/**
 * Generate detailed before/after comparison
 */
static generateBeforeAfterComparison(originalData, updatedData) {
  const comparison = {
    scores: {
      before: {
        overallScore: originalData.analysis?.overallScore || 0,
        atsCompatibility: originalData.analysis?.atsCompatibility || 0
      },
      after: {
        overallScore: updatedData.analysis?.overallScore || 0,
        atsCompatibility: updatedData.analysis?.atsCompatibility || 0
      }
    },
    changes: [],
    summary: {
      sectionsModified: 0,
      improvementsCount: 0,
      keywordsAdded: 0
    }
  };

  // Compare experience section
  const originalExp = originalData.parsedData?.experience || [];
  const updatedExp = updatedData.parsedData?.experience || [];

  originalExp.forEach((origJob, index) => {
    if (updatedExp[index]) {
      const updatedJob = updatedExp[index];
      
      // Compare highlights
      if (JSON.stringify(origJob.highlights) !== JSON.stringify(updatedJob.highlights)) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'highlights',
          before: origJob.highlights || [],
          after: updatedJob.highlights || [],
          changeType: 'enhanced',
          impact: 'Improved quantification and ATS keywords'
        });
        comparison.summary.sectionsModified++;
      }

      // Compare description
      if (origJob.description !== updatedJob.description) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'description',
          before: origJob.description || '',
          after: updatedJob.description || '',
          changeType: 'optimized',
          impact: 'Enhanced for ATS compatibility'
        });
      }
    }
  });

  // Compare skills section
  const originalSkills = originalData.parsedData?.skills || [];
  const updatedSkills = updatedData.parsedData?.skills || [];
  
  if (JSON.stringify(originalSkills) !== JSON.stringify(updatedSkills)) {
    comparison.changes.push({
      section: 'skills',
      field: 'skills',
      before: originalSkills,
      after: updatedSkills,
      changeType: 'expanded',
      impact: 'Added relevant keywords and skills'
    });
    comparison.summary.sectionsModified++;
  }

  // Calculate improvement metrics
  comparison.summary.improvementsCount = comparison.changes.length;
  comparison.summary.keywordsAdded = this.countNewKeywords(originalData, updatedData);

  // Generate summary text
  const scoreImprovement = comparison.scores.after.atsCompatibility - comparison.scores.before.atsCompatibility;
  comparison.summaryText = `Enhanced ${comparison.summary.sectionsModified} section${comparison.summary.sectionsModified !== 1 ? 's' : ''} with ${comparison.summary.improvementsCount} improvement${comparison.summary.improvementsCount !== 1 ? 's' : ''}${scoreImprovement > 0 ? `, boosting ATS score by ${scoreImprovement}%` : ''}`;

  return comparison;
}

/**
 * Count new keywords added during optimization
 */
static countNewKeywords(originalData, updatedData) {
  const originalText = JSON.stringify(originalData.parsedData).toLowerCase();
  const updatedText = JSON.stringify(updatedData.parsedData).toLowerCase();
  
  // Simple keyword counting - could be enhanced with more sophisticated analysis
  const commonKeywords = ['api', 'cloud', 'agile', 'leadership', 'development', 'management', 'strategy', 'security'];
  
  let newKeywords = 0;
  commonKeywords.forEach(keyword => {
    const originalCount = (originalText.match(new RegExp(keyword, 'g')) || []).length;
    const updatedCount = (updatedText.match(new RegExp(keyword, 'g')) || []).length;
    if (updatedCount > originalCount) {
      newKeywords += (updatedCount - originalCount);
    }
  });
  
  return newKeywords;
}

/**
 * Generate detailed before/after comparison
 */
static generateBeforeAfterComparison(originalData, updatedData) {
  const comparison = {
    scores: {
      before: {
        overallScore: originalData.analysis?.overallScore || 0,
        atsCompatibility: originalData.analysis?.atsCompatibility || 0
      },
      after: {
        overallScore: updatedData.analysis?.overallScore || 0,
        atsCompatibility: updatedData.analysis?.atsCompatibility || 0
      }
    },
    changes: [],
    summary: {
      sectionsModified: 0,
      improvementsCount: 0,
      keywordsAdded: 0
    }
  };

  // Compare experience section
  const originalExp = originalData.parsedData?.experience || [];
  const updatedExp = updatedData.parsedData?.experience || [];

  originalExp.forEach((origJob, index) => {
    if (updatedExp[index]) {
      const updatedJob = updatedExp[index];
      
      // Compare highlights
      if (JSON.stringify(origJob.highlights) !== JSON.stringify(updatedJob.highlights)) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'highlights',
          before: origJob.highlights || [],
          after: updatedJob.highlights || [],
          changeType: 'enhanced',
          impact: 'Improved quantification and ATS keywords'
        });
        comparison.summary.sectionsModified++;
      }

      // Compare description
      if (origJob.description !== updatedJob.description) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'description',
          before: origJob.description || '',
          after: updatedJob.description || '',
          changeType: 'optimized',
          impact: 'Enhanced for ATS compatibility'
        });
      }
    }
  });

  // Compare skills section
  const originalSkills = originalData.parsedData?.skills || [];
  const updatedSkills = updatedData.parsedData?.skills || [];
  
  if (JSON.stringify(originalSkills) !== JSON.stringify(updatedSkills)) {
    comparison.changes.push({
      section: 'skills',
      field: 'skills',
      before: originalSkills,
      after: updatedSkills,
      changeType: 'expanded',
      impact: 'Added relevant keywords and skills'
    });
    comparison.summary.sectionsModified++;
  }

  // Calculate improvement metrics
  comparison.summary.improvementsCount = comparison.changes.length;
  comparison.summary.keywordsAdded = this.countNewKeywords(originalData, updatedData);

  // Generate summary text
  const scoreImprovement = comparison.scores.after.atsCompatibility - comparison.scores.before.atsCompatibility;
  comparison.summaryText = `Enhanced ${comparison.summary.sectionsModified} section${comparison.summary.sectionsModified !== 1 ? 's' : ''} with ${comparison.summary.improvementsCount} improvement${comparison.summary.improvementsCount !== 1 ? 's' : ''}${scoreImprovement > 0 ? `, boosting ATS score by ${scoreImprovement}%` : ''}`;

  return comparison;
}

/**
 * Count new keywords added during optimization
 */
static countNewKeywords(originalData, updatedData) {
  const originalText = JSON.stringify(originalData.parsedData).toLowerCase();
  const updatedText = JSON.stringify(updatedData.parsedData).toLowerCase();
  
  // Simple keyword counting - could be enhanced with more sophisticated analysis
  const commonKeywords = ['api', 'cloud', 'agile', 'leadership', 'development', 'management', 'strategy', 'security'];
  
  let newKeywords = 0;
  commonKeywords.forEach(keyword => {
    const originalCount = (originalText.match(new RegExp(keyword, 'g')) || []).length;
    const updatedCount = (updatedText.match(new RegExp(keyword, 'g')) || []).length;
    if (updatedCount > originalCount) {
      newKeywords += (updatedCount - originalCount);
    }
  });
  
  return newKeywords;
}

  /**
   * Generate ATS optimization suggestions
   */
  static async generateATSOptimizations(resumeData, targetJob) {
    try {
      let prompt = `You are an ATS (Applicant Tracking System) optimization expert. Analyze this resume and provide specific optimizations to improve ATS compatibility.

CURRENT RESUME DATA:
${JSON.stringify(resumeData, null, 2)}`;

      if (targetJob) {
        prompt += `\n\nTARGET JOB:
Title: ${targetJob.title}
Company: ${targetJob.company}
Description: ${targetJob.description}`;
      }

      prompt += `

Provide ATS optimizations in this JSON format:
{
  "optimizations": [
    {
      "section": "summary|experience|skills|education|etc",
      "type": "keyword_addition|format_improvement|section_enhancement|ats_formatting",
      "change": "specific change to make",
      "reason": "why this improves ATS score",
      "keywords": ["relevant", "keywords", "to", "add"],
      "priority": "high|medium|low"
    }
  ],
  "atsImprovements": {
    "keywordDensity": "improvements needed",
    "formatting": "formatting changes",
    "structure": "structural improvements",
    "content": "content enhancements"
  }
}

Focus on:
1. Adding relevant keywords naturally
2. Improving section headers for ATS parsing
3. Optimizing bullet point structure
4. Enhancing skill descriptions
5. Ensuring proper formatting for ATS scanning

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          {
            role: 'system',
            content: 'You are an ATS optimization expert. Provide specific, actionable suggestions to improve resume ATS compatibility. Return only valid JSON.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 1500
      });

      const responseContent = response.choices[0].message.content.trim();
      const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
      const optimizations = JSON.parse(cleanedResponse);

      return optimizations.optimizations || [];

    } catch (error) {
      console.error('Error generating ATS optimizations:', error);
      throw error;
    }
  }
}

module.exports = ResumeEditorService;

================
File: services/resumeParser.service.js
================
// services/resumeParser.service.js
const { GetObjectCommand } = require('@aws-sdk/client-s3');
const { s3Client, S3_BUCKET } = require('../config/s3');
const { openai } = require('../config/openai');
const pdf = require('pdf-parse');
const mammoth = require('mammoth');

/**
 * Parse a resume file and extract structured data using OpenAI
 * @param {string} fileUrl - S3 key for the resume file
 * @param {string} fileType - Type of file (PDF, DOCX, DOC)
 * @returns {Object} Parsed resume data
 */
exports.parseResume = async (fileUrl, fileType) => {
  try {
    console.log(`Parsing resume file: ${fileUrl}, type: ${fileType}`);
    
    // Debug check for S3 bucket configuration
    console.log('S3 bucket config check:', { bucket: S3_BUCKET });
    
    if (!S3_BUCKET) {
      throw new Error('S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.');
    }
    
    // Get file from S3
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: fileUrl
    };
    
    console.log('Getting file from S3:', { bucket: S3_BUCKET, key: fileUrl });
    
    const { Body } = await s3Client.send(new GetObjectCommand(getObjectParams));
    
    // Convert readable stream to buffer
    const chunks = [];
    for await (const chunk of Body) {
      chunks.push(chunk);
    }
    const buffer = Buffer.concat(chunks);
    
    console.log(`File retrieved from S3, size: ${buffer.length} bytes`);
    
    // Extract text based on file type
    let text = '';
    if (fileType === 'PDF') {
      console.log('Parsing PDF file...');
      const pdfData = await pdf(buffer);
      text = pdfData.text;
    } else if (fileType === 'DOCX') {
      console.log('Parsing DOCX file...');
      const result = await mammoth.extractRawText({ buffer });
      text = result.value;
    } else if (fileType === 'DOC') {
      // For DOC files, we would need a different parser
      // This is a placeholder for now
      console.log('DOC parsing not fully implemented');
      text = 'DOC parsing not fully implemented';
    } else {
      throw new Error(`Unsupported file type: ${fileType}`);
    }
    
    console.log(`Text extracted, length: ${text.length} characters`);
    
    // Process the text using OpenAI to extract structured information
    return await processWithOpenAI(text);
  } catch (error) {
    console.error('Error parsing resume:', error);
    throw error;
  }
};

/**
 * Process resume text with OpenAI to extract structured data
 * @param {string} text - Extracted text from resume
 * @returns {Object} Structured resume data
 */
async function processWithOpenAI(text) {
  try {
    console.log('Processing resume text with OpenAI...');
    
    // Check if text is too long for the API
    const maxTokens = 8000; // GPT-4 can handle ~8000 tokens
    // Rough estimation: 1 token ~= 4 characters in English
    if (text.length > maxTokens * 4) {
      console.log('Text is too long, truncating...');
      text = text.substring(0, maxTokens * 4);
    }
    
    // Prompt for OpenAI to extract structured data from the resume
    const prompt = `
    Extract structured information from the following resume text. 
    Provide the information in JSON format with the following structure:
    {
      "contactInfo": {
        "name": "",
        "email": "",
        "phone": "",
        "location": "",
        "websites": []
      },
      "summary": "",
      "experience": [
        {
          "company": "",
          "title": "",
          "location": "",
          "startDate": "",
          "endDate": "",
          "description": "",
          "highlights": [],
          "skills": []
        }
      ],
      "education": [
        {
          "institution": "",
          "degree": "",
          "field": "",
          "startDate": "",
          "endDate": "",
          "gpa": null,
          "highlights": []
        }
      ],
      "skills": [
        {
          "name": "",
          "level": "",
          "yearsOfExperience": null
        }
      ],
      "certifications": [
        {
          "name": "",
          "issuer": "",
          "dateObtained": "",
          "validUntil": ""
        }
      ],
      "languages": [
        {
          "language": "",
          "proficiency": ""
        }
      ],
      "projects": [
        {
          "name": "",
          "description": "",
          "url": "",
          "startDate": "",
          "endDate": "",
          "skills": []
        }
      ]
    }

    Extract all the information accurately from the resume. For dates, use the format YYYY-MM-DD when possible. 
    If information is not available or empty, leave it as an empty string or null. 
    For arrays, if no elements are present, return an empty array [].
    Make sure to include all skills mentioned in each work experience and project.
    For skill levels, use one of: "Beginner", "Intermediate", "Advanced", or "Expert".
    
    IMPORTANT: Return ONLY the JSON object without any markdown formatting, code blocks, or additional text.

    Resume Text:
    ${text}
    `;

    // Call OpenAI API
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: "You are an expert resume parser that extracts structured information from resume text. Be precise and thorough. Return ONLY valid JSON without any markdown formatting or code blocks."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.2,
      max_tokens: 3000,
    });

    // Get the response content
    const responseContent = response.choices[0].message.content.trim();
    
    // Clean up the response - remove any markdown code block syntax
    let cleanedResponse = responseContent;
    
    // If response starts with ```json or ``` and ends with ```, remove these markers
    if (responseContent.startsWith('```json') || responseContent.startsWith('```')) {
      const startIndex = responseContent.indexOf('{');
      const endIndex = responseContent.lastIndexOf('}');
      
      if (startIndex !== -1 && endIndex !== -1) {
        cleanedResponse = responseContent.substring(startIndex, endIndex + 1);
      }
    }
    
    console.log('Cleaned response for parsing:', cleanedResponse.substring(0, 100) + '...');
    
    // Parse the response
    const parsedData = JSON.parse(cleanedResponse);
    console.log('Resume parsing with OpenAI completed successfully');
    
    return parsedData;
  } catch (error) {
    console.error('Error processing with OpenAI:', error);
    
    // Fallback to a simplified parsed data structure
    return {
      contactInfo: {
        name: 'Parsing Error',
        email: '',
        phone: '',
        location: '',
        websites: []
      },
      summary: 'Error parsing resume. Please try again or contact support.',
      experience: [],
      education: [],
      skills: [],
      certifications: [],
      languages: [],
      projects: []
    };
  }
}

================
File: services/resumeTailoring.service.js
================
// services/resumeTailoring.service.js - FIXED FRESH ANALYSIS ISSUE
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');
const { PutObjectCommand, GetObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const { s3Client, S3_BUCKET } = require('../config/s3');
const path = require('path');
const uuid = require('uuid').v4;
const resumeAnalysisService = require('./resumeAnalysis.service');
const PDFDocument = require('pdfkit');

/**
 * Get tailoring recommendations for a resume based on a job
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @returns {Object} Tailoring recommendations
 */
exports.getTailoringRecommendations = async (resumeId, jobId) => {
  try {
    console.log(`Generating tailoring recommendations for resume ${resumeId} to job ${jobId}`);
    
    // Get the resume, job, and any existing match analysis
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Get the match analysis if it exists
    const matchAnalysis = job.matchAnalysis && job.matchAnalysis.resumeId && 
                          job.matchAnalysis.resumeId.toString() === resumeId ? 
                          job.matchAnalysis : null;
    
    console.log('Generating tailoring recommendations with OpenAI');
    
    // Convert data to strings for OpenAI
    const resumeData = JSON.stringify(resume.parsedData, null, 2);
    const jobData = JSON.stringify(job.parsedData, null, 2);
    const matchData = matchAnalysis ? JSON.stringify(matchAnalysis, null, 2) : 'No match analysis available';
    
    // Prompt for OpenAI to generate tailoring recommendations
    const prompt = `
    Generate detailed recommendations for tailoring the following resume to better match the job description.

    Provide the recommendations in JSON format with the following structure:
    {
      "summary": {
        "original": "original summary text",
        "tailored": "tailored summary text"
      },
      "experienceImprovements": [
        {
          "company": "company name",
          "position": "position title",
          "original": ["original bullet point 1", "original bullet point 2"],
          "tailored": ["tailored bullet point 1", "tailored bullet point 2"]
        }
      ],
      "skillsImprovements": {
        "skillsToAdd": ["skill1", "skill2"],
        "skillsToEmphasize": ["skill3", "skill4"]
      },
      "keywordSuggestions": ["keyword1", "keyword2", "keyword3"],
      "formatSuggestions": ["format suggestion 1", "format suggestion 2"],
      "generalAdvice": "General advice for tailoring this resume to this job"
    }

    Return ONLY the JSON without any markdown formatting, code blocks, or additional explanation.
    Focus on tailoring content to highlight experience and skills that are most relevant to the job.
    The tailored content should be truthful and based on the original resume - no fabrication.
    Use relevant keywords and phrases from the job description naturally.
    Prioritize the most important skills and requirements from the job description.
    Keep the tailored version concise, impactful, and achievement-oriented.

    Resume Data:
    ${resumeData}

    Job Data:
    ${jobData}

    Match Analysis:
    ${matchData}
    `;
    
    // Call OpenAI API
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: "You are an expert resume writer specializing in tailoring resumes to specific job descriptions. Return ONLY JSON without markdown formatting or code blocks."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.4,
      max_tokens: 3000,
    });
    
    // Parse the response
    const content = response.choices[0].message.content;
    
    // Extract JSON from the response if it's wrapped in markdown
    let jsonStr = content;
    
    // Handle potential markdown code blocks
    if (content.includes('```')) {
      const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    // Clean up any extra whitespace or newlines
    jsonStr = jsonStr.trim();
    
    // Ensure it's a valid JSON object
    if (!jsonStr.startsWith('{')) {
      jsonStr = '{' + jsonStr.substring(jsonStr.indexOf('"'));
    }
    if (!jsonStr.endsWith('}')) {
      jsonStr = jsonStr.substring(0, jsonStr.lastIndexOf('}') + 1);
    }
    
    // Parse the cleaned JSON
    const recommendations = JSON.parse(jsonStr);
    console.log('Resume tailoring recommendations with OpenAI completed successfully');
    
    return recommendations;
  } catch (error) {
    console.error('Error generating tailoring recommendations with OpenAI:', error);
    
    // Fallback to a simplified recommendations structure
    return {
      summary: {
        original: "Could not retrieve original summary.",
        tailored: "Could not generate tailored summary. Please try again later."
      },
      experienceImprovements: [],
      skillsImprovements: {
        skillsToAdd: ["Technical error occurred while generating recommendations."],
        skillsToEmphasize: []
      },
      keywordSuggestions: ["Please try again later."],
      formatSuggestions: ["Ensure your resume is clear and concise."],
      generalAdvice: "Focus on highlighting relevant experience and skills that match the job requirements."
    };
  }
};

/**
 * Generate a proper PDF from resume data
 * @param {Object} resumeData - The tailored resume data
 * @param {string} resumeName - Name of the resume
 * @param {Object} jobInfo - Job information for context
 * @returns {Buffer} PDF buffer
 */
function generateResumePDF(resumeData, resumeName, jobInfo) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: 'A4'
      });
      
      const buffers = [];
      
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });
      
      // Helper function to add styled text
      const addText = (text, options = {}) => {
        const defaultOptions = {
          fontSize: 11,
          lineGap: 2
        };
        doc.text(text, { ...defaultOptions, ...options });
      };
      
      // Header with contact info
      if (resumeData.contactInfo) {
        doc.fontSize(18).font('Helvetica-Bold')
           .text(resumeData.contactInfo.name || 'Professional Resume', { align: 'center' });
        
        doc.fontSize(10).font('Helvetica')
           .text([
             resumeData.contactInfo.email,
             resumeData.contactInfo.phone,
             resumeData.contactInfo.location
           ].filter(Boolean).join(' | '), { align: 'center' });
        
        doc.moveDown(1);
      }
      
      // Professional Summary
      if (resumeData.summary) {
        doc.fontSize(14).font('Helvetica-Bold').text('PROFESSIONAL SUMMARY');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        doc.fontSize(11).font('Helvetica').text(resumeData.summary, {
          align: 'justify',
          lineGap: 2
        });
        doc.moveDown(1);
      }
      
      // Work Experience
      if (resumeData.experience && resumeData.experience.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('WORK EXPERIENCE');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.experience.forEach((exp, index) => {
          // Job title and company
          doc.fontSize(12).font('Helvetica-Bold')
             .text(`${exp.title || 'Position'} | ${exp.company || 'Company'}`, { continued: false });
          
          // Dates and location
          const dateStr = exp.startDate && exp.endDate 
            ? `${new Date(exp.startDate).toLocaleDateString()} - ${exp.endDate ? new Date(exp.endDate).toLocaleDateString() : 'Present'}`
            : exp.startDate 
              ? `From ${new Date(exp.startDate).toLocaleDateString()}`
              : 'Date not specified';
          
          doc.fontSize(10).font('Helvetica').fillColor('gray')
             .text(`${dateStr}${exp.location ? ' | ' + exp.location : ''}`, { align: 'right' });
          
          doc.fillColor('black').moveDown(0.3);
          
          // Description
          if (exp.description) {
            doc.fontSize(11).font('Helvetica').text(exp.description, { lineGap: 2 });
            doc.moveDown(0.3);
          }
          
          // Highlights/Achievements
          if (exp.highlights && exp.highlights.length > 0) {
            exp.highlights.forEach(highlight => {
              doc.fontSize(11).font('Helvetica')
                 .text(`• ${highlight}`, { 
                   indent: 15,
                   lineGap: 2,
                   paragraphGap: 2
                 });
            });
          }
          
          // Skills used
          if (exp.skills && exp.skills.length > 0) {
            doc.moveDown(0.3);
            doc.fontSize(10).font('Helvetica-Oblique').fillColor('gray')
               .text(`Technologies: ${exp.skills.join(', ')}`, { lineGap: 2 });
            doc.fillColor('black');
          }
          
          if (index < resumeData.experience.length - 1) {
            doc.moveDown(0.8);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Education
      if (resumeData.education && resumeData.education.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('EDUCATION');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.education.forEach((edu, index) => {
          doc.fontSize(12).font('Helvetica-Bold')
             .text(`${edu.degree || 'Degree'} ${edu.field ? 'in ' + edu.field : ''}`);
          
          doc.fontSize(11).font('Helvetica')
             .text(edu.institution || 'Institution');
          
          if (edu.startDate || edu.endDate) {
            const dateStr = edu.startDate && edu.endDate 
              ? `${new Date(edu.startDate).getFullYear()} - ${new Date(edu.endDate).getFullYear()}`
              : edu.endDate 
                ? new Date(edu.endDate).getFullYear().toString()
                : 'Current';
            
            doc.fontSize(10).font('Helvetica').fillColor('gray')
               .text(dateStr);
            doc.fillColor('black');
          }
          
          if (edu.gpa) {
            doc.fontSize(10).text(`GPA: ${edu.gpa}`);
          }
          
          if (index < resumeData.education.length - 1) {
            doc.moveDown(0.5);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Skills
      if (resumeData.skills && resumeData.skills.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('SKILLS & TECHNOLOGIES');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        const skillsText = resumeData.skills.map(skill => {
          if (typeof skill === 'object' && skill.name) {
            return skill.level ? `${skill.name} (${skill.level})` : skill.name;
          }
          return skill;
        }).join(' • ');
        
        doc.fontSize(11).font('Helvetica').text(skillsText, { lineGap: 2 });
        doc.moveDown(1);
      }
      
      // Certifications
      if (resumeData.certifications && resumeData.certifications.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('CERTIFICATIONS');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.certifications.forEach((cert, index) => {
          doc.fontSize(11).font('Helvetica-Bold').text(cert.name || 'Certification');
          doc.fontSize(10).font('Helvetica').text(cert.issuer || 'Issuer');
          
          if (cert.dateObtained) {
            doc.fontSize(10).fillColor('gray')
               .text(`Obtained: ${new Date(cert.dateObtained).toLocaleDateString()}`);
            doc.fillColor('black');
          }
          
          if (index < resumeData.certifications.length - 1) {
            doc.moveDown(0.5);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Footer note about tailoring
      doc.fontSize(8).font('Helvetica-Oblique').fillColor('gray')
         .text(`This resume has been AI-tailored for ${jobInfo.title} at ${jobInfo.company}`, {
           align: 'center'
         });
      
      // Finalize PDF
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Create a tailored version of a resume for a job
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @param {Object} tailoringOptions - Options for tailoring
 * @returns {Object} New resume version information
 */
exports.createTailoredResume = async (resumeId, jobId, tailoringOptions) => {
  try {
    console.log(`Creating tailored resume for resumeId: ${resumeId}, jobId: ${jobId}`);
    
    // Get the resume and job
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Get tailoring recommendations if not provided
    const tailoringRecommendations = tailoringOptions?.recommendations || 
                                    await this.getTailoringRecommendations(resumeId, jobId);
    
    // Create a new resume with the tailored data
    const userId = resume.userId;
    
    // Create a unique name for the new resume
    const newResumeName = tailoringOptions?.name || 
                         `[AI Tailored] ${resume.name} for ${job.title} at ${job.company}`;
    
    // Create a deep copy of the original resume's parsed data
    const parsedData = JSON.parse(JSON.stringify(resume.parsedData));
    
    // Apply tailoring recommendations to the parsed data
    // Update summary if available
    if (tailoringRecommendations.summary && 
        tailoringRecommendations.summary.tailored && 
        tailoringRecommendations.summary.tailored !== "Could not generate tailored summary. Please try again later.") {
      parsedData.summary = tailoringRecommendations.summary.tailored;
    }
    
    // Update experience bullet points
    if (tailoringRecommendations.experienceImprovements && 
        tailoringRecommendations.experienceImprovements.length > 0) {
      
      tailoringRecommendations.experienceImprovements.forEach(improvement => {
        // Find the matching experience in the original resume
        const experienceIndex = parsedData.experience.findIndex(exp => 
          exp.company === improvement.company && exp.title === improvement.position);
        
        if (experienceIndex !== -1) {
          // If there are highlights, replace them with the tailored ones
          if (parsedData.experience[experienceIndex].highlights && improvement.tailored) {
            parsedData.experience[experienceIndex].highlights = improvement.tailored;
          }
        }
      });
    }
    
    // Add missing skills
    if (tailoringRecommendations.skillsImprovements && 
        tailoringRecommendations.skillsImprovements.skillsToAdd) {
      
      // Create a set of existing skill names for quick lookup
      const existingSkillNames = new Set(parsedData.skills.map(skill => 
        typeof skill === 'string' ? skill.toLowerCase() : skill.name.toLowerCase()));
      
      // Add new skills that don't already exist
      tailoringRecommendations.skillsImprovements.skillsToAdd.forEach(skill => {
        if (!existingSkillNames.has(skill.toLowerCase())) {
          // If existing skills are objects with name property
          if (parsedData.skills.length > 0 && typeof parsedData.skills[0] === 'object') {
            parsedData.skills.push({
              name: skill,
              level: "Intermediate", // Default level
              yearsOfExperience: null
            });
          } else {
            // If existing skills are just strings
            parsedData.skills.push(skill);
          }
        }
      });
    }
    
    console.log('Generating tailored resume PDF...');
    
    // Generate the tailored resume as a proper PDF
    const pdfBuffer = await generateResumePDF(parsedData, newResumeName, {
      title: job.title,
      company: job.company
    });
    
    // Generate a unique S3 key
    const s3Key = `resumes/${userId}/${uuid()}.pdf`;
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: pdfBuffer,
      ContentType: 'application/pdf'
    };
    
    await s3Client.send(new PutObjectCommand(uploadParams));
    console.log('Tailored resume PDF uploaded to S3:', s3Key);
    
    // Create a new resume document in MongoDB WITHOUT ANALYSIS INITIALLY
    const newResume = new Resume({
      userId,
      name: newResumeName,
      originalFilename: `${newResumeName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`,
      fileUrl: s3Key,
      fileType: 'PDF',
      isActive: false,
      parsedData: parsedData,
      analysis: null, // CRITICAL: Set to null initially to force fresh analysis
      isTailored: true,
      tailoredForJob: {
        jobId: job._id,
        jobTitle: job.title,
        company: job.company,
        originalResumeId: resume._id
      },
      versions: [],
      processingStatus: {
        status: 'analyzing',
        progress: 75,
        message: 'Running fresh AI analysis on tailored resume...',
        updatedAt: new Date()
      }
    });
    
    // CRITICAL: Save the resume FIRST, then run analysis
    await newResume.save();
    console.log('Tailored resume created successfully with ID:', newResume._id);
    
    // CRITICAL: Add a delay to ensure the resume is fully saved before analysis
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // CRITICAL: Run fresh analysis on the tailored resume in a separate process
    console.log('Starting fresh AI analysis for tailored resume...');
    
    try {
      // Force a fresh analysis by calling the service directly
      const analysis = await resumeAnalysisService.analyzeResume(newResume._id);
      
      console.log('Fresh analysis completed:', {
        resumeId: newResume._id,
        overallScore: analysis.overallScore,
        atsCompatibility: analysis.atsCompatibility,
        hasProfileSummary: !!analysis.profileSummary,
        strengthsCount: analysis.strengths?.length || 0
      });
      
      // CRITICAL: Update the resume with the NEW analysis scores
      await Resume.findByIdAndUpdate(newResume._id, {
        $set: {
          analysis: analysis,
          processingStatus: {
            status: 'completed',
            progress: 100,
            message: 'Fresh analysis completed successfully',
            updatedAt: new Date()
          }
        }
      }, { new: true });
      
      console.log('✅ Fresh analysis saved to database successfully');
      
      // Update the local object for return
      newResume.analysis = analysis;
      newResume.processingStatus = {
        status: 'completed',
        progress: 100,
        message: 'Fresh analysis completed successfully',
        updatedAt: new Date()
      };
      
    } catch (analysisError) {
      console.error('❌ Error running fresh analysis on tailored resume:', analysisError);
      
      // Update status to show analysis failed
      await Resume.findByIdAndUpdate(newResume._id, {
        $set: {
          analysis: {
            overallScore: 0,
            atsCompatibility: 0,
            profileSummary: { currentRole: "Analysis pending", careerLevel: "Unknown", industries: [], suggestedJobTitles: [], suggestedIndustries: [] },
            strengths: ["Analysis in progress..."],
            weaknesses: ["Analysis in progress..."],
            keywordsSuggestions: ["Analysis in progress..."],
            improvementAreas: []
          },
          processingStatus: {
            status: 'error',
            progress: 50,
            message: 'Fresh analysis failed - please try manual analysis',
            error: analysisError.message,
            updatedAt: new Date()
          }
        }
      });
      
      // Set the error state in the local object
      newResume.analysis = {
        overallScore: 0,
        atsCompatibility: 0,
        profileSummary: { currentRole: "Analysis pending", careerLevel: "Unknown", industries: [], suggestedJobTitles: [], suggestedIndustries: [] },
        strengths: ["Analysis failed - please retry"],
        weaknesses: ["Analysis failed - please retry"],
        keywordsSuggestions: ["Analysis failed - please retry"],
        improvementAreas: []
      };
    }
    
    // AUTOMATIC TRIGGER: Re-match THIS SPECIFIC JOB with the new tailored resume
    console.log('🔄 Auto-triggering job re-match with new tailored resume...');
    try {
      const jobMatchingService = require('./jobMatching.service');
      
      // Force re-match this specific job with the new tailored resume
      const matchAnalysis = await jobMatchingService.matchResumeWithJob(newResume._id, jobId);
      
      // Update the job's match analysis with the new tailored resume
      job.matchAnalysis = {
        ...matchAnalysis,
        resumeId: newResume._id,
        lastAnalyzed: new Date(),
        analysisVersion: '2.0-tailored-auto',
        tailoredResumeId: newResume._id
      };
      
      await job.save();
      
      console.log('✅ Job-specific auto re-match completed:', {
        jobId: job._id,
        jobTitle: job.title,
        newScore: `${matchAnalysis.overallScore}%`,
        usedTailoredResume: newResume.name
      });
      
    } catch (rematchError) {
      console.error('❌ Auto re-match failed (non-critical):', rematchError.message);
      // Still add reference even if re-matching fails
      if (job.matchAnalysis) {
        job.matchAnalysis.tailoredResumeId = newResume._id;
        await job.save();
      }
    }
    
    // Generate a signed URL for downloading
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: s3Key
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
    
    return {
      message: "Tailored resume created successfully with fresh analysis",
      resume: {
        id: newResume._id,
        name: newResume.name,
        originalFilename: newResume.originalFilename,
        fileType: newResume.fileType,
        isTailored: newResume.isTailored,
        downloadUrl: signedUrl,
        analysis: newResume.analysis,
        processingStatus: newResume.processingStatus,
        createdAt: newResume.createdAt
      }
    };
  } catch (error) {
    console.error('Error creating tailored resume:', error);
    throw error;
  }
};

================
File: test-controller.js
================
// backend/test-controller.js - Simple test to verify our controller works
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function testController() {
  try {
    console.log('🧪 TESTING BACKEND CONTROLLER');
    console.log('==============================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Simulate the exact query from the controller
    const sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
        AND (
          COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $2 OR
          COALESCE(r.title, '') ILIKE $2
        )
      ORDER BY r.first_name ASC
      LIMIT 20 OFFSET 0
    `;

    const queryParams = [userId, `%${query}%`];

    console.log('🗄️ Testing exact controller query...');
    console.log('📝 SQL Query:', sqlQuery.replace(/\s+/g, ' ').trim());
    console.log('📝 Query Params:', queryParams);

    const result = await pool.query(sqlQuery, queryParams);
    
    console.log(`📊 Query returned ${result.rows.length} rows`);
    
    if (result.rows.length > 0) {
      console.log('✅ SUCCESS: Found results!');
      console.log('👥 Sample results:');
      result.rows.slice(0, 5).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    } else {
      console.log('❌ PROBLEM: No results found');
    }

    // Test count query
    const countQuery = `
      SELECT COUNT(*) as count FROM recruiters r 
      WHERE r.is_active = true
        AND (
          COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $1 OR
          COALESCE(r.title, '') ILIKE $1
        )
    `;

    const countResult = await pool.query(countQuery, [`%${query}%`]);
    console.log(`📊 Count query returned: ${countResult.rows[0].count}`);

    console.log('\n✅ Test complete!');

  } catch (error) {
    console.error('❌ Test failed:', error);
  } finally {
    await pool.end();
  }
}

testController();

================
File: test-extraction.js
================
// test-extraction.js - Quick test script for the new extraction methods
const jobBoardAPIsService = require('./services/jobBoardAPIs.service');
const headlessScraperService = require('./services/headlessScraper.service');

// Test configuration
const testCompanies = [
  {
    name: 'Lever Test Company',
    careerUrl: 'https://jobs.lever.co/example',
    industry: 'Technology'
  },
  {
    name: 'Simple Tech Company',
    careerUrl: 'https://example-tech.com/careers',
    industry: 'Technology'
  }
];

const testCareerProfile = {
  jobTitles: ['Software Engineer', 'Frontend Developer', 'Product Manager'],
  industries: ['Technology', 'Software'],
  experienceLevel: 'mid',
  keySkills: ['JavaScript', 'React', 'Node.js']
};

async function testExtractionMethods() {
  console.log('🧪 Testing extraction methods...\n');
  
  for (const company of testCompanies) {
    console.log(`\n🏢 Testing ${company.name}...`);
    console.log(`URL: ${company.careerUrl}`);
    
    // Test 1: ATS Platform Detection
    console.log('\n1️⃣ Testing ATS Platform Detection...');
    try {
      const atsInfo = await jobBoardAPIsService.detectATSPlatform(company.careerUrl);
      console.log('ATS Detection Result:', {
        platform: atsInfo.platform,
        hasAPI: atsInfo.hasAPI,
        slug: atsInfo.slug,
        apiUrl: atsInfo.apiUrl ? atsInfo.apiUrl.substring(0, 100) + '...' : null
      });
    } catch (error) {
      console.error('ATS Detection Error:', error.message);
    }
    
    // Test 2: Free APIs
    console.log('\n2️⃣ Testing Free APIs...');
    try {
      const apiResult = await jobBoardAPIsService.tryFreeAPIs(company, testCareerProfile);
      console.log('API Result:', {
        success: apiResult.success,
        method: apiResult.method,
        platform: apiResult.platform,
        jobsFound: apiResult.jobs?.length || 0
      });
      
      if (apiResult.jobs && apiResult.jobs.length > 0) {
        console.log('Sample job:', {
          title: apiResult.jobs[0].title,
          company: apiResult.jobs[0].company,
          location: apiResult.jobs[0].location
        });
      }
    } catch (error) {
      console.error('API Test Error:', error.message);
    }
    
    // Test 3: Pattern Scraping (only test for non-real URLs to avoid hitting real sites)
    if (company.careerUrl.includes('example')) {
      console.log('\n3️⃣ Testing Pattern Scraping...');
      try {
        const patternResult = await headlessScraperService.tryPatternScraping(company, testCareerProfile);
        console.log('Pattern Scraping Result:', {
          success: patternResult.success,
          method: patternResult.method,
          jobsFound: patternResult.jobs?.length || 0,
          error: patternResult.error
        });
      } catch (error) {
        console.error('Pattern Scraping Error:', error.message);
      }
    }
    
    console.log('\n' + '='.repeat(50));
  }
  
  // Test 4: Job relevance filtering
  console.log('\n4️⃣ Testing Job Relevance Filtering...');
  
  const testJobs = [
    { title: 'Senior Software Engineer', company: 'TestCorp' },
    { title: 'Frontend Developer', company: 'TestCorp' },
    { title: 'Product Manager', company: 'TestCorp' },
    { title: 'Marketing Specialist', company: 'TestCorp' },
    { title: 'Data Scientist', company: 'TestCorp' },
    { title: 'Junior Developer', company: 'TestCorp' }
  ];
  
  console.log('Test jobs:', testJobs.map(j => j.title));
  console.log('Career profile targets:', testCareerProfile.jobTitles);
  
  // Import the filtering function (you'll need to expose this from the service)
  // This is just for testing - in real implementation it's internal
  
  await headlessScraperService.cleanup();
  console.log('\n✅ Testing completed!');
}

// Helper function to test just ATS detection without hitting APIs
async function quickATSTest() {
  console.log('🔍 Quick ATS Detection Test...\n');
  
  const testUrls = [
    'https://boards.greenhouse.io/company',
    'https://jobs.lever.co/company',
    'https://company.myworkdayjobs.com/careers',
    'https://company.bamboohr.com/jobs/',
    'https://regular-company.com/careers'
  ];
  
  for (const url of testUrls) {
    console.log(`Testing: ${url}`);
    try {
      const result = await jobBoardAPIsService.detectATSPlatform(url);
      console.log(`  Platform: ${result.platform}, Has API: ${result.hasAPI}, Slug: ${result.slug}\n`);
    } catch (error) {
      console.log(`  Error: ${error.message}\n`);
    }
  }
}

// Run the appropriate test
if (process.argv.includes('--quick')) {
  quickATSTest().catch(console.error);
} else if (process.argv.includes('--ats-only')) {
  quickATSTest().catch(console.error);
} else {
  testExtractionMethods().catch(console.error);
}

module.exports = { testExtractionMethods, quickATSTest };

================
File: test-s3.js
================
// test-s3.js
const AWS = require('aws-sdk');
const fs = require('fs');
require('dotenv').config();

// Configure AWS SDK
AWS.config.update({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1'
});

const s3 = new AWS.S3();
const bucketName = process.env.AWS_BUCKET_NAME;

// Create a test file
const testFilePath = './test-file.txt';
fs.writeFileSync(testFilePath, 'This is a test file for S3 upload');

// Test bucket connection and file upload
async function testS3() {
  try {
    // Check if bucket exists
    await s3.headBucket({ Bucket: bucketName }).promise();
    console.log(`✅ Successfully connected to bucket: ${bucketName}`);
    
    // Upload a test file
    const fileContent = fs.readFileSync(testFilePath);
    const params = {
      Bucket: bucketName,
      Key: 'test-file.txt',
      Body: fileContent
    };
    
    const uploadResult = await s3.upload(params).promise();
    console.log(`✅ Successfully uploaded file to: ${uploadResult.Location}`);
    
    // List files in bucket
    const listResult = await s3.listObjectsV2({ Bucket: bucketName }).promise();
    console.log('Files in bucket:');
    listResult.Contents.forEach(item => {
      console.log(` - ${item.Key} (${item.Size} bytes)`);
    });
    
    // Clean up - delete test file
    await s3.deleteObject({ Bucket: bucketName, Key: 'test-file.txt' }).promise();
    console.log('✅ Successfully deleted test file');
    
    console.log('All S3 tests passed! Your configuration is working.');
  } catch (error) {
    console.error('❌ S3 Test Error:', error);
  } finally {
    // Delete local test file
    fs.unlinkSync(testFilePath);
  }
}

testS3();

================
File: tests/test-auth.js
================
// backend/tests/test-auth.js
require('dotenv').config();
const axios = require('axios');
const mongoose = require('mongoose');
const connectMongoDB = require('../config/mongodb');

const API_URL = 'http://localhost:5000/api';

// Helper function to make API requests
const api = axios.create({
  baseURL: API_URL,
  withCredentials: true
});

// Test user details
const testUser = {
  firstName: 'Test',
  lastName: 'User',
  email: `testuser${Date.now()}@example.com`,
  password: 'Test@123456'
};

let token = null;

const runTests = async () => {
  try {
    console.log('Starting authentication tests...');
    
    // Connect to MongoDB
    await connectMongoDB();
    
    // Clean up any previous test users
    await mongoose.connection.collection('users').deleteMany({
      email: { $regex: /testuser.*@example.com/ }
    });
    
    // Test registration
    console.log('\nTesting user registration...');
    const registrationResponse = await api.post('/auth/register', testUser);
    console.log('Registration response status:', registrationResponse.status);
    console.log('Registration data:', registrationResponse.data);
    
    // Save token
    token = registrationResponse.data.token;
    
    // Test get current user
    console.log('\nTesting get current user...');
    const meResponse = await api.get('/auth/me', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    console.log('Get me response status:', meResponse.status);
    console.log('User data:', meResponse.data);
    
    // Test logout
    console.log('\nTesting logout...');
    const logoutResponse = await api.post('/auth/logout', {}, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    console.log('Logout response status:', logoutResponse.status);
    console.log('Logout data:', logoutResponse.data);
    
    // Test login
    console.log('\nTesting login...');
    const loginResponse = await api.post('/auth/login', {
      email: testUser.email,
      password: testUser.password
    });
    console.log('Login response status:', loginResponse.status);
    console.log('Login data:', loginResponse.data);
    
    // Save new token
    token = loginResponse.data.token;
    
    // Test updating user details
    console.log('\nTesting update user details...');
    const updateResponse = await api.put('/auth/update-details', 
      { firstName: 'Updated', lastName: 'User' },
      {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }
    );
    console.log('Update details response status:', updateResponse.status);
    console.log('Updated user data:', updateResponse.data);
    
    // Test updating password
    console.log('\nTesting update password...');
    const updatePasswordResponse = await api.put('/auth/update-password', 
      { 
        currentPassword: testUser.password,
        newPassword: 'NewTest@123456'
      },
      {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }
    );
    console.log('Update password response status:', updatePasswordResponse.status);
    console.log('Update password data:', updatePasswordResponse.data);
    
    // Test login with new password
    console.log('\nTesting login with new password...');
    const newLoginResponse = await api.post('/auth/login', {
      email: testUser.email,
      password: 'NewTest@123456'
    });
    console.log('New login response status:', newLoginResponse.status);
    console.log('New login data:', newLoginResponse.data);
    
    console.log('\nAll authentication tests completed successfully!');
  } catch (error) {
    console.error('Error in authentication tests:', error.message);
    if (error.response) {
      console.error('Response data:', error.response.data);
      console.error('Response status:', error.response.status);
    }
  } finally {
    // Clean up test user
    if (mongoose.connection.readyState === 1) {
      await mongoose.connection.collection('users').deleteMany({
        email: testUser.email
      });
      console.log('\nTest user cleaned up');
      
      // Close the MongoDB connection
      await mongoose.connection.close();
      console.log('MongoDB connection closed');
    }
    
    process.exit(0);
  }
};

runTests();

================
File: tests/test-neon-connection.js
================
// backend/tests/test-neon-connection.js
require('dotenv').config();
const db = require('../config/postgresql');

const testNeonConnection = async () => {
  try {
    // Test basic connection
    const result = await db.query('SELECT NOW() as current_time');
    console.log('Connection successful!');
    console.log('Current server time:', result.rows[0].current_time);
    
    // Test creating a simple table
    await db.query(`
      CREATE TABLE IF NOT EXISTS connection_test (
        id SERIAL PRIMARY KEY,
        test_message TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('Test table created successfully');
    
    // Insert a test record
    const insertResult = await db.query(
      'INSERT INTO connection_test (test_message) VALUES ($1) RETURNING *',
      ['Connection test from job application platform']
    );
    console.log('Test record inserted:', insertResult.rows[0]);
    
    // Query the test record
    const records = await db.query('SELECT * FROM connection_test');
    console.log('All test records:', records.rows);
    
    console.log('Neon PostgreSQL connection test completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('Neon PostgreSQL connection test failed:', error);
    console.error('Error details:', error.message);
    process.exit(1);
  }
};

testNeonConnection();

================
File: utils/email-templates.js
================
// backend/utils/email-templates.js
/**
 * Generate verification email HTML
 * @param {string} firstName User's first name
 * @param {string} verificationUrl Verification URL
 * @returns {string} HTML email content
 */
exports.generateVerificationEmail = (firstName, verificationUrl) => {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Verify Your Email</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .logo {
            text-align: center;
            margin-bottom: 20px;
          }
          .container {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
          }
          .button {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 20px 0;
          }
          .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #777;
            text-align: center;
          }
        </style>
      </head>
      <body>
        <div class="logo">
          <h2>Job Application Platform</h2>
        </div>
        <div class="container">
          <h2>Hello ${firstName},</h2>
          <p>Welcome to the Job Application Platform! Please verify your email address to get started.</p>
          <p>This link will expire in 24 hours.</p>
          <a href="${verificationUrl}" class="button">Verify Email Address</a>
          <p>If you didn't create an account, you can safely ignore this email.</p>
        </div>
        <div class="footer">
          <p>&copy; 2025 Job Application Platform. All rights reserved.</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </body>
      </html>
    `;
  };
  
  /**
   * Generate password reset email HTML
   * @param {string} firstName User's first name
   * @param {string} resetUrl Reset URL
   * @returns {string} HTML email content
   */
  exports.generatePasswordResetEmail = (firstName, resetUrl) => {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Reset Your Password</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .logo {
            text-align: center;
            margin-bottom: 20px;
          }
          .container {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
          }
          .button {
            display: inline-block;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 20px 0;
          }
          .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #777;
            text-align: center;
          }
        </style>
      </head>
      <body>
        <div class="logo">
          <h2>Job Application Platform</h2>
        </div>
        <div class="container">
          <h2>Hello ${firstName},</h2>
          <p>We received a request to reset your password. Click the button below to create a new password.</p>
          <p>This link will expire in 10 minutes.</p>
          <a href="${resetUrl}" class="button">Reset Password</a>
          <p>If you didn't request a password reset, you can safely ignore this email.</p>
        </div>
        <div class="footer">
          <p>&copy; 2025 Job Application Platform. All rights reserved.</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </body>
      </html>
    `;
  };

================
File: utils/jobBoardPatterns.js
================
// utils/jobBoardPatterns.js
/**
 * Pattern-based scraping for career pages
 * Covers ~35% additional companies with predictable patterns
 */

// Common CSS selectors for job listings
const CSS_SELECTORS = {
  jobLinks: [
    'a[href*="/job/"]',
    'a[href*="/jobs/"]',
    'a[href*="/career/"]',
    'a[href*="/careers/"]',
    'a[href*="/position/"]',
    'a[href*="/opening/"]',
    '.job-link a',
    '.job-item a',
    '.position-link a',
    '.career-item a',
    '[data-job-id] a',
    '.job-listing a',
    '.job-card a',
    '.position-card a'
  ],
  
  jobTitles: [
    '.job-title',
    '.position-title',
    '.role-title',
    'h2 a',
    'h3 a',
    '[data-job-title]',
    '.title a',
    '.job-name',
    '.position-name'
  ],
  
  jobDescriptions: [
    '.job-description',
    '.position-description',
    '.job-content',
    '.job-details',
    '.position-details',
    '.description',
    '.content'
  ],
  
  locations: [
    '.job-location',
    '.position-location',
    '.location',
    '[data-location]',
    '.office-location',
    '.work-location'
  ],
  
  departments: [
    '.job-department',
    '.department',
    '.team',
    '[data-department]',
    '.job-category',
    '.category'
  ]
};

// URL patterns for different career page types
const URL_PATTERNS = {
  workday: {
    basePattern: /myworkdayjobs\.com\/([^\/]+)/,
    jobUrlPattern: /myworkdayjobs\.com\/[^\/]+\/job\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://${company}.myworkdayjobs.com/${company}/search`,
    selectors: {
      jobLinks: 'a[data-automation-id="jobTitle"]',
      jobTitles: '[data-automation-id="jobTitle"]',
      locations: '[data-automation-id="locations"]',
      departments: '[data-automation-id="jobCategory"]'
    }
  },
  
  bamboohr: {
    basePattern: /bamboohr\.com\/jobs\/([^\/]+)/,
    jobUrlPattern: /bamboohr\.com\/jobs\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://${company}.bamboohr.com/jobs/`,
    selectors: {
      jobLinks: '.job-board-item a',
      jobTitles: '.job-board-item h3',
      locations: '.job-board-item .location',
      departments: '.job-board-item .department'
    }
  },
  
  smartrecruiters: {
    basePattern: /jobs\.smartrecruiters\.com\/([^\/]+)/,
    jobUrlPattern: /jobs\.smartrecruiters\.com\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://jobs.smartrecruiters.com/${company}`,
    selectors: {
      jobLinks: '.opening-job a',
      jobTitles: '.opening-job h4',
      locations: '.opening-job .location',
      departments: '.opening-job .department'
    }
  },
  
  jobvite: {
    basePattern: /jobs\.jobvite\.com\/([^\/]+)/,
    jobUrlPattern: /jobs\.jobvite\.com\/[^\/]+\/job\/([^\/]+)/,
    searchEndpoint: (company) => `https://jobs.jobvite.com/${company}/search?c=&l=&t=&s=`,
    selectors: {
      jobLinks: '.jv-job-list-item a',
      jobTitles: '.jv-job-list-item h3',
      locations: '.jv-job-list-item .location',
      departments: '.jv-job-list-item .department'
    }
  },
  
  icims: {
    basePattern: /careers\.icims\.com\/jobs\/([^\/]+)/,
    jobUrlPattern: /careers\.icims\.com\/jobs\/\d+\/job/,
    searchEndpoint: (company) => `https://careers.icims.com/jobs/search?ss=1&searchCompany=${company}`,
    selectors: {
      jobLinks: '.iCIMS_JobsTable a',
      jobTitles: '.iCIMS_JobsTable .title',
      locations: '.iCIMS_JobsTable .location',
      departments: '.iCIMS_JobsTable .department'
    }
  },
  
  // Custom corporate career pages
  custom: {
    commonSelectors: CSS_SELECTORS,
    urlIndicators: [
      '/careers',
      '/jobs',
      '/work-with-us',
      '/join-us',
      '/employment',
      '/opportunities'
    ]
  }
};

// Common job title patterns for filtering
const JOB_TITLE_PATTERNS = {
  software: [
    'software engineer',
    'software developer',
    'full stack',
    'frontend',
    'backend',
    'web developer',
    'mobile developer',
    'devops',
    'sre'
  ],
  
  product: [
    'product manager',
    'product owner',
    'product marketing',
    'technical product',
    'senior product'
  ],
  
  data: [
    'data scientist',
    'data engineer',
    'data analyst',
    'machine learning',
    'ai engineer',
    'analytics'
  ],
  
  design: [
    'ux designer',
    'ui designer',
    'product designer',
    'graphic designer',
    'visual designer'
  ],
  
  marketing: [
    'marketing manager',
    'growth marketing',
    'digital marketing',
    'content marketing',
    'marketing specialist'
  ],
  
  sales: [
    'sales manager',
    'account executive',
    'sales development',
    'business development',
    'sales representative'
  ]
};

// Experience level indicators
const EXPERIENCE_INDICATORS = {
  entry: [
    'entry level',
    'junior',
    'associate',
    'new grad',
    'graduate',
    '0-2 years',
    'early career'
  ],
  
  mid: [
    'mid level',
    'intermediate',
    '3-5 years',
    '2-4 years',
    'experienced'
  ],
  
  senior: [
    'senior',
    'sr.',
    'lead',
    'principal',
    '5+ years',
    '7+ years',
    'expert'
  ],
  
  executive: [
    'director',
    'manager',
    'head of',
    'vp',
    'vice president',
    'chief',
    'executive'
  ]
};

/**
 * Detect career page type from URL
 * @param {string} url - Career page URL
 * @returns {Object} { type, pattern, config }
 */
exports.detectCareerPageType = (url) => {
  const lowerUrl = url.toLowerCase();
  
  // Check for known ATS patterns
  for (const [type, config] of Object.entries(URL_PATTERNS)) {
    if (type === 'custom') continue;
    
    if (config.basePattern && config.basePattern.test(url)) {
      return {
        type,
        pattern: config.basePattern,
        config,
        isKnownATS: true
      };
    }
  }
  
  // Check for custom corporate career pages
  const hasCareerIndicator = URL_PATTERNS.custom.urlIndicators.some(
    indicator => lowerUrl.includes(indicator)
  );
  
  if (hasCareerIndicator) {
    return {
      type: 'custom',
      pattern: null,
      config: URL_PATTERNS.custom,
      isKnownATS: false
    };
  }
  
  return {
    type: 'unknown',
    pattern: null,
    config: null,
    isKnownATS: false
  };
};

/**
 * Extract company identifier from URL
 * @param {string} url - Career page URL
 * @param {string} type - Career page type
 * @returns {string} Company identifier
 */
exports.extractCompanyId = (url, type) => {
  const config = URL_PATTERNS[type];
  if (!config || !config.basePattern) {
    return null;
  }
  
  const match = url.match(config.basePattern);
  return match ? match[1] : null;
};

/**
 * Get CSS selectors for a career page type
 * @param {string} type - Career page type
 * @returns {Object} CSS selectors object
 */
exports.getSelectorsForType = (type) => {
  const config = URL_PATTERNS[type];
  if (!config) {
    return CSS_SELECTORS;
  }
  
  return config.selectors || CSS_SELECTORS;
};

/**
 * Generate search endpoint URL for known ATS
 * @param {string} type - ATS type
 * @param {string} companyId - Company identifier
 * @returns {string} Search endpoint URL
 */
exports.generateSearchEndpoint = (type, companyId) => {
  const config = URL_PATTERNS[type];
  if (!config || !config.searchEndpoint) {
    return null;
  }
  
  return config.searchEndpoint(companyId);
};

/**
 * Check if job title matches career profile
 * @param {string} jobTitle - Job title to check
 * @param {Object} careerProfile - User career profile
 * @returns {Object} { isMatch, score, matchedCategory }
 */
exports.isJobTitleRelevant = (jobTitle, careerProfile) => {
  if (!jobTitle || !careerProfile) {
    return { isMatch: false, score: 0, matchedCategory: null };
  }
  
  const lowerTitle = jobTitle.toLowerCase();
  
  // Check against target job titles from career profile
  if (careerProfile.jobTitles) {
    for (const targetTitle of careerProfile.jobTitles) {
      const targetLower = targetTitle.toLowerCase();
      const titleWords = targetLower.split(' ');
      
      // Calculate word overlap
      const matchedWords = titleWords.filter(word => 
        word.length > 2 && lowerTitle.includes(word)
      );
      
      if (matchedWords.length > 0) {
        const score = Math.round((matchedWords.length / titleWords.length) * 100);
        if (score >= 50) { // At least 50% word match
          return { 
            isMatch: true, 
            score, 
            matchedCategory: 'direct_title_match',
            matchedTitle: targetTitle
          };
        }
      }
    }
  }
  
  // Check against job category patterns
  for (const [category, patterns] of Object.entries(JOB_TITLE_PATTERNS)) {
    for (const pattern of patterns) {
      if (lowerTitle.includes(pattern)) {
        // Check if this category aligns with user's experience
        if (careerProfile.industries && 
            careerProfile.industries.some(industry => 
              industry.toLowerCase().includes(category) ||
              category === 'software' && industry.toLowerCase().includes('tech')
            )) {
          return { 
            isMatch: true, 
            score: 70, 
            matchedCategory: category,
            matchedPattern: pattern
          };
        }
      }
    }
  }
  
  return { isMatch: false, score: 0, matchedCategory: null };
};

/**
 * Check if experience level matches career profile
 * @param {string} jobTitle - Job title or description
 * @param {Object} careerProfile - User career profile
 * @returns {boolean} Whether experience level is appropriate
 */
exports.isExperienceLevelAppropriate = (jobTitle, careerProfile) => {
  if (!jobTitle || !careerProfile || !careerProfile.experienceLevel) {
    return true; // Default to include if unclear
  }
  
  const lowerTitle = jobTitle.toLowerCase();
  const userLevel = careerProfile.experienceLevel.toLowerCase();
  
  // Check for experience indicators in job title
  for (const [level, indicators] of Object.entries(EXPERIENCE_INDICATORS)) {
    if (indicators.some(indicator => lowerTitle.includes(indicator))) {
      // Match experience levels appropriately
      if (userLevel === 'entry' && ['mid', 'senior', 'executive'].includes(level)) {
        return false; // Entry level shouldn't see senior roles
      }
      if (userLevel === 'mid' && level === 'executive') {
        return false; // Mid level shouldn't see executive roles
      }
      break;
    }
  }
  
  return true;
};

/**
 * Validate if URL is a direct job posting
 * @param {string} url - URL to validate
 * @returns {boolean} Whether URL points to a specific job
 */
exports.isDirectJobPostingUrl = (url) => {
  if (!url || typeof url !== 'string') {
    return false;
  }
  
  const lowerUrl = url.toLowerCase();
  
  // Invalid patterns (job boards, not specific jobs)
  const invalidPatterns = [
    /\/embed\/job_board/,
    /job_board\?for=/,
    /\/careers\/?$/,
    /\/jobs\/?$/,
    /\/careers\/all/,
    /\/careers\/search/,
    /\/careers\/openings\/?$/
  ];
  
  if (invalidPatterns.some(pattern => pattern.test(url))) {
    return false;
  }
  
  // Valid job posting patterns
  const validPatterns = [
    /\/job\/\d+/,
    /\/jobs\/\d+/,
    /\/careers\/\d+/,
    /\/positions\/\d+/,
    /\/job-description\/?\?.*id=/,
    /\/careers\/job\/[^\/]+/,
    /\/jobs\/[^\/\?]+$/,
    /\/position\/[^\/\?]+$/,
    /\/openings\/[^\/\?]+$/,
    /job-id[=_-]\d+/,
    /position[_-]id[=_-]\d+/,
    /req[_-]?\d+/
  ];
  
  return validPatterns.some(pattern => pattern.test(url));
};

/**
 * Get all supported ATS types
 * @returns {Array} List of supported ATS types
 */
exports.getSupportedATS = () => {
  return Object.keys(URL_PATTERNS).filter(type => type !== 'custom');
};

/**
 * Get job category from title
 * @param {string} jobTitle - Job title
 * @returns {string} Job category
 */
exports.getJobCategory = (jobTitle) => {
  if (!jobTitle) return 'general';
  
  const lowerTitle = jobTitle.toLowerCase();
  
  for (const [category, patterns] of Object.entries(JOB_TITLE_PATTERNS)) {
    if (patterns.some(pattern => lowerTitle.includes(pattern))) {
      return category;
    }
  }
  
  return 'general';
};

/**
 * Extract job metadata from HTML content
 * @param {Object} $ - Cheerio instance
 * @param {Object} selectors - CSS selectors to use
 * @returns {Array} Array of job metadata objects
 */
exports.extractJobMetadata = ($, selectors) => {
  const jobs = [];
  
  try {
    // Find all job links
    const jobElements = $(selectors.jobLinks.join(', '));
    
    jobElements.each((index, element) => {
      const $job = $(element);
      
      // Extract basic information
      const title = extractText($job, selectors.jobTitles, $);
      const location = extractText($job, selectors.locations, $);
      const department = extractText($job, selectors.departments, $);
      const url = $job.attr('href');
      
      if (title && url) {
        jobs.push({
          title: title.trim(),
          location: location ? location.trim() : 'Not specified',
          department: department ? department.trim() : null,
          url: url.startsWith('http') ? url : null,
          relativeUrl: url.startsWith('/') ? url : null,
          extractedAt: new Date()
        });
      }
    });
    
    console.log(`📊 Extracted ${jobs.length} job metadata entries`);
    return jobs;
    
  } catch (error) {
    console.error('Error extracting job metadata:', error);
    return [];
  }
};

/**
 * Helper function to extract text using multiple selectors
 * @param {Object} $element - Cheerio element
 * @param {Array} selectors - Array of CSS selectors to try
 * @param {Object} $ - Cheerio instance
 * @returns {string} Extracted text
 */
function extractText($element, selectors, $) {
  // First try within the element itself
  for (const selector of selectors) {
    const text = $element.find(selector).first().text();
    if (text && text.trim()) {
      return text.trim();
    }
  }
  
  // Then try the element's own text if it matches patterns
  const elementText = $element.text();
  if (elementText && elementText.trim()) {
    return elementText.trim();
  }
  
  // Finally try parent elements
  const $parent = $element.parent();
  for (const selector of selectors) {
    const text = $parent.find(selector).first().text();
    if (text && text.trim()) {
      return text.trim();
    }
  }
  
  return null;
}

/**
 * Build absolute URLs from relative URLs
 * @param {string} baseUrl - Base URL of the career page
 * @param {Array} jobs - Array of job objects with relative URLs
 * @returns {Array} Jobs with absolute URLs
 */
exports.buildAbsoluteUrls = (baseUrl, jobs) => {
  const base = new URL(baseUrl);
  
  return jobs.map(job => {
    if (job.url) {
      // Already absolute URL
      return job;
    }
    
    if (job.relativeUrl) {
      try {
        const absoluteUrl = new URL(job.relativeUrl, base).href;
        return {
          ...job,
          url: absoluteUrl,
          directJobUrl: absoluteUrl
        };
      } catch (error) {
        console.error(`Error building absolute URL for ${job.relativeUrl}:`, error);
        return job;
      }
    }
    
    return job;
  });
};

/**
 * Filter jobs by relevance and experience level
 * @param {Array} jobs - Array of job objects
 * @param {Object} careerProfile - User career profile
 * @returns {Array} Filtered jobs
 */
exports.filterJobsByRelevance = (jobs, careerProfile) => {
  if (!jobs || !Array.isArray(jobs)) {
    return [];
  }
  
  return jobs
    .map(job => {
      // Check title relevance
      const titleRelevance = this.isJobTitleRelevant(job.title, careerProfile);
      const experienceAppropriate = this.isExperienceLevelAppropriate(job.title, careerProfile);
      
      return {
        ...job,
        isRelevant: titleRelevance.isMatch && experienceAppropriate,
        matchScore: titleRelevance.score,
        matchReason: titleRelevance.matchedCategory,
        category: this.getJobCategory(job.title)
      };
    })
    .filter(job => job.isRelevant)
    .sort((a, b) => b.matchScore - a.matchScore) // Sort by match score
    .slice(0, 15); // Limit to top 15 matches
};

/**
 * Common patterns for job posting URLs
 */
exports.JOB_URL_PATTERNS = {
  withId: [
    /\/job\/(\d+)/,
    /\/jobs\/(\d+)/,
    /\/position\/(\d+)/,
    /\/careers\/(\d+)/,
    /job-id[=_-](\d+)/,
    /position[_-]id[=_-](\d+)/,
    /req[_-]?(\d+)/
  ],
  
  withSlug: [
    /\/job\/([^\/\?]+)/,
    /\/jobs\/([^\/\?]+)/,
    /\/position\/([^\/\?]+)/,
    /\/careers\/job\/([^\/\?]+)/,
    /\/openings\/([^\/\?]+)/
  ]
};

/**
 * Extract job ID from URL
 * @param {string} url - Job URL
 * @returns {string} Job ID or slug
 */
exports.extractJobId = (url) => {
  if (!url) return null;
  
  // Try ID patterns first
  for (const pattern of this.JOB_URL_PATTERNS.withId) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  
  // Try slug patterns
  for (const pattern of this.JOB_URL_PATTERNS.withSlug) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  
  return null;
};

// Export all patterns for external use
exports.CSS_SELECTORS = CSS_SELECTORS;
exports.URL_PATTERNS = URL_PATTERNS;
exports.JOB_TITLE_PATTERNS = JOB_TITLE_PATTERNS;
exports.EXPERIENCE_INDICATORS = EXPERIENCE_INDICATORS;

================
File: utils/recruiter-importer.js
================
// backend/utils/recruiter-importer.js
const fs = require('fs');
const path = require('path');
const { parse } = require('csv-parse/sync');
const db = require('../config/postgresql');

/**
 * Import recruiters from a CSV/TSV file
 * @param {string} filePath Path to the CSV/TSV file
 * @param {boolean} isHeaderRow Whether the first row is a header row
 * @param {string} delimiter Delimiter used in the file
 */
const importRecruitersFromFile = async (filePath, isHeaderRow = true, delimiter = '\t') => {
  try {
    console.log(`Importing recruiters from ${filePath}...`);
    
    // Read the file
    const fileContent = fs.readFileSync(filePath, 'utf8');
    
    // Parse the CSV/TSV content
    const records = parse(fileContent, {
      delimiter,
      columns: isHeaderRow,
      skip_empty_lines: true,
      trim: true
    });
    
    console.log(`Found ${records.length} records to import`);
    
    // Process each record
    for (const record of records) {
      await processRecruiterRecord(record);
    }
    
    console.log('Recruiter import completed successfully');
  } catch (error) {
    console.error('Error importing recruiters:', error);
    throw error;
  }
};

/**
 * Process a single recruiter record and insert into database
 * @param {Object} record The recruiter record from the CSV/TSV
 */
const processRecruiterRecord = async (record) => {
  try {
    // 1. First, process the company information
    const companyId = await processCompany(record);
    
    // 2. Process the location information
    const locationId = await processLocation(record);
    
    // 3. Process industry information
    const industryId = await processIndustry(record);
    
    // 4. Create or update the recruiter record
    await processRecruiter(record, companyId, locationId, industryId);
    
  } catch (error) {
    console.error(`Error processing recruiter record:`, error);
    console.error('Problematic record:', record);
  }
};

/**
 * Process company data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The company ID
 */
const processCompany = async (record) => {
  try {
    // Check if company already exists
    const companyResult = await db.query(
      'SELECT id FROM companies WHERE name = $1',
      [record['Company Name']]
    );
    
    if (companyResult.rows.length > 0) {
      return companyResult.rows[0].id;
    }
    
    // Insert new company
    const result = await db.query(
      `INSERT INTO companies (
        name, website, employee_count, employee_range, founded_year,
        phone, revenue, revenue_range, ownership_type, business_model,
        stock_ticker, zoominfo_id, zoominfo_url, linkedin_url,
        facebook_url, twitter_url, email_domain
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
      RETURNING id`,
      [
        record['Company Name'] || null,
        record['Website'] || null,
        parseInt(record['Employees']) || null,
        record['Employee Range'] || null,
        parseInt(record['Founded Year']) || null,
        record['Company HQ Phone'] || null,
        parseInt(record['Revenue (in 000s USD)']) || null,
        record['Revenue Range (in USD)'] || null,
        record['Ownership Type'] || null,
        record['Business Model'] || null,
        record['Ticker'] || null,
        record['ZoomInfo Company ID'] || null,
        record['ZoomInfo Company Profile URL'] || null,
        record['LinkedIn Company Profile URL'] || null,
        record['Facebook Company Profile URL'] || null,
        record['Twitter Company Profile URL'] || null,
        record['Email Domain'] || null
      ]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing company:', error);
    throw error;
  }
};

/**
 * Process location data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The location ID
 */
const processLocation = async (record) => {
  try {
    // Check for person location first, then company location
    let street = record['Person Street'] || record['Company Street Address'] || null;
    let city = record['Person City'] || record['Company City'] || null;
    let state = record['Person State'] || record['Company State'] || null;
    let postalCode = record['Person Zip Code'] || record['Company Zip Code'] || null;
    let country = record['Country'] || record['Company Country'] || null;
    
    if (!city && !state && !country) {
      return null;
    }
    
    // Check if location already exists
    const locationResult = await db.query(
      'SELECT id FROM locations WHERE city = $1 AND state = $2 AND country = $3 AND (postal_code = $4 OR $4 IS NULL)',
      [city, state, country, postalCode]
    );
    
    if (locationResult.rows.length > 0) {
      return locationResult.rows[0].id;
    }
    
    // Create full address
    let fullAddress = '';
    if (street) fullAddress += street + ', ';
    if (city) fullAddress += city + ', ';
    if (state) fullAddress += state + ', ';
    if (postalCode) fullAddress += postalCode + ', ';
    if (country) fullAddress += country;
    
    // Insert new location
    const result = await db.query(
      `INSERT INTO locations (
        street_address, city, state, postal_code, country, full_address
      ) VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id`,
      [street, city, state, postalCode, country, fullAddress]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing location:', error);
    throw error;
  }
};

/**
 * Process industry data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The industry ID
 */
const processIndustry = async (record) => {
  try {
    const primaryIndustry = record['Primary Industry'] || null;
    
    if (!primaryIndustry) {
      return null;
    }
    
    // Check if industry already exists
    const industryResult = await db.query(
      'SELECT id FROM industries WHERE name = $1',
      [primaryIndustry]
    );
    
    if (industryResult.rows.length > 0) {
      return industryResult.rows[0].id;
    }
    
    // Parse SIC and NAICS codes
    const sicCodes = [];
    if (record['SIC Code 1']) sicCodes.push(record['SIC Code 1']);
    if (record['SIC Code 2']) sicCodes.push(record['SIC Code 2']);
    if (record['SIC Codes']) {
      const additionalSIC = record['SIC Codes'].split(';').filter(Boolean);
      sicCodes.push(...additionalSIC);
    }
    
    const naicsCodes = [];
    if (record['NAICS Code 1']) naicsCodes.push(record['NAICS Code 1']);
    if (record['NAICS Code 2']) naicsCodes.push(record['NAICS Code 2']);
    if (record['NAICS Codes']) {
      const additionalNAICS = record['NAICS Codes'].split(';').filter(Boolean);
      naicsCodes.push(...additionalNAICS);
    }
    
    // Insert new industry
    const result = await db.query(
      `INSERT INTO industries (
        name, description, primary_category, sub_category, 
        hierarchical_category, sic_codes, naics_codes
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING id`,
      [
        primaryIndustry,
        null,
        record['Primary Industry'] || null,
        record['Primary Sub-Industry'] || null,
        record['Industry Hierarchical Category'] || null,
        sicCodes.length > 0 ? sicCodes : null,
        naicsCodes.length > 0 ? naicsCodes : null
      ]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing industry:', error);
    throw error;
  }
};

/**
 * Process recruiter data from the record
 * @param {Object} record The recruiter record
 * @param {number} companyId The company ID
 * @param {number} locationId The location ID
 * @param {number} industryId The industry ID
 */
const processRecruiter = async (record, companyId, locationId, industryId) => {
  try {
    // Check if recruiter already exists by email
    const email = record['Email Address'] || null;
    
    if (email) {
      const recruiterResult = await db.query(
        'SELECT id FROM recruiters WHERE email = $1',
        [email]
      );
      
      if (recruiterResult.rows.length > 0) {
        const recruiterId = recruiterResult.rows[0].id;
        await updateRecruiter(recruiterId, record, companyId, locationId, industryId);
        return;
      }
    }
    
    // Parse job start date
    let jobStartDate = null;
    if (record['Job Start Date']) {
      try {
        jobStartDate = new Date(record['Job Start Date']);
      } catch (e) {
        console.warn(`Could not parse job start date: ${record['Job Start Date']}`);
      }
    }
    
    // Parse notice provided date
    let noticeProvidedDate = null;
    if (record['Notice Provided Date']) {
      try {
        noticeProvidedDate = new Date(record['Notice Provided Date']);
      } catch (e) {
        console.warn(`Could not parse notice provided date: ${record['Notice Provided Date']}`);
      }
    }
    
    // Insert new recruiter
    const result = await db.query(
      `INSERT INTO recruiters (
        first_name, middle_name, last_name, salutation, suffix,
        email, email_domain, supplemental_email, direct_phone, mobile_phone,
        current_company_id, title, job_title_hierarchy_level, management_level,
        job_start_date, job_function, department, company_division,
        education_level, accuracy_score, accuracy_grade, zoominfo_url,
        linkedin_url, notice_provided_date, location_id, industry_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
        $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
      )
      RETURNING id`,
      [
        record['First Name'] || null,
        record['Middle Name'] || null,
        record['Last Name'] || null,
        record['Salutation'] || null,
        record['Suffix'] || null,
        email,
        record['Email Domain'] || null,
        record['Supplemental Email'] || null,
        record['Direct Phone Number'] || null,
        record['Mobile phone'] || null,
        companyId,
        record['Job Title'] || null,
        parseInt(record['Job Title Hierarchy Level']) || null,
        record['Management Level'] || null,
        jobStartDate,
        record['Job Function'] || null,
        record['Department'] || null,
        record['Company Division Name'] || null,
        record['Highest Level of Education'] || null,
        parseInt(record['Contact Accuracy Score']) || null,
        record['Contact Accuracy Grade'] || null,
        record['ZoomInfo Contact Profile URL'] || null,
        record['LinkedIn Contact Profile URL'] || null,
        noticeProvidedDate,
        locationId,
        industryId
      ]
    );
    
    console.log(`Created recruiter: ${record['First Name']} ${record['Last Name']}`);
  } catch (error) {
    console.error('Error processing recruiter:', error);
    throw error;
  }
};

/**
 * Update an existing recruiter
 * @param {number} recruiterId The recruiter ID
 * @param {Object} record The recruiter record
 * @param {number} companyId The company ID
 * @param {number} locationId The location ID
 * @param {number} industryId The industry ID
 */
const updateRecruiter = async (recruiterId, record, companyId, locationId, industryId) => {
  try {
    // Parse job start date
    let jobStartDate = null;
    if (record['Job Start Date']) {
      try {
        jobStartDate = new Date(record['Job Start Date']);
      } catch (e) {
        console.warn(`Could not parse job start date: ${record['Job Start Date']}`);
      }
    }
    
    // Parse notice provided date
    let noticeProvidedDate = null;
    if (record['Notice Provided Date']) {
      try {
        noticeProvidedDate = new Date(record['Notice Provided Date']);
      } catch (e) {
        console.warn(`Could not parse notice provided date: ${record['Notice Provided Date']}`);
      }
    }
    
    await db.query(
      `UPDATE recruiters SET
        first_name = $1, middle_name = $2, last_name = $3, salutation = $4,
        suffix = $5, email_domain = $6, supplemental_email = $7,
        direct_phone = $8, mobile_phone = $9, current_company_id = $10,
        title = $11, job_title_hierarchy_level = $12, management_level = $13,
        job_start_date = $14, job_function = $15, department = $16,
        company_division = $17, education_level = $18, accuracy_score = $19,
        accuracy_grade = $20, zoominfo_url = $21, linkedin_url = $22,
        notice_provided_date = $23, location_id = $24, industry_id = $25,
        updated_at = NOW()
      WHERE id = $26`,
      [
        record['First Name'] || null,
        record['Middle Name'] || null,
        record['Last Name'] || null,
        record['Salutation'] || null,
        record['Suffix'] || null,
        record['Email Domain'] || null,
        record['Supplemental Email'] || null,
        record['Direct Phone Number'] || null,
        record['Mobile phone'] || null,
        companyId,
        record['Job Title'] || null,
        parseInt(record['Job Title Hierarchy Level']) || null,
        record['Management Level'] || null,
        jobStartDate,
        record['Job Function'] || null,
        record['Department'] || null,
        record['Company Division Name'] || null,
        record['Highest Level of Education'] || null,
        parseInt(record['Contact Accuracy Score']) || null,
        record['Contact Accuracy Grade'] || null,
        record['ZoomInfo Contact Profile URL'] || null,
        record['LinkedIn Contact Profile URL'] || null,
        noticeProvidedDate,
        locationId,
        industryId,
        recruiterId
      ]
    );
    
    console.log(`Updated recruiter: ${record['First Name']} ${record['Last Name']}`);
  } catch (error) {
    console.error('Error updating recruiter:', error);
    throw error;
  }
};

module.exports = { importRecruitersFromFile };

================
File: utils/send-email.js
================
// backend/utils/send-email.js
const nodemailer = require('nodemailer');

/**
 * Send email using nodemailer with Gmail
 * @param {Object} options Email options (to, subject, text, html)
 */
const sendEmail = async (options) => {
  try {
    // Create a transporter using Gmail
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD // App Password, not regular password
      }
    });
    
    // Define mail options
    const mailOptions = {
      from: `${process.env.FROM_NAME} <${process.env.GMAIL_USER}>`,
      to: options.email,
      subject: options.subject,
      html: options.html
    };
    
    // Send mail
    const info = await transporter.sendMail(mailOptions);
    console.log('Email sent: %s', info.messageId);
    return info;
  } catch (error) {
    console.error('Error sending email:', error);
    throw error;
  }
};

module.exports = sendEmail;

================
File: verify-controller.js
================
// backend/verify-controller.js - Test if the controller changes are working
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function verifyControllerFix() {
  try {
    console.log('🧪 VERIFYING CONTROLLER FIX');
    console.log('=============================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Test the EXACT query from the controller (with COALESCE)
    console.log('\n1️⃣ TESTING MAIN QUERY WITH COALESCE:');
    
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    // Add the search filter exactly as it should be in the controller
    sqlQuery += ` AND (
      COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $${paramIndex} OR
      COALESCE(r.title, '') ILIKE $${paramIndex}
    )`;
    queryParams.push(`%${query}%`);
    paramIndex++;

    // Add ordering
    sqlQuery += ` ORDER BY r.first_name ASC`;
    
    // Add pagination
    sqlQuery += ` LIMIT 20 OFFSET 0`;

    console.log('📝 Executing exact controller query...');
    console.log('📋 Params:', queryParams);
    
    const result = await pool.query(sqlQuery, queryParams);
    console.log(`📊 Main query result: ${result.rows.length} rows`);

    if (result.rows.length > 0) {
      console.log('✅ SUCCESS: Main query found results!');
      result.rows.slice(0, 3).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    } else {
      console.log('❌ PROBLEM: Main query returned 0 results');
    }

    // Test the count query
    console.log('\n2️⃣ TESTING COUNT QUERY:');
    const countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE '%${query}%' OR COALESCE(r.title, '') ILIKE '%${query}%')
    `;

    console.log('📝 Count query:', countQuery);
    const countResult = await pool.query(countQuery);
    console.log(`📊 Count query result: ${countResult.rows[0].count}`);

    // Test without COALESCE to see the difference
    console.log('\n3️⃣ TESTING WITHOUT COALESCE (old version):');
    const oldQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE '%${query}%' OR r.title ILIKE '%${query}%')
    `;

    try {
      const oldResult = await pool.query(oldQuery);
      console.log(`📊 Old query result: ${oldResult.rows[0].count}`);
    } catch (error) {
      console.log(`❌ Old query failed: ${error.message}`);
    }

    // Test if there's an issue with the outreach_history join
    console.log('\n4️⃣ TESTING WITHOUT OUTREACH JOIN:');
    const noJoinQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE '%${query}%' OR COALESCE(r.title, '') ILIKE '%${query}%')
    `;

    const noJoinResult = await pool.query(noJoinQuery);
    console.log(`📊 No join query result: ${noJoinResult.rows[0].count}`);

    console.log('\n✅ Verification complete!');

  } catch (error) {
    console.error('❌ Verification failed:', error);
  } finally {
    await pool.end();
  }
}

verifyControllerFix();

================
File: backend/routes/assistant.routes.js
================
// backend/routes/assistant.routes.js - RAG VERSION WITH NO MEMORY SYSTEM
const express = require('express');
const router = express.Router();
const assistantController = require('../controllers/assistant.controller');
const { protect } = require('../middleware/auth.middleware');
const rateLimit = require('express-rate-limit');

// All assistant routes require authentication
router.use(protect);

// ===================================================================
// RATE LIMITING SETUP (updated for RAG)
// ===================================================================

// Rate limiting for AI operations with RAG context (more restrictive due to cost)
const ragAiLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 30, // Reduced limit for RAG operations
  message: {
    success: false,
    error: 'RAG AI operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting for mention suggestions (moderate)
const mentionLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 60, // Allow frequent @-mention lookups
  message: {
    success: false,
    error: 'Mention lookup rate limit exceeded. Please wait before trying again.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting for resume operations with context (moderate)
const resumeContextLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 15, // Reduced for context-aware operations
  message: {
    success: false,
    error: 'Resume operation rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Standard rate limiter for basic operations
const standardLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  message: {
    success: false,
    error: 'Rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// ===================================================================
// 🆕 RAG: @-MENTION ENDPOINTS
// ===================================================================

// Get mention suggestions for @-functionality
router.get('/mention-suggestions', mentionLimiter, assistantController.getMentionSuggestions);

// Get full context data for mentioned item
router.get('/context-data/:type/:id', standardLimiter, assistantController.getContextData);

// ===================================================================
// ENHANCED CHAT & CONVERSATION MANAGEMENT (with RAG)
// ===================================================================

// Enhanced main chat endpoint with RAG context support
router.post('/chat', ragAiLimiter, assistantController.chat);

// Conversation management (unchanged)
router.get('/conversations', standardLimiter, assistantController.getConversations);
router.get('/conversations/:conversationId', standardLimiter, assistantController.getConversation);
router.put('/conversations/:conversationId', standardLimiter, assistantController.updateConversation);
router.delete('/conversations/:conversationId', standardLimiter, assistantController.deleteConversation);

// ===================================================================
// ENHANCED RESUME OPERATIONS WITH RAG CONTEXT
// ===================================================================

// Core resume editing operations with context awareness
router.post('/apply-resume-changes', resumeContextLimiter, assistantController.applyResumeChanges);
router.post('/optimize-ats', resumeContextLimiter, assistantController.optimizeForATS);
router.post('/analyze-resume', resumeContextLimiter, assistantController.analyzeResume);

// ===================================================================
// JOB ANALYSIS WITH RAG CONTEXT
// ===================================================================

// Job matching with resume context
router.post('/analyze-job-match', ragAiLimiter, assistantController.analyzeJobMatch);
router.post('/generate-cover-letter', ragAiLimiter, assistantController.generateCoverLetter);

// ===================================================================
// SIMPLIFIED SEARCH (NO MEMORY SYSTEM)
// ===================================================================

// Search conversations only (memory system removed)
router.get('/search', standardLimiter, assistantController.search);

// ===================================================================
// SYSTEM & HEALTH
// ===================================================================

// System endpoints with RAG information
router.get('/capabilities', assistantController.getCapabilities);
router.get('/health', assistantController.healthCheck);
router.get('/usage-stats', assistantController.getUsageStats);
router.post('/track-interaction', assistantController.trackInteraction);
router.post('/reset-context', assistantController.resetContext);

// ===================================================================
// CAREER GUIDANCE WITH RAG CONTEXT
// ===================================================================

// Career guidance endpoints (simplified, context-aware)
router.post('/career-advice', ragAiLimiter, assistantController.getCareerAdvice);
router.post('/contextual-suggestions', standardLimiter, assistantController.getContextualSuggestions);
router.post('/personalized-tips', standardLimiter, assistantController.getPersonalizedTips);

// ===================================================================
// ANALYTICS (simplified, no memory analytics)
// ===================================================================

router.get('/analytics', standardLimiter, assistantController.getAnalytics);

// ===================================================================
// REMOVED: MEMORY SYSTEM ENDPOINTS
// ===================================================================
// The following endpoints have been removed as we've eliminated the memory system:
// - /memories (GET, POST, DELETE)
// - /memory-insights
// - /memory-maintenance
//
// These are replaced by conversation-scoped RAG context

// ===================================================================
// LEGACY COMPATIBILITY ENDPOINTS (return simplified responses)
// ===================================================================

// Memory endpoints (return empty/disabled responses for compatibility)
router.get('/memories', assistantController.getMemories);
router.post('/memories', assistantController.updateMemory);
router.delete('/memories/:memoryId', assistantController.deleteMemory);
router.get('/memory-insights', assistantController.getMemoryInsights);
router.post('/memory-maintenance', assistantController.performMemoryMaintenance);

// Conversation utilities (simplified implementations)
router.post('/conversations/:conversationId/summary', assistantController.generateSummary);
router.get('/conversations/:conversationId/insights', assistantController.getConversationInsights);
router.get('/conversations/:conversationId/export', assistantController.exportConversation);
router.post('/conversations/bulk-update', assistantController.bulkUpdateConversations);

// ===================================================================
// ERROR HANDLING MIDDLEWARE (enhanced for RAG)
// ===================================================================

// Enhanced error handling for RAG operations
router.use((error, req, res, next) => {
  console.error('Assistant route error:', {
    error: error.message,
    stack: error.stack,
    route: req.route?.path,
    method: req.method,
    userId: req.user?._id,
ragContext: req.body?.context ? {
      hasAttachedResumes: req.body.context.attachedResumes?.length > 0,
      hasAttachedJobs: req.body.context.attachedJobs?.length > 0
    } : null,
    timestamp: new Date().toISOString()
  });

  // RAG-specific errors
  if (error.message.includes('context') || error.message.includes('RAG')) {
    return res.status(500).json({
      success: false,
      error: 'RAG context processing error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try removing attached context or using a simpler query',
      ragEnabled: true
    });
  }

  // Resume context errors
  if (error.message.includes('resume') || error.message.includes('Resume')) {
    return res.status(500).json({
      success: false,
      error: 'Resume processing error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try refreshing the page or re-attaching the resume context',
      ragEnabled: true
    });
  }

  // Job context errors
  if (error.message.includes('job') || error.message.includes('Job')) {
    return res.status(500).json({
      success: false,
      error: 'Job analysis error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try refreshing the page or re-attaching the job context',
      ragEnabled: true
    });
  }

  // Mention/context lookup errors
  if (error.message.includes('mention') || error.message.includes('lookup')) {
    return res.status(500).json({
      success: false,
      error: 'Context lookup error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try typing @ again to reload suggestions',
      ragEnabled: true
    });
  }

  // Conversation-specific errors
  if (error.message.includes('conversation') || error.message.includes('Conversation')) {
    return res.status(500).json({
      success: false,
      error: 'Conversation system error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Try starting a new conversation or contact support',
      ragEnabled: true
    });
  }

  // OpenAI API errors (enhanced for RAG)
  if (error.message.includes('OpenAI') || error.status === 429) {
    return res.status(503).json({
      success: false,
      error: 'AI service temporarily unavailable',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'RAG operations require more processing time. Please try again in a few moments.',
      ragEnabled: true
    });
  }

  // Rate limiting errors (enhanced for RAG)
  if (error.status === 429 || error.message.includes('rate limit')) {
    const isRagOperation = req.route?.path?.includes('chat') || 
                          req.route?.path?.includes('context') ||
                          req.body?.context?.attachedResumes?.length > 0 ||
                          req.body?.context?.attachedJobs?.length > 0;

    return res.status(429).json({
      success: false,
      error: 'Too many requests',
      details: isRagOperation ? 
        'RAG operations have lower rate limits due to processing complexity' : 
        'Rate limit exceeded for AI operations',
      suggestion: isRagOperation ?
        'RAG context processing is resource-intensive. Please wait a few minutes before trying again.' :
        'Please wait a few minutes before trying again',
      retryAfter: error.retryAfter || (isRagOperation ? 600 : 300), // Longer retry for RAG
      ragEnabled: true
    });
  }

  // File/upload errors
  if (error.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({
      success: false,
      error: 'File too large',
      suggestion: 'Please upload a file smaller than 10MB',
      ragEnabled: true
    });
  }

  // Authentication errors
  if (error.status === 401) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required',
      suggestion: 'Please log in again',
      ragEnabled: true
    });
  }

  // Context validation errors
  if (error.message.includes('validation') || error.message.includes('invalid')) {
    return res.status(400).json({
      success: false,
      error: 'Invalid request data',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined,
      suggestion: 'Check your attached context and try again',
      ragEnabled: true
    });
  }

  // Database connection errors
  if (error.message.includes('database') || error.message.includes('connection')) {
    return res.status(503).json({
      success: false,
      error: 'Database connection error',
      suggestion: 'Our servers are experiencing issues. Please try again shortly.',
      ragEnabled: true
    });
  }

  // Default error response (enhanced for RAG)
  res.status(error.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : error.message,
    suggestion: 'If you have attached context (@-mentions), try removing them and asking again.',
    ragEnabled: true,
    ...(process.env.NODE_ENV !== 'production' && { 
      stack: error.stack,
      timestamp: new Date().toISOString(),
      ragContext: req.body?.context ? {
        hasAttachedResumes: req.body.context.attachedResumes?.length > 0,
        hasAttachedJobs: req.body.context.attachedJobs?.length > 0,
        page: req.body.context.page
      } : null
    })
  });
});

module.exports = router;

================
File: backend/routes/auth.routes.js
================
// backend/routes/auth.routes.js (updated)
const express = require('express');
const authController = require('../controllers/auth.controller');
const { protect } = require('../middleware/auth.middleware');
const { 
  validateRegistration, 
  validateLogin, 
  validatePasswordReset,
  validateUpdateDetails,
  validateUpdatePassword,
  handleValidationErrors
} = require('../middleware/validation.middleware');

const router = express.Router();

// Public routes
router.post('/register', validateRegistration, handleValidationErrors, authController.register);
router.post('/login', validateLogin, handleValidationErrors, authController.login);
router.post('/forgot-password', authController.forgotPassword);
router.put('/reset-password/:token', validatePasswordReset, handleValidationErrors, authController.resetPassword);
router.get('/verify-email/:token', authController.verifyEmail);

// Protected routes
router.use(protect); // All routes below this require authentication
router.get('/me', authController.getMe);
router.post('/logout', authController.logout);
router.post('/resend-verification', authController.resendVerification);
router.put('/update-details', validateUpdateDetails, handleValidationErrors, authController.updateDetails);
router.put('/update-password', validateUpdatePassword, handleValidationErrors, authController.updatePassword);
router.delete('/delete-account', authController.deleteAccount);

module.exports = router;

================
File: backend/routes/job.routes.js
================
// routes/job.routes.js
const express = require('express');
const router = express.Router();
const jobController = require('../controllers/job.controller');
const authMiddleware = require('../middleware/auth.middleware');

// All job routes require authentication
router.use(authMiddleware.protect);

// Create a new job
router.post('/', jobController.createJob);

// Get all user jobs
router.get('/', jobController.getUserJobs);

// IMPORTANT: Place specific routes BEFORE parameterized routes

// Get analysis insights (must be before /:id)
router.get('/analysis-insights', jobController.getJobAnalysisInsights);

// AI Search Management Routes (must be before /:id)
router.get('/ai-searches', jobController.getUserAiSearches);
router.post('/ai-search/:searchId/pause', jobController.pauseAiSearch);
router.post('/ai-search/:searchId/resume', jobController.resumeAiSearch);
router.delete('/ai-search/:searchId', jobController.deleteAiSearch);

// Re-analyze job (must be before /:id)
router.post('/re-analyze/:id', jobController.reAnalyzeJob);

// Re-match job with best available resume (NEW - must be before /:id)
router.post('/rematch-best/:jobId', jobController.rematchJobWithBestResume);

// NEW: Get job analysis status (must be before /:id)
router.get('/analysis-status/:id', jobController.getJobAnalysisStatus);

// Get job by ID (this catches all /jobs/:id patterns, so it must come after specific routes)
router.get('/:id', jobController.getJobById);

// Get resume match status for a specific job
router.get('/:id/resume-match-status', jobController.getResumeMatchStatus);

// Update job
router.put('/:id', jobController.updateJob);

// Delete job
router.delete('/:id', jobController.deleteJob);

// Match resume with job
router.post('/match/:jobId/:resumeId', jobController.matchResumeWithJob);

// Get tailoring recommendations
router.post('/tailor/:jobId/:resumeId', jobController.tailorResumeToJob);

// Find jobs with AI
router.post('/find-with-ai/:resumeId', jobController.findJobsWithAi);

module.exports = router;

================
File: backend/routes/recruiter.routes.js
================
// backend/routes/recruiter.routes.js - FIXED ROUTE ORDERING
const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/auth.middleware');
const recruiterController = require('../controllers/recruiter.controller');

// Simple validation middleware (since we don't have express-validator setup)
const validate = (req, res, next) => {
  // For now, just pass through - we can add validation later
  next();
};

// ===================================================================
// VALIDATION MIDDLEWARE (Simplified for now)
// ===================================================================

const validateSearch = [validate];
const validateRecruiterParams = [validate];
const validateOutreachCreation = [validate];
const validateMessageGeneration = [validate];
const validateOutreachParams = [validate];

// ===================================================================
// SPECIFIC ROUTES (MUST COME BEFORE PARAMETERIZED ROUTES)
// ===================================================================

/**
 * @route   GET /api/recruiters/search
 * @desc    Search recruiters with advanced filtering
 * @access  Private
 */
router.get('/search', protect, validateSearch, recruiterController.searchRecruiters);

/**
 * @route   GET /api/recruiters/filters
 * @desc    Get available filter options for recruiter search
 * @access  Private
 */
router.get('/filters', protect, recruiterController.getFilterOptions);

/**
 * @route   GET /api/recruiters/analytics
 * @desc    Get outreach analytics and performance metrics
 * @access  Private
 */
router.get('/analytics', protect, recruiterController.getOutreachAnalytics);

/**
 * @route   POST /api/recruiters/generate-message
 * @desc    Generate AI-powered personalized message
 * @access  Private
 */
router.post('/generate-message', protect, validateMessageGeneration, recruiterController.generatePersonalizedMessage);

// ===================================================================
// OUTREACH MANAGEMENT ROUTES (SPECIFIC PATHS)
// ===================================================================

/**
 * @route   GET /api/recruiters/outreach
 * @desc    Get user's outreach campaigns
 * @access  Private
 */
router.get('/outreach', protect, recruiterController.getUserOutreach);

/**
 * @route   POST /api/recruiters/outreach
 * @desc    Create a new outreach campaign
 * @access  Private
 */
router.post('/outreach', protect, validateOutreachCreation, recruiterController.createOutreach);

/**
 * @route   PUT /api/recruiters/outreach/:outreachId/send
 * @desc    Send a drafted outreach message
 * @access  Private
 */
router.put('/outreach/:outreachId/send', protect, validateOutreachParams, recruiterController.sendOutreach);

/**
 * @route   PUT /api/recruiters/outreach/:outreachId
 * @desc    Update an outreach campaign
 * @access  Private
 */
router.put('/outreach/:outreachId', protect, validateOutreachParams, recruiterController.updateOutreach);

/**
 * @route   DELETE /api/recruiters/outreach/:outreachId
 * @desc    Delete an outreach campaign
 * @access  Private
 */
router.delete('/outreach/:outreachId', protect, validateOutreachParams, recruiterController.deleteOutreach);

// ===================================================================
// FUTURE IMPLEMENTATION ROUTES (SPECIFIC PATHS)
// ===================================================================

/**
 * @route   GET /api/recruiters/campaigns
 * @desc    Get outreach campaigns
 * @access  Private
 * @note    Future implementation for campaign management
 */
router.get('/campaigns', protect, (req, res) => {
  res.json({
    success: true,
    message: 'Campaign management feature coming soon',
    feature: 'campaign_management'
  });
});

/**
 * @route   POST /api/recruiters/bulk-outreach
 * @desc    Create bulk outreach to multiple recruiters
 * @access  Private
 * @note    Future implementation for bulk messaging
 */
router.post('/bulk-outreach', protect, (req, res) => {
  res.json({
    success: true,
    message: 'Bulk outreach feature coming soon',
    feature: 'bulk_messaging'
  });
});

/**
 * @route   GET /api/recruiters/recommendations
 * @desc    Get AI-recommended recruiters based on user profile
 * @access  Private
 * @note    Future implementation for AI recommendations
 */
router.get('/recommendations', protect, (req, res) => {
  res.json({
    success: true,
    message: 'AI recruiter recommendations coming soon',
    feature: 'ai_recommendations'
  });
});

// ===================================================================
// PARAMETERIZED ROUTES (MUST COME AFTER ALL SPECIFIC ROUTES)
// ===================================================================

/**
 * @route   GET /api/recruiters/:recruiterId
 * @desc    Get detailed recruiter information
 * @access  Private
 */
router.get('/:recruiterId', protect, validateRecruiterParams, recruiterController.getRecruiterById);

// ===================================================================
// ADVANCED OUTREACH FEATURES (Future Implementation)
// ===================================================================

/**
 * @route   POST /api/recruiters/outreach/:outreachId/reply
 * @desc    Record a reply to an outreach message
 * @access  Private
 * @note    Future implementation for reply tracking
 */
router.post('/outreach/:outreachId/reply', protect, validateOutreachParams, (req, res) => {
  res.json({
    success: true,
    message: 'Reply tracking feature coming soon',
    feature: 'reply_tracking'
  });
});

/**
 * @route   POST /api/recruiters/outreach/:outreachId/follow-up
 * @desc    Create a follow-up message
 * @access  Private
 * @note    Future implementation for automated follow-ups
 */
router.post('/outreach/:outreachId/follow-up', protect, validateOutreachParams, (req, res) => {
  res.json({
    success: true,
    message: 'Automated follow-up feature coming soon',
    feature: 'automated_follow_ups'
  });
});

// ===================================================================
// ERROR HANDLING
// ===================================================================

// Handle 404 for recruiter routes
router.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Recruiter API endpoint not found',
    suggestion: 'Check the API documentation for available recruiter endpoints',
    requestedPath: req.path,
    method: req.method,
    availableEndpoints: [
      'GET /api/recruiters/search - Search recruiters',
      'GET /api/recruiters/filters - Get filter options',
      'GET /api/recruiters/analytics - Get analytics',
      'POST /api/recruiters/generate-message - Generate AI message',
      'GET /api/recruiters/outreach - Get outreach campaigns',
      'POST /api/recruiters/outreach - Create outreach',
      'PUT /api/recruiters/outreach/:id - Update outreach',
      'DELETE /api/recruiters/outreach/:id - Delete outreach',
      'PUT /api/recruiters/outreach/:id/send - Send outreach',
      'GET /api/recruiters/:id - Get recruiter details'
    ]
  });
});

module.exports = router;

================
File: backend/routes/resume.routes.js
================
// backend/routes/resume.routes.js - FINAL WORKING VERSION
const express = require('express');
const router = express.Router();
const resumeController = require('../controllers/resume.controller');
const authMiddleware = require('../middleware/auth.middleware');
const multer = require('multer');
const upload = multer({ storage: multer.memoryStorage() });

console.log('🔧 Setting up resume routes...');



// 📡 REAL SSE endpoint - MUST be before auth middleware
console.log('📡 Registering SSE endpoint: /:id/optimization-progress');
router.get('/:id/optimization-progress', resumeController.getOptimizationProgress);

// 🔒 Apply auth middleware to all other routes
console.log('🔒 Applying auth middleware to remaining routes');
router.use(authMiddleware.protect);

// 📁 Other routes (all require authentication)
router.post('/upload', upload.single('file'), resumeController.uploadResume);
router.get('/', resumeController.getUserResumes);

// Specific routes BEFORE generic /:id
router.get('/status/:id', resumeController.getResumeProcessingStatus);
router.post('/:id/optimize-ats', resumeController.optimizeResumeForATS);
router.post('/analyze/:id', resumeController.analyzeResume);
router.post('/versions/:id', upload.single('file'), resumeController.addResumeVersion);
router.post('/tailor/:resumeId/:jobId', resumeController.createTailoredResume);
router.delete('/:id', resumeController.deleteResume);

// Generic /:id route LAST
router.get('/:id', resumeController.getResumeById);

console.log('✅ Resume routes setup complete');

module.exports = router;

================
File: backend/routes/search.routes.js
================
// backend/routes/search.routes.js
const express = require('express');
const router = express.Router();
const SearchController = require('../controllers/search.controller');
const { protect } = require('../middleware/auth.middleware');

/**
 * Search Routes
 * All routes require authentication
 */

// @desc    Global search across all content types
// @route   GET /api/search
// @access  Private
// @params  query (required), category (optional: all|jobs|resumes|recruiters), limit (optional)
router.get('/', protect, SearchController.globalSearch);

// @desc    Get search suggestions as user types
// @route   GET /api/search/suggestions
// @access  Private
// @params  query (required), limit (optional)
router.get('/suggestions', protect, SearchController.getSearchSuggestions);

// @desc    Get popular/trending searches
// @route   GET /api/search/popular
// @access  Private
router.get('/popular', protect, SearchController.getPopularSearches);

module.exports = router;

================
File: backend/routes/settings.routes.js
================
// backend/routes/settings.routes.js
const express = require('express');
const router = express.Router();
const settingsController = require('../controllers/settings.controller');
const { protect } = require('../middleware/auth.middleware');

// All routes require authentication
router.use(protect);

// Profile management routes
router.get('/profile', settingsController.getProfile);
router.put('/profile', settingsController.updateProfile);

// Security routes
router.put('/change-password', settingsController.changePassword);
router.delete('/delete-account', settingsController.deleteAccount);

// Account verification routes
router.post('/send-verification-email', settingsController.sendVerificationEmail);
router.get('/verify-email/:token', settingsController.verifyEmail);

module.exports = router;

================
File: backend/routes/subscription.routes.js
================
// backend/routes/subscription.routes.js - COMPLETE MONTHLY ONLY VERSION
const express = require('express');
const rateLimit = require('express-rate-limit');
const SubscriptionController = require('../controllers/subscription.controller');
const authMiddleware = require('../middleware/auth.middleware');
const SubscriptionMiddleware = require('../middleware/subscription.middleware');
const UsageMiddleware = require('../middleware/usage.middleware');
const { body, param, query, validationResult } = require('express-validator');

const router = express.Router();

// Rate limiting for subscription operations
const subscriptionLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 50, // Limit each IP to 50 requests per windowMs
  message: {
    success: false,
    error: 'Too many subscription requests, please try again later'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Stripe webhook rate limiting (more permissive)
const webhookLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 100, // Allow more webhook requests
  message: {
    success: false,
    error: 'Webhook rate limit exceeded'
  }
});

// Validation middleware
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      error: 'Validation failed',
      details: errors.array()
    });
  }
  next();
};

// ======================================
// PUBLIC ROUTES (No authentication required)
// ======================================

/**
 * @route GET /api/subscriptions/plans
 * @desc Get all available subscription plans (Monthly only)
 * @access Public
 */
router.get('/plans', 
  subscriptionLimiter,
  SubscriptionController.getPlans
);

/**
 * @route GET /api/subscriptions/plans/compare
 * @desc Get plan comparison matrix (Monthly only)
 * @access Public
 */
router.get('/plans/compare', 
  subscriptionLimiter,
  SubscriptionController.getPlansComparison
);

/**
 * @route POST /api/subscriptions/webhook
 * @desc Handle Stripe webhooks
 * @access Public (but verified by Stripe signature)
 */
router.post('/webhook',
  webhookLimiter,
  express.raw({ type: 'application/json' }), // Stripe requires raw body
  SubscriptionController.handleWebhook
);

// ======================================
// PROTECTED ROUTES (Authentication required)
// ======================================

/**
 * @route GET /api/subscriptions/current
 * @desc Get user's current subscription
 * @access Private
 */
router.get('/current',
  subscriptionLimiter,
  authMiddleware.protect,
  SubscriptionMiddleware.injectSubscriptionContext(),
  SubscriptionController.getCurrentSubscription
);

/**
 * @route GET /api/subscriptions/usage
 * @desc Get user's usage statistics
 * @access Private
 */
router.get('/usage',
  subscriptionLimiter,
  authMiddleware.protect,
  SubscriptionMiddleware.injectSubscriptionContext(),
  SubscriptionController.getUsageStats
);

/**
 * @route GET /api/subscriptions/usage/history
 * @desc Get user's usage history
 * @access Private
 */
router.get('/usage/history',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    query('months')
      .optional()
      .isInt({ min: 1, max: 24 })
      .withMessage('Months must be between 1 and 24')
  ],
  handleValidationErrors,
  SubscriptionController.getUsageHistory
);

/**
 * @route GET /api/subscriptions/usage/warnings
 * @desc Get usage warnings for user
 * @access Private
 */
router.get('/usage/warnings',
  subscriptionLimiter,
  authMiddleware.protect,
  SubscriptionController.getUsageWarnings
);

/**
 * @route POST /api/subscriptions/usage/track
 * @desc Manually track usage (for testing)
 * @access Private
 */
router.post('/usage/track',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    body('action')
      .notEmpty()
      .withMessage('Action is required')
      .isIn(['resumeUploads', 'resumeAnalysis', 'jobImports', 'resumeTailoring', 'recruiterUnlocks', 'aiJobDiscovery', 'aiConversations', 'aiMessagesTotal'])
      .withMessage('Invalid action'),
    body('quantity')
      .optional()
      .isInt({ min: 1, max: 100 })
      .withMessage('Quantity must be between 1 and 100'),
    body('metadata')
      .optional()
      .isObject()
      .withMessage('Metadata must be an object')
  ],
  handleValidationErrors,
  SubscriptionController.trackUsage
);

/**
 * @route GET /api/subscriptions/permissions/:feature
 * @desc Check permission for a specific feature
 * @access Private
 */
router.get('/permissions/:feature',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    param('feature')
      .notEmpty()
      .withMessage('Feature is required')
      .isIn(['resumeUploads', 'recruiterAccess', 'aiAssistant', 'aiJobDiscovery'])
      .withMessage('Invalid feature'),
    query('quantity')
      .optional()
      .isInt({ min: 1, max: 100 })
      .withMessage('Quantity must be between 1 and 100')
  ],
  handleValidationErrors,
  SubscriptionMiddleware.injectSubscriptionContext(),
  SubscriptionController.checkPermission
);

/**
 * @route POST /api/subscriptions/create-checkout
 * @desc Create Stripe checkout session (Monthly only)
 * @access Private
 */
router.post('/create-checkout',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    body('planName')
      .notEmpty()
      .withMessage('Plan name is required')
      .isIn(['casual', 'hunter'])
      .withMessage('Invalid plan name')
    // Note: No billingCycle validation since we only do monthly
  ],
  handleValidationErrors,
  SubscriptionController.createCheckoutSession
);

/**
 * @route POST /api/subscriptions/customer-portal
 * @desc Create customer portal session
 * @access Private
 */
router.post('/customer-portal',
  subscriptionLimiter,
  authMiddleware.protect,
  SubscriptionMiddleware.requireSubscription(['casual', 'hunter']),
  SubscriptionController.createCustomerPortal
);

/**
 * @route POST /api/subscriptions/cancel
 * @desc Cancel subscription
 * @access Private
 */
router.post('/cancel',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    body('atPeriodEnd')
      .optional()
      .isBoolean()
      .withMessage('atPeriodEnd must be a boolean')
  ],
  handleValidationErrors,
  SubscriptionMiddleware.requireSubscription(['casual', 'hunter']),
  SubscriptionController.cancelSubscription
);

/**
 * @route POST /api/subscriptions/resume
 * @desc Resume canceled subscription
 * @access Private
 */
router.post('/resume',
  subscriptionLimiter,
  authMiddleware.protect,
  SubscriptionController.resumeSubscription
);

/**
 * @route PUT /api/subscriptions/change-plan
 * @desc Change subscription plan (Monthly only)
 * @access Private
 */
router.put('/change-plan',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    body('newPlanName')
      .notEmpty()
      .withMessage('New plan name is required')
      .isIn(['casual', 'hunter'])
      .withMessage('Invalid plan name')
    // Note: No billingCycle validation since we only do monthly
  ],
  handleValidationErrors,
  SubscriptionMiddleware.requireSubscription(['casual', 'hunter']),
  SubscriptionController.changeSubscriptionPlan
);

/**
 * @route POST /api/subscriptions/preview-change
 * @desc Preview plan change (calculate costs) - Monthly only
 * @access Private
 */
router.post('/preview-change',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    body('newPlanName')
      .notEmpty()
      .withMessage('New plan name is required')
      .isIn(['casual', 'hunter'])
      .withMessage('Invalid plan name')
  ],
  handleValidationErrors,
  SubscriptionMiddleware.requireSubscription(['casual', 'hunter']),
  SubscriptionController.previewPlanChange
);

/**
 * @route POST /api/subscriptions/sync
 * @desc Sync subscription status with Stripe
 * @access Private
 */
router.post('/sync',
  subscriptionLimiter,
  authMiddleware.protect,
  SubscriptionController.syncSubscription
);

/**
 * @route GET /api/subscriptions/billing-history
 * @desc Get billing history
 * @access Private
 */
router.get('/billing-history',
  subscriptionLimiter,
  authMiddleware.protect,
  [
    query('limit')
      .optional()
      .isInt({ min: 1, max: 50 })
      .withMessage('Limit must be between 1 and 50')
  ],
  handleValidationErrors,
  SubscriptionController.getBillingHistory
);

/**
 * @route GET /api/subscriptions/health
 * @desc Get subscription health check
 * @access Private
 */
router.get('/health',
  subscriptionLimiter,
  authMiddleware.protect,
  SubscriptionMiddleware.injectSubscriptionContext(),
  SubscriptionMiddleware.handleTrialPeriod(),
  SubscriptionController.getSubscriptionHealth
);

// ======================================
// ADMIN-ONLY ROUTES
// ======================================

/**
 * @route GET /api/subscriptions/analytics
 * @desc Get subscription analytics (Admin only)
 * @access Private (Admin)
 */
router.get('/analytics',
  subscriptionLimiter,
  authMiddleware.protect,
  authMiddleware.restrictTo('admin'),
  [
    query('startDate')
      .optional()
      .isISO8601()
      .withMessage('Start date must be a valid ISO 8601 date'),
    query('endDate')
      .optional()
      .isISO8601()
      .withMessage('End date must be a valid ISO 8601 date'),
    query('planTier')
      .optional()
      .isIn(['free', 'casual', 'hunter'])
      .withMessage('Invalid plan tier'),
    query('feature')
      .optional()
      .isIn(['resumeUploads', 'jobImports', 'recruiterUnlocks', 'aiConversations'])
      .withMessage('Invalid feature')
  ],
  handleValidationErrors,
  SubscriptionController.getSubscriptionAnalytics
);

/**
 * @route GET /api/subscriptions/analytics/trends/:feature
 * @desc Get feature usage trends (Admin only)
 * @access Private (Admin)
 */
router.get('/analytics/trends/:feature',
  subscriptionLimiter,
  authMiddleware.protect,
  authMiddleware.restrictTo('admin'),
  [
    param('feature')
      .notEmpty()
      .withMessage('Feature is required')
      .isIn(['resumeUploads', 'jobImports', 'recruiterUnlocks', 'aiConversations'])
      .withMessage('Invalid feature'),
    query('days')
      .optional()
      .isInt({ min: 1, max: 365 })
      .withMessage('Days must be between 1 and 365')
  ],
  handleValidationErrors,
  SubscriptionController.getFeatureTrends
);

// ======================================
// EXAMPLE USAGE MIDDLEWARE INTEGRATION
// ======================================

/**
 * Example middleware usage for existing routes
 * These would be added to your existing controllers
 */

// Example: Resume upload with usage checking and tracking
// router.post('/upload', 
//   authMiddleware.protect,
//   UsageMiddleware.checkUsageLimit('resumeUploads', 1),
//   // ... existing middleware ...
//   UsageMiddleware.trackUsage('resumeUploads', 1, (req, res, body) => ({
//     fileName: body.data?.resume?.fileName,
//     fileSize: body.data?.resume?.fileSize
//   })),
//   ResumeController.uploadResume
// );

// Example: Job import with usage checking
// router.post('/import',
//   authMiddleware.protect,
//   UsageMiddleware.checkUsageLimit('jobImports', 1),
//   // ... existing middleware ...
//   UsageMiddleware.trackUsage('jobImports', 1),
//   JobController.importJob
// );

// Example: Recruiter unlock with feature and usage checking
// router.get('/:id/unlock',
//   authMiddleware.protect,
//   SubscriptionMiddleware.requireFeature('recruiterAccess'),
//   UsageMiddleware.checkUsageLimit('recruiterUnlocks', 1),
//   // ... existing middleware ...
//   UsageMiddleware.trackUsage('recruiterUnlocks', 1, (req, res, body) => ({
//     recruiterId: req.params.id,
//     recruiterName: body.data?.recruiter?.name
//   })),
//   RecruiterController.unlockRecruiter
// );

// Example: AI Assistant chat with comprehensive usage tracking
// router.post('/chat',
//   authMiddleware.protect,
//   SubscriptionMiddleware.requireFeature('aiAssistant'),
//   UsageMiddleware.checkUsageLimit('aiConversations', 1), // For new conversations
//   // ... existing middleware ...
//   UsageMiddleware.trackAIUsage(), // Special AI tracking middleware
//   AssistantController.chat
// );

// ======================================
// ERROR HANDLING MIDDLEWARE
// ======================================

// Error handling middleware for subscription routes
router.use((error, req, res, next) => {
  console.error('Subscription route error:', error);

  // Handle Stripe-specific errors
  if (error.type && error.type.includes('Stripe')) {
    return res.status(400).json({
      success: false,
      error: 'Payment processing error',
      details: process.env.NODE_ENV !== 'production' ? error.message : undefined
    });
  }

  // Handle subscription-specific errors
  if (error.message && error.message.includes('subscription')) {
    return res.status(400).json({
      success: false,
      error: error.message
    });
  }

  // Handle usage limit errors
  if (error.message && error.message.includes('limit')) {
    return res.status(403).json({
      success: false,
      error: error.message,
      upgradeRequired: true,
      billingCycle: 'monthly'
    });
  }

  // Default error handling
  res.status(500).json({
    success: false,
    error: 'Subscription service error',
    details: process.env.NODE_ENV !== 'production' ? error.message : undefined
  });
});

module.exports = router;

================
File: backend/routes/test.routes.js
================
// backend/routes/test.routes.js
const express = require('express');
const sendEmail = require('../utils/send-email');
const emailTemplates = require('../utils/email-templates');

const router = express.Router();

router.post('/test-email', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({
        success: false,
        error: 'Please provide an email address'
      });
    }
    
    const testUrl = 'http://localhost:3000/test';
    
    await sendEmail({
      email,
      subject: 'Test Email',
      html: emailTemplates.generateVerificationEmail('Test User', testUrl)
    });
    
    res.status(200).json({
      success: true,
      message: 'Test email sent successfully'
    });
  } catch (error) {
    console.error('Error sending test email:', error);
    res.status(500).json({
      success: false,
      error: 'Email could not be sent'
    });
  }
});

module.exports = router;

================
File: backend/scripts/fix-missing-columns.js
================
// backend/scripts/fix-missing-columns.js
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const db = require('../config/postgresql');

async function addMissingColumns() {
  try {
    console.log('Adding missing columns to recruiters table...');
    
    const columnsToAdd = [
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS highest_education VARCHAR(100);',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS contact_accuracy_score INTEGER;',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS contact_accuracy_grade VARCHAR(10);',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS zoominfo_profile_url TEXT;',
      'ALTER TABLE recruiters ADD COLUMN IF NOT EXISTS linkedin_profile_url TEXT;'
    ];
    
    for (const sql of columnsToAdd) {
      try {
        await db.query(sql);
        console.log(`✅ Executed: ${sql}`);
      } catch (error) {
        console.log(`Column might already exist: ${error.message}`);
      }
    }
    
    console.log('✅ All missing columns added to recruiters table');
    process.exit(0);
  } catch (error) {
    console.error('❌ Error adding columns:', error);
    process.exit(1);
  }
}

addMissingColumns();

================
File: backend/scripts/fix-outreach-history.js
================
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const db = require('../config/postgresql');

async function fixOutreachHistory() {
  try {
    console.log('🔧 Fixing outreach_history table...');
    
    // Check if constraint exists
    const constraintCheck = await db.query(`
      SELECT constraint_name 
      FROM information_schema.table_constraints 
      WHERE table_name = 'outreach_history' 
      AND constraint_type = 'UNIQUE'
      AND constraint_name = 'outreach_history_recruiter_user_unique'
    `);
    
    if (constraintCheck.rows.length === 0) {
      console.log('📊 Adding unique constraint...');
      
      await db.query(`
        ALTER TABLE outreach_history 
        ADD CONSTRAINT outreach_history_recruiter_user_unique 
        UNIQUE (recruiter_id, mongodb_user_id)
      `);
      
      console.log('✅ Unique constraint added successfully');
    } else {
      console.log('✅ Unique constraint already exists');
    }
    
    // Verify table structure
    const tableInfo = await db.query(`
      SELECT column_name, data_type, is_nullable
      FROM information_schema.columns 
      WHERE table_name = 'outreach_history'
      ORDER BY ordinal_position
    `);
    
    console.log('📋 Current table structure:');
    tableInfo.rows.forEach(row => {
      console.log(`  ${row.column_name}: ${row.data_type} (${row.is_nullable === 'YES' ? 'nullable' : 'not null'})`);
    });
    
    console.log('✅ Outreach history table is ready');
    
  } catch (error) {
    console.error('❌ Error fixing outreach history:', error);
  } finally {
    process.exit(0);
  }
}

fixOutreachHistory();

================
File: backend/scripts/import-recruiters.js
================
// backend/scripts/import-recruiters.js
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const { createTables, seedInitialData } = require('../models/postgresql/schema');
const RecruiterImportService = require('../services/recruiterImport.service');

async function main() {
  try {
    console.log('🚀 Starting recruiter database setup...');
    
    // Create/update tables
    await createTables();
    
    // Seed initial data
    await seedInitialData();
    
    // Import from CSV if file exists
    const csvPath = process.argv[2];
    if (csvPath) {
      if (!require('fs').existsSync(csvPath)) {
        console.error('❌ CSV file not found:', csvPath);
        process.exit(1);
      }
      
      console.log(`📥 Importing from CSV: ${csvPath}`);
      const result = await RecruiterImportService.importFromCSV(csvPath);
      
      console.log('✅ Import Results:');
      console.log(`   Companies: ${result.companiesImported}`);
      console.log(`   Recruiters: ${result.recruitersImported}`);
      console.log(`   Total Processed: ${result.totalProcessed}`);
      console.log(`   Errors: ${result.errors}`);
    } else {
      console.log('ℹ️  Tables created. To import data, run:');
      console.log('   node scripts/import-recruiters.js /path/to/your/csv/file.csv');
    }
    
    process.exit(0);
  } catch (error) {
    console.error('❌ Setup failed:', error);
    process.exit(1);
  }
}

main();

================
File: backend/scripts/update-recruiter-industries.js
================
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const db = require('../config/postgresql');

async function updateRecruiterIndustries() {
  try {
    console.log('🔍 Checking current state...');
    
    // Check current state
    const beforeCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters 
      WHERE industry_id IS NULL
    `);
    
    console.log(`📊 Recruiters without industry: ${beforeCount.rows[0].count}`);
    
    // Check how many can be updated
    const canUpdateCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters r
      JOIN companies c ON r.current_company_id = c.id
      WHERE r.industry_id IS NULL 
      AND c.industry_id IS NOT NULL
    `);
    
    console.log(`📊 Recruiters that can get industry from company: ${canUpdateCount.rows[0].count}`);
    
    // Perform the update
    console.log('🔄 Updating recruiter industries...');
    
    const updateResult = await db.query(`
      UPDATE recruiters 
      SET 
        industry_id = companies.industry_id,
        updated_at = NOW()
      FROM companies 
      WHERE recruiters.current_company_id = companies.id 
        AND recruiters.industry_id IS NULL
        AND companies.industry_id IS NOT NULL
    `);
    
    console.log(`✅ Updated ${updateResult.rowCount} recruiters with industries`);
    
    // Check final state
    const afterCount = await db.query(`
      SELECT COUNT(*) as count
      FROM recruiters 
      WHERE industry_id IS NOT NULL
    `);
    
    console.log(`📊 Recruiters with industry after update: ${afterCount.rows[0].count}`);
    
    // Show sample results
    console.log('📋 Sample results:');
    const sampleResults = await db.query(`
      SELECT 
        r.first_name,
        r.last_name,
        r.title,
        c.name as company_name,
        i.name as industry_name
      FROM recruiters r
      JOIN companies c ON r.current_company_id = c.id
      JOIN industries i ON r.industry_id = i.id
      LIMIT 5
    `);
    
    sampleResults.rows.forEach((row, index) => {
      console.log(`${index + 1}. ${row.first_name} ${row.last_name} (${row.title}) at ${row.company_name} - Industry: ${row.industry_name}`);
    });
    
    console.log('✅ Update completed successfully!');
    
  } catch (error) {
    console.error('❌ Error updating recruiter industries:', error);
  } finally {
    process.exit(0);
  }
}

updateRecruiterIndustries();

================
File: backend/server.js
================
// backend/server.js - UPDATED WITH SUBSCRIPTION ROUTES
const express = require('express');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Database connections
const connectMongoDB = require('./config/mongodb');
const { createTables, seedInitialData } = require('./models/postgresql/schema');
const { initializeStripe } = require('./config/stripe'); // NEW: Stripe initialization

// Import routes
const authRoutes = require('./routes/auth.routes');
const resumeRoutes = require('./routes/resume.routes');
const jobRoutes = require('./routes/job.routes');
const assistantRoutes = require('./routes/assistant.routes');
const recruiterRoutes = require('./routes/recruiter.routes');
const searchRoutes = require('./routes/search.routes');
const settingsRoutes = require('./routes/settings.routes');
const subscriptionRoutes = require('./routes/subscription.routes'); // NEW: Subscription routes

// Initialize Express
const app = express();

console.log('🚀 Starting Job Application Platform API with Subscription System...');

// Trust proxy for production
if (process.env.NODE_ENV === 'production') {
  app.set('trust proxy', 1);
}

// CORS configuration
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.FRONTEND_URL || 'https://yourproductiondomain.com'
    : 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: [
    'Content-Type',
    'Authorization', 
    'X-Requested-With',
    'Accept',
    'Origin',
    'stripe-signature' // NEW: Allow Stripe webhook signatures
  ]
}));

// Security middleware
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: false // Disable CSP for development
}));

// Special middleware for Stripe webhooks (must be before express.json())
app.use('/api/subscriptions/webhook', express.raw({ type: 'application/json' }));

// Body parser middleware (after webhook route)
app.use(express.json({ 
  limit: '10mb',
  strict: true
}));
app.use(express.urlencoded({ 
  extended: true, 
  limit: '10mb' 
}));

// Cookie parser middleware
app.use(cookieParser());

// Request sanitization middleware
const sanitizeRequest = (req, res, next) => {
  const sanitize = (obj) => {
    if (!obj) return obj;
    
    if (typeof obj === 'object' && obj !== null) {
      // Handle arrays
      if (Array.isArray(obj)) {
        return obj.map(sanitize);
      }
      
      // Handle objects
      const sanitized = {};
      for (const key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
        
        // Check for MongoDB injection patterns
        if (key.startsWith('$') || key.includes('.')) {
          console.warn(`Potentially malicious key detected and removed: ${key}`);
          continue;
        }
        
        sanitized[key] = sanitize(obj[key]);
      }
      return sanitized;
    }
    return obj;
  };
  
  // Sanitize request data
  try {
    if (req.body) req.body = sanitize(req.body);
    if (req.query) req.query = sanitize(req.query);
    if (req.params) req.params = sanitize(req.params);
  } catch (error) {
    console.warn('Sanitization error:', error);
  }
  
  next();
};

app.use(sanitizeRequest);

// Rate limiting
const generalLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: 'Too many requests from this IP, please try again later.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for AI Assistant (more restrictive due to cost)
const aiLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 50, // limit AI requests to 50 per 10 minutes
  message: {
    success: false,
    error: 'AI Assistant rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for Recruiter API (moderate limits)
const recruiterLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 150, // Higher limit for recruiter searches
  message: {
    success: false,
    error: 'Recruiter API rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for Search API (moderate limits)
const searchLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 100, // Allow frequent searches
  message: {
    success: false,
    error: 'Search rate limit exceeded. Please wait before searching again.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Special rate limiter for Settings API
const settingsLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 30, // Allow reasonable settings updates
  message: {
    success: false,
    error: 'Settings rate limit exceeded. Please wait before making more changes.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// NEW: Special rate limiter for Subscription API
const subscriptionLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 50, // Allow reasonable subscription operations
  message: {
    success: false,
    error: 'Subscription rate limit exceeded. Please wait before making more requests.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', generalLimiter);
app.use('/api/assistant', aiLimiter);
app.use('/api/recruiters', recruiterLimiter);
app.use('/api/search', searchLimiter);
app.use('/api/settings', settingsLimiter);
app.use('/api/subscriptions', subscriptionLimiter); // NEW: Subscription rate limiting

// Request logging middleware (development only)
if (process.env.NODE_ENV !== 'production') {
  app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.originalUrl}`);
    next();
  });
}

// Database and service initialization
const initializeServices = async () => {
  try {
    console.log('🔌 Initializing services...');
    
    // Connect to MongoDB
    await connectMongoDB();
    console.log('✅ MongoDB connected successfully');
    
    // Set up PostgreSQL tables
    await createTables();
    console.log('✅ PostgreSQL tables created successfully');
    
    // Seed initial data
    await seedInitialData();
    console.log('✅ Initial data seeded successfully');
    
    // NEW: Initialize Stripe
    const stripeInitialized = await initializeStripe();
    if (stripeInitialized) {
      console.log('✅ Stripe initialized successfully');
    } else {
      console.log('⚠️ Stripe initialization failed - subscription features may not work');
    }
    
    console.log('🎉 All services initialized successfully');
  } catch (error) {
    console.error('❌ Service initialization error:', error.message);
    
    // In production, exit on database failure
    if (process.env.NODE_ENV === 'production') {
      process.exit(1);
    } else {
      console.log('⚠️ Continuing in development mode without full service setup...');
    }
  }
};

// Initialize services
initializeServices();

// API Routes
app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'Job Application Platform API with Subscription System',
    version: '2.0.0',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString(),
    features: [
      'User Authentication',
      'Resume Management', 
      'Job Tracking',
      'AI Career Assistant',
      'Job Matching',
      'AI Job Search',
      'Recruiter Outreach',
      'Global Search',
      'User Settings & Security',
      '💳 Subscription & Billing System', // NEW
      '📊 Usage Tracking & Limits', // NEW
      '⚡ Feature Gating' // NEW
    ]
  });
});

app.get('/api/health', (req, res) => {
  res.status(200).json({ 
    success: true,
    status: 'OK', 
    message: 'API is healthy',
    timestamp: new Date().toISOString(),
    uptime: Math.floor(process.uptime()),
    memory: process.memoryUsage(),
    environment: process.env.NODE_ENV || 'development',
    services: {
      ai_status: process.env.OPENAI_API_KEY ? 'configured' : 'not_configured',
      stripe_status: process.env.STRIPE_SECRET_KEY ? 'configured' : 'not_configured', // NEW
      database_status: {
        mongodb: 'connected',
        postgresql: 'connected'
      }
    }
  });
});

// Mount API routes
app.use('/api/auth', authRoutes);
app.use('/api/resumes', resumeRoutes);
app.use('/api/jobs', jobRoutes);
app.use('/api/assistant', assistantRoutes);
app.use('/api/recruiters', recruiterRoutes);
app.use('/api/search', searchRoutes);
app.use('/api/settings', settingsRoutes);
app.use('/api/subscriptions', subscriptionRoutes); // NEW: Mount subscription routes

// Catch-all route for undefined API endpoints
app.all('/api/*', (req, res) => {
  res.status(404).json({
    success: false,
    error: `API endpoint ${req.originalUrl} not found`,
    suggestion: 'Check the API documentation for available endpoints',
    availableEndpoints: {
      auth: [
        'POST /api/auth/login',
        'POST /api/auth/register',
        'GET /api/auth/me',
        'POST /api/auth/logout'
      ],
      resumes: [
        'GET /api/resumes',
        'POST /api/resumes/upload',
        'GET /api/resumes/:id'
      ],
      jobs: [
        'GET /api/jobs',
        'POST /api/jobs',
        'GET /api/jobs/:id'
      ],
      assistant: [
        'POST /api/assistant/chat',
        'POST /api/assistant/analyze-resume',
        'POST /api/assistant/analyze-job-match',
        'GET /api/assistant/health'
      ],
      recruiters: [
        'GET /api/recruiters/search',
        'GET /api/recruiters/filters',
        'GET /api/recruiters/:id',
        'POST /api/recruiters/outreach',
        'GET /api/recruiters/outreach',
        'POST /api/recruiters/generate-message',
        'GET /api/recruiters/analytics'
      ],
      search: [
        'GET /api/search?query={query}&category={category}',
        'GET /api/search/suggestions?query={query}',
        'GET /api/search/popular'
      ],
      settings: [
        'GET /api/settings/profile',
        'PUT /api/settings/profile',
        'PUT /api/settings/change-password',
        'DELETE /api/settings/delete-account',
        'POST /api/settings/send-verification-email',
        'GET /api/settings/verify-email/:token'
      ],
      subscriptions: [ // NEW: Subscription endpoints
        'GET /api/subscriptions/plans',
        'GET /api/subscriptions/current',
        'GET /api/subscriptions/usage',
        'POST /api/subscriptions/create-checkout',
        'POST /api/subscriptions/cancel',
        'POST /api/subscriptions/resume',
        'PUT /api/subscriptions/change-plan',
        'GET /api/subscriptions/billing-history',
        'POST /api/subscriptions/webhook'
      ]
    }
  });
});

// Global error handling middleware
app.use((err, req, res, next) => {
  console.error('Global error handler triggered:', {
    message: err.message,
    stack: process.env.NODE_ENV !== 'production' ? err.stack : undefined,
    url: req.originalUrl,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  // OpenAI API error handling
  if (err.message && err.message.includes('OpenAI')) {
    return res.status(503).json({
      success: false,
      error: 'AI service temporarily unavailable',
      details: process.env.NODE_ENV !== 'production' ? err.message : undefined
    });
  }
  
  // NEW: Stripe error handling
  if (err.type && err.type.includes('Stripe')) {
    return res.status(400).json({
      success: false,
      error: 'Payment processing error',
      details: process.env.NODE_ENV !== 'production' ? err.message : undefined
    });
  }
  
  // PostgreSQL error handling
  if (err.code && err.code.startsWith('23')) { // PostgreSQL constraint violations
    return res.status(400).json({
      success: false,
      error: 'Database constraint violation',
      details: process.env.NODE_ENV !== 'production' ? err.message : undefined
    });
  }
  
  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(val => val.message);
    return res.status(400).json({
      success: false,
      error: 'Validation Error',
      details: errors
    });
  }
  
  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue || {})[0] || 'field';
    return res.status(400).json({
      success: false,
      error: `${field} already exists`
    });
  }
  
  // JWT error
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
  
  // MongoDB connection error
  if (err.name === 'MongoNetworkError') {
    return res.status(503).json({
      success: false,
      error: 'Database connection error'
    });
  }
  
  // Default error response
  res.status(err.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal Server Error' 
      : err.message,
    ...(process.env.NODE_ENV !== 'production' && { 
      stack: err.stack,
      timestamp: new Date().toISOString()
    })
  });
});

// Start the server
const PORT = process.env.PORT || 5000;
const server = app.listen(PORT, () => {
  console.log(`🚀 Server running successfully on port ${PORT}`);
  console.log(`📍 Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`🌐 CORS enabled for: ${process.env.NODE_ENV === 'production' ? 'production domain' : 'http://localhost:3000'}`);
  console.log(`📊 Health check available at: http://localhost:${PORT}/api/health`);
  console.log(`🔗 API documentation: http://localhost:${PORT}/`);
  console.log(`🤖 AI Assistant: ${process.env.OPENAI_API_KEY ? '✅ Configured' : '❌ Not configured - add OPENAI_API_KEY to .env'}`);
  console.log(`💳 Stripe Payments: ${process.env.STRIPE_SECRET_KEY ? '✅ Configured' : '❌ Not configured - add STRIPE_SECRET_KEY to .env'}`); // NEW
  console.log(`🎯 Recruiter API: ✅ Configured with PostgreSQL database`);
  console.log(`🔍 Global Search: ✅ Configured with cross-platform search`);
  console.log(`⚙️ Settings API: ✅ Configured with profile & security management`);
  console.log(`📈 Subscription System: ✅ Configured with usage tracking & limits`); // NEW
});

// Graceful shutdown handlers
process.on('SIGTERM', () => {
  console.log('🛑 SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    console.log('✅ HTTP server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('🛑 SIGINT received. Shutting down gracefully...');
  server.close(() => {
    console.log('✅ HTTP server closed');
    process.exit(0);
  });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err, promise) => {
  console.error('🔥 UNHANDLED REJECTION:', {
    message: err.message,
    stack: err.stack,
    promise: promise
  });
  
  if (process.env.NODE_ENV === 'production') {
    console.log('🛑 Shutting down server due to unhandled promise rejection');
    server.close(() => {
      process.exit(1);
    });
  }
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('🔥 UNCAUGHT EXCEPTION:', {
    message: err.message,
    stack: err.stack
  });
  
  console.log('🛑 Shutting down server due to uncaught exception');
  process.exit(1);
});

================
File: backend/services/adzunaJobExtractor.service.js
================
// services/adzunaJobExtractor.service.js - ENHANCED WITH DIAGNOSTICS AND FIXES
require('dotenv').config();
const axios = require('axios');

/**
 * Enhanced Adzuna API Job Extractor with comprehensive diagnostics
 * Includes fallback strategies and better search optimization
 */
class AdzunaJobExtractor {
  constructor() {
    this.appId = process.env.ADZUNA_APP_ID;
    this.appKey = process.env.ADZUNA_APP_KEY;
    this.baseUrl = 'https://api.adzuna.com/v1/api/jobs';
    this.country = 'us'; // United States
    
    // Enhanced logging for diagnostics
    this.diagnosticsEnabled = true;
    this.searchAttempts = 0;
    this.successfulSearches = 0;
    this.totalJobsFound = 0;
    
    if (!this.appId || !this.appKey) {
      console.warn('⚠️ Adzuna API keys not configured. Set ADZUNA_APP_ID and ADZUNA_APP_KEY in .env file');
      console.warn('🔗 Get free API keys at: https://developer.adzuna.com/');
    } else {
      console.log('🎯 Enhanced AdzunaJobExtractor initialized with diagnostics');
      console.log(`📊 Rate limit: 1000 requests/month (free tier)`);
      console.log(`🌐 Coverage: Indeed, LinkedIn, Monster, CareerBuilder, and 1000+ job boards`);
    }
  }

  /**
   * Enhanced extraction with better search strategies
   */
  async extractJobsForCareerProfile(careerProfile, search, options = {}) {
    const {
      maxJobs = 10,
      maxDaysOld = 30,
      sortBy = 'date'
    } = options;

    console.log(`🎯 Starting enhanced Adzuna API job extraction...`);
    console.log(`📋 Target titles: ${careerProfile.targetJobTitles?.join(', ')}`);
    console.log(`📍 Preferred locations: ${careerProfile.preferredLocations?.join(', ')}`);

    // Reset diagnostics
    this.searchAttempts = 0;
    this.successfulSearches = 0;
    this.totalJobsFound = 0;

    const results = {
      jobs: [],
      totalFound: 0,
      errors: [],
      extractionMode: 'adzuna_api_enhanced',
      source: 'adzuna_aggregator',
      searchAttempts: 0,
      diagnostics: {
        searchStrategies: [],
        apiResponses: [],
        searchOptimizations: []
      }
    };

    if (!this.appId || !this.appKey) {
      throw new Error('Adzuna API keys not configured. Please set ADZUNA_APP_ID and ADZUNA_APP_KEY in your .env file.');
    }

    try {
      // STRATEGY 1: Original specific searches
      console.log('📈 STRATEGY 1: Specific job title searches...');
      await this.performSpecificJobSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search);

      // STRATEGY 2: Broader keyword searches if few results
      if (results.jobs.length < 3) {
        console.log('📈 STRATEGY 2: Broader keyword searches (few results from specific search)...');
        await this.performBroaderKeywordSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search);
      }

      // STRATEGY 3: Industry-based searches if still few results
      if (results.jobs.length < 5) {
        console.log('📈 STRATEGY 3: Industry-based searches...');
        await this.performIndustryBasedSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search);
      }

      // STRATEGY 4: Fallback to very broad searches
      if (results.jobs.length < 2) {
        console.log('📈 STRATEGY 4: Fallback broad searches...');
        await this.performFallbackBroadSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search);
      }

      results.totalFound = results.jobs.length;
      results.searchAttempts = this.searchAttempts;

      // Enhanced diagnostics logging
      console.log(`✅ Enhanced Adzuna extraction completed:`);
      console.log(`   📊 Jobs found: ${results.totalFound}`);
      console.log(`   🔍 API calls made: ${this.searchAttempts}`);
      console.log(`   ✅ Successful calls: ${this.successfulSearches}`);
      console.log(`   📈 Success rate: ${this.searchAttempts > 0 ? Math.round((this.successfulSearches / this.searchAttempts) * 100) : 0}%`);
      console.log(`   🎯 Jobs per successful call: ${this.successfulSearches > 0 ? (results.totalFound / this.successfulSearches).toFixed(1) : 0}`);

      // Log diagnostics for debugging
      if (this.diagnosticsEnabled) {
        console.log(`🔍 DIAGNOSTICS SUMMARY:`);
        results.diagnostics.searchStrategies.forEach((strategy, index) => {
          console.log(`   Strategy ${index + 1}: ${strategy.name} - ${strategy.jobsFound} jobs found`);
        });
      }

      return results;

    } catch (error) {
      console.error(`❌ Enhanced Adzuna extraction failed:`, error.message);
      
      // Enhanced error logging
      await search.addReasoningLog(
        'web_search_discovery',
        `Enhanced Adzuna API extraction failed: ${error.message}. Diagnostics: ${this.searchAttempts} calls made, ${this.successfulSearches} successful.`,
        {
          error: error.message,
          diagnostics: {
            totalCalls: this.searchAttempts,
            successfulCalls: this.successfulSearches,
            jobsFound: this.totalJobsFound
          }
        },
        false
      );

      throw error;
    }
  }

  /**
   * STRATEGY 1: Specific job title searches (original approach)
   */
  async performSpecificJobSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search) {
    const strategy = {
      name: 'Specific Job Title Searches',
      searches: [],
      jobsFound: 0
    };

    const jobTitles = careerProfile.targetJobTitles || ['Software Engineer'];
    const locations = careerProfile.preferredLocations || ['Remote'];
    
    for (const jobTitle of jobTitles) {
      if (results.jobs.length >= maxJobs) break;
      
      for (const location of locations) {
        if (results.jobs.length >= maxJobs) break;
        
        try {
          const searchResult = await this.searchAdzunaAPI({
            jobTitle,
            location,
            experienceLevel: careerProfile.experienceLevel,
            salaryMin: careerProfile.salaryExpectation?.min,
            salaryMax: careerProfile.salaryExpectation?.max,
            maxResults: Math.min(maxJobs - results.jobs.length, 10),
            maxDaysOld,
            sortBy,
            keywords: careerProfile.targetKeywords
          });

          strategy.searches.push({
            query: `${jobTitle} in ${location}`,
            jobsReturned: searchResult.jobs?.length || 0,
            totalAvailable: searchResult.totalAvailable || 0
          });

          if (searchResult.jobs && searchResult.jobs.length > 0) {
            this.addUniqueJobs(searchResult.jobs, results, careerProfile);
            strategy.jobsFound += searchResult.jobs.length;
          }

        } catch (error) {
          console.error(`❌ Strategy 1 error for "${jobTitle}" in ${location}:`, error.message);
          strategy.searches.push({
            query: `${jobTitle} in ${location}`,
            error: error.message
          });
        }
      }
    }

    results.diagnostics.searchStrategies.push(strategy);
    console.log(`   Strategy 1 results: ${strategy.jobsFound} jobs found from ${strategy.searches.length} searches`);
  }

  /**
   * STRATEGY 2: Broader keyword searches
   */
  async performBroaderKeywordSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search) {
    const strategy = {
      name: 'Broader Keyword Searches',
      searches: [],
      jobsFound: 0
    };

    // Extract base job types from titles
    const baseJobTypes = this.extractBaseJobTypes(careerProfile.targetJobTitles);
    const keywords = careerProfile.targetKeywords || [];
    
    for (const jobType of baseJobTypes) {
      if (results.jobs.length >= maxJobs) break;
      
      // Search with just the base job type (e.g., "Manager" instead of "Product Manager")
      try {
        const searchResult = await this.searchAdzunaAPI({
          jobTitle: jobType,
          location: '', // Broader location search
          maxResults: Math.min(maxJobs - results.jobs.length, 20),
          maxDaysOld: maxDaysOld * 2, // Longer time range
          sortBy: 'relevance',
          keywords: keywords.slice(0, 2) // Top 2 keywords only
        });

        strategy.searches.push({
          query: `${jobType} (broad search)`,
          jobsReturned: searchResult.jobs?.length || 0,
          totalAvailable: searchResult.totalAvailable || 0
        });

        if (searchResult.jobs && searchResult.jobs.length > 0) {
          // Filter for relevance before adding
          const relevantJobs = searchResult.jobs.filter(job => 
            this.isJobRelevantToProfile(job, careerProfile)
          );
          
          this.addUniqueJobs(relevantJobs, results, careerProfile);
          strategy.jobsFound += relevantJobs.length;
        }

      } catch (error) {
        console.error(`❌ Strategy 2 error for "${jobType}":`, error.message);
        strategy.searches.push({
          query: `${jobType} (broad search)`,
          error: error.message
        });
      }
    }

    results.diagnostics.searchStrategies.push(strategy);
    console.log(`   Strategy 2 results: ${strategy.jobsFound} jobs found from ${strategy.searches.length} searches`);
  }

  /**
   * STRATEGY 3: Industry-based searches
   */
  async performIndustryBasedSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search) {
    const strategy = {
      name: 'Industry-Based Searches',
      searches: [],
      jobsFound: 0
    };

    const industries = careerProfile.industries || ['Technology', 'Software'];
    const mainKeywords = careerProfile.targetKeywords?.slice(0, 3) || [];
    
    for (const industry of industries) {
      if (results.jobs.length >= maxJobs) break;
      
      for (const keyword of mainKeywords) {
        if (results.jobs.length >= maxJobs) break;
        
        try {
          const searchResult = await this.searchAdzunaAPI({
            jobTitle: keyword, // Use keyword as job title
            location: '',
            maxResults: Math.min(maxJobs - results.jobs.length, 15),
            maxDaysOld: maxDaysOld * 3,
            sortBy: 'relevance',
            keywords: [industry]
          });

          strategy.searches.push({
            query: `${keyword} in ${industry}`,
            jobsReturned: searchResult.jobs?.length || 0,
            totalAvailable: searchResult.totalAvailable || 0
          });

          if (searchResult.jobs && searchResult.jobs.length > 0) {
            const relevantJobs = searchResult.jobs.filter(job => 
              this.isJobRelevantToProfile(job, careerProfile)
            );
            
            this.addUniqueJobs(relevantJobs, results, careerProfile);
            strategy.jobsFound += relevantJobs.length;
          }

        } catch (error) {
          console.error(`❌ Strategy 3 error for "${keyword}" in ${industry}:`, error.message);
        }
      }
    }

    results.diagnostics.searchStrategies.push(strategy);
    console.log(`   Strategy 3 results: ${strategy.jobsFound} jobs found from ${strategy.searches.length} searches`);
  }

  /**
   * STRATEGY 4: Fallback broad searches
   */
  async performFallbackBroadSearches(careerProfile, results, maxJobs, maxDaysOld, sortBy, search) {
    const strategy = {
      name: 'Fallback Broad Searches',
      searches: [],
      jobsFound: 0
    };

    // Very broad searches as last resort
    const broadTerms = ['manager', 'analyst', 'specialist', 'coordinator', 'engineer'];
    
    for (const term of broadTerms) {
      if (results.jobs.length >= maxJobs) break;
      
      try {
        const searchResult = await this.searchAdzunaAPI({
          jobTitle: term,
          location: '',
          maxResults: Math.min(maxJobs - results.jobs.length, 50),
          maxDaysOld: 60, // Very long time range
          sortBy: 'date',
          keywords: []
        });

        strategy.searches.push({
          query: `${term} (fallback broad)`,
          jobsReturned: searchResult.jobs?.length || 0,
          totalAvailable: searchResult.totalAvailable || 0
        });

        if (searchResult.jobs && searchResult.jobs.length > 0) {
          // Very strict relevance filtering for broad searches
          const relevantJobs = searchResult.jobs.filter(job => 
            this.isJobStronglyRelevantToProfile(job, careerProfile)
          );
          
          this.addUniqueJobs(relevantJobs, results, careerProfile);
          strategy.jobsFound += relevantJobs.length;
        }

      } catch (error) {
        console.error(`❌ Strategy 4 error for "${term}":`, error.message);
      }
    }

    results.diagnostics.searchStrategies.push(strategy);
    console.log(`   Strategy 4 results: ${strategy.jobsFound} jobs found from ${strategy.searches.length} searches`);
  }

  /**
   * Enhanced API search with better error handling and diagnostics
   */
  async searchAdzunaAPI(searchParams) {
    const {
      jobTitle,
      location = '',
      experienceLevel,
      salaryMin,
      salaryMax,
      maxResults = 10,
      maxDaysOld = 30,
      sortBy = 'date',
      keywords = []
    } = searchParams;

    this.searchAttempts++;

    try {
      // Enhanced query building
      const searchQuery = this.buildOptimizedSearchQuery(jobTitle, keywords, experienceLevel);
      const searchLocation = this.optimizeLocation(location);

      const params = {
        app_id: this.appId,
        app_key: this.appKey,
        results_per_page: Math.min(maxResults, 50),
        what: searchQuery,
        sort_by: sortBy,
        max_days_old: maxDaysOld,
        full_time: 1,
        permanent: 1
      };

      // Only add location if it's not empty (for broader searches)
      if (searchLocation) {
        params.where = searchLocation;
      }

      // Add salary filters if specified
      if (salaryMin && salaryMin > 0) params.salary_min = salaryMin;
      if (salaryMax && salaryMax > 0) params.salary_max = salaryMax;

      const url = `${this.baseUrl}/${this.country}/search/1`;
      
      if (this.diagnosticsEnabled) {
        console.log(`🌐 Enhanced API request: "${searchQuery}"${searchLocation ? ` in ${searchLocation}` : ' (any location)'}`);
      }
      
      const response = await axios.get(url, { 
        params,
        timeout: 30000,
        headers: {
          'User-Agent': 'AutoJobAI/1.0 JobDiscoveryBot',
          'Accept': 'application/json'
        }
      });

      const data = response.data;
      this.successfulSearches++;
      
      if (this.diagnosticsEnabled) {
        console.log(`📊 API response: ${data.count || 0} total available, processing ${data.results?.length || 0}`);
        console.log(`   🔍 Search params used:`, {
          what: searchQuery,
          where: searchLocation || 'any',
          max_days_old: maxDaysOld,
          results_per_page: params.results_per_page
        });
      }

      const jobs = [];
      
      if (data.results && data.results.length > 0) {
        for (const apiJob of data.results) {
          try {
            const job = this.convertApiJobToStandardFormat(apiJob);
            if (job) {
              jobs.push(job);
              this.totalJobsFound++;
            }
          } catch (error) {
            console.error(`Error processing individual job:`, error.message);
          }
        }
      }

      return {
        jobs,
        totalAvailable: data.count || 0,
        searchParams: {
          ...searchParams,
          actualQuery: searchQuery,
          actualLocation: searchLocation
        },
        apiResponse: {
          resultCount: data.results?.length || 0,
          totalCount: data.count || 0,
          searchUrl: url,
          searchParams: params
        }
      };

    } catch (error) {
      console.error(`❌ Enhanced API search failed:`, error.message);
      
      if (this.diagnosticsEnabled) {
        console.log(`🔍 Failed search details:`, {
          query: jobTitle,
          location: location,
          error: error.response?.status || error.code,
          message: error.message
        });
      }
      
      if (error.response?.status === 401) {
        throw new Error('Adzuna API authentication failed - check your API keys');
      } else if (error.response?.status === 429) {
        throw new Error('Adzuna API rate limit exceeded - try again later');
      } else if (error.response?.status === 403) {
        throw new Error('Adzuna API access forbidden - verify credentials');
      } else {
        throw new Error(`Adzuna API request failed: ${error.message}`);
      }
    }
  }

  /**
   * Build optimized search queries for better results
   */
  buildOptimizedSearchQuery(jobTitle, keywords = [], experienceLevel) {
    // Start with the job title
    let query = jobTitle;
    
    // For very specific titles, try just the core part
    if (jobTitle.includes(' - ') || jobTitle.includes(' / ')) {
      const corePart = jobTitle.split(/[\-\/]/)[0].trim();
      query = corePart;
    }
    
    // Remove overly specific terms that might limit results
    query = query
      .replace(/\b(Senior|Junior|Lead|Principal|Director)\b/gi, '') // Remove seniority for broader search
      .replace(/\b(AI|ML|Machine Learning|Artificial Intelligence)\b/gi, '') // Remove AI terms for broader search
      .trim();
    
    // Add back experience level if specified
    if (experienceLevel && !query.toLowerCase().includes(experienceLevel.toLowerCase())) {
      if (experienceLevel === 'senior' || experienceLevel === 'lead') {
        query = `${experienceLevel} ${query}`;
      }
    }
    
    return query;
  }

  /**
   * Optimize location for better API results
   */
  optimizeLocation(location) {
    if (!location || location.toLowerCase().includes('remote')) {
      return ''; // Empty for remote/broader search
    }
    
    // Simplify location names
    return location
      .replace(/,?\s*(USA?|United States)$/i, '')
      .replace(/^(Greater\s+|Metro\s+)/i, '')
      .replace(/\s+Area$/i, '')
      .trim();
  }

  /**
   * Extract base job types from specific titles
   */
  extractBaseJobTypes(jobTitles) {
    const baseTypes = new Set();
    
    (jobTitles || []).forEach(title => {
      // Extract the main job type
      const cleaned = title
        .replace(/\b(Senior|Junior|Lead|Principal|Director|Vice President|VP)\b/gi, '')
        .replace(/\b(AI|ML|Machine Learning|Artificial Intelligence)\b/gi, '')
        .replace(/[\-\/].+$/, '') // Remove everything after dash or slash
        .trim();
      
      if (cleaned.length > 2) {
        baseTypes.add(cleaned);
      }
      
      // Also add individual words for very broad search
      const words = cleaned.split(' ').filter(word => word.length > 3);
      words.forEach(word => baseTypes.add(word));
    });
    
    return Array.from(baseTypes);
  }

  /**
   * Check if job is relevant to career profile
   */
  isJobRelevantToProfile(job, careerProfile) {
    const titleLower = job.title.toLowerCase();
    const descLower = (job.description || '').toLowerCase();
    
    // Check for any target job title words
    const titleWords = (careerProfile.targetJobTitles || [])
      .flatMap(title => title.toLowerCase().split(' '))
      .filter(word => word.length > 3);
    
    const titleMatch = titleWords.some(word => titleLower.includes(word));
    
    // Check for target keywords
    const keywordMatch = (careerProfile.targetKeywords || [])
      .some(keyword => descLower.includes(keyword.toLowerCase()) || titleLower.includes(keyword.toLowerCase()));
    
    return titleMatch || keywordMatch;
  }

  /**
   * Strong relevance check for fallback searches
   */
  isJobStronglyRelevantToProfile(job, careerProfile) {
    const titleLower = job.title.toLowerCase();
    const descLower = (job.description || '').toLowerCase();
    
    // Must match both title and keywords for strong relevance
    const titleWords = (careerProfile.targetJobTitles || [])
      .flatMap(title => title.toLowerCase().split(' '))
      .filter(word => word.length > 3);
    
    const titleMatch = titleWords.some(word => titleLower.includes(word));
    
    const keywordMatch = (careerProfile.targetKeywords || [])
      .filter(keyword => keyword.length > 2)
      .some(keyword => descLower.includes(keyword.toLowerCase()));
    
    return titleMatch && keywordMatch;
  }

  /**
   * Add unique jobs to results (avoiding duplicates)
   */
  addUniqueJobs(newJobs, results, careerProfile) {
    for (const job of newJobs) {
      // Check for duplicates
      const isDuplicate = results.jobs.some(existingJob => 
        existingJob.company.toLowerCase() === job.company.toLowerCase() &&
        this.calculateSimilarity(existingJob.title, job.title) > 0.8
      );

      if (!isDuplicate) {
        const enhancedJob = this.enhanceJobWithCareerContext(job, careerProfile);
        results.jobs.push(enhancedJob);
        
        if (this.diagnosticsEnabled) {
          console.log(`✅ Added: "${job.title}" at ${job.company} (${job.sourcePlatform})`);
        }
      } else if (this.diagnosticsEnabled) {
        console.log(`⚠️ Skipped duplicate: "${job.title}" at ${job.company}`);
      }
    }
  }

  /**
   * Run comprehensive diagnostics
   */
  async runDiagnostics() {
    console.log('🔍 Running comprehensive Adzuna API diagnostics...');
    
    const diagnostics = {
      apiConnection: null,
      searchCapabilities: [],
      dataQuality: {},
      recommendations: []
    };

    try {
      // Test API connection
      diagnostics.apiConnection = await this.getApiHealth();
      
      // Test different search types
      const testSearches = [
        { query: 'manager', location: '' },
        { query: 'engineer', location: 'new york' },
        { query: 'analyst', location: 'remote' },
        { query: 'product manager', location: 'san francisco' }
      ];

      for (const test of testSearches) {
        try {
          const result = await this.searchAdzunaAPI({
            jobTitle: test.query,
            location: test.location,
            maxResults: 5,
            maxDaysOld: 30
          });

          diagnostics.searchCapabilities.push({
            query: test.query,
            location: test.location || 'any',
            totalAvailable: result.totalAvailable,
            jobsReturned: result.jobs.length,
            status: 'success'
          });

        } catch (error) {
          diagnostics.searchCapabilities.push({
            query: test.query,
            location: test.location || 'any',
            status: 'failed',
            error: error.message
          });
        }
      }

      // Generate recommendations
      const totalJobs = diagnostics.searchCapabilities.reduce((sum, cap) => sum + (cap.totalAvailable || 0), 0);
      
      if (totalJobs < 100) {
        diagnostics.recommendations.push('Consider using broader search terms');
        diagnostics.recommendations.push('Try removing experience level filters');
        diagnostics.recommendations.push('Expand geographic search area');
      }

      if (diagnostics.searchCapabilities.some(cap => cap.status === 'failed')) {
        diagnostics.recommendations.push('Check API credentials and rate limits');
      }

      console.log('✅ Diagnostics completed:', diagnostics);
      return diagnostics;

    } catch (error) {
      console.error('❌ Diagnostics failed:', error);
      return {
        error: error.message,
        status: 'failed'
      };
    }
  }

  // ... (keeping all existing helper methods like calculateSimilarity, enhanceJobWithCareerContext, etc.)
  
  calculateSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const distance = this.levenshteinDistance(longer.toLowerCase(), shorter.toLowerCase());
    return (longer.length - distance) / longer.length;
  }

  levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  enhanceJobWithCareerContext(job, careerProfile) {
    job.careerContext = {
      targetedForProfile: true,
      experienceLevel: careerProfile.experienceLevel,
      targetJobTitles: careerProfile.targetJobTitles,
      targetKeywords: careerProfile.targetKeywords,
      workArrangementPreference: careerProfile.workArrangement,
      salaryExpectation: careerProfile.salaryExpectation
    };
    
    let profileBonus = 0;
    
    if (job.title && careerProfile.experienceLevel) {
      const titleLower = job.title.toLowerCase();
      if (careerProfile.experienceLevel === 'senior' && titleLower.includes('senior')) {
        profileBonus += 15;
      } else if (careerProfile.experienceLevel === 'lead' && 
                 (titleLower.includes('lead') || titleLower.includes('principal'))) {
        profileBonus += 15;
      }
    }
    
    if (careerProfile.targetKeywords && job.description) {
      const descLower = job.description.toLowerCase();
      const matchingKeywords = careerProfile.targetKeywords.filter(keyword =>
        descLower.includes(keyword.toLowerCase())
      );
      profileBonus += Math.min(matchingKeywords.length * 5, 20);
    }
    
    job.matchScore = Math.min((job.matchScore || 70) + profileBonus, 100);
    
    return job;
  }

  async getApiHealth() {
    try {
      if (!this.appId || !this.appKey) {
        return {
          status: 'not_configured',
          message: 'Adzuna API keys not set'
        };
      }

      const testParams = {
        app_id: this.appId,
        app_key: this.appKey,
        results_per_page: 1,
        what: 'test'
      };

const response = await axios.get(`${this.baseUrl}/${this.country}/search/1`, {
        params: testParams,
        timeout: 10000
      });

      return {
        status: 'healthy',
        message: 'Adzuna API connection successful',
        totalJobsAvailable: response.data.count || 0,
        provider: 'Adzuna',
        rateLimit: '1000 requests/month (free tier)',
        coverage: 'Indeed, LinkedIn, Monster, CareerBuilder, and 1000+ job boards',
        lastTested: new Date()
      };

    } catch (error) {
      let status = 'error';
      let message = `Adzuna API connection failed: ${error.message}`;
      
      if (error.response?.status === 401) {
        status = 'auth_error';
        message = 'Adzuna API authentication failed - check your API keys';
      } else if (error.response?.status === 429) {
        status = 'rate_limited';
        message = 'Adzuna API rate limit exceeded (1000/month) - try again later';
      }

      return {
        status,
        message,
        error: error.response?.data || error.message,
        provider: 'Adzuna',
        lastTested: new Date()
      };
    }
  }

  // Keep all other existing methods (convertApiJobToStandardFormat, etc.)
  convertApiJobToStandardFormat(apiJob) {
    try {
      let salary = {};
      if (apiJob.salary_min || apiJob.salary_max) {
        salary = {
          min: apiJob.salary_min,
          max: apiJob.salary_max,
          currency: 'USD',
          isExplicit: !apiJob.salary_is_predicted
        };
      }

      let workArrangement = this.inferWorkArrangement(
        apiJob.description || '', 
        apiJob.location?.display_name || '',
        apiJob.contract_time
      );

      const company = apiJob.company?.display_name || 'Unknown Company';
      const sourcePlatform = this.identifySourcePlatform(apiJob.redirect_url || '');

      const job = {
        title: this.cleanJobTitle(apiJob.title || 'Unknown Title'),
        company: company,
        location: this.normalizeJobLocation(apiJob.location?.display_name || 'Not specified'),
        description: apiJob.description || '',
        fullContent: apiJob.description || '',
        jobUrl: apiJob.redirect_url || apiJob.url,
        sourceUrl: apiJob.redirect_url || apiJob.url,
        salary: Object.keys(salary).length > 0 ? salary : {},
        postedDate: apiJob.created ? new Date(apiJob.created).toISOString().split('T')[0] : null,
        sourcePlatform: sourcePlatform,
        extractedAt: new Date(),
        extractionMethod: 'adzuna_api_enhanced',
        workArrangement: workArrangement,
        jobType: this.mapContractType(apiJob.contract_type, apiJob.contract_time),
        
        adzunaData: {
          id: apiJob.id,
          category: apiJob.category?.label,
          contractType: apiJob.contract_type,
          contractTime: apiJob.contract_time,
          latitude: apiJob.latitude,
          longitude: apiJob.longitude,
          adref: apiJob.adref,
          salaryPredicted: apiJob.salary_is_predicted
        },
        
        contentQuality: this.assessApiJobQuality(apiJob),
        matchScore: this.calculateInitialMatchScore(apiJob),
        
        metadata: {
          discoveryMethod: 'adzuna_api_enhanced',
          platform: sourcePlatform,
          extractedAt: new Date(),
          contentLength: (apiJob.description || '').length,
          directCompanyPosting: this.isDirectCompanyPosting(apiJob.redirect_url),
          apiJobBoard: true,
          aggregatorSource: 'adzuna'
        }
      };

      return job;

    } catch (error) {
      console.error('Error converting Adzuna API job to standard format:', error);
      return null;
    }
  }

  inferWorkArrangement(description, location, contractTime) {
    const lowerDesc = (description || '').toLowerCase();
    const lowerLoc = (location || '').toLowerCase();
    
    if (lowerLoc.includes('remote') || lowerDesc.includes('remote') || 
        lowerDesc.includes('work from home') || lowerDesc.includes('wfh') ||
        lowerDesc.includes('telecommute') || lowerDesc.includes('distributed')) {
      
      if (lowerDesc.includes('hybrid') || lowerDesc.includes('flexible') || 
          lowerDesc.includes('office days') || lowerDesc.includes('days in office')) {
        return 'hybrid';
      }
      
      return 'remote';
    }
    
    if (lowerDesc.includes('hybrid') || lowerDesc.includes('flexible') || 
        lowerDesc.includes('mix of remote') || lowerDesc.includes('part remote') ||
        lowerDesc.includes('days remote') || lowerDesc.includes('home/office')) {
      return 'hybrid';
    }
    
    if (lowerDesc.includes('on-site') || lowerDesc.includes('onsite') || 
        lowerDesc.includes('in office') || lowerDesc.includes('office location') ||
        lowerDesc.includes('headquarters') || lowerDesc.includes('physical presence')) {
      return 'onsite';
    }
    
    if (location && !lowerLoc.includes('remote') && !lowerLoc.includes('anywhere')) {
      return 'onsite';
    }
    
    return 'unknown';
  }

  identifySourcePlatform(redirectUrl) {
    if (!redirectUrl) return 'Adzuna Direct';
    
    const url = redirectUrl.toLowerCase();
    
    if (url.includes('indeed.')) return 'Indeed';
    if (url.includes('linkedin.')) return 'LinkedIn';
    if (url.includes('monster.')) return 'Monster';
    if (url.includes('careerbuilder.')) return 'CareerBuilder';
    if (url.includes('glassdoor.')) return 'Glassdoor';
    if (url.includes('ziprecruiter.')) return 'ZipRecruiter';
    if (url.includes('simplyhired.')) return 'SimplyHired';
    if (url.includes('dice.')) return 'Dice';
    if (url.includes('stackoverflow.')) return 'Stack Overflow Jobs';
    if (url.includes('greenhouse.')) return 'Greenhouse';
    if (url.includes('lever.')) return 'Lever';
    
    return 'Adzuna Partner';
  }

  cleanJobTitle(title) {
    return title
      .replace(/\s+/g, ' ')
      .replace(/[^\w\s\-\(\)\/&+]/g, '')
      .trim();
  }

  normalizeJobLocation(location) {
    if (!location || location.toLowerCase().includes('remote')) {
      return 'Remote';
    }
    
    return location
      .replace(/,\s*United States?$/i, '')
      .replace(/,\s*USA?$/i, '')
      .trim();
  }

  mapContractType(contractType, contractTime) {
    if (contractTime === 'full_time') {
      return contractType === 'permanent' ? 'FULL_TIME' : 'CONTRACT';
    } else if (contractTime === 'part_time') {
      return 'PART_TIME';
    }
    
    return 'FULL_TIME';
  }

  isDirectCompanyPosting(redirectUrl) {
    if (!redirectUrl) return false;
    
    const directIndicators = [
      'greenhouse.io', 'lever.co', 'workday.com', 'bamboohr.com',
      'smartrecruiters.com', 'jobvite.com', 'careers.', '/careers/'
    ];
    
    return directIndicators.some(indicator => 
      redirectUrl.toLowerCase().includes(indicator)
    );
  }

  assessApiJobQuality(apiJob) {
    let qualityScore = 0;
    
    if (apiJob.title && apiJob.title.length > 5) qualityScore += 2;
    if (apiJob.company?.display_name) qualityScore += 2;
    if (apiJob.description && apiJob.description.length > 100) qualityScore += 3;
    if (apiJob.location?.display_name) qualityScore += 1;
    if (apiJob.redirect_url || apiJob.url) qualityScore += 2;
    if (apiJob.created) qualityScore += 1;
    
    if (apiJob.salary_min || apiJob.salary_max) {
      qualityScore += apiJob.salary_is_predicted ? 1 : 2;
    }
    
    if (apiJob.description && apiJob.description.length > 500) qualityScore += 2;
    if (apiJob.description && apiJob.description.length > 1000) qualityScore += 1;
    
    if (apiJob.contract_type && apiJob.contract_time) qualityScore += 1;
    if (apiJob.category?.label) qualityScore += 1;
    
    if (qualityScore >= 12) return 'high';
    else if (qualityScore >= 8) return 'medium';
    else return 'low';
  }

  calculateInitialMatchScore(apiJob) {
    let score = 70;
    
    if (apiJob.salary_min && !apiJob.salary_is_predicted) score += 10;
    if (apiJob.description && apiJob.description.length > 500) score += 5;
    
    if (apiJob.created) {
      const daysSincePosted = (new Date() - new Date(apiJob.created)) / (1000 * 60 * 60 * 24);
      if (daysSincePosted <= 7) score += 10;
      else if (daysSincePosted <= 14) score += 5;
    }
    
    if (apiJob.contract_type === 'permanent' && apiJob.contract_time === 'full_time') {
      score += 5;
    }
    
    return Math.min(score, 100);
  }
}

module.exports = AdzunaJobExtractor;

================
File: backend/services/assistant.service.js
================
// src/utils/assistantService.js - ENHANCED WITH MEMORY & CONVERSATIONS
import api from './axios';

const assistantService = {
  // ===================================================================
  // ENHANCED CHAT WITH CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Send message to AI Assistant with enhanced context and conversation management
   */
  sendMessage: async (requestData) => {
    try {
      const {
        message,
        context = {},
        conversationId,
        newConversation = false,
        conversationHistory = []
      } = requestData;

      const response = await api.post('/assistant/chat', {
        message,
        context: {
          page: context.page || 'unknown',
          currentResume: context.currentResume || null,
          currentJob: context.currentJob || null,
          resumeCount: context.resumeCount || 0,
          jobCount: context.jobCount || 0,
          userProfile: context.userProfile || null
        },
        conversationId,
        newConversation,
        conversationHistory: conversationHistory.slice(-10) // Last 10 messages
      });

      return {
        message: response.data.message,
        suggestions: response.data.suggestions || [],
        actions: response.data.actions || [],
        confidence: response.data.confidence || 0.8,
        conversationId: response.data.conversationId,
        conversationTitle: response.data.conversationTitle,
        memoryInsights: response.data.memoryInsights || [],
        usage: response.data.usage || {}
      };

    } catch (error) {
      console.error('Enhanced AI Assistant Service Error:', error);
      
      // Enhanced fallback responses based on context
      const fallbackResponse = this.getContextualFallback(requestData.message, requestData.context);
      
      if (error.response?.status === 503) {
        throw new Error('AI service temporarily unavailable. Please try again in a moment.');
      } else if (error.response?.status === 429) {
        throw new Error('Rate limit exceeded. Please wait before sending another message.');
      } else {
        throw new Error(fallbackResponse.error || 'AI service temporarily unavailable');
      }
    }
  },

  // ===================================================================
  // CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Get user's conversations
   */
  getConversations: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.category) params.append('category', options.category);
      if (options.tags && options.tags.length > 0) params.append('tags', options.tags.join(','));
      if (options.search) params.append('search', options.search);
      if (options.pinned !== undefined) params.append('pinned', options.pinned);
      if (options.starred !== undefined) params.append('starred', options.starred);
      if (options.limit) params.append('limit', options.limit);
      if (options.offset) params.append('offset', options.offset);
      if (options.sortBy) params.append('sortBy', options.sortBy);

      const response = await api.get(`/assistant/conversations?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching conversations:', error);
      throw error;
    }
  },

  /**
   * Get specific conversation
   */
  getConversation: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}`);
      return response.data.conversation;
    } catch (error) {
      console.error('Error fetching conversation:', error);
      throw error;
    }
  },

  /**
   * Create new conversation
   */
  createConversation: async (conversationData) => {
    try {
      const response = await api.post('/assistant/conversations', conversationData);
      return response.data.conversation;
    } catch (error) {
      console.error('Error creating conversation:', error);
      throw error;
    }
  },

  /**
   * Update conversation
   */
  updateConversation: async (conversationId, updates) => {
    try {
      const response = await api.put(`/assistant/conversations/${conversationId}`, updates);
      return response.data.conversation;
    } catch (error) {
      console.error('Error updating conversation:', error);
      throw error;
    }
  },

  /**
   * Delete conversation
   */
  deleteConversation: async (conversationId, permanent = false) => {
    try {
      const params = permanent ? '?permanent=true' : '';
      const response = await api.delete(`/assistant/conversations/${conversationId}${params}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting conversation:', error);
      throw error;
    }
  },

  /**
   * Generate conversation summary
   */
  generateSummary: async (conversationId) => {
    try {
      const response = await api.post(`/assistant/conversations/${conversationId}/summary`);
      return response.data.summary;
    } catch (error) {
      console.error('Error generating summary:', error);
      throw error;
    }
  },

  /**
   * Get conversation insights
   */
  getConversationInsights: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/insights`);
      return response.data.insights;
    } catch (error) {
      console.error('Error getting insights:', error);
      throw error;
    }
  },

  /**
   * Export conversation
   */
  exportConversation: async (conversationId, format = 'json') => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/export?format=${format}`);
      return response.data.export;
    } catch (error) {
      console.error('Error exporting conversation:', error);
      throw error;
    }
  },

  /**
   * Bulk update conversations
   */
  bulkUpdateConversations: async (conversationIds, updates) => {
    try {
      const response = await api.post('/assistant/conversations/bulk-update', {
        conversationIds,
        updates
      });
      return response.data.result;
    } catch (error) {
      console.error('Error bulk updating conversations:', error);
      throw error;
    }
  },

  // ===================================================================
  // MEMORY MANAGEMENT
  // ===================================================================

  /**
   * Get user memories
   */
  getMemories: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.type) params.append('type', options.type);
      if (options.category) params.append('category', options.category);
      if (options.search) params.append('search', options.search);
      if (options.minConfidence) params.append('minConfidence', options.minConfidence);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/memories?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching memories:', error);
      throw error;
    }
  },

  /**
   * Add or update memory
   */
  updateMemory: async (memoryData) => {
    try {
      const response = await api.post('/assistant/memories', { memoryData });
      return response.data;
    } catch (error) {
      console.error('Error updating memory:', error);
      throw error;
    }
  },

  /**
   * Delete memory
   */
  deleteMemory: async (memoryId) => {
    try {
      const response = await api.delete(`/assistant/memories/${memoryId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting memory:', error);
      throw error;
    }
  },

  /**
   * Get memory insights
   */
  getMemoryInsights: async () => {
    try {
      const response = await api.get('/assistant/memory-insights');
      return response.data;
    } catch (error) {
      console.error('Error getting memory insights:', error);
      throw error;
    }
  },

  /**
   * Perform memory maintenance
   */
  performMemoryMaintenance: async () => {
    try {
      const response = await api.post('/assistant/memory-maintenance');
      return response.data.maintenance;
    } catch (error) {
      console.error('Error performing memory maintenance:', error);
      throw error;
    }
  },

  // ===================================================================
  // SEARCH & ANALYTICS
  // ===================================================================

  /**
   * Search across conversations and memories
   */
  search: async (query, options = {}) => {
    try {
      const params = new URLSearchParams();
      params.append('query', query);
      
      if (options.searchType) params.append('searchType', options.searchType);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/search?${params}`);
      return response.data.results;

    } catch (error) {
      console.error('Error searching:', error);
      return { conversations: [], memories: [] };
    }
  },

  /**
   * Get analytics
   */
  getAnalytics: async (timeframe = '30d') => {
    try {
      const response = await api.get(`/assistant/analytics?timeframe=${timeframe}`);
      return response.data.analytics;
    } catch (error) {
      console.error('Error getting analytics:', error);
      throw error;
    }
  },

  // ===================================================================
  // ENHANCED RESUME OPERATIONS
  // ===================================================================

  /**
   * Analyze resume with memory context
   */
  analyzeResume: async (resumeId, analysisType = 'comprehensive') => {
    try {
      const response = await api.post('/assistant/analyze-resume', {
        resumeId,
        analysisType,
        includeImprovements: true,
        includeKeywords: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing resume:', error);
      throw error;
    }
  },

  /**
   * Apply resume changes suggested by AI
   */
  applyResumeChanges: async (changes) => {
    try {
      const response = await api.post('/assistant/apply-resume-changes', {
        resumeId: changes.resumeId,
        changes: changes.modifications,
        changeType: changes.type || 'enhancement'
      });

      return response.data;

    } catch (error) {
      console.error('Error applying resume changes:', error);
      throw error;
    }
  },

  /**
   * Optimize resume for ATS
   */
  optimizeForATS: async (resumeId, jobId = null) => {
    try {
      const response = await api.post('/assistant/optimize-ats', {
        resumeId,
        targetJobId: jobId,
        optimizationLevel: 'aggressive',
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error optimizing for ATS:', error);
      throw error;
    }
  },

  // ===================================================================
  // JOB MATCHING & CAREER GUIDANCE
  // ===================================================================

  /**
   * Get job matching insights with memory context
   */
  analyzeJobMatch: async (resumeId, jobId) => {
    try {
      const response = await api.post('/assistant/analyze-job-match', {
        resumeId,
        jobId,
        includeImprovements: true,
        includeTailoringAdvice: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing job match:', error);
      throw error;
    }
  },

/**
   * Generate personalized cover letter
   */
  generateCoverLetter: async (resumeId, jobId, style = 'professional') => {
    try {
      const response = await api.post('/assistant/generate-cover-letter', {
        resumeId,
        jobId,
        style,
        customization: 'high',
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error generating cover letter:', error);
      throw error;
    }
  },

  /**
   * Get career advice and guidance with memory context
   */
  getCareerAdvice: async (userProfile, specificQuestion = null) => {
    try {
      const response = await api.post('/assistant/career-advice', {
        userProfile,
        question: specificQuestion,
        includeJobSuggestions: true,
        includeSkillGaps: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error getting career advice:', error);
      throw error;
    }
  },

  /**
   * Get contextual suggestions for current page
   */
  getContextualSuggestions: async (page, contextData = {}) => {
    try {
      const response = await api.post('/assistant/contextual-suggestions', {
        page,
        contextData,
        maxSuggestions: 5,
        useMemoryContext: true
      });

      return response.data.suggestions || [];

    } catch (error) {
      console.error('Error getting contextual suggestions:', error);
      return this.getFallbackSuggestions(page, contextData);
    }
  },

  /**
   * Get personalized tips based on user profile and memory
   */
  getPersonalizedTips: async (category = 'general') => {
    try {
      const response = await api.post('/assistant/personalized-tips', {
        category,
        includeActions: true,
        useMemoryContext: true
      });

      return response.data.tips || [];

    } catch (error) {
      console.error('Error getting personalized tips:', error);
      return this.getFallbackTips(category);
    }
  },

  // ===================================================================
  // SYSTEM & HEALTH
  // ===================================================================

  /**
   * Get AI Assistant capabilities and status
   */
  getCapabilities: async () => {
    try {
      const response = await api.get('/assistant/capabilities');
      return response.data;
    } catch (error) {
      console.error('Error getting AI capabilities:', error);
      return {
        available: false,
        features: ['basic_chat', 'contextual_suggestions'],
        limitations: ['Full AI features unavailable in test mode'],
        memory_features: {
          available: false
        }
      };
    }
  },

  /**
   * Check AI Assistant health
   */
  checkHealth: async () => {
    try {
      const response = await api.get('/assistant/health');
      return response.data;
    } catch (error) {
      console.error('Health check failed:', error);
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  },

  /**
   * Get user's AI usage statistics
   */
  getUsageStats: async () => {
    try {
      const response = await api.get('/assistant/usage-stats');
      return response.data;
    } catch (error) {
      console.error('Error getting usage stats:', error);
      return {
        messagesThisMonth: 0,
        resumeAnalyses: 0,
        jobMatches: 0,
        careerAdviceRequests: 0,
        conversationsCreated: 0,
        memoriesStored: 0
      };
    }
  },

  /**
   * Track user interaction
   */
  trackInteraction: async (interactionType, data) => {
    try {
      await api.post('/assistant/track-interaction', {
        type: interactionType,
        data,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      // Non-critical, just log
      console.warn('Failed to track interaction:', error);
    }
  },

  /**
   * Reset AI conversation context
   */
  resetContext: async () => {
    try {
      await api.post('/assistant/reset-context');
      return { success: true };
    } catch (error) {
      console.error('Error resetting context:', error);
      return { success: false };
    }
  },

  // ===================================================================
  // CONVERSATION UTILITIES
  // ===================================================================

  /**
   * Auto-generate conversation title based on content
   */
  generateConversationTitle: async (messages, context = {}) => {
    try {
      if (!messages || messages.length === 0) return 'New Conversation';

      // Use the first user message to generate title
      const firstUserMessage = messages.find(m => m.type === 'user');
      if (!firstUserMessage) return 'New Conversation';

      // Simple client-side title generation for immediate feedback
      const content = firstUserMessage.content.toLowerCase();
      
      if (content.includes('resume')) return 'Resume Assistance';
      if (content.includes('job') || content.includes('application')) return 'Job Search Help';
      if (content.includes('interview')) return 'Interview Preparation';
      if (content.includes('career')) return 'Career Guidance';
      if (content.includes('skill')) return 'Skill Development';
      
      // Fallback based on context
      const contextTitles = {
        'resumes': 'Resume Help',
        'jobs': 'Job Search',
        'dashboard': 'Career Planning'
      };
      
      return contextTitles[context.page] || 'Career Assistance';

    } catch (error) {
      console.error('Error generating conversation title:', error);
      return 'New Conversation';
    }
  },

  /**
   * Format conversation for display
   */
  formatConversation: (conversation) => {
    if (!conversation) return null;

    return {
      ...conversation,
      formattedDate: new Date(conversation.createdAt).toLocaleDateString(),
      formattedTime: new Date(conversation.lastActiveAt).toLocaleTimeString(),
      preview: conversation.messages && conversation.messages.length > 0
        ? conversation.messages[conversation.messages.length - 1].content.substring(0, 100) + '...'
        : conversation.description || 'No messages yet',
      messageCount: conversation.messages ? conversation.messages.length : 0,
      isRecent: Date.now() - new Date(conversation.lastActiveAt).getTime() < 24 * 60 * 60 * 1000
    };
  },

  /**
   * Format memory for display
   */
  formatMemory: (memory) => {
    if (!memory) return null;

    return {
      ...memory,
      formattedDate: new Date(memory.createdAt).toLocaleDateString(),
      confidencePercentage: Math.round(memory.confidence * 100),
      isHighConfidence: memory.confidence >= 0.8,
      isRecentlyAccessed: memory.usage?.lastAccessedAt && 
        Date.now() - new Date(memory.usage.lastAccessedAt).getTime() < 7 * 24 * 60 * 60 * 1000,
      typeLabel: this.getMemoryTypeLabel(memory.type),
      categoryLabel: this.getCategoryLabel(memory.category)
    };
  },

  /**
   * Get human-readable memory type labels
   */
  getMemoryTypeLabel: (type) => {
    const labels = {
      'preference': 'Preference',
      'skill': 'Skill',
      'career_goal': 'Career Goal',
      'experience': 'Experience',
      'achievement': 'Achievement',
      'challenge': 'Challenge',
      'personality_trait': 'Personality',
      'communication_style': 'Communication Style',
      'work_style': 'Work Style',
      'industry_knowledge': 'Industry Knowledge',
      'tool_preference': 'Tool Preference',
      'feedback_pattern': 'Feedback Pattern'
    };
    return labels[type] || type;
  },

  /**
   * Get human-readable category labels
   */
  getCategoryLabel: (category) => {
    const labels = {
      'personal': 'Personal',
      'professional': 'Professional',
      'technical': 'Technical',
      'behavioral': 'Behavioral',
      'contextual': 'Contextual'
    };
    return labels[category] || category;
  },

  // ===================================================================
  // ENHANCED FALLBACK RESPONSES
  // ===================================================================

  /**
   * Enhanced fallback responses based on context
   */
  getContextualFallback: (message, context) => {
    const lowercaseMessage = message.toLowerCase();

    // Resume-related queries
    if (lowercaseMessage.includes('resume') || lowercaseMessage.includes('cv')) {
      if (context?.page === 'resumes' && context?.currentResume) {
        return {
          message: `I can see you're working on "${context.currentResume.name}". While I can't access my full AI capabilities right now, I suggest focusing on: quantifying achievements with metrics, using action verbs, and ensuring ATS compatibility. I remember our previous discussions about your career goals and can provide personalized suggestions once I'm back online.`,
          suggestions: [
            'Help improve work experience section',
            'Suggest better action verbs',
            'Check ATS compatibility',
            'Add missing skills based on your profile'
          ]
        };
      }
      return {
        message: "I'd love to help improve your resume! I remember our previous conversations about your career goals and preferences. Common improvements include quantifying achievements, using strong action verbs, optimizing for ATS systems, and tailoring to specific jobs. Which resume would you like to work on?",
        suggestions: [
          'Analyze my best resume',
          'Create new resume',
          'Compare my resumes',
          'ATS optimization tips'
        ]
      };
    }

    // Job-related queries
    if (lowercaseMessage.includes('job') || lowercaseMessage.includes('application') || lowercaseMessage.includes('interview')) {
      if (context?.page === 'jobs' && context?.currentJob) {
        return {
          message: `Looking at "${context.currentJob.title}" at ${context.currentJob.company}. Based on what I remember about your background and preferences, I can help you understand how well your resume matches this position and suggest improvements to increase your chances.`,
          suggestions: [
            'Match my best resume to this job',
            'What skills am I missing?',
            'Help tailor my resume',
            'Write a personalized cover letter'
          ]
        };
      }
      return {
        message: "I can help you with job searching, application optimization, and interview preparation! I remember your career goals and can provide personalized advice. What specific aspect would you like assistance with?",
        suggestions: [
          'Find matching jobs for my profile',
          'Improve application materials',
          'Interview preparation tips',
          'Salary negotiation advice'
        ]
      };
    }

    // Career guidance queries
    if (lowercaseMessage.includes('career') || lowercaseMessage.includes('advice') || lowercaseMessage.includes('guidance')) {
      return {
        message: "I'm here to provide personalized career guidance! I remember our previous conversations about your goals and challenges. I can help with career planning, skill development, industry insights, and strategic job search approaches. What's your biggest career challenge right now?",
        suggestions: [
          'Plan my next career move',
          'Identify skill gaps for my goals',
          'Industry insights for my field',
          'Job search strategy review'
        ]
      };
    }

    // Memory-related queries
    if (lowercaseMessage.includes('remember') || lowercaseMessage.includes('memory') || lowercaseMessage.includes('previous')) {
      return {
        message: "I maintain a memory of our conversations to provide better assistance! I remember your preferences, goals, and career journey. While I'm currently in test mode, I can still access some of our conversation history and provide personalized advice.",
        suggestions: [
          'Show my conversation history',
          'What do you remember about me?',
          'Review my career progress',
          'Update my preferences'
        ]
      };
    }

    // Default fallback
    return {
      message: "I'm currently running in test mode while my full AI capabilities are being set up, but I can still access our conversation history and provide personalized career advice. I remember your goals and preferences from our previous discussions. What would you like to explore?",
      suggestions: [
        'Review my career progress',
        'Resume improvement tips',
        'Job search strategy',
        'Show conversation history'
      ],
      error: 'AI service temporarily in test mode'
    };
  },

  /**
   * Get fallback suggestions based on page context
   */
  getFallbackSuggestions: (page, contextData) => {
    const suggestions = {
      dashboard: [
        'Review my career progress',
        'What should I focus on today?',
        'Find new job opportunities',
        'Show my conversation history'
      ],
      resumes: [
        'Improve this resume with memory context',
        'Check ATS compatibility',
        'Compare with other resumes',
        'Add missing keywords for my goals'
      ],
      jobs: [
        'Match resume to this job',
        'Find similar positions for my profile',
        'Improve match score',
        'Create tailored resume version'
      ],
      'ai-searches': [
        'Optimize search criteria for my goals',
        'Review found opportunities',
        'Adjust search parameters',
        'Set up new automated searches'
      ]
    };

    return suggestions[page] || [
      'Help with resume using my profile',
      'Find job opportunities that match me',
      'Career guidance based on my goals',
      'Review my conversation history'
    ];
  },

  /**
   * Get fallback tips based on category
   */
  getFallbackTips: (category) => {
    const fallbackTips = {
      resume: [
        'Use action verbs to start each bullet point',
        'Quantify achievements with specific numbers',
        'Tailor keywords to match job descriptions',
        'Keep formatting clean and ATS-friendly',
        'Highlight achievements relevant to your career goals'
      ],
      job_search: [
        'Apply to jobs within 24-48 hours of posting',
        'Customize your resume for each application',
        'Research company culture before applying',
        'Follow up professionally after 1-2 weeks',
        'Leverage your network for referrals'
      ],
      career: [
        'Set SMART career goals every quarter',
        'Build your professional network consistently',
        'Stay updated with industry trends',
        'Invest in learning new skills regularly',
        'Seek feedback and mentorship opportunities'
      ],
      interview: [
        'Practice common interview questions',
        'Research the company and role thoroughly',
        'Prepare specific examples using STAR method',
        'Ask thoughtful questions about the role',
        'Follow up with a thank-you message'
      ],
      general: [
        'Keep your LinkedIn profile updated',
        'Track your job applications systematically',
        'Practice interviewing regularly',
        'Maintain a professional online presence',
        'Document your achievements for future reference'
      ]
    };

    return fallbackTips[category] || fallbackTips.general;
  },

  // ===================================================================
  // VALIDATION & UTILITIES
  // ===================================================================

  /**
   * Validate message content before sending
   */
  validateMessage: (message) => {
    if (!message || typeof message !== 'string') {
      return { valid: false, error: 'Message must be a non-empty string' };
    }

    if (message.trim().length === 0) {
      return { valid: false, error: 'Message cannot be empty' };
    }

    if (message.length > 3000) {
      return { valid: false, error: 'Message too long (max 3000 characters)' };
    }

    // Check for potential harmful content
    const harmfulPatterns = [
      /password/i,
      /credit card/i,
      /social security/i,
      /ssn/i
    ];

    for (const pattern of harmfulPatterns) {
      if (pattern.test(message)) {
        return { 
          valid: false, 
          error: 'Please avoid sharing sensitive personal information' 
        };
      }
    }

    return { valid: true };
  },

  /**
   * Format AI response for display
   */
  formatResponse: (response) => {
    if (!response || typeof response !== 'string') {
      return 'I encountered an issue processing that request. Please try again.';
    }

    // Clean up common AI response artifacts
    let formatted = response
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove markdown bold
      .replace(/\*(.*?)\*/g, '$1')     // Remove markdown italic
      .replace(/\n\n+/g, '\n\n')      // Normalize line breaks
      .trim();

    // Ensure proper sentence structure
    if (formatted && !formatted.endsWith('.') && !formatted.endsWith('!') && !formatted.endsWith('?')) {
      formatted += '.';
    }

    return formatted;
  },

  /**
   * Check if AI service is available
   */
  isAvailable: async () => {
    try {
      const response = await api.get('/assistant/health');
      return response.data.status === 'healthy';
    } catch (error) {
      console.warn('AI Assistant service unavailable:', error.message);
      return false;
    }
  },

  /**
   * Get conversation statistics
   */
  getConversationStats: async () => {
    try {
      const analytics = await this.getAnalytics('30d');
      return {
        totalConversations: analytics.totalConversations || 0,
        totalMessages: analytics.totalMessages || 0,
        avgEngagement: analytics.avgEngagement || 0,
        mostActiveCategory: analytics.categoryDistribution ? 
          Object.keys(analytics.categoryDistribution)[0] : 'general'
      };
    } catch (error) {
      console.error('Error getting conversation stats:', error);
      return {
        totalConversations: 0,
        totalMessages: 0,
        avgEngagement: 0,
        mostActiveCategory: 'general'
      };
    }
  },

  /**
   * Estimate tokens for message
   */
  estimateTokens: (text) => {
    // Rough estimation: ~4 characters per token
    return Math.ceil(text.length / 4);
  },

  /**
   * Calculate estimated cost
   */
  estimateCost: (tokens) => {
    // GPT-4 Turbo pricing estimate
    const inputCost = 0.01 / 1000;
    const outputCost = 0.03 / 1000;
    return ((tokens * 0.5 * inputCost) + (tokens * 0.5 * outputCost)).toFixed(4);
  }
};

export default assistantService;

================
File: backend/services/conversationService.js
================
// backend/services/conversationService.js - ENHANCED PERSISTENCE SUPPORT
const Conversation = require('../models/mongodb/conversation.model');
const MemoryService = require('./memoryService');
const { openai } = require('../config/openai');
const mongoose = require('mongoose');

class ConversationService {
    /**
     * Create a new conversation with enhanced persistence
     */
    static async createConversation(userId, conversationData) {
        try {
            const conversation = new Conversation({
                userId,
                title: conversationData.title || 'New Conversation',
                description: conversationData.description || '',
                category: conversationData.category || 'general',
                tags: conversationData.tags || [],
                messages: [], // Start with empty messages array
                messageCount: 0,
                isActive: true,
                isPinned: conversationData.isPinned || false,
                isStarred: conversationData.isStarred || false,
                context: conversationData.context || {},
                settings: {
                    memoryEnabled: true,
                    autoSummarize: true,
                    ...conversationData.settings
                },
                analytics: {
                    messageCount: 0,
                    tokensUsed: 0,
                    engagementScore: 0
                }
            });

            await conversation.save();

            // Add initial system message if provided
            if (conversationData.initialMessage) {
                await this.addMessage(conversation._id, {
                    type: 'system',
                    content: conversationData.initialMessage,
                    metadata: {
                        context: conversationData.context
                    }
                });
            }

            console.log(`✅ Created conversation: ${conversation.title} (${conversation._id})`);
            return conversation;

        } catch (error) {
            console.error('Create conversation error:', error);
            throw error;
        }
    }

    /**
     * Get user's conversations with enhanced filtering and persistence support
     */
    static async getUserConversations(userId, options = {}) {
        try {
            const {
                category,
                tags,
                search,
                pinned,
                starred,
                limit = 50,
                offset = 0,
                sortBy = 'lastActiveAt',
                sortOrder = 'desc'
            } = options;

            // Build query with isActive instead of status
            let query = { userId, isActive: true };

            // Apply filters
            if (category) query.category = category;
            if (tags && tags.length > 0) query.tags = { $in: tags };
            if (pinned !== undefined) query.isPinned = pinned;
            if (starred !== undefined) query.isStarred = starred;

            // Handle search
            if (search) {
                query.$or = [
                    { title: { $regex: search, $options: 'i' } },
                    { description: { $regex: search, $options: 'i' } },
                    { tags: { $regex: search, $options: 'i' } }
                ];
            }

            const sortOptions = {};
            sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;

            console.log('🔍 Querying conversations with:', query);

            // ENHANCED: Better field selection and population
            const conversations = await Conversation.find(query)
                .sort(sortOptions)
                .limit(limit)
                .skip(offset)
                .select({
                    _id: 1,
                    title: 1,
                    description: 1,
                    category: 1,
                    tags: 1,
                    messages: 1,
                    messageCount: 1,
                    createdAt: 1,
                    updatedAt: 1,
                    lastActiveAt: 1,
                    isActive: 1,
                    isPinned: 1,
                    isStarred: 1,
                    context: 1,
                    settings: 1,
                    analytics: 1,
                    summary: 1
                })
                .lean();

            console.log(`📚 Found ${conversations.length} conversations for user ${userId}`);

            // ENHANCED: Enrich conversations with computed fields and ensure consistency
            const enrichedConversations = conversations.map(conv => {
                // Ensure messages array exists and calculate actual count
                const messages = conv.messages || [];
                const actualMessageCount = messages.length;
                
                // Get last message for preview
                const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;
                
                // Generate preview text
                const preview = this.generatePreview(conv, lastMessage);
                
                return {
                    ...conv,
                    // Ensure consistent message count
                    messageCount: actualMessageCount,
                    lastMessage: lastMessage,
                    preview: preview,
                    // Ensure boolean fields are properly set with fallbacks
                    isStarred: conv.isStarred || false,
                    isPinned: conv.isPinned || false,
                    isActive: conv.isActive !== false, // Default to true
                    // Add formatted date for easier display
                    formattedDate: conv.lastActiveAt ? 
                        new Date(conv.lastActiveAt).toLocaleDateString() : 
                        new Date(conv.createdAt).toLocaleDateString(),
                    // Add relative time indicator
                    isRecent: conv.lastActiveAt ? 
                        (Date.now() - new Date(conv.lastActiveAt).getTime() < 24 * 60 * 60 * 1000) : false,
                    // Ensure analytics exist
                    analytics: conv.analytics || {
                        messageCount: actualMessageCount,
                        tokensUsed: 0,
                        engagementScore: 0
                    }
                };
            });

            const total = await Conversation.countDocuments(query);

            return {
                conversations: enrichedConversations,
                total: total,
                hasMore: (offset + limit) < total,
                metadata: {
                    query: query,
                    sortBy: sortBy,
                    sortOrder: sortOrder,
                    limit: limit,
                    offset: offset,
                    timestamp: new Date()
                }
            };

        } catch (error) {
            console.error('Get user conversations error:', error);
            
            // ENHANCED: Try migration if query fails with status-related error
            if (error.message && error.message.includes('status')) {
                console.log('🔄 Attempting conversation migration...');
                try {
                    await this.migrateConversationsToIsActive(userId);
                    // Retry the query
                    return await this.getUserConversations(userId, options);
                } catch (migrationError) {
                    console.error('Migration failed:', migrationError);
                }
            }
            
            throw error;
        }
    }

    /**
     * Get a specific conversation with enhanced persistence support
     */
    static async getConversation(conversationId, userId) {
        try {
            console.log(`🔍 Loading conversation ${conversationId} for user ${userId}`);
            
            const conversation = await Conversation.findOne({
                _id: conversationId,
                userId,
                isActive: true
            })
            .populate('context.primaryResumeId', 'name analysis.overallScore parsedData.skills')
            .populate('context.relatedJobIds', 'title company parsedData.keySkills')
            .lean();

            if (!conversation) {
                // Try with legacy status field as fallback
                const legacyConversation = await Conversation.findOne({
                    _id: conversationId,
                    userId,
                    status: { $ne: 'deleted' }
                })
                .populate('context.primaryResumeId', 'name analysis.overallScore parsedData.skills')
                .populate('context.relatedJobIds', 'title company parsedData.keySkills')
                .lean();

                if (legacyConversation) {
                    console.log('📋 Found conversation using legacy status field, migrating...');
                    await this.migrateConversationsToIsActive(userId);
                    // Continue with the found conversation
                    return this.enhanceConversationData(legacyConversation, conversationId);
                }
                
                throw new Error('Conversation not found');
            }

            const enhancedConversation = this.enhanceConversationData(conversation, conversationId);

            // Update last active time (separate query to avoid lean() conflicts)
            try {
                await Conversation.findByIdAndUpdate(conversationId, {
                    lastActiveAt: new Date()
                });
            } catch (updateError) {
                console.warn('Failed to update lastActiveAt:', updateError);
            }

            console.log(`✅ Loaded conversation: ${enhancedConversation.title} with ${enhancedConversation.messageCount} messages`);
            
            return enhancedConversation;

        } catch (error) {
            console.error('Get conversation error:', error);
            throw error;
        }
    }

    /**
     * Enhance conversation data with consistent structure
     */
    static enhanceConversationData(conversation, conversationId) {
        const messages = conversation.messages || [];
        
        return {
            ...conversation,
            messages: messages,
            messageCount: messages.length,
            isStarred: conversation.isStarred || conversation.starred || false,
            isPinned: conversation.isPinned || conversation.pinned || false,
            isActive: conversation.isActive !== false,
            settings: conversation.settings || {
                memoryEnabled: true,
                autoSummarize: true
            },
            analytics: conversation.analytics || {
                messageCount: messages.length,
                tokensUsed: 0,
                engagementScore: 0
            },
            context: conversation.context || {},
            // Ensure lastActiveAt exists
            lastActiveAt: conversation.lastActiveAt || conversation.updatedAt || conversation.createdAt
        };
    }

    /**
     * Add a message to a conversation with enhanced persistence
     */
    static async addMessage(conversationId, messageData) {
        try {
            const conversation = await Conversation.findById(conversationId);
            if (!conversation) {
                throw new Error('Conversation not found');
            }

            // Create message with proper ID generation and validation
            const message = {
                id: messageData.id || new mongoose.Types.ObjectId().toString(),
                type: messageData.type,
                content: messageData.content,
                timestamp: messageData.timestamp || new Date(),
                createdAt: messageData.createdAt || new Date(),
                metadata: messageData.metadata || {}
            };

            // Validate message content
            if (!message.content || typeof message.content !== 'string') {
                throw new Error('Message content is required and must be a string');
            }

            if (!['user', 'ai', 'system'].includes(message.type)) {
                throw new Error('Invalid message type');
            }

            // Add message using the model method
            conversation.addMessage(message);

            // Update conversation metadata
            conversation.analytics.messageCount = conversation.messages.length;
            conversation.lastActiveAt = new Date();
            conversation.markModified('analytics');

            // Save conversation
            await conversation.save();

            console.log(`✅ Added ${message.type} message to conversation ${conversationId}`);

            // ENHANCED: Extract memories from user messages
            if (messageData.type === 'user' && conversation.settings?.memoryEnabled) {
                try {
                    await MemoryService.extractMemoriesFromMessage(
                        conversation.userId,
                        messageData.content,
                        {
                            conversationId: conversationId,
                            messageId: message.id,
                            page: messageData.metadata?.context?.page,
                            category: conversation.category,
                            tags: conversation.tags
                        }
                    );
                } catch (memoryError) {
                    console.warn('Memory extraction failed for message:', memoryError);
                }
            }

            // ENHANCED: Auto-summarize if needed
            if (conversation.settings?.autoSummarize && 
                conversation.messages.length % 20 === 0 &&
                conversation.messages.length >= 20) {
                try {
                    await this.generateConversationSummary(conversationId);
                    console.log(`📋 Auto-summarized conversation ${conversationId}`);
                } catch (summaryError) {
                    console.warn('Auto-summarization failed:', summaryError);
                }
            }

            return message;

        } catch (error) {
            console.error('Add message error:', error);
            throw error;
        }
    }

    /**
     * Update conversation metadata with persistence support
     */
    static async updateConversation(conversationId, userId, updates) {
        try {
            const allowedUpdates = [
                'title', 'description', 'category', 'tags', 'isPinned', 'isStarred', 'settings'
            ];
            
            const filteredUpdates = {};
            Object.keys(updates).forEach(key => {
                if (allowedUpdates.includes(key)) {
                    filteredUpdates[key] = updates[key];
                }
            });

            // Add timestamp
            filteredUpdates.updatedAt = new Date();

            // ENHANCED: Also update legacy fields for backward compatibility
            if (filteredUpdates.isPinned !== undefined) {
                filteredUpdates.pinned = filteredUpdates.isPinned;
            }
            if (filteredUpdates.isStarred !== undefined) {
                filteredUpdates.starred = filteredUpdates.isStarred;
            }

            const conversation = await Conversation.findOneAndUpdate(
                { _id: conversationId, userId, isActive: true },
                { $set: filteredUpdates },
                { new: true, runValidators: true }
            );

            if (!conversation) {
                throw new Error('Conversation not found');
            }

            console.log(`✅ Updated conversation ${conversationId}:`, Object.keys(filteredUpdates));
            return conversation;

        } catch (error) {
            console.error('Update conversation error:', error);
            throw error;
        }
    }

    /**
     * Delete or archive a conversation with enhanced cleanup
     */
    static async deleteConversation(conversationId, userId, permanent = false) {
        try {
            if (permanent) {
                // Permanently delete
                const result = await Conversation.findOneAndDelete({
                    _id: conversationId,
                    userId
                });
                
                if (!result) {
                    throw new Error('Conversation not found');
                }
                
                console.log(`🗑️ Permanently deleted conversation ${conversationId}`);
                return { deleted: true, permanent: true };
            } else {
                // Soft delete (mark as inactive)
                const update = { 
                    isActive: false,
                    status: 'archived', // Update legacy field too
                    updatedAt: new Date()
                };
                
                const conversation = await Conversation.findOneAndUpdate(
                    { _id: conversationId, userId, isActive: true },
                    { $set: update },
                    { new: true }
                );

                if (!conversation) {
                    throw new Error('Conversation not found');
                }

                console.log(`📦 Archived conversation ${conversationId}`);
                return conversation;
            }

        } catch (error) {
            console.error('Delete conversation error:', error);
            throw error;
        }
    }

    /**
     * Generate conversation summary
     */
    static async generateConversationSummary(conversationId) {
        try {
            const conversation = await Conversation.findById(conversationId);
            if (!conversation || !conversation.messages || conversation.messages.length < 5) {
                return null;
            }

            const recentMessages = conversation.messages.slice(-20);
            const messageText = recentMessages
                .map(m => `${m.type.toUpperCase()}: ${m.content}`)
                .join('\n');

            const systemPrompt = `Summarize this conversation concisely. Focus on:
1. Main topics discussed
2. Key insights or decisions
3. Action items or next steps
4. User's goals or challenges

Keep the summary under 200 words and extract 3-5 key topics.`;

            const response = await openai.chat.completions.create({
                model: 'gpt-3.5-turbo',
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: messageText }
                ],
                temperature: 0.3,
                max_tokens: 300
            });

            const summaryContent = response.choices[0].message.content.trim();
            
            // Extract key topics (simple implementation)
            const keyTopics = this.extractKeyTopicsFromSummary(summaryContent);
            
            // Update conversation with summary
            conversation.updateSummary({
                content: summaryContent,
                keyTopics: keyTopics,
                generatedAt: new Date()
            });

            await conversation.save();
            
            console.log(`📋 Generated summary for conversation ${conversationId}`);
            return {
                content: summaryContent,
                keyTopics: keyTopics
            };

        } catch (error) {
            console.error('Generate conversation summary error:', error);
            throw error;
        }
    }

    /**
     * Migration helper to convert status to isActive
     */
    static async migrateConversationsToIsActive(userId = null) {
        try {
            console.log('🔄 Starting conversation migration to isActive field...');
            
            const query = userId ? { userId } : {};
            
            // Update active conversations
            const activeResult = await Conversation.updateMany(
                { ...query, status: 'active', isActive: { $exists: false } },
                { $set: { isActive: true } }
            );

            // Update archived/deleted conversations
            const inactiveResult = await Conversation.updateMany(
                { ...query, status: { $in: ['archived', 'deleted'] }, isActive: { $exists: false } },
                { $set: { isActive: false } }
            );

            // Update pinned/starred fields
            const pinnedResult = await Conversation.updateMany(
                { ...query, pinned: true, isPinned: { $exists: false } },
                { $set: { isPinned: true } }
            );

            const starredResult = await Conversation.updateMany(
                { ...query, starred: true, isStarred: { $exists: false } },
                { $set: { isStarred: true } }
            );

            console.log(`✅ Migration completed:`, {
                activeUpdated: activeResult.modifiedCount,
                inactiveUpdated: inactiveResult.modifiedCount,
                pinnedUpdated: pinnedResult.modifiedCount,
                starredUpdated: starredResult.modifiedCount
            });

            return {
                success: true,
                activeUpdated: activeResult.modifiedCount,
                inactiveUpdated: inactiveResult.modifiedCount,
                pinnedUpdated: pinnedResult.modifiedCount,
                starredUpdated: starredResult.modifiedCount
            };

        } catch (error) {
            console.error('❌ Conversation migration failed:', error);
            throw error;
        }
    }

    /**
     * Search conversations with enhanced persistence support
     */
    static async searchAllConversations(userId, query, options = {}) {
        try {
            const { limit = 10, category, includeMessages = false } = options;
            
            // Build search query with isActive
            const searchQuery = {
                userId,
                isActive: true,
                $or: [
                    { title: { $regex: query, $options: 'i' } },
                    { description: { $regex: query, $options: 'i' } },
                    { tags: { $regex: query, $options: 'i' } }
                ]
            };

            if (category) {
                searchQuery.category = category;
            }

            // If includeMessages is true, also search in message content
            if (includeMessages) {
                searchQuery.$or.push({
                    'messages.content': { $regex: query, $options: 'i' }
                });
            }

            const conversations = await Conversation.find(searchQuery)
                .sort({ lastActiveAt: -1 })
                .limit(limit)
                .select('title description category tags lastActiveAt messageCount createdAt isStarred isPinned')
                .lean();

            // Add search highlights and previews
            const enrichedResults = conversations.map(conv => ({
                ...conv,
                preview: this.generateSearchPreview(conv, query),
                highlights: this.findQueryHighlights(conv, query),
                matchType: this.determineMatchType(conv, query),
                // Ensure boolean fields
                isStarred: conv.isStarred || false,
                isPinned: conv.isPinned || false
            }));

            console.log(`🔍 Search for "${query}" found ${enrichedResults.length} conversations`);

            return enrichedResults;

        } catch (error) {
            console.error('Search conversations error:', error);
            return [];
        }
    }

    /**
     * Get conversation analytics with enhanced persistence
     */
    static async getConversationAnalytics(userId, timeframe = '30d') {
        try {
            const dateThreshold = new Date();
            if (timeframe === '7d') {
                dateThreshold.setDate(dateThreshold.getDate() - 7);
            } else if (timeframe === '30d') {
                dateThreshold.setDate(dateThreshold.getDate() - 30);
            } else if (timeframe === '90d') {
                dateThreshold.setDate(dateThreshold.getDate() - 90);
            }

            const analytics = await Conversation.aggregate([
                {
                    $match: {
                        userId: new mongoose.Types.ObjectId(userId),
                        isActive: true,
                        createdAt: { $gte: dateThreshold }
                    }
                },
                {
                    $group: {
                        _id: null,
                        totalConversations: { $sum: 1 },
                        totalMessages: { $sum: { $size: { $ifNull: ['$messages', []] } } },
                        totalTokens: { $sum: { $ifNull: ['$analytics.tokensUsed', 0] } },
                        avgEngagement: { $avg: { $ifNull: ['$analytics.engagementScore', 0] } },
                        pinnedCount: {
                            $sum: { $cond: [{ $eq: [{ $ifNull: ['$isPinned', false] }, true] }, 1, 0] }
                        },
                        starredCount: {
                            $sum: { $cond: [{ $eq: [{ $ifNull: ['$isStarred', false] }, true] }, 1, 0] }
                        },
                        categoryCounts: { $push: '$category' }
                    }
                },
                {
                    $project: {
                        totalConversations: 1,
                        totalMessages: 1,
                        totalTokens: 1,
                        avgEngagement: { $round: ['$avgEngagement', 1] },
                        pinnedCount: 1,
                        starredCount: 1,
                        categoryCounts: 1
                    }
                }
            ]);

            const result = analytics[0] || {
                totalConversations: 0,
                totalMessages: 0,
                totalTokens: 0,
                avgEngagement: 0,
                pinnedCount: 0,
                starredCount: 0,
                categoryCounts: []
            };

            // Calculate category distribution
            const categoryDistribution = result.categoryCounts.reduce((acc, category) => {
                acc[category] = (acc[category] || 0) + 1;
                return acc;
            }, {});

            // Get most active conversations
            const mostActiveConversations = await Conversation.find({
                userId: new mongoose.Types.ObjectId(userId),
                isActive: true,
                createdAt: { $gte: dateThreshold }
            })
            .sort({ messageCount: -1 })
            .limit(5)
            .select('title messageCount lastActiveAt')
            .lean();

            console.log(`📊 Analytics for user ${userId} (${timeframe}): ${result.totalConversations} conversations, ${result.totalMessages} messages`);

            return {
                ...result,
                categoryDistribution,
                mostActiveConversations,
                timeframe,
                avgMessagesPerConversation: result.totalConversations > 0 ? 
                    Math.round(result.totalMessages / result.totalConversations) : 0,
                generatedAt: new Date()
            };

        } catch (error) {
            console.error('Get conversation analytics error:', error);
            return {
                totalConversations: 0,
                totalMessages: 0,
                totalTokens: 0,
                avgEngagement: 0,
                pinnedCount: 0,
                starredCount: 0,
                categoryDistribution: {},
                mostActiveConversations: [],
                timeframe,
                avgMessagesPerConversation: 0,
                generatedAt: new Date(),
                error: 'Failed to load analytics'
            };
        }
    }

    // ===================================================================
    // HELPER METHODS
    // ===================================================================

    /**
     * Generate preview for conversation
     */
    static generatePreview(conversation, lastMessage = null) {
        // Try summary first
        if (conversation.summary && conversation.summary.content) {
            return conversation.summary.content.substring(0, 100) + '...';
        }

        // Try description
        if (conversation.description && conversation.description.trim()) {
            return conversation.description.substring(0, 100) + '...';
        }

        // Try last message
        const message = lastMessage || (conversation.messages && conversation.messages.length > 0 ? 
            conversation.messages[conversation.messages.length - 1] : null);
        
        if (message && message.content) {
            return message.content.substring(0, 100) + '...';
        }

        // Fallback
        return 'No content available';
    }

    /**
     * Extract key topics from summary
     */
    static extractKeyTopicsFromSummary(summaryContent) {
        // Simple keyword extraction
        const commonWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by']);
        const words = summaryContent.toLowerCase()
            .replace(/[^\w\s]/g, ' ')
            .split(/\s+/)
            .filter(word => word.length > 3 && !commonWords.has(word));

        // Count word frequency
        const wordCount = {};
        words.forEach(word => {
            wordCount[word] = (wordCount[word] || 0) + 1;
        });

        // Return top 5 most frequent words as topics
        return Object.entries(wordCount)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([word]) => word);
    }

    /**
     * Find query highlights in conversation content
     */
    static findQueryHighlights(conversation, query) {
        const highlights = [];
        const queryLower = query.toLowerCase();

        // Check title
        if (conversation.title && conversation.title.toLowerCase().includes(queryLower)) {
            highlights.push({
                type: 'title',
                text: conversation.title,
                position: conversation.title.toLowerCase().indexOf(queryLower)
            });
        }

        // Check description
        if (conversation.description) {
            const descLower = conversation.description.toLowerCase();
            if (descLower.includes(queryLower)) {
                const position = descLower.indexOf(queryLower);
                const start = Math.max(0, position - 30);
                const end = Math.min(conversation.description.length, position + 70);
                
                highlights.push({
                    type: 'description',
                    text: conversation.description.substring(start, end),
                    position: position
                });
            }
        }

        // Check tags
        if (conversation.tags) {
            conversation.tags.forEach(tag => {
                if (tag.toLowerCase().includes(queryLower)) {
                    highlights.push({
                        type: 'tag',
                        text: tag,
                        position: 0
                    });
                }
            });
        }

        return highlights.slice(0, 3);
    }

    /**
     * Generate search preview
     */
    static generateSearchPreview(conversation, query) {
        const queryLower = query.toLowerCase();
        
        // Try title first
        if (conversation.title && conversation.title.toLowerCase().includes(queryLower)) {
            return conversation.title;
        }
        
        // Try description
        if (conversation.description) {
            const content = conversation.description;
            const contentLower = content.toLowerCase();
            
            if (contentLower.includes(queryLower)) {
                const position = contentLower.indexOf(queryLower);
                const start = Math.max(0, position - 50);
                const end = Math.min(content.length, position + 100);
                
                return content.substring(start, end) + (end < content.length ? '...' : '');
            }
        }

        return conversation.description || 'No preview available';
    }

    /**
     * Determine match type
     */
    static determineMatchType(conversation, query) {
        const queryLower = query.toLowerCase();
        
        if (conversation.title.toLowerCase().includes(queryLower)) {
            return 'title';
        }
        
        if (conversation.description && conversation.description.toLowerCase().includes(queryLower)) {
            return 'description';
        }
        
        if (conversation.tags && conversation.tags.some(tag => tag.toLowerCase().includes(queryLower))) {
            return 'tags';
        }
        
        return 'content';
    }
}

module.exports = ConversationService;

================
File: backend/services/jobAnalysis.service.js
================
// services/jobAnalysis.service.js - FIXED FOR EXPERIENCE LEVEL VALIDATION AND RELEVANCE
const { openai } = require('../config/openai');

/**
 * Enhanced job analysis with FIXED experience level validation and better relevance filtering
 * - GPT-4o for manual jobs (quality-critical, low volume)
 * - GPT-4o for AI discovery (now same quality as manual!)
 * - Batch processing for efficiency
 * 
 * @param {string} jobDescription - Raw job description text
 * @param {Object} jobMetadata - Additional job metadata (title, company, etc.)
 * @param {Object} options - Analysis options
 * @param {boolean} options.isAiDiscovery - Whether this is from AI discovery (now uses GPT-4o!)
 * @param {boolean} options.prioritizeCost - Force use of Mini model (deprecated)
 * @returns {Object} Parsed job data with detailed analysis
 */
exports.analyzeJob = async (jobDescription, jobMetadata = {}, options = {}) => {
  try {
    // NEW: Use GPT-4o for both manual and AI discovery for consistent quality
    const model = "gpt-4o";
    const maxTokens = 3500;
    
    console.log(`Starting premium job analysis with ${model} (same quality for all jobs)...`);
    
    if (!jobDescription || jobDescription.trim().length < 50) {
      throw new Error('Job description is too short for meaningful analysis');
    }

    const prompt = createPromptForModel(jobDescription, jobMetadata, false); // Always use premium prompt

    // Call OpenAI API with GPT-4o
    const response = await openai.chat.completions.create({
      model: model,
      messages: [
        {
          role: "system",
          content: createSystemPromptForModel(false) // Always use premium system prompt
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Low for consistent extraction
      max_tokens: maxTokens,
    });

    const content = response.choices[0].message.content.trim();
    console.log(`Job analysis response received from ${model}, parsing...`);

    let parsedData;
    try {
      // Clean up the response to extract JSON
      let jsonStr = content;
      
      // Remove any markdown code blocks
      if (content.includes('```')) {
        const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          jsonStr = jsonMatch[1];
        }
      }
      
      // Clean up and ensure valid JSON structure
      jsonStr = jsonStr.trim();
      if (!jsonStr.startsWith('{')) {
        const startIndex = jsonStr.indexOf('{');
        if (startIndex !== -1) {
          jsonStr = jsonStr.substring(startIndex);
        }
      }
      if (!jsonStr.endsWith('}')) {
        const endIndex = jsonStr.lastIndexOf('}');
        if (endIndex !== -1) {
          jsonStr = jsonStr.substring(0, endIndex + 1);
        }
      }

      parsedData = JSON.parse(jsonStr);
      
      // FIXED: Validate and enhance the parsed data with proper experience level normalization
      parsedData = validateAndEnhanceJobData(parsedData, jobDescription, false); // Always use premium validation
      
      console.log(`Job analysis completed successfully with ${model}. Found ${parsedData.keySkills?.length || 0} skills.`);
      
    } catch (parseError) {
      console.error(`Error parsing job analysis response from ${model}:`, parseError);
      console.log('Raw response:', content);
      throw new Error(`Failed to parse job analysis response from ${model}`);
    }

    // Add analysis metadata
    parsedData.analysisMetadata = {
      analyzedAt: new Date(),
      algorithmVersion: options.isAiDiscovery ? '3.0-ai-discovery-premium' : '3.0-manual-premium',
      model: model,
      originalLength: jobDescription.length,
      extractedSkillsCount: parsedData.keySkills?.length || 0,
      costOptimized: false, // Now using premium for all
      analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium',
      estimatedCost: '$0.01-0.02',
      qualityLevel: 'premium'
    };

    return parsedData;

  } catch (error) {
    console.error('Error in premium job analysis:', error);
    
    // Intelligent fallback analysis
    return generateJobAnalysisFallback(jobDescription, jobMetadata, error, options);
  }
};

/**
 * FIXED: Batch job analysis for AI discovery efficiency
 * Analyzes multiple jobs in a single API call for cost efficiency
 * 
 * @param {Array} jobBatch - Array of job objects with title, company, fullContent
 * @returns {Array} Array of analysis results matching input order
 */
exports.analyzeBatchJobs = async (jobBatch) => {
  try {
    console.log(`🔬 Starting batch analysis of ${jobBatch.length} jobs with GPT-4o...`);
    
    if (!jobBatch || jobBatch.length === 0) {
      return [];
    }
    
    // Limit batch size to prevent token overflow
    const maxBatchSize = 3;
    if (jobBatch.length > maxBatchSize) {
      console.log(`Batch size ${jobBatch.length} exceeds maximum ${maxBatchSize}, processing in chunks...`);
      
      const results = [];
      for (let i = 0; i < jobBatch.length; i += maxBatchSize) {
        const chunk = jobBatch.slice(i, i + maxBatchSize);
        const chunkResults = await this.analyzeBatchJobs(chunk);
        results.push(...chunkResults);
      }
      return results;
    }
    
    // Prepare batch content for analysis
    const batchContent = jobBatch.map((job, index) => 
      `JOB ${index + 1}:
Title: ${job.title}
Company: ${job.company}
Location: ${job.location || 'Not specified'}
Content: ${(job.fullContent || job.description || '').substring(0, 2500)}
---`
    ).join('\n\n');
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert job analyst providing premium batch analysis. Analyze multiple job postings and return detailed structured data for each. Focus on extracting comprehensive requirements, responsibilities, and skills with high accuracy. Return valid JSON array with exactly ${jobBatch.length} objects.

CRITICAL: For experienceLevel field, use ONLY these exact single values:
- "entry" (0-2 years)
- "junior" (1-3 years) 
- "mid" (3-6 years)
- "senior" (5-10 years)
- "lead" (7-12 years)
- "principal" (10+ years)
- "executive" (12+ years)

NEVER use compound values like "mid/senior" or "senior/lead". Pick the SINGLE most appropriate level.`
        },
        {
          role: "user",
          content: `Analyze these ${jobBatch.length} job postings and return detailed analysis for each:

${batchContent}

Return JSON array with exactly ${jobBatch.length} objects in this EXACT format:
[
  {
    "requirements": ["Specific requirement 1", "Specific requirement 2"],
    "responsibilities": ["Key responsibility 1", "Key responsibility 2"],
    "qualifications": {
      "required": ["Must-have qualification 1", "Must-have qualification 2"],
      "preferred": ["Nice-to-have qualification 1", "Nice-to-have qualification 2"]
    },
    "keySkills": [
      {
        "name": "Python",
        "importance": 9,
        "category": "technical",
        "skillType": "programming"
      },
      {
        "name": "Leadership",
        "importance": 7,
        "category": "soft",
        "skillType": "management"
      }
    ],
    "experienceLevel": "mid",
    "yearsOfExperience": {
      "minimum": 3,
      "preferred": 5
    },
    "educationRequirements": ["Bachelor's degree in relevant field"],
    "benefits": ["Health insurance", "401k", "Remote work"],
    "salary": {
      "min": 120000,
      "max": 150000,
      "currency": "USD"
    },
    "workArrangement": "remote",
    "industryContext": "technology",
    "roleCategory": "software-engineering",
    "technicalComplexity": "high",
    "leadershipRequired": true,
    "companyStage": "startup"
  }
]

CRITICAL REQUIREMENTS:
- Skills importance: 9-10=critical, 7-8=very important, 5-6=important, 3-4=nice to have
- experienceLevel: Use ONLY single values: "entry", "junior", "mid", "senior", "lead", "principal", "executive"
- workArrangement: Use ONLY "remote", "hybrid", "onsite", or "unknown"
- Extract comprehensive information from each job posting
- Maintain high accuracy and detail level
- Return exactly ${jobBatch.length} analysis objects in the same order`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    let jsonStr = content;
    
    // Clean JSON extraction
    if (content.includes('```')) {
      const jsonMatch = content.match(/```(?:json)?\s*(\[[\s\S]*?\])\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    const analyses = JSON.parse(jsonStr);
    
    // Ensure we have the right number of analyses
    if (!Array.isArray(analyses)) {
      throw new Error('Response is not an array');
    }
    
    if (analyses.length !== jobBatch.length) {
      console.warn(`Expected ${jobBatch.length} analyses, got ${analyses.length}. Padding or trimming...`);
      
      // Pad with fallback analyses if too few
      while (analyses.length < jobBatch.length) {
        analyses.push(createFallbackSingleAnalysis());
      }
      
      // Trim if too many
      if (analyses.length > jobBatch.length) {
        analyses.splice(jobBatch.length);
      }
    }
    
    // FIXED: Enhance analyses with metadata and proper validation
    const enhancedAnalyses = analyses.map((analysis, index) => {
      // Normalize experience level to ensure it's valid
      analysis.experienceLevel = normalizeExperienceLevel(analysis.experienceLevel);
      
      return {
        ...analysis,
        analysisMetadata: {
          analyzedAt: new Date(),
          algorithmVersion: '3.0-batch-premium',
          model: 'gpt-4o',
          analysisType: 'ai_discovery_batch_premium',
          qualityLevel: 'premium',
          batchIndex: index,
          batchSize: jobBatch.length
        }
      };
    });
    
    console.log(`✅ Batch analysis completed: ${enhancedAnalyses.length} jobs analyzed with GPT-4o`);
    return enhancedAnalyses;
    
  } catch (error) {
    console.error('Error in batch job analysis:', error);
    
    // Return fallback analyses for all jobs in batch
    return jobBatch.map((job, index) => ({
      ...createFallbackSingleAnalysis(),
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-batch-fallback',
        model: 'gpt-4o-fallback',
        analysisType: 'ai_discovery_batch_fallback',
        error: error.message,
        batchIndex: index,
        batchSize: jobBatch.length
      }
    }));
  }
};

/**
 * FIXED: Experience level normalization function
 */
function normalizeExperienceLevel(experienceLevel) {
  if (!experienceLevel || typeof experienceLevel !== 'string') {
    return 'mid'; // Default fallback
  }
  
  const level = experienceLevel.toLowerCase().trim();
  
  // Handle compound experience levels by picking the higher one
  if (level.includes('/') || level.includes('-')) {
    const parts = level.split(/[\/\-]/).map(p => p.trim());
    
    // Mapping for priority (higher number = more senior)
    const levelPriority = {
      'entry': 1,
      'junior': 2,
      'mid': 3,
      'senior': 4,
      'lead': 5,
      'principal': 6,
      'executive': 7
    };
    
    let highestLevel = 'mid';
    let highestPriority = 0;
    
    for (const part of parts) {
      const normalizedPart = normalizeSingleLevel(part);
      const priority = levelPriority[normalizedPart] || 0;
      
      if (priority > highestPriority) {
        highestLevel = normalizedPart;
        highestPriority = priority;
      }
    }
    
    return highestLevel;
  }
  
  return normalizeSingleLevel(level);
}

function normalizeSingleLevel(level) {
  const levelMappings = {
    'entry': 'entry',
    'entry-level': 'entry',
    'entry level': 'entry',
    'graduate': 'entry',
    'new grad': 'entry',
    'intern': 'entry',
    'associate': 'entry',
    
    'junior': 'junior',
    'jr': 'junior',
    'junior-level': 'junior',
    
    'mid': 'mid',
    'middle': 'mid',
    'mid-level': 'mid',
    'intermediate': 'mid',
    
    'senior': 'senior',
    'sr': 'senior',
    'senior-level': 'senior',
    
    'lead': 'lead',
    'team lead': 'lead',
    'tech lead': 'lead',
    'technical lead': 'lead',
    
    'principal': 'principal',
    'staff': 'principal',
    'architect': 'principal',
    
    'executive': 'executive',
    'director': 'executive',
    'vp': 'executive',
    'vice president': 'executive',
    'c-level': 'executive',
    'chief': 'executive'
  };
  
  // Direct mapping
  if (levelMappings[level]) {
    return levelMappings[level];
  }
  
  // Partial matching
  for (const [key, value] of Object.entries(levelMappings)) {
    if (level.includes(key)) {
      return value;
    }
  }
  
  return 'mid'; // Default fallback
}

/**
 * NEW: Check if a job is relevant to the target career profile
 */
function isJobRelevantToCareerProfile(job, targetJobTitles = []) {
  if (!job || !job.title) return true; // Allow if we can't determine
  
  const jobTitle = job.title.toLowerCase();
  const jobDescription = (job.description || job.fullContent || '').toLowerCase();
  
  // If no target titles specified, allow all jobs
  if (!targetJobTitles || targetJobTitles.length === 0) {
    return true;
  }
  
  // Extract key role words from target titles
  const targetWords = targetJobTitles
    .flatMap(title => title.toLowerCase().split(' '))
    .filter(word => word.length > 3 && !['senior', 'junior', 'lead', 'principal'].includes(word));
  
  // Check if job title contains any target words
  const titleMatch = targetWords.some(word => jobTitle.includes(word));
  
  // Check if job description contains multiple target words (for broader relevance)
  const descriptionMatches = targetWords.filter(word => jobDescription.includes(word)).length;
  
  // Consider relevant if:
  // 1. Title contains target words, OR
  // 2. Description contains 2+ target words (for related roles)
  return titleMatch || descriptionMatches >= 2;
}

/**
 * Content analysis with premium quality
 * @param {string} jobContent - Raw job content from URL
 * @param {Object} jobInfo - Job metadata
 * @param {boolean} isAiDiscovery - Whether this is from AI discovery (now uses GPT-4o regardless)
 * @returns {Object} Analyzed job content
 */
exports.analyzeJobContent = async (jobContent, jobInfo, isAiDiscovery = false) => {
  if (!jobContent) return null;
  
  try {
    // NEW: Always use GPT-4o for consistent premium quality
    const model = "gpt-4o";
    const maxTokens = 2000;
    
    console.log(`🤖 Analyzing job content with premium ${model}: "${jobInfo.title}"`);
    
    // Create optimized prompt
    const prompt = createContentAnalysisPrompt(jobContent, jobInfo, false); // Always use premium prompt

    const response = await openai.chat.completions.create({
      model: model,
      messages: [
        {
          role: "system",
          content: "You are an expert job analyst. Extract comprehensive job data and return valid JSON only."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0,
      max_tokens: maxTokens
    });

    const analysisText = response.choices[0].message.content.trim();
    let jsonStr = analysisText;
    
    // Clean JSON extraction
    if (analysisText.includes('```')) {
      const jsonMatch = analysisText.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    const analysis = JSON.parse(jsonStr);
    
    // Validate work arrangement
    if (analysis.workArrangement) {
      analysis.workArrangement = normalizeWorkArrangement(analysis.workArrangement);
    }
    
    // FIXED: Normalize experience level
    if (analysis.experienceLevel) {
      analysis.experienceLevel = normalizeExperienceLevel(analysis.experienceLevel);
    }
    
    // Add metadata
    analysis.analysisMetadata = {
      model: model,
      analysisType: isAiDiscovery ? 'ai_discovery_content_premium' : 'manual_content_premium',
      qualityLevel: 'premium',
      analyzedAt: new Date()
    };
    
    console.log(`✅ Premium content analysis completed with ${model} for "${jobInfo.title}"`);
    return analysis;
    
  } catch (error) {
    console.error(`Error analyzing job content with premium approach:`, error);
    return generateBasicContentAnalysis(jobContent, jobInfo, isAiDiscovery);
  }
};

/**
 * Create model-specific prompts (now always premium)
 */
function createPromptForModel(jobDescription, jobMetadata, useMinimModel) {
  // Always use comprehensive prompt for premium quality
  const contentLength = 4000;
  const truncatedDescription = jobDescription.length > contentLength ? 
    jobDescription.substring(0, contentLength) + '...' : jobDescription;

  return `
    Analyze this job posting and extract detailed information. Be thorough and accurate in your analysis.

    **JOB POSTING:**
    ${truncatedDescription}

    **ADDITIONAL CONTEXT:**
    ${jobMetadata.title ? `Title: ${jobMetadata.title}` : ''}
    ${jobMetadata.company ? `Company: ${jobMetadata.company}` : ''}
    ${jobMetadata.location ? `Location: ${JSON.stringify(jobMetadata.location)}` : ''}

    Extract and categorize information into this EXACT JSON structure:

    {
      "requirements": [
        "specific requirement 1",
        "specific requirement 2"
      ],
      "responsibilities": [
        "key responsibility 1",
        "key responsibility 2"
      ],
      "qualifications": {
        "required": [
          "must-have qualification 1",
          "must-have qualification 2"
        ],
        "preferred": [
          "nice-to-have qualification 1",
          "nice-to-have qualification 2"
        ]
      },
      "keySkills": [
        {
          "name": "Python",
          "importance": 9,
          "category": "technical",
          "skillType": "programming"
        },
        {
          "name": "Project Management",
          "importance": 7,
          "category": "soft",
          "skillType": "management"
        }
      ],
      "experienceLevel": "mid",
      "yearsOfExperience": {
        "minimum": 3,
        "preferred": 5
      },
      "educationRequirements": [
        "Bachelor's degree in Computer Science or related field",
        "Master's degree preferred"
      ],
      "benefits": [
        "Health insurance",
        "401k matching",
        "Remote work options"
      ],
      "industryContext": "technology",
      "roleCategory": "product-management",
      "seniorityLevel": "mid",
      "technicalComplexity": "high",
      "leadershipRequired": true,
      "certifications": [
        "PMP certification preferred",
        "Agile certification a plus"
      ],
      "softSkills": [
        "Communication",
        "Leadership",
        "Problem-solving"
      ],
      "technicalSkills": [
        "SQL",
        "Python",
        "Data Analysis"
      ],
      "toolsAndTechnologies": [
        "Jira",
        "Confluence",
        "Tableau"
      ],
      "companySize": "medium",
      "workArrangement": "hybrid"
    }

    **EXTRACTION GUIDELINES:**

    1. **Skills Importance Scale (1-10):**
       - 9-10: Critical/Must-have (mentioned multiple times, essential)
       - 7-8: Very Important (clearly stated as required)
       - 5-6: Important (mentioned in requirements)
       - 3-4: Nice to have (preferred qualifications)
       - 1-2: Bonus (mentioned casually)

    2. **Experience Level Mapping (use ONLY single values):**
       - "entry": 0-2 years
       - "junior": 1-3 years
       - "mid": 3-6 years
       - "senior": 5-10 years
       - "lead": 7-12 years
       - "principal": 10+ years
       - "executive": 12+ years

    CRITICAL: Never use compound values like "mid-senior" or "senior/lead". Always pick the single most appropriate level.

    3. **Work Arrangement (use exact values):**
       - "remote": Fully remote work
       - "hybrid": Mix of remote and office work
       - "onsite": Must work from office/physical location
       - "unknown": Work arrangement not specified

    **IMPORTANT:** Extract only information explicitly mentioned in the job posting. Don't infer or add generic requirements.

    Return ONLY the JSON object without any markdown formatting or explanations.
    `;
}

/**
 * Create model-specific system prompts (now always premium)
 */
function createSystemPromptForModel(useMinimModel) {
  return "You are an expert HR technology analyst specializing in job posting analysis. You extract precise, detailed information from job descriptions without adding assumptions. You return only valid JSON without markdown formatting. For experienceLevel field, use ONLY these exact single values: 'entry', 'junior', 'mid', 'senior', 'lead', 'principal', 'executive'. For workArrangement field, use ONLY these exact values: 'remote', 'hybrid', 'onsite', or 'unknown'.";
}

/**
 * Create content analysis prompt (now always premium)
 */
function createContentAnalysisPrompt(jobContent, jobInfo, isAiDiscovery) {
  const contentLength = 3000;
  const truncatedContent = jobContent.length > contentLength ? 
    jobContent.substring(0, contentLength) + '...' : jobContent;

  return `
    Analyze this job content and extract structured data:

    Job: ${jobInfo.title} at ${jobInfo.company}
    Content: ${truncatedContent}

    Return JSON:
    {
      "requirements": ["Required skill 1", "Required skill 2"],
      "responsibilities": ["Responsibility 1", "Responsibility 2"],
      "qualifications": {
        "required": ["Must have 1", "Must have 2"],
        "preferred": ["Nice to have 1", "Nice to have 2"]
      },
      "salary": {
        "min": 120000,
        "max": 150000,
        "currency": "USD"
      },
      "benefits": ["Benefit 1", "Benefit 2"],
      "jobType": "FULL_TIME",
      "experienceLevel": "mid",
      "workArrangement": "remote"
    }

    CRITICAL: For experienceLevel, use ONLY single values: "entry", "junior", "mid", "senior", "lead", "principal", "executive".
    For workArrangement, use ONLY: "remote", "hybrid", "onsite", "unknown".

    Extract comprehensive information. Be thorough with requirements and qualifications.
    `;
}

/**
 * FIXED: Enhanced validation for premium quality
 */
function validateAndEnhanceJobData(parsedData, originalDescription, useMinimModel) {
  // FIXED: Normalize experience level first
  if (parsedData.experienceLevel) {
    parsedData.experienceLevel = normalizeExperienceLevel(parsedData.experienceLevel);
  }
  
  // Ensure required fields exist
  if (!parsedData.requirements) parsedData.requirements = [];
  if (!parsedData.responsibilities) parsedData.responsibilities = [];
  if (!parsedData.qualifications) {
    parsedData.qualifications = { required: [], preferred: [] };
  }
  if (!parsedData.keySkills) parsedData.keySkills = [];
  if (!parsedData.benefits) parsedData.benefits = [];
  if (!parsedData.educationRequirements) parsedData.educationRequirements = [];

  // Validate and normalize skill importance scores
  if (parsedData.keySkills && Array.isArray(parsedData.keySkills)) {
    parsedData.keySkills = parsedData.keySkills.map(skill => {
      if (typeof skill === 'string') {
        return {
          name: skill,
          importance: 5,
          category: 'technical',
          skillType: 'general'
        };
      }
      
      // Validate importance score
      if (!skill.importance || skill.importance < 1 || skill.importance > 10) {
        skill.importance = 5;
      }
      
      // Ensure required fields
      if (!skill.category) skill.category = 'technical';
      if (!skill.skillType) skill.skillType = 'general';
      
      return skill;
    });
  }

  // Enhanced skill extraction (now always comprehensive)
  const skillLimit = 15; // Increased for premium quality
  const additionalSkills = extractSkillsFromText(originalDescription);
  const existingSkillNames = parsedData.keySkills.map(s => s.name.toLowerCase());
  
  additionalSkills.slice(0, skillLimit).forEach(skill => {
    if (!existingSkillNames.includes(skill.toLowerCase())) {
      parsedData.keySkills.push({
        name: skill,
        importance: 4,
        category: 'technical',
        skillType: 'extracted'
      });
    }
  });

  // Apply standard validations
  const validExperienceLevels = ['entry', 'junior', 'mid', 'senior', 'lead', 'principal', 'executive'];
  if (!parsedData.experienceLevel || !validExperienceLevels.includes(parsedData.experienceLevel)) {
    parsedData.experienceLevel = inferExperienceLevel(originalDescription);
  }

  if (!parsedData.yearsOfExperience) {
    parsedData.yearsOfExperience = inferYearsOfExperience(originalDescription, parsedData.experienceLevel);
  }

  if (!parsedData.industryContext) {
    parsedData.industryContext = inferIndustryContext(originalDescription);
  }

  if (!parsedData.roleCategory) {
    parsedData.roleCategory = inferRoleCategory(originalDescription, parsedData.keySkills);
  }

  // Normalize workArrangement
  if (parsedData.workArrangement) {
    parsedData.workArrangement = normalizeWorkArrangement(parsedData.workArrangement);
  } else {
    parsedData.workArrangement = inferWorkArrangement(originalDescription);
  }

  return parsedData;
}

/**
 * Create fallback single analysis for batch processing
 */
function createFallbackSingleAnalysis() {
  return {
    requirements: ['Relevant experience in the field'],
    responsibilities: ['Perform assigned duties effectively'],
    qualifications: {
      required: ['Relevant education or experience'],
      preferred: ['Additional qualifications preferred']
    },
    keySkills: [
      {
        name: 'Communication',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      },
      {
        name: 'Problem Solving',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      }
    ],
    experienceLevel: 'mid',
    yearsOfExperience: { minimum: 3, preferred: 5 },
    educationRequirements: ['Bachelor\'s degree preferred'],
    benefits: ['Competitive benefits package'],
    workArrangement: 'unknown',
    industryContext: 'general',
    roleCategory: 'general',
    technicalComplexity: 'medium',
    leadershipRequired: false,
    companyStage: 'unknown'
  };
}

/**
 * Generate fallback analysis with premium approach awareness
 */
function generateJobAnalysisFallback(jobDescription, jobMetadata, error, options = {}) {
  console.log('Generating premium fallback job analysis...');
  
  try {
    const extractedSkills = extractSkillsFromText(jobDescription);
    const experienceLevel = inferExperienceLevel(jobDescription);
    const workArrangement = inferWorkArrangement(jobDescription);
    
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      keySkills: extractedSkills.map(skill => ({
        name: skill,
        importance: 5,
        category: 'technical',
        skillType: 'extracted'
      })),
      experienceLevel,
      yearsOfExperience: inferYearsOfExperience(jobDescription, experienceLevel),
      educationRequirements: [],
      benefits: [],
      industryContext: inferIndustryContext(jobDescription),
roleCategory: inferRoleCategory(jobDescription, extractedSkills),
      seniorityLevel: experienceLevel,
      technicalComplexity: 'medium',
      leadershipRequired: jobDescription.toLowerCase().includes('lead'),
      certifications: [],
      softSkills: ['Communication', 'Problem-solving'],
      technicalSkills: extractedSkills,
      toolsAndTechnologies: [],
      companySize: 'unknown',
      workArrangement: workArrangement,
      fallbackReason: error.message,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-premium-fallback',
        model: 'gpt-4o-fallback',
        originalLength: jobDescription.length,
        extractedSkillsCount: extractedSkills.length,
        fallback: true,
        analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium'
      }
    };
    
  } catch (fallbackError) {
    console.error('Error in premium fallback analysis:', fallbackError);
    
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      keySkills: [],
      experienceLevel: 'mid',
      yearsOfExperience: { minimum: 3, preferred: 5 },
      educationRequirements: [],
      benefits: [],
      industryContext: 'general',
      roleCategory: 'general',
      workArrangement: 'unknown',
      errorDetails: error.message,
      analysisMetadata: {
        analyzedAt: new Date(),
        algorithmVersion: '3.0-premium-error',
        model: 'error-fallback-premium',
        originalLength: jobDescription.length,
        error: true,
        analysisType: options.isAiDiscovery ? 'ai_discovery_premium' : 'manual_upload_premium'
      }
    };
  }
}

/**
 * Generate basic content analysis with premium awareness
 */
function generateBasicContentAnalysis(jobContent, jobInfo, isAiDiscovery = false) {
  console.log('Generating premium content analysis fallback...');
  
  try {
    const lowerContent = jobContent.toLowerCase();
    
    // Basic salary extraction
    const salaryMatch = jobContent.match(/\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*-?\s*\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)?/);
    let salary = {};
    if (salaryMatch) {
      salary.min = parseInt(salaryMatch[1].replace(/,/g, ''));
      if (salaryMatch[2]) {
        salary.max = parseInt(salaryMatch[2].replace(/,/g, ''));
      }
      salary.currency = 'USD';
    }
    
    // Basic work arrangement detection
    let workArrangement = 'unknown';
    if (lowerContent.includes('remote')) {
      workArrangement = lowerContent.includes('hybrid') ? 'hybrid' : 'remote';
    } else if (lowerContent.includes('onsite') || lowerContent.includes('on-site')) {
      workArrangement = 'onsite';
    }
    
    return {
      requirements: ['Experience in relevant field'],
      responsibilities: ['Perform job duties as assigned'],
      qualifications: {
        required: ['Relevant experience'],
        preferred: []
      },
      salary: Object.keys(salary).length > 0 ? salary : null,
      benefits: [],
      jobType: 'FULL_TIME',
      experienceLevel: 'mid',
      workArrangement: workArrangement,
      fallbackReason: 'Premium model analysis failed',
      analysisMetadata: {
        model: 'gpt-4o-basic-fallback',
        analysisType: isAiDiscovery ? 'ai_discovery_premium' : 'manual_content_premium',
        qualityLevel: 'basic_fallback'
      }
    };
    
  } catch (error) {
    console.error('Error in basic premium content analysis:', error);
    return {
      requirements: [],
      responsibilities: [],
      qualifications: { required: [], preferred: [] },
      salary: null,
      benefits: [],
      jobType: 'FULL_TIME',
      experienceLevel: 'mid',
      workArrangement: 'unknown',
      error: true,
      analysisMetadata: {
        model: 'error-premium',
        analysisType: isAiDiscovery ? 'ai_discovery_premium' : 'manual_content_premium',
        qualityLevel: 'error_fallback'
      }
    };
  }
}

// Keep all existing helper functions unchanged
function normalizeWorkArrangement(workArrangement) {
  if (!workArrangement || typeof workArrangement !== 'string') {
    return 'unknown';
  }
  
  const normalized = workArrangement.toLowerCase().trim();
  
  const mappings = {
    'remote': 'remote',
    'fully remote': 'remote',
    'work from home': 'remote',
    'wfh': 'remote',
    '100% remote': 'remote',
    
    'hybrid': 'hybrid',
    'flex': 'hybrid',
    'flexible': 'hybrid',
    'mix': 'hybrid',
    'part remote': 'hybrid',
    'partial remote': 'hybrid',
    
    'onsite': 'onsite',
    'on-site': 'onsite',
    'on site': 'onsite',
    'office': 'onsite',
    'in-office': 'onsite',
    'in office': 'onsite',
    'on-premise': 'onsite',
    'on premise': 'onsite',
    'physical location': 'onsite',
    'in-person': 'onsite',
    'in person': 'onsite'
  };
  
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  
  for (const [key, value] of Object.entries(mappings)) {
    if (normalized.includes(key)) {
      return value;
    }
  }
  
  return 'unknown';
}

function extractSkillsFromText(description) {
  const commonSkills = [
    'JavaScript', 'Python', 'Java', 'C++', 'C#', 'PHP', 'Ruby', 'Go', 'Rust', 'Swift',
    'TypeScript', 'Kotlin', 'Scala', 'R', 'MATLAB', 'Perl', 'Shell', 'PowerShell',
    'React', 'Vue.js', 'Angular', 'Node.js', 'Express', 'Django', 'Flask', 'Spring',
    'Laravel', 'Rails', 'ASP.NET', 'HTML', 'CSS', 'SASS', 'LESS', 'Bootstrap',
    'SQL', 'MySQL', 'PostgreSQL', 'MongoDB', 'Redis', 'Elasticsearch', 'Oracle',
    'AWS', 'Azure', 'GCP', 'Docker', 'Kubernetes', 'Jenkins', 'GitLab CI', 'CircleCI',
    'Git', 'GitHub', 'GitLab', 'Bitbucket', 'Jira', 'Confluence', 'Slack',
    'Machine Learning', 'Data Analysis', 'Tableau', 'Power BI', 'Excel', 'Pandas',
    'Figma', 'Sketch', 'Adobe XD', 'Photoshop', 'Illustrator',
    'Agile', 'Scrum', 'Kanban', 'Waterfall', 'PMP', 'PRINCE2',
    'Project Management', 'Leadership', 'Communication', 'Problem Solving'
  ];
  
  const foundSkills = [];
  const lowerDescription = description.toLowerCase();
  
  commonSkills.forEach(skill => {
    const skillVariations = [
      skill.toLowerCase(),
      skill.toLowerCase().replace(/\./g, ''),
      skill.toLowerCase().replace(/\s+/g, ''),
      skill.toLowerCase().replace(/-/g, ''),
      skill.toLowerCase().replace(/\//g, ' ')
    ];
    
    if (skillVariations.some(variation => lowerDescription.includes(variation))) {
      foundSkills.push(skill);
    }
  });
  
  return foundSkills;
}

function inferExperienceLevel(description) {
  const lowerDesc = description.toLowerCase();
  
  if (lowerDesc.includes('entry level') || lowerDesc.includes('0-2 years') || 
      lowerDesc.includes('new grad') || lowerDesc.includes('graduate') ||
      lowerDesc.includes('junior developer') || lowerDesc.includes('associate')) {
    return 'entry';
  }
  
  if (lowerDesc.includes('junior') && !lowerDesc.includes('senior')) {
    return 'junior';
  }
  
  if (lowerDesc.includes('3-5 years') || lowerDesc.includes('mid level') ||
      lowerDesc.includes('3+ years') || lowerDesc.includes('4+ years')) {
    return 'mid';
  }
  
  if (lowerDesc.includes('senior') || lowerDesc.includes('5+ years') ||
      lowerDesc.includes('6+ years') || lowerDesc.includes('7+ years')) {
    return 'senior';
  }
  
  if (lowerDesc.includes('lead') || lowerDesc.includes('tech lead') ||
      lowerDesc.includes('team lead') || lowerDesc.includes('8+ years')) {
    return 'lead';
  }
  
  if (lowerDesc.includes('principal') || lowerDesc.includes('10+ years') ||
      lowerDesc.includes('architect') || lowerDesc.includes('staff')) {
    return 'principal';
  }
  
  if (lowerDesc.includes('director') || lowerDesc.includes('vp') ||
      lowerDesc.includes('executive') || lowerDesc.includes('15+ years') ||
      lowerDesc.includes('chief')) {
    return 'executive';
  }
  
  if (lowerDesc.includes('manage') || lowerDesc.includes('supervise') ||
      lowerDesc.includes('oversee')) {
    return 'senior';
  }
  
  return 'mid'; // Default fallback
}

function inferYearsOfExperience(description, experienceLevel) {
  // Try to extract explicit years mentioned
  const yearMatches = description.match(/(\d+)[\s\-\+]*years?/gi);
  if (yearMatches && yearMatches.length > 0) {
    const years = yearMatches.map(match => parseInt(match.match(/\d+/)[0]));
    const maxYears = Math.max(...years);
    const minYears = Math.min(...years);
    
    return {
      minimum: minYears,
      preferred: maxYears > minYears ? maxYears : minYears + 2
    };
  }
  
  // Fall back to level-based inference
  const levelMappings = {
    'entry': { minimum: 0, preferred: 2 },
    'junior': { minimum: 1, preferred: 3 },
    'mid': { minimum: 3, preferred: 5 },
    'senior': { minimum: 5, preferred: 8 },
    'lead': { minimum: 7, preferred: 10 },
    'principal': { minimum: 10, preferred: 15 },
    'executive': { minimum: 12, preferred: 20 }
  };
  
  return levelMappings[experienceLevel] || { minimum: 3, preferred: 5 };
}

function inferWorkArrangement(description) {
  const lowerDesc = description.toLowerCase();
  
  if (lowerDesc.includes('remote') || lowerDesc.includes('work from home') || 
      lowerDesc.includes('wfh') || lowerDesc.includes('telecommute') ||
      lowerDesc.includes('distributed team')) {
    
    if (lowerDesc.includes('office') || lowerDesc.includes('hybrid') || 
        lowerDesc.includes('flexible') || lowerDesc.includes('mix')) {
      return 'hybrid';
    }
    
    return 'remote';
  }
  
  if (lowerDesc.includes('hybrid') || lowerDesc.includes('flexible') || 
      lowerDesc.includes('mix of remote') || lowerDesc.includes('part remote')) {
    return 'hybrid';
  }
  
  if (lowerDesc.includes('on-site') || lowerDesc.includes('onsite') || 
      lowerDesc.includes('on site') || lowerDesc.includes('in office') ||
      lowerDesc.includes('office location') || lowerDesc.includes('headquarters') ||
      lowerDesc.includes('in-person') || lowerDesc.includes('physical presence')) {
    return 'onsite';
  }
  
  return 'unknown';
}

function inferIndustryContext(description) {
  const lowerDesc = description.toLowerCase();
  
  const industryKeywords = {
    'technology': ['software', 'tech', 'startup', 'saas', 'platform', 'api', 'cloud', 'digital'],
    'finance': ['financial', 'bank', 'investment', 'trading', 'fintech', 'insurance', 'credit'],
    'healthcare': ['health', 'medical', 'hospital', 'pharmaceutical', 'biotech', 'clinical'],
    'retail': ['retail', 'ecommerce', 'e-commerce', 'shopping', 'consumer', 'marketplace'],
    'education': ['education', 'university', 'school', 'learning', 'training', 'academic'],
    'manufacturing': ['manufacturing', 'production', 'factory', 'industrial', 'automotive'],
    'consulting': ['consulting', 'advisory', 'professional services', 'strategy'],
    'media': ['media', 'entertainment', 'publishing', 'content', 'journalism', 'broadcasting'],
    'government': ['government', 'public sector', 'federal', 'state', 'municipal'],
    'nonprofit': ['nonprofit', 'ngo', 'foundation', 'charity', 'social impact']
  };
  
  for (const [industry, keywords] of Object.entries(industryKeywords)) {
    if (keywords.some(keyword => lowerDesc.includes(keyword))) {
      return industry;
    }
  }
  
  return 'general';
}

function inferRoleCategory(description, skills) {
  const lowerDesc = description.toLowerCase();
  const skillNames = skills.map(s => s.name ? s.name.toLowerCase() : s.toLowerCase());
  
  // Direct role mentions
  if (lowerDesc.includes('software engineer') || lowerDesc.includes('developer') ||
      lowerDesc.includes('programmer')) {
    return 'software-engineering';
  }
  
  if (lowerDesc.includes('product manager') || lowerDesc.includes('product owner')) {
    return 'product-management';
  }
  
  if (lowerDesc.includes('data scientist') || lowerDesc.includes('data analyst') ||
      lowerDesc.includes('machine learning')) {
    return 'data-science';
  }
  
  if (lowerDesc.includes('designer') || lowerDesc.includes('ux') || lowerDesc.includes('ui')) {
    return 'design';
  }
  
  if (lowerDesc.includes('marketing') || lowerDesc.includes('growth')) {
    return 'marketing';
  }
  
  if (lowerDesc.includes('sales') || lowerDesc.includes('account executive')) {
    return 'sales';
  }
  
  // Infer from skills
  const techSkills = ['javascript', 'python', 'java', 'react', 'node.js'];
  const dataSkills = ['sql', 'tableau', 'python', 'r', 'machine learning'];
  const designSkills = ['figma', 'sketch', 'photoshop', 'prototyping'];
  
  if (techSkills.some(skill => skillNames.includes(skill))) {
    return 'software-engineering';
  }
  
  if (dataSkills.some(skill => skillNames.includes(skill))) {
    return 'data-science';
  }
  
  if (designSkills.some(skill => skillNames.includes(skill))) {
    return 'design';
  }
  
  return 'general';
}

/**
 * Re-analyze a job with updated algorithm (always premium now)
 * @param {string} jobId - Job ID to re-analyze
 * @returns {Object} Updated job analysis
 */
exports.reAnalyzeJob = async (jobId) => {
  try {
    const Job = require('../models/mongodb/job.model');
    const job = await Job.findById(jobId);
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    console.log(`Re-analyzing job with premium quality: ${job.title} at ${job.company}`);
    
    // Re-analyze with premium GPT-4o for all re-analysis
    const updatedAnalysis = await this.analyzeJob(job.description, {
      title: job.title,
      company: job.company,
      location: job.location
    }, { 
      isAiDiscovery: false,  // Use premium approach for all re-analysis
      prioritizeCost: false 
    });
    
    // Update the job with new analysis
    job.parsedData = updatedAnalysis;
    job.updatedAt = new Date();
    await job.save();
    
    console.log('Premium job re-analysis completed successfully');
    return updatedAnalysis;
    
  } catch (error) {
    console.error('Error re-analyzing job:', error);
    throw error;
  }
};

/**
 * Batch analyze multiple jobs with premium quality
 * @param {Array} jobIds - Array of job IDs to analyze
 * @param {boolean} isAiDiscovery - Whether this is AI discovery (now uses premium regardless)
 * @returns {Object} Batch analysis results
 */
exports.batchAnalyzeJobs = async (jobIds, isAiDiscovery = false) => {
  const results = {
    successful: [],
    failed: [],
    total: jobIds.length,
    modelUsed: 'gpt-4o', // Always premium now
    qualityLevel: 'premium',
    estimatedCost: '$0.01-0.02 per job'
  };
  
  console.log(`Starting premium batch analysis of ${jobIds.length} jobs with ${results.modelUsed}...`);
  
  for (const jobId of jobIds) {
    try {
      const Job = require('../models/mongodb/job.model');
      const job = await Job.findById(jobId);
      
      if (!job) {
        throw new Error('Job not found');
      }
      
      const analysis = await this.analyzeJob(job.description, {
        title: job.title,
        company: job.company,
        location: job.location
      }, { 
        isAiDiscovery: isAiDiscovery,
        prioritizeCost: false  // Always premium quality
      });
      
      job.parsedData = analysis;
      job.updatedAt = new Date();
      await job.save();
      
      results.successful.push({ jobId, analysis });
      
    } catch (error) {
      console.error(`Failed to analyze job ${jobId}:`, error);
      results.failed.push({ jobId, error: error.message });
    }
  }
  
  console.log(`Premium batch analysis completed: ${results.successful.length} successful, ${results.failed.length} failed`);
  return results;
};

================
File: backend/services/jobBoardExtractor.service.js
================
// services/jobBoardExtractor.service.js - UPDATED WITH HTTP MODE FOR INDEED
const axios = require('axios');
const cheerio = require('cheerio');
const UserAgent = require('user-agents');

// Try to import Puppeteer, fall back gracefully if not available
let puppeteer = null;
try {
  puppeteer = require('puppeteer');
  console.log('✅ Puppeteer loaded - browser automation enabled');
} catch (error) {
  console.log('⚠️ Puppeteer not available - using HTTP-only mode');
}

/**
 * Production-Grade Job Board Extraction Service
 * Updated with HTTP-first approach for reliability
 */
class JobBoardExtractor {
  constructor() {
    this.browsers = new Map();
    this.rateLimits = new Map();
    this.userAgents = new UserAgent({ deviceCategory: 'desktop' });
    this.successRates = new Map();
    this.lastRequestTimes = new Map();
    this.useBrowser = !!puppeteer;
    
    console.log(`🎯 JobBoardExtractor initialized - Mode: ${this.useBrowser ? 'HTTP-First + Browser Fallback' : 'HTTP Only'}`);
    
    // Updated board configurations with current selectors
    this.boardConfigs = {
      indeed: {
        baseUrl: 'https://www.indeed.com',
        rateLimitMs: 2000,
        preferHttp: true, // Force HTTP mode for Indeed (more reliable)
        selectors: {
          // Updated Indeed selectors (2024/2025)
          jobCard: '[data-jk], .job_seen_beacon, .jobsearch-SerpJobCard, .result',
          title: '[data-testid="job-title"] a span, .jobTitle a span, h2 a span, .jobTitle span[title]',
          company: '[data-testid="company-name"] a, [data-testid="company-name"] span, .companyName a, .companyName span',
          location: '[data-testid="job-location"], .companyLocation, .locationsContainer',
          description: '[data-testid="job-snippet"], .job-snippet, .summary',
          url: '[data-testid="job-title"] a, .jobTitle a, h2 a',
          salary: '[data-testid="attribute_snippet_testid"], .salary-snippet, .salaryText',
          postedDate: '[data-testid="myJobsStateDate"], .date, .dateLabel'
        }
      },
      linkedin: {
        baseUrl: 'https://www.linkedin.com',
        rateLimitMs: 3000,
        preferHttp: true, // Also prefer HTTP for LinkedIn
        selectors: {
          jobCard: '.job-search-card, .jobs-search__results-list li, .job-result-card',
          title: '.base-search-card__title, .job-search-card__title, .sr-only',
          company: '.base-search-card__subtitle, .job-search-card__subtitle, .job-result-card__subtitle',
          location: '.job-search-card__location, .job-result-card__location',
          description: '.job-search-card__snippet, .job-result-card__snippet',
          url: '.base-card__full-link, .job-search-card__title-link, .job-result-card__title-link',
          salary: '.job-search-card__salary-info, .job-result-card__salary',
          postedDate: '.job-search-card__listdate, .job-result-card__listdate'
        }
      },
      glassdoor: {
        baseUrl: 'https://www.glassdoor.com',
        rateLimitMs: 2500,
        preferHttp: false, // Glassdoor works better with browser
        selectors: {
          jobCard: '[data-test="job-listing"], .react-job-listing, .jobContainer',
          title: '[data-test="job-title"], .jobTitle, .jobLink',
          company: '[data-test="employer-name"], .employerName, .jobEmpolyerName',
          location: '[data-test="job-location"], .loc, .jobLocation',
          description: '[data-test="job-description"], .jobDescription, .jobDescriptionContent',
          url: '[data-test="job-title"] a, .jobTitle a, .jobLink',
          salary: '[data-test="detailSalary"], .salaryText, .jobSalary',
          postedDate: '[data-test="job-age"], .empAge, .jobAge'
        }
      }
    };
  }

  /**
   * Main extraction method - now with HTTP-first approach
   */
  async extractJobsForCriteria(searchCriteria, options = {}) {
    const {
      jobTitle,
      location = 'Remote',
      experienceLevel = 'mid',
      maxJobs = 10,
      boards = ['indeed', 'linkedin', 'glassdoor']
    } = searchCriteria;

    console.log(`🎯 Starting job extraction for "${jobTitle}" in ${location}`);
    console.log(`📋 Target boards: ${boards.join(', ')}`);
    console.log(`🎪 Extraction mode: HTTP-First (more reliable)`);

    const results = {
      jobs: [],
      boardStats: {},
      totalFound: 0,
      errors: [],
      extractionMode: 'http-first',
      metadata: {
        extractedAt: new Date(),
        searchCriteria,
        boards: boards,
        extractionMethod: 'production_job_board_extractor_http_first'
      }
    };

    // Extract from each board sequentially with rate limiting
    for (const boardName of boards) {
      try {
        console.log(`🔍 Extracting from ${boardName}...`);
        
        await this.enforceRateLimit(boardName);
        
        const boardJobs = await this.extractFromBoard(boardName, {
          jobTitle,
          location,
          experienceLevel,
          maxJobs: Math.ceil(maxJobs / boards.length)
        }, options);

        results.boardStats[boardName] = {
          jobsFound: boardJobs.length,
          success: true,
          extractedAt: new Date(),
          method: 'HTTP'
        };

        results.jobs.push(...boardJobs);
        console.log(`✅ ${boardName}: Found ${boardJobs.length} jobs`);

      } catch (error) {
        console.error(`❌ ${boardName} extraction failed:`, error.message);
        
        results.boardStats[boardName] = {
          jobsFound: 0,
          success: false,
          error: error.message,
          extractedAt: new Date()
        };

        results.errors.push({
          board: boardName,
          error: error.message,
          timestamp: new Date()
        });
      }
    }

    // Deduplicate and limit results
    results.jobs = this.deduplicateJobs(results.jobs);
    results.totalFound = results.jobs.length;

    if (results.jobs.length > maxJobs) {
      results.jobs = results.jobs.slice(0, maxJobs);
    }

    console.log(`🎉 Job extraction completed: ${results.totalFound} total jobs found`);
    return results;
  }

  /**
   * Extract from specific board - HTTP-first approach
   */
  async extractFromBoard(boardName, criteria, options = {}) {
    const config = this.boardConfigs[boardName];
    if (!config) {
      throw new Error(`Unsupported job board: ${boardName}`);
    }

    // Always prefer HTTP mode for reliability (browsers can be blocked)
    console.log(`🌐 Using HTTP extraction for ${boardName} (more reliable)`);
    return await this.extractWithHttp(boardName, criteria, options);
  }

  /**
   * HTTP-based extraction with improved error handling
   */
  async extractWithHttp(boardName, criteria, options = {}) {
    const { jobTitle, location, maxJobs = 5 } = criteria;
    const config = this.boardConfigs[boardName];
    const jobs = [];

    try {
      const searchUrl = this.buildSearchUrl(boardName, jobTitle, location);
      console.log(`🌐 HTTP extraction from ${boardName}: ${searchUrl.substring(0, 100)}...`);

      const response = await this.makeHttpRequest(searchUrl, {
        headers: {
          'User-Agent': this.userAgents.toString(),
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9',
          'Accept-Encoding': 'gzip, deflate, br',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
          'Sec-Fetch-Dest': 'document',
          'Sec-Fetch-Mode': 'navigate',
          'Sec-Fetch-Site': 'none',
          'Sec-Fetch-User': '?1',
          'Cache-Control': 'max-age=0'
        },
        timeout: 30000
      });

      console.log(`📄 Received ${response.data.length} characters from ${boardName}`);

      const $ = cheerio.load(response.data);
      
      // Try multiple selector variations for job cards
      let jobCards = $();
      for (const selector of config.selectors.jobCard.split(', ')) {
        const cards = $(selector.trim());
        if (cards.length > 0) {
          jobCards = cards;
          console.log(`📄 Found ${cards.length} job cards using selector: ${selector.trim()}`);
          break;
        }
      }

      if (jobCards.length === 0) {
        console.log(`⚠️ No job cards found on ${boardName} with any selector`);
        console.log(`📝 Page title: ${$('title').text()}`);
        console.log(`📝 Page contains "job": ${response.data.toLowerCase().includes('job')}`);
        
        // Try to find any job-related content
        const jobElements = $('*').filter((i, el) => {
          const text = $(el).text().toLowerCase();
          return text.includes('software engineer') || text.includes('developer') || text.includes('job');
        });
        
        console.log(`📝 Found ${jobElements.length} elements containing job-related text`);
        
        return jobs; // Return empty array but don't throw error
      }

      // Extract jobs with improved error handling
      jobCards.each((index, element) => {
        if (jobs.length >= maxJobs) return false;

        try {
          const job = this.extractJobFromCheerio($, element, boardName);
          
          if (job && job.title && job.company) {
            jobs.push({
              ...job,
              sourcePlatform: this.capitalize(boardName),
              extractedAt: new Date(),
              searchQuery: `${jobTitle} ${location}`,
              extractionMethod: `http_${boardName}`,
              extractorVersion: '2.0-http-first'
            });
            console.log(`   ✅ Job ${jobs.length}: ${job.title} at ${job.company}`);
          } else {
            console.log(`   ⚠️ Job ${index}: Missing required fields (title or company)`);
          }
        } catch (error) {
          console.error(`   ❌ Error extracting job ${index} from ${boardName}:`, error.message);
        }
      });

      console.log(`✅ HTTP extraction from ${boardName} completed: ${jobs.length} jobs`);

    } catch (error) {
      console.error(`❌ HTTP extraction from ${boardName} failed:`, error.message);
      
      // Provide more specific error information
      if (error.code === 'ENOTFOUND') {
        throw new Error(`Network error: Cannot reach ${boardName} (DNS resolution failed)`);
      } else if (error.code === 'ECONNRESET') {
        throw new Error(`Connection error: ${boardName} reset the connection`);
      } else if (error.code === 'ETIMEDOUT') {
        throw new Error(`Timeout error: ${boardName} took too long to respond`);
      } else if (error.response?.status === 403) {
        throw new Error(`Access denied: ${boardName} blocked the request (403)`);
      } else if (error.response?.status === 429) {
        throw new Error(`Rate limited: ${boardName} is throttling requests (429)`);
      } else {
        throw new Error(`HTTP extraction from ${boardName} failed: ${error.message}`);
      }
    }

    return jobs;
  }

  /**
   * Improved job extraction from Cheerio with fallback selectors
   */
  extractJobFromCheerio($, element, boardName) {
    const config = this.boardConfigs[boardName];
    const job = {};

    try {
      const $el = $(element);

      // Extract title with multiple selector fallbacks
      const titleSelectors = config.selectors.title.split(', ');
      for (const selector of titleSelectors) {
        const titleText = this.cleanText($el.find(selector.trim()).first().text());
        if (titleText) {
          job.title = titleText;
          break;
        }
      }

      // Extract company with multiple selector fallbacks
      const companySelectors = config.selectors.company.split(', ');
      for (const selector of companySelectors) {
        const companyText = this.cleanText($el.find(selector.trim()).first().text());
        if (companyText) {
          job.company = companyText;
          break;
        }
      }

      // Extract location
      const locationSelectors = config.selectors.location.split(', ');
      for (const selector of locationSelectors) {
        const locationText = this.cleanText($el.find(selector.trim()).first().text());
        if (locationText) {
          job.location = locationText;
          break;
        }
      }

      // Extract description
      const descSelectors = config.selectors.description.split(', ');
      for (const selector of descSelectors) {
        const descText = this.cleanText($el.find(selector.trim()).first().text());
        if (descText) {
          job.description = descText;
          break;
        }
      }

      // Extract job URL with multiple fallbacks
      const urlSelectors = config.selectors.url.split(', ');
      for (const selector of urlSelectors) {
        const urlElement = $el.find(selector.trim()).first();
        let jobUrl = urlElement.attr('href');
        if (jobUrl) {
          if (!jobUrl.startsWith('http')) {
            jobUrl = `${config.baseUrl}${jobUrl.startsWith('/') ? jobUrl : '/' + jobUrl}`;
          }
          job.jobUrl = jobUrl;
          break;
        }
      }

      // Extract salary (optional)
      const salarySelectors = config.selectors.salary.split(', ');
      for (const selector of salarySelectors) {
        const salaryText = this.cleanText($el.find(selector.trim()).first().text());
        if (salaryText) {
          job.salary = salaryText;
          break;
        }
      }

      // Extract posted date (optional)
      const dateSelectors = config.selectors.postedDate.split(', ');
      for (const selector of dateSelectors) {
        const dateText = this.cleanText($el.find(selector.trim()).first().text());
        if (dateText) {
          job.postedDate = dateText;
          break;
        }
      }

      // Validate required fields
      if (!job.title || !job.company) {
        console.log(`   ⚠️ Missing required fields - Title: "${job.title}", Company: "${job.company}"`);
        return null;
      }

      return job;

    } catch (error) {
      console.error(`   ❌ Error extracting job with Cheerio from ${boardName}:`, error.message);
      return null;
    }
  }

  /**
   * Utility methods (unchanged)
   */
  async enforceRateLimit(boardName) {
    const config = this.boardConfigs[boardName];
    const lastRequest = this.lastRequestTimes.get(boardName);
    
    if (lastRequest) {
      const timeSinceLastRequest = Date.now() - lastRequest;
      if (timeSinceLastRequest < config.rateLimitMs) {
        const delay = config.rateLimitMs - timeSinceLastRequest;
        console.log(`⏱️ Rate limiting ${boardName}: waiting ${delay}ms`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    this.lastRequestTimes.set(boardName, Date.now());
  }

  async makeHttpRequest(url, options = {}, retries = 3) {
    for (let i = 0; i < retries; i++) {
      try {
        const response = await axios.get(url, {
          timeout: 30000,
          maxRedirects: 5,
          ...options
        });
        return response;
      } catch (error) {
        if (i === retries - 1) throw error;
        console.log(`   🔄 Retrying HTTP request (${i + 1}/${retries}): ${error.message}`);
        await this.randomDelay(2000, 5000);
      }
    }
  }

  buildSearchUrl(boardName, jobTitle, location) {
    const baseUrl = this.boardConfigs[boardName].baseUrl;
    
    switch (boardName) {
      case 'indeed':
        const indeedParams = new URLSearchParams({
          q: jobTitle,
          l: location,
          sort: 'date',
          limit: '50', // Increased limit
          fromage: '7' // Jobs from last 7 days
        });
        return `${baseUrl}/jobs?${indeedParams.toString()}`;
        
      case 'linkedin':
        const linkedinParams = new URLSearchParams({
          keywords: jobTitle,
          location: location,
          sortBy: 'DD',
          f_TPR: 'r604800' // Past week
        });
        return `${baseUrl}/jobs/search?${linkedinParams.toString()}`;
        
      case 'glassdoor':
        const glassdoorParams = new URLSearchParams({
          sc: '0kf',
          kw: jobTitle,
          locT: 'C',
          locId: location === 'Remote' ? '11047' : '1147401'
        });
        return `${baseUrl}/Job/jobs.htm?${glassdoorParams.toString()}`;
        
      default:
        throw new Error(`Search URL builder not implemented for ${boardName}`);
    }
  }

  cleanText(text) {
    if (!text) return '';
    return text.replace(/\s+/g, ' ').replace(/[^\w\s\-.,]/g, '').trim();
  }

  capitalize(str) {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  async randomDelay(min, max) {
    const delay = Math.floor(Math.random() * (max - min + 1)) + min;
    await new Promise(resolve => setTimeout(resolve, delay));
  }

  deduplicateJobs(jobs) {
    const seen = new Set();
    return jobs.filter(job => {
      const key = `${job.title?.toLowerCase()}_${job.company?.toLowerCase()}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  async cleanup() {
    console.log('🧹 Cleaning up job board extractor...');
    for (const [boardName, browser] of this.browsers) {
      try {
        await browser.close();
        console.log(`✅ Closed ${boardName} browser`);
      } catch (error) {
        console.error(`Error closing ${boardName} browser:`, error.message);
      }
    }
    this.browsers.clear();
  }

  getStats() {
    return {
      activeBrowsers: this.browsers.size,
      successRates: Object.fromEntries(this.successRates),
      rateLimits: Object.fromEntries(this.rateLimits),
      lastRequests: Object.fromEntries(this.lastRequestTimes),
      extractionMode: 'http-first'
    };
  }
}

module.exports = JobBoardExtractor;

================
File: backend/services/jobMatching.service.js
================
// services/jobMatching.service.js - UPDATED TO AUTO-SELECT BEST RESUME
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');

/**
 * Find the best resume for a user to match against a job
 * @param {string} userId - User ID
 * @param {string} jobId - Job ID (optional, for tailored resume detection)
 * @returns {Object} Best resume for matching
 */
async function findBestResumeForMatching(userId, jobId = null) {
  try {
    // Get all user's resumes
    const allResumes = await Resume.find({ userId }).sort({ createdAt: -1 });
    
    if (!allResumes || allResumes.length === 0) {
      throw new Error('No resumes found for user');
    }
    
    // First, check if there's a tailored resume specifically for this job
    if (jobId) {
      const tailoredResume = allResumes.find(resume => 
        resume.isTailored && 
        resume.tailoredForJob?.jobId && 
        resume.tailoredForJob.jobId.toString() === jobId.toString()
      );
      
      if (tailoredResume) {
        console.log(`Found tailored resume for job ${jobId}:`, {
          resumeId: tailoredResume._id,
          name: tailoredResume.name,
          overallScore: tailoredResume.analysis?.overallScore
        });
        return tailoredResume;
      }
    }
    
    // If no job-specific tailored resume, find the highest scoring resume
    const resumesWithScores = allResumes
      .filter(resume => resume.analysis && resume.analysis.overallScore)
      .sort((a, b) => b.analysis.overallScore - a.analysis.overallScore);
    
    if (resumesWithScores.length > 0) {
      const bestResume = resumesWithScores[0];
      console.log(`Selected best resume by score:`, {
        resumeId: bestResume._id,
        name: bestResume.name,
        overallScore: bestResume.analysis.overallScore,
        isTailored: bestResume.isTailored
      });
      return bestResume;
    }
    
    // Fallback to most recent resume
    const fallbackResume = allResumes[0];
    console.log(`Fallback to most recent resume:`, {
      resumeId: fallbackResume._id,
      name: fallbackResume.name
    });
    return fallbackResume;
    
  } catch (error) {
    console.error('Error finding best resume for matching:', error);
    throw error;
  }
}

/**
 * Enhanced job matching with automatic best resume selection
 * @param {string} jobId - MongoDB ID of the job
 * @param {string} resumeId - MongoDB ID of the resume (optional - will auto-select if not provided)
 * @param {string} userId - User ID (for auto-selection)
 * @returns {Object} Match analysis results with accurate scoring
 */
exports.matchJobWithBestResume = async (jobId, userId, specificResumeId = null) => {
  try {
    console.log(`Starting intelligent job matching for job ${jobId}, user ${userId}`);
    
    // Get the job
    const job = await Job.findById(jobId);
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Find the best resume to use for matching
    let resume;
    if (specificResumeId) {
      // Use specific resume if provided
      resume = await Resume.findOne({ _id: specificResumeId, userId });
      if (!resume) {
        throw new Error('Specified resume not found');
      }
      console.log(`Using specified resume: ${resume.name}`);
    } else {
      // Auto-select best resume
      resume = await findBestResumeForMatching(userId, jobId);
    }
    
    console.log(`Starting enhanced matching for job "${job.title}" with resume "${resume.name}"`);
    
    // Perform the actual matching
    const matchAnalysis = await this.matchResumeWithJob(resume._id, jobId);
    
    // Update the job with the new match analysis
    job.matchAnalysis = {
      ...matchAnalysis,
      resumeId: resume._id,
      lastAnalyzed: new Date(),
      analysisVersion: '2.0-auto-best'
    };
    
    await job.save();
    
    console.log(`Job match updated with best resume. Score: ${matchAnalysis.overallScore}%`);
    
    return {
      matchAnalysis,
      usedResume: {
        id: resume._id,
        name: resume.name,
        isTailored: resume.isTailored,
        overallScore: resume.analysis?.overallScore
      }
    };
    
  } catch (error) {
    console.error('Error in enhanced job matching:', error);
    throw error;
  }
};

/**
 * Enhanced job matching with more intelligent scoring
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @returns {Object} Match analysis results with accurate scoring
 */
exports.matchResumeWithJob = async (resumeId, jobId) => {
  try {
    console.log(`Starting enhanced matching for resume ${resumeId} with job ${jobId}`);
    
    // Get the resume and job from the database
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Check if parsed data is available for both
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      throw new Error('Resume parsing data not available for matching');
    }
    
    if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
      throw new Error('Job analysis data not available for matching');
    }
    
    console.log('Performing intelligent job-resume matching with OpenAI...');
    
    // Create detailed prompts for more accurate analysis
    const resumeSkills = extractSkillsFromResume(resume.parsedData);
    const jobSkills = extractSkillsFromJob(job.parsedData);
    const resumeExperience = extractExperienceFromResume(resume.parsedData);
    const jobRequirements = extractRequirementsFromJob(job.parsedData);
    
    // Check if this is a tailored resume for bonus consideration
    const isTailoredForThisJob = resume.isTailored && 
      resume.tailoredForJob?.jobId && 
      resume.tailoredForJob.jobId.toString() === jobId.toString();
    
    // Enhanced prompt for more precise matching
    const prompt = `
    You are an expert ATS (Applicant Tracking System) and recruitment analyst. Perform a detailed match analysis between this resume and job posting.

    IMPORTANT: Provide realistic and accurate scores based on actual content matching. ${isTailoredForThisJob ? 'This resume has been AI-tailored specifically for this job, so it should score higher than a generic resume.' : 'Avoid giving inflated scores.'}

    **JOB POSTING:**
    Title: ${job.title}
    Company: ${job.company}
    Description: ${job.description}
    
    **JOB REQUIREMENTS ANALYSIS:**
    Required Skills: ${JSON.stringify(jobSkills.required)}
    Preferred Skills: ${JSON.stringify(jobSkills.preferred)}
    Experience Level: ${job.parsedData.experienceLevel || 'Not specified'}
    Education Requirements: ${JSON.stringify(job.parsedData.educationRequirements)}
    Key Requirements: ${JSON.stringify(jobRequirements)}

    **CANDIDATE RESUME:**
    Summary: ${resume.parsedData.summary || 'No summary provided'}
    Skills: ${JSON.stringify(resumeSkills)}
    Experience: ${JSON.stringify(resumeExperience)}
    Education: ${JSON.stringify(resume.parsedData.education)}
    ${isTailoredForThisJob ? 'NOTE: This resume has been specifically tailored for this job posting.' : ''}

    **MATCHING CRITERIA:**
    1. **Skills Match (40% weight)**: Compare required vs candidate skills
    2. **Experience Match (35% weight)**: Evaluate relevant experience depth and breadth
    3. **Education Match (25% weight)**: Check education requirements vs candidate background

    **SCORING GUIDELINES:**
    - 95-100%: Perfect match, candidate exceeds all requirements ${isTailoredForThisJob ? '(expected for tailored resumes)' : ''}
    - 85-94%: Excellent match, candidate meets all core requirements with strong alignment
    - 75-84%: Very good match, candidate meets most requirements
    - 65-74%: Good match, candidate meets core requirements with some gaps
    - 55-64%: Moderate match, candidate has potential but significant gaps
    - Below 55%: Poor match, major misalignment

    ${isTailoredForThisJob ? 'TAILORED RESUME BONUS: This resume should score 10-15 points higher than the original due to optimization.' : ''}

    Provide analysis in this EXACT JSON format:
    {
      "overallScore": <realistic number 0-100>,
      "categoryScores": {
        "skills": <realistic number 0-100>,
        "experience": <realistic number 0-100>,
        "education": <realistic number 0-100>
      },
      "matchedSkills": [
        {
          "skill": "exact skill name from job",
          "found": true/false,
          "importance": <1-10 scale>,
          "matchQuality": "exact|partial|related|none",
          "resumeEvidence": "where found in resume or null"
        }
      ],
      "missingSkills": [
        {
          "skill": "missing skill name",
          "importance": <1-10 scale>,
          "category": "required|preferred",
          "suggestionToAdd": "specific advice"
        }
      ],
      "experienceAnalysis": {
        "totalYearsExperience": <number>,
        "relevantYearsExperience": <number>,
        "seniorityMatch": "junior|mid|senior|executive",
        "industryAlignment": "high|medium|low",
        "roleAlignment": "high|medium|low"
      },
      "educationAnalysis": {
        "degreeMatch": "exceeds|meets|partial|none",
        "fieldAlignment": "high|medium|low",
        "certificationBonus": true/false
      },
      "improvementSuggestions": [
        "specific actionable suggestion 1",
        "specific actionable suggestion 2",
        "specific actionable suggestion 3"
      ],
      "strengthsHighlight": [
        "key strength 1",
        "key strength 2",
        "key strength 3"
      ]
    }

    **IMPORTANT**: ${isTailoredForThisJob ? 'This is a tailored resume - expect scores in the 85-95% range due to optimization.' : 'Base scores on actual content analysis, not generic assumptions. Be critical and realistic in scoring.'}
    `;

    // Call OpenAI API with enhanced model settings
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: `You are an expert ATS system and senior recruitment analyst with 15+ years of experience. You provide realistic, accurate match scores based on detailed analysis. ${isTailoredForThisJob ? 'You recognize when resumes have been optimized for specific jobs and score them appropriately higher.' : 'You never inflate scores and always provide evidence-based assessments.'} Return ONLY valid JSON without markdown formatting.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Lower temperature for more consistent scoring
      max_tokens: 4000,
    });

    // Parse and validate the response
    const content = response.choices[0].message.content.trim();
    console.log('OpenAI Response received, parsing...');
    
    let matchAnalysis;
    try {
      // Clean up the response to extract JSON
      let jsonStr = content;
      
      // Remove any markdown code blocks
      if (content.includes('```')) {
        const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          jsonStr = jsonMatch[1];
        }
      }
      
      // Clean up and ensure valid JSON structure
      jsonStr = jsonStr.trim();
      if (!jsonStr.startsWith('{')) {
        const startIndex = jsonStr.indexOf('{');
        if (startIndex !== -1) {
          jsonStr = jsonStr.substring(startIndex);
        }
      }
      if (!jsonStr.endsWith('}')) {
        const endIndex = jsonStr.lastIndexOf('}');
        if (endIndex !== -1) {
          jsonStr = jsonStr.substring(0, endIndex + 1);
        }
      }
      
      matchAnalysis = JSON.parse(jsonStr);
      
      // Validate and ensure realistic scoring
      matchAnalysis = validateAndNormalizeScores(matchAnalysis);
      
      console.log(`Enhanced matching completed - Overall Score: ${matchAnalysis.overallScore}%`);
      
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.log('Raw response:', content);
      throw new Error('Failed to parse AI response');
    }

    // Add additional metadata
    matchAnalysis.analysisMetadata = {
      resumeId,
      jobId,
      analyzedAt: new Date(),
      algorithmVersion: '2.0',
      isTailoredResume: isTailoredForThisJob
    };

    return matchAnalysis;
    
  } catch (error) {
    console.error('Error in enhanced job matching:', error);
    
    // More intelligent fallback based on available data
    return generateIntelligentFallback(resume, job, error);
  }
};

/**
 * Extract skills from resume data
 */
function extractSkillsFromResume(parsedData) {
  const skills = [];
  
  // From skills section
  if (parsedData.skills && Array.isArray(parsedData.skills)) {
    parsedData.skills.forEach(skill => {
      if (typeof skill === 'string') {
        skills.push(skill);
      } else if (skill && skill.name) {
        skills.push(skill.name);
      }
    });
  }
  
  // From experience highlights
  if (parsedData.experience && Array.isArray(parsedData.experience)) {
    parsedData.experience.forEach(exp => {
      if (exp.skills && Array.isArray(exp.skills)) {
        skills.push(...exp.skills);
      }
    });
  }
  
  return [...new Set(skills)]; // Remove duplicates
}

/**
 * Extract skills from job data
 */
function extractSkillsFromJob(parsedData) {
  const required = [];
  const preferred = [];
  
  // From key skills
  if (parsedData.keySkills && Array.isArray(parsedData.keySkills)) {
    parsedData.keySkills.forEach(skill => {
      if (typeof skill === 'string') {
        required.push(skill);
      } else if (skill && skill.name) {
        const importance = skill.importance || 5;
        if (importance >= 7) {
          required.push(skill.name);
        } else {
          preferred.push(skill.name);
        }
      }
    });
  }
  
  // From qualifications
  if (parsedData.qualifications) {
    if (parsedData.qualifications.required) {
      required.push(...parsedData.qualifications.required);
    }
    if (parsedData.qualifications.preferred) {
      preferred.push(...parsedData.qualifications.preferred);
    }
  }
  
  return {
    required: [...new Set(required)],
    preferred: [...new Set(preferred)]
  };
}

/**
 * Extract experience from resume
 */
function extractExperienceFromResume(parsedData) {
  if (!parsedData.experience || !Array.isArray(parsedData.experience)) {
    return [];
  }
  
  return parsedData.experience.map(exp => ({
    company: exp.company,
    title: exp.title,
    duration: calculateDuration(exp.startDate, exp.endDate),
    description: exp.description,
    highlights: exp.highlights || []
  }));
}

/**
 * Extract requirements from job
 */
function extractRequirementsFromJob(parsedData) {
  const requirements = [];
  
  if (parsedData.requirements && Array.isArray(parsedData.requirements)) {
    requirements.push(...parsedData.requirements);
  }
  
  if (parsedData.responsibilities && Array.isArray(parsedData.responsibilities)) {
    requirements.push(...parsedData.responsibilities);
  }
  
  return requirements;
}

/**
 * Calculate duration between two dates
 */
function calculateDuration(startDate, endDate) {
  if (!startDate) return 0;
  
  const start = new Date(startDate);
  const end = endDate ? new Date(endDate) : new Date();
  
  const diffTime = Math.abs(end - start);
  const diffMonths = Math.ceil(diffTime / (1000 * 60 * 60 * 24 * 30));
  
  return diffMonths;
}

/**
 * Validate and normalize scores to ensure realistic ranges
 */
function validateAndNormalizeScores(analysis) {
  // Ensure overall score is reasonable based on category scores
  if (analysis.categoryScores) {
    const { skills, experience, education } = analysis.categoryScores;
    
    // Weighted average: Skills 40%, Experience 35%, Education 25%
    const calculatedOverall = Math.round((skills * 0.4) + (experience * 0.35) + (education * 0.25));
    
    // If provided overall score is significantly different, use calculated
    if (Math.abs(analysis.overallScore - calculatedOverall) > 10) {
      analysis.overallScore = calculatedOverall;
    }
  }
  
  // Ensure scores are within valid range
  analysis.overallScore = Math.max(0, Math.min(100, analysis.overallScore));
  if (analysis.categoryScores) {
    analysis.categoryScores.skills = Math.max(0, Math.min(100, analysis.categoryScores.skills));
    analysis.categoryScores.experience = Math.max(0, Math.min(100, analysis.categoryScores.experience));
    analysis.categoryScores.education = Math.max(0, Math.min(100, analysis.categoryScores.education));
  }
  
  return analysis;
}

/**
 * Generate intelligent fallback when AI analysis fails
 */
function generateIntelligentFallback(resume, job, error) {
  console.log('Generating intelligent fallback analysis...');
  
  try {
    // Basic skills matching
    const resumeSkills = extractSkillsFromResume(resume.parsedData);
    const jobSkills = extractSkillsFromJob(job.parsedData);
    
    // Calculate basic skill match percentage
    const allJobSkills = [...jobSkills.required, ...jobSkills.preferred];
    const matchedSkills = resumeSkills.filter(skill => 
      allJobSkills.some(jobSkill => 
        skill.toLowerCase().includes(jobSkill.toLowerCase()) ||
        jobSkill.toLowerCase().includes(skill.toLowerCase())
      )
    );
    
    const skillsScore = allJobSkills.length > 0 ? 
      Math.round((matchedSkills.length / allJobSkills.length) * 100) : 50;
    
    // Basic experience scoring
    const experienceYears = resume.parsedData.experience ? 
      resume.parsedData.experience.length * 2 : 0; // Rough estimate
    
    let experienceScore = 40;
    if (experienceYears >= 5) experienceScore = 75;
    if (experienceYears >= 8) experienceScore = 85;
    if (experienceYears >= 12) experienceScore = 95;
    
    // Basic education scoring
    const hasEducation = resume.parsedData.education && 
      resume.parsedData.education.length > 0;
    const educationScore = hasEducation ? 70 : 40;
    
    // Calculate weighted overall score
    const overallScore = Math.round(
      (skillsScore * 0.4) + (experienceScore * 0.35) + (educationScore * 0.25)
    );
    
    return {
      overallScore,
      categoryScores: {
        skills: skillsScore,
        experience: experienceScore,
        education: educationScore
      },
      matchedSkills: matchedSkills.map(skill => ({
        skill,
        found: true,
        importance: 5,
        matchQuality: 'partial',
        resumeEvidence: 'Skills section'
      })),
      missingSkills: allJobSkills
        .filter(skill => !matchedSkills.includes(skill))
        .slice(0, 5)
        .map(skill => ({
          skill,
          importance: 6,
          category: 'required',
          suggestionToAdd: `Consider highlighting experience with ${skill} if you have it`
        })),
      improvementSuggestions: [
        'Analysis temporarily unavailable - basic matching performed',
        'Consider highlighting relevant skills mentioned in the job posting',
        'Quantify your achievements with specific metrics and results'
      ],
      strengthsHighlight: [
        'Resume structure is well-organized',
        'Relevant work experience present',
        'Skills section is comprehensive'
      ],
      fallbackReason: error.message,
      analysisMetadata: {
        resumeId: resume._id,
        jobId: job._id,
        analyzedAt: new Date(),
        algorithmVersion: '2.0-fallback'
      }
    };
    
  } catch (fallbackError) {
    console.error('Error in fallback analysis:', fallbackError);
    
    // Final fallback with very basic scores
    return {
      overallScore: 45,
      categoryScores: {
        skills: 40,
        experience: 50,
        education: 45
      },
      matchedSkills: [],
      missingSkills: [],
      improvementSuggestions: [
        'Unable to complete detailed analysis at this time',
        'Please ensure your resume includes relevant skills for this position',
        'Try the analysis again later for more detailed insights'
      ],
      strengthsHighlight: [
        'Resume uploaded successfully',
        'Basic profile information captured'
      ],
      errorDetails: error.message,
      analysisMetadata: {
        resumeId: resume._id,
        jobId: job._id,
        analyzedAt: new Date(),
        algorithmVersion: '2.0-error-fallback'
      }
    };
  }
}

================
File: backend/services/jobSearch.service.js
================
// services/jobSearch.service.js - COMPLETE GENERIC VERSION FOR ALL JOB TYPES
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const AiJobSearch = require('../models/mongodb/aiJobSearch.model');
const { openai } = require('../config/openai');
const AdzunaJobExtractor = require('./adzunaJobExtractor.service');

// CENTRALIZED VALIDATION UTILITIES
class ValidationUtils {
  static normalizeSkillCategory(category) {
    if (!category || typeof category !== 'string') {
      return 'technical';
    }
    
    const normalized = category.toLowerCase().trim();
    
    const categoryMappings = {
      'technical': 'technical',
      'tech': 'technical',
      'technology': 'technical',
      'programming': 'technical',
      'development': 'technical',
      'engineering': 'technical',
      
      'soft': 'soft',
      'soft skills': 'soft',
      'interpersonal': 'soft',
      'communication': 'soft',
      'leadership': 'soft',
      'management': 'soft',
      'managerial': 'soft',
      'people': 'soft',
      'social': 'soft',
      
      'business': 'business',
      'strategy': 'business',
      'strategic': 'business',
      'analytical': 'business',
      'analysis': 'business',
      'finance': 'business',
      'marketing': 'business',
      'sales': 'business'
    };
    
    if (categoryMappings[normalized]) {
      return categoryMappings[normalized];
    }
    
    for (const [key, value] of Object.entries(categoryMappings)) {
      if (normalized.includes(key)) {
        return value;
      }
    }
    
    return 'technical';
  }

  static normalizeSkillType(skillType) {
    if (!skillType || typeof skillType !== 'string') {
      return 'general';
    }
    
    const normalized = skillType.toLowerCase().trim();
    
    const typeMappings = {
      'programming': 'programming',
      'management': 'management',
      'analytical': 'analytical',
      'communication': 'communication',
      'design': 'design',
      'general': 'general'
    };
    
    if (typeMappings[normalized]) {
      return typeMappings[normalized];
    }
    
    for (const [key, value] of Object.entries(typeMappings)) {
      if (normalized.includes(key)) {
        return value;
      }
    }
    
    return 'general';
  }

  static validateAndNormalizeSkills(skills) {
    if (!Array.isArray(skills)) {
      return [];
    }
    
    return skills.map(skill => {
      if (typeof skill === 'string') {
        return {
          name: skill,
          importance: 5,
          category: 'technical',
          skillType: 'general'
        };
      }
      
      return {
        name: skill.name || 'Unknown Skill',
        importance: (skill.importance >= 1 && skill.importance <= 10) ? skill.importance : 5,
        category: this.normalizeSkillCategory(skill.category),
        skillType: this.normalizeSkillType(skill.skillType)
      };
    });
  }

  static normalizeExperienceLevel(experienceLevel) {
    if (!experienceLevel || typeof experienceLevel !== 'string') {
      return 'mid';
    }
    
    const level = experienceLevel.toLowerCase().trim();
    
    const levelMappings = {
      'entry': 'entry', 'junior': 'junior', 'mid': 'mid', 'senior': 'senior', 
      'lead': 'lead', 'principal': 'principal', 'executive': 'executive'
    };
    
    if (levelMappings[level]) {
      return levelMappings[level];
    }
    
    if (level.includes('entry') || level.includes('graduate')) return 'entry';
    if (level.includes('junior') || level.includes('jr')) return 'junior';
    if (level.includes('senior') || level.includes('sr')) return 'senior';
    if (level.includes('lead') || level.includes('principal')) return 'lead';
    if (level.includes('director') || level.includes('executive')) return 'executive';
    
    return 'mid';
  }

  static normalizeWorkArrangement(workArrangement) {
    if (!workArrangement || typeof workArrangement !== 'string') {
      return 'unknown';
    }
    
    const normalized = workArrangement.toLowerCase().trim();
    
    if (normalized.includes('remote')) return 'remote';
    if (normalized.includes('hybrid') || normalized.includes('flexible')) return 'hybrid';
    if (normalized.includes('onsite') || normalized.includes('office')) return 'onsite';
    
    return 'unknown';
  }
}

// GENERIC RELEVANCE FILTERING - WORKS FOR ALL JOB TYPES
class RelevanceFilter {
  static calculateJobRelevanceScore(jobData, targetJobTitles, targetKeywords) {
    let score = 0;
    const jobTitle = (jobData.title || '').toLowerCase();
    const jobDescription = (jobData.description || jobData.fullContent || '').toLowerCase();
    
    // 1. TITLE RELEVANCE (60% of score) - GENERIC LOGIC
    let titleScore = this.calculateGenericTitleRelevance(jobTitle, targetJobTitles);
    score += titleScore * 0.6;
    
    // 2. KEYWORD RELEVANCE (25% of score) - GENERIC
    if (targetKeywords && targetKeywords.length > 0) {
      const matchingKeywords = targetKeywords.filter(keyword => 
        jobDescription.includes(keyword.toLowerCase()) || jobTitle.includes(keyword.toLowerCase())
      );
      score += (matchingKeywords.length / targetKeywords.length) * 25;
    }
    
    // 3. ROLE CATEGORY RELEVANCE (15% of score) - GENERIC
    let categoryScore = this.calculateGenericCategoryRelevance(jobTitle, targetJobTitles);
    score += categoryScore * 0.15;
    
    // 4. ANTI-PATTERN PENALTIES - GENERIC (only for obviously irrelevant jobs)
    const penalty = this.calculateGenericAntiPatternPenalties(jobTitle);
    score += penalty;
    
    return Math.max(0, Math.min(100, Math.round(score)));
  }

  static calculateGenericTitleRelevance(jobTitle, targetJobTitles) {
    let maxScore = 0;
    
    for (const targetTitle of targetJobTitles) {
      const targetLower = targetTitle.toLowerCase();
      
      // Exact match gets highest score
      if (jobTitle === targetLower) {
        return 100;
      }
      
      // Partial exact match (job title contains target)
      if (jobTitle.includes(targetLower)) {
        maxScore = Math.max(maxScore, 95);
        continue;
      }
      
      // Extract core function words (remove seniority levels)
      const targetWords = this.extractCoreWords(targetLower);
      const jobWords = this.extractCoreWords(jobTitle);
      
      // Calculate word overlap
      const matchingWords = targetWords.filter(word => jobWords.includes(word));
      
      if (matchingWords.length > 0) {
        // Score based on percentage of core words matched
        const wordScore = (matchingWords.length / targetWords.length) * 85;
        maxScore = Math.max(maxScore, wordScore);
      }
    }
    
    return maxScore;
  }

  static extractCoreWords(title) {
    // Remove seniority levels and extract core job function words
    const seniorityWords = ['senior', 'sr', 'junior', 'jr', 'lead', 'principal', 'director', 'head', 'chief', 'vp', 'vice', 'president', 'entry', 'associate', 'staff', 'executive'];
    
    return title.split(' ')
      .filter(word => word.length > 2)
      .filter(word => !seniorityWords.includes(word))
      .filter(word => !['the', 'of', 'and', 'or', 'for', 'at', 'in', 'to', 'with', 'a', 'an'].includes(word));
  }

  static calculateGenericCategoryRelevance(jobTitle, targetJobTitles) {
    // Determine the job category from target titles
    const targetCategory = this.determineJobCategory(targetJobTitles);
    const jobCategory = this.determineJobCategory([jobTitle]);
    
    if (targetCategory === jobCategory) {
      return 100; // Same category
    }
    
    // Some categories are related
    const relatedCategories = {
      'engineering': ['developer', 'technical'],
      'management': ['leadership', 'director'],
      'design': ['creative', 'visual'],
      'data': ['analytics', 'research'],
      'marketing': ['growth', 'communications'],
      'sales': ['business-development', 'account-management']
    };
    
    for (const [category, related] of Object.entries(relatedCategories)) {
      if (targetCategory === category && related.includes(jobCategory)) {
        return 70; // Related category
      }
      if (jobCategory === category && related.includes(targetCategory)) {
        return 70; // Related category
      }
    }
    
    return 0; // Unrelated category
  }

  static determineJobCategory(jobTitles) {
    const allTitles = jobTitles.join(' ').toLowerCase();
    
    // Engineering/Development
    if (allTitles.includes('engineer') || allTitles.includes('developer') || allTitles.includes('programmer')) {
      return 'engineering';
    }
    
    // Product Management
    if (allTitles.includes('product') && allTitles.includes('manager')) {
      return 'product-management';
    }
    
    // Data Science/Analytics
    if (allTitles.includes('data') && (allTitles.includes('scientist') || allTitles.includes('analyst'))) {
      return 'data';
    }
    
    // Design
    if (allTitles.includes('designer') || allTitles.includes('design') || allTitles.includes('ux') || allTitles.includes('ui')) {
      return 'design';
    }
    
    // Marketing
    if (allTitles.includes('marketing') || allTitles.includes('growth') || allTitles.includes('brand')) {
      return 'marketing';
    }
    
    // Sales
    if (allTitles.includes('sales') || allTitles.includes('account') || allTitles.includes('business development')) {
      return 'sales';
    }
    
    // Management (general)
    if (allTitles.includes('manager') || allTitles.includes('director') || allTitles.includes('lead')) {
      return 'management';
    }
    
    // Research
    if (allTitles.includes('research') || allTitles.includes('scientist')) {
      return 'research';
    }
    
    // Operations
    if (allTitles.includes('operations') || allTitles.includes('ops')) {
      return 'operations';
    }
    
    return 'general';
  }

  static calculateGenericAntiPatternPenalties(jobTitle) {
    // Only penalize obviously unrelated jobs - be very conservative
    const universalAntiPatterns = [
      'customer service', 'receptionist', 'driver', 'delivery', 'warehouse', 
      'janitor', 'cleaner', 'cashier', 'retail', 'food service', 'server',
      'administrative assistant', 'data entry clerk', 'call center'
    ];
    
    for (const pattern of universalAntiPatterns) {
      if (jobTitle.includes(pattern)) {
        console.log(`⚠️ Applied penalty (-25) for universal anti-pattern: ${pattern}`);
        return -25;
      }
    }
    
    return 0; // No penalty for most jobs
  }

  static filterJobsForRelevance(jobs, careerProfile, minScore = 55) {
    const targetJobTitles = careerProfile.targetJobTitles || [];
    const targetKeywords = careerProfile.targetKeywords || [];
    
    console.log(`🎯 Applying GENERIC relevance filtering (min score: ${minScore}) for: ${targetJobTitles.join(', ')}`);
    
    const relevantJobs = [];
    
    for (const job of jobs) {
      const relevanceScore = this.calculateJobRelevanceScore(job, targetJobTitles, targetKeywords);
      
      if (relevanceScore >= minScore) {
        job.relevanceScore = relevanceScore;
        relevantJobs.push(job);
        console.log(`✅ RELEVANT (${relevanceScore}%): "${job.title}" at ${job.company}`);
      } else {
        console.log(`❌ FILTERED OUT (${relevanceScore}%): "${job.title}" at ${job.company}`);
      }
    }
    
    // Sort by relevance score
    relevantJobs.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0));
    
    console.log(`🎯 Generic filtering complete: ${relevantJobs.length}/${jobs.length} jobs meet relevance criteria`);
    return relevantJobs;
  }
}

// MAIN SEARCH FUNCTION
exports.findJobsWithAi = async (userId, resumeId) => {
  try {
    console.log(`🚀 Starting generic AI job search for user ${userId}`);
    
    const resume = await Resume.findById(resumeId);
    if (!resume || !resume.parsedData) {
      throw new Error('Resume not found or not parsed');
    }
    
    // Create search record using existing valid enum values
    const aiJobSearch = new AiJobSearch({
      userId,
      resumeId,
      resumeName: resume.name,
      searchCriteria: extractSearchCriteria(resume.parsedData),
      status: 'running',
      dailyLimit: 8,
      jobsFoundToday: 0,
      totalJobsFound: 0,
      searchApproach: '3-phase-intelligent-adzuna-api', // Existing valid enum value
      approachVersion: '4.0-adzuna-api-integration',
      qualityLevel: 'adzuna-api-enhanced' // Existing valid enum value
    });
    
    await aiJobSearch.save();
    
    await aiJobSearch.addReasoningLog(
      'initialization',
      'Starting generic AI job search that works for any job type with improved relevance filtering.',
      {
        searchCriteria: aiJobSearch.searchCriteria,
        dailyLimit: aiJobSearch.dailyLimit,
        approach: 'Generic 3-phase process with field-agnostic filtering'
      }
    );
    
    // Start generic background search
    performGenericAdzunaJobSearch(aiJobSearch._id, userId, resume).catch(error => {
      console.error('Generic job search error:', error);
      updateSearchStatus(aiJobSearch._id, 'failed', error.message);
    });
    
    return {
      success: true,
      message: 'Generic AI job search started! Works for any job type with improved filtering.',
      searchId: aiJobSearch._id,
      searchMethod: 'Generic Adzuna API discovery with field-agnostic filtering'
    };
    
  } catch (error) {
    console.error('Error initiating generic job search:', error);
    throw error;
  }
};

// GENERIC MAIN SEARCH PROCESS
async function performGenericAdzunaJobSearch(searchId, userId, resume) {
  const searchStartTime = Date.now();
  let search;
  
  try {
    search = await AiJobSearch.findById(searchId);
    if (!search || search.status !== 'running') return;
    
    // Check daily limits
    if (await isDailyLimitReached(search)) {
      await search.addReasoningLog(
        'completion',
        `Reached today's limit of ${search.dailyLimit} quality job discoveries.`,
        { dailyLimit: search.dailyLimit, reason: 'daily_limit_reached' }
      );
      await updateSearchStatus(searchId, 'paused', 'Daily limit reached');
      return;
    }
    
    // PHASE 1: Generic Career Analysis
    console.log(`📊 Phase 1: Generic Career Analysis...`);
    const careerProfile = await analyzeGenericCareerProfile(resume.parsedData);
    
    await search.addReasoningLog(
      'career_analysis',
      `Generic career analysis complete! Identified ${careerProfile.targetJobTitles?.length || 0} target job titles for field: ${careerProfile.careerDirection}`,
      {
        targetJobTitles: careerProfile.targetJobTitles || [],
        targetKeywords: careerProfile.targetKeywords || [],
        experienceLevel: careerProfile.experienceLevel,
        careerField: careerProfile.careerDirection
      }
    );
    
    // PHASE 2: Generic Job Discovery
    console.log(`🎯 Phase 2: Generic Job Discovery...`);
    const discoveredJobs = await performGenericJobDiscovery(careerProfile, search);
    
    if (discoveredJobs.length === 0) {
      await search.addReasoningLog(
        'completion',
        'No relevant opportunities found for this career profile. Generic filtering ensures we only save appropriate matches.',
        { phase: 'no_quality_results', careerField: careerProfile.careerDirection }
      );
      await updateSearchStatus(searchId, 'completed', 'No quality matches found');
      return;
    }
    
    // PHASE 3: Generic Job Analysis
    console.log(`🔬 Phase 3: Generic Job Analysis...`);
    const analyzedJobs = await performGenericJobAnalysis(discoveredJobs, search, careerProfile);
    
    // Save Jobs
    console.log(`💾 Saving generic job results...`);
    const savedCount = await saveJobsGeneric(analyzedJobs, userId, searchId, search);
    
    const totalDuration = Date.now() - searchStartTime;
    
    await search.addReasoningLog(
      'completion',
      `Generic job search complete! Found ${savedCount} relevant opportunities for ${careerProfile.careerDirection}. Field-agnostic filtering works for any job type.`,
      {
        jobsSaved: savedCount,
        totalDuration: totalDuration,
        searchTime: `${Math.round(totalDuration / 1000)} seconds`,
        careerField: careerProfile.careerDirection
      }
    );
    
    await updateSearchStatus(searchId, savedCount > 0 ? 'running' : 'completed', 
      `Found ${savedCount} relevant opportunities`);
    console.log(`✅ Generic job search complete: ${savedCount} jobs saved`);
    
  } catch (error) {
    console.error('Error in generic job search:', error);
    
    if (search) {
      await search.addReasoningLog(
        'error',
        `Generic job search encountered an issue: ${error.message}`,
        { error: error.message },
        false
      );
    }
    
    await updateSearchStatus(searchId, 'failed', error.message);
  }
}

// GENERIC JOB DISCOVERY
async function performGenericJobDiscovery(careerProfile, search) {
  try {
    const adzunaExtractor = new AdzunaJobExtractor();
    
    const apiHealth = await adzunaExtractor.getApiHealth();
    if (apiHealth.status !== 'healthy') {
      throw new Error(`Adzuna API unavailable: ${apiHealth.message}`);
    }
    
    const searchResults = await adzunaExtractor.extractJobsForCareerProfile(careerProfile, search, {
      maxJobs: 12,
      maxDaysOld: 21,
      sortBy: 'relevance'
    });
    
    const discoveredJobs = searchResults.jobs || [];
    
    console.log(`🔍 Initial discovery: ${discoveredJobs.length} jobs found, applying GENERIC filtering...`);
    
    // Apply GENERIC relevance filtering
    const relevantJobs = RelevanceFilter.filterJobsForRelevance(discoveredJobs, careerProfile, 55);
    
    await search.addReasoningLog(
      'web_search_discovery',
      `Generic job discovery completed! Found ${relevantJobs.length} relevant opportunities from ${discoveredJobs.length} total for ${careerProfile.careerDirection}. Filtering works for any job type.`,
      {
        totalJobsInitial: discoveredJobs.length,
        totalJobsFiltered: relevantJobs.length,
        filteredOut: discoveredJobs.length - relevantJobs.length,
        genericFiltering: true,
        careerField: careerProfile.careerDirection || 'General'
      }
    );
    
    return relevantJobs.slice(0, 8).map(job => ({
      ...job,
      extractedAt: new Date(),
      extractionMethod: 'generic_adzuna_api_with_filtering',
      contentQuality: job.contentQuality || 'high',
      matchScore: job.relevanceScore || 75
    }));
    
  } catch (error) {
    console.error('Error in generic job discovery:', error);
    throw error;
  }
}

// GENERIC CAREER ANALYSIS
async function analyzeGenericCareerProfile(resumeData) {
  try {
    // Determine user's career field from their experience
    const currentRole = resumeData.experience?.[0]?.title || '';
    const allRoles = resumeData.experience?.map(exp => exp.title).join(', ') || '';
    const skills = resumeData.skills?.map(skill => typeof skill === 'string' ? skill : skill.name).join(', ') || '';
    
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert career strategist. Analyze any career background and create targeted job search criteria.

IMPORTANT RULES:
1. Include BOTH specific titles AND broad base titles for maximum coverage
2. For any field (engineering, marketing, sales, etc.) include progression levels
3. Extract the core job function and include variations
4. Don't assume any specific field - work with what's provided

Examples:
- If someone is a "Senior Software Engineer", include: ["Software Engineer", "Senior Software Engineer", "Staff Engineer", "Principal Engineer"]
- If someone is a "Marketing Manager", include: ["Marketing Manager", "Senior Marketing Manager", "Marketing Director", "Growth Manager"]
- If someone is a "Data Scientist", include: ["Data Scientist", "Senior Data Scientist", "ML Engineer", "Research Scientist"]`
        },
        {
          role: "user",
          content: `Analyze this career profile and create targeted search criteria:

Current Role: "${currentRole}"
Career History: ${allRoles}
Skills: ${skills}

Return JSON with comprehensive targeting:
{
  "targetJobTitles": [
    "// Include base title, senior versions, and related roles",
    "// Example: if current is 'Software Engineer', include variations"
  ],
  "targetKeywords": ["// Extract 4-6 most relevant skills/technologies"],
  "experienceLevel": "// entry, junior, mid, senior, lead, principal, executive",
  "careerDirection": "// Brief description of career focus"
}

Be comprehensive but relevant to the actual background provided.`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      const profile = JSON.parse(jsonMatch[0]);
      
      // SAFETY: Ensure we have enough variety in job titles
      if (profile.targetJobTitles && profile.targetJobTitles.length < 3) {
        profile.targetJobTitles = enhanceJobTitles(profile.targetJobTitles, currentRole);
      }
      
      return {
        ...profile,
        preferredLocations: ['Remote', 'New York', 'San Francisco', 'Austin'],
        workArrangement: 'remote'
      };
    }
    
    return createGenericFallbackCareerProfile(currentRole, skills);
    
  } catch (error) {
    console.error('Error in generic career analysis:', error);
    return createGenericFallbackCareerProfile(
      resumeData.experience?.[0]?.title || 'Professional',
      resumeData.skills?.map(s => typeof s === 'string' ? s : s.name).join(', ') || ''
    );
  }
}

function enhanceJobTitles(existingTitles, currentRole) {
  const enhanced = [...existingTitles];
  
  // Add base version if not present
  const baseRole = currentRole.replace(/^(senior|sr|junior|jr|lead|principal|staff|director|head|chief|vp|vice president)\s+/i, '').trim();
  if (baseRole && !enhanced.some(title => title.toLowerCase().includes(baseRole.toLowerCase()))) {
    enhanced.unshift(baseRole);
  }
  
  // Add senior version if not present
  if (baseRole && !enhanced.some(title => title.toLowerCase().includes('senior'))) {
    enhanced.push(`Senior ${baseRole}`);
  }
  
  return enhanced;
}

function createGenericFallbackCareerProfile(currentRole, skills) {
  const baseRole = currentRole.replace(/^(senior|sr|junior|jr|lead|principal|staff|director|head|chief|vp|vice president)\s+/i, '').trim() || 'Professional';
  const skillsArray = skills.split(',').map(s => s.trim()).filter(s => s.length > 0).slice(0, 4);
  
  return {
    targetJobTitles: [
      baseRole,
      `Senior ${baseRole}`,
      `Lead ${baseRole}`,
      currentRole // Include the full original title too
    ].filter((title, index, arr) => arr.indexOf(title) === index), // Remove duplicates
    targetKeywords: skillsArray.length > 0 ? skillsArray : ['professional', 'experience', 'management'],
    experienceLevel: 'mid',
    careerDirection: `${baseRole} career progression`,
    preferredLocations: ['Remote'],
    workArrangement: 'remote'
  };
}

// GENERIC JOB ANALYSIS
async function performGenericJobAnalysis(discoveredJobs, search, careerProfile) {
  const analyzedJobs = [];
  
  console.log(`🔬 Starting generic analysis of ${discoveredJobs.length} pre-filtered jobs...`);
  
  for (const job of discoveredJobs) {
    try {
      const analysis = await analyzeJobGeneric(job, careerProfile);
      
      analyzedJobs.push({
        ...job,
        analysis: analysis,
        analysisError: null,
        premiumAnalysis: true
      });
      
      await search.addReasoningLog(
        'premium_analysis',
        `"${job.title}" at ${job.company} - Generic analysis complete (Relevance: ${job.relevanceScore}%)`,
        {
          jobTitle: job.title,
          companyName: job.company,
          relevanceScore: job.relevanceScore,
          skillsFound: analysis?.keySkills?.length || 0,
          careerField: careerProfile.careerDirection
        }
      );
      
    } catch (error) {
      console.error(`Error analyzing ${job.title}:`, error);
      analyzedJobs.push({
        ...job,
        analysis: createGenericFallbackAnalysis(),
        analysisError: error.message
      });
    }
  }
  
  return analyzedJobs;
}

async function analyzeJobGeneric(job, careerProfile) {
  // Create generic skills based on career field
  const skills = createGenericSkillsForCareer(careerProfile);

  return {
    requirements: ['Relevant experience in the field', 'Strong problem-solving skills'],
    responsibilities: ['Execute on key initiatives', 'Collaborate with team members'],
    qualifications: {
      required: ['Bachelor\'s degree or equivalent experience', 'Relevant years of experience'],
      preferred: ['Advanced degree', 'Industry certifications']
    },
    keySkills: skills,
    experienceLevel: ValidationUtils.normalizeExperienceLevel(careerProfile.experienceLevel || 'mid'),
    workArrangement: ValidationUtils.normalizeWorkArrangement('remote'),
    analysisMetadata: {
      analyzedAt: new Date(),
      algorithmVersion: '4.0-generic-adzuna-api',
      analysisType: 'generic_adzuna_api_analysis',
      qualityLevel: 'standard',
      careerField: careerProfile.careerDirection
    }
  };
}

function createGenericSkillsForCareer(careerProfile) {
  // Create appropriate skills based on career direction
  const careerField = (careerProfile.careerDirection || '').toLowerCase();
  let skills = [];
  
  if (careerField.includes('engineering') || careerField.includes('software') || careerField.includes('developer')) {
    skills = [
      { name: 'Programming', importance: 8, category: 'technical', skillType: 'programming' },
      { name: 'Problem Solving', importance: 7, category: 'soft', skillType: 'analytical' },
      { name: 'Team Collaboration', importance: 6, category: 'soft', skillType: 'communication' }
    ];
  } else if (careerField.includes('product') && careerField.includes('management')) {
    skills = [
      { name: 'Product Strategy', importance: 8, category: 'business', skillType: 'management' },
      { name: 'Stakeholder Management', importance: 7, category: 'soft', skillType: 'communication' },
      { name: 'Data Analysis', importance: 6, category: 'technical', skillType: 'analytical' }
    ];
  } else if (careerField.includes('data') || careerField.includes('analytics')) {
    skills = [
      { name: 'Data Analysis', importance: 8, category: 'technical', skillType: 'analytical' },
      // services/jobSearch.service.js - FINAL PART (Continued from previous)

      { name: 'Statistical Analysis', importance: 7, category: 'technical', skillType: 'analytical' },
      { name: 'Communication', importance: 6, category: 'soft', skillType: 'communication' }
    ];
  } else if (careerField.includes('marketing')) {
    skills = [
      { name: 'Marketing Strategy', importance: 8, category: 'business', skillType: 'management' },
      { name: 'Content Creation', importance: 7, category: 'soft', skillType: 'communication' },
      { name: 'Analytics', importance: 6, category: 'technical', skillType: 'analytical' }
    ];
  } else if (careerField.includes('design')) {
    skills = [
      { name: 'Design Thinking', importance: 8, category: 'technical', skillType: 'design' },
      { name: 'User Experience', importance: 7, category: 'technical', skillType: 'design' },
      { name: 'Collaboration', importance: 6, category: 'soft', skillType: 'communication' }
    ];
  } else if (careerField.includes('sales')) {
    skills = [
      { name: 'Sales Strategy', importance: 8, category: 'business', skillType: 'management' },
      { name: 'Relationship Building', importance: 7, category: 'soft', skillType: 'communication' },
      { name: 'Negotiation', importance: 6, category: 'soft', skillType: 'communication' }
    ];
  } else {
    // Generic fallback skills
    skills = [
      { name: 'Communication', importance: 7, category: 'soft', skillType: 'communication' },
      { name: 'Problem Solving', importance: 7, category: 'soft', skillType: 'general' },
      { name: 'Leadership', importance: 6, category: 'soft', skillType: 'management' },
      { name: 'Project Management', importance: 6, category: 'business', skillType: 'management' }
    ];
  }
  
  return ValidationUtils.validateAndNormalizeSkills(skills);
}

function createGenericFallbackAnalysis() {
  const skills = ValidationUtils.validateAndNormalizeSkills([
    { name: 'Communication', importance: 6, category: 'soft', skillType: 'communication' },
    { name: 'Problem Solving', importance: 6, category: 'soft', skillType: 'general' }
  ]);

  return {
    requirements: ['Relevant experience'],
    responsibilities: ['Perform assigned duties'],
    qualifications: { required: ['Relevant education'], preferred: [] },
    keySkills: skills,
    experienceLevel: 'mid',
    workArrangement: 'unknown',
    analysisMetadata: {
      analyzedAt: new Date(),
      algorithmVersion: '4.0-generic-fallback',
      analysisType: 'generic_fallback',
      qualityLevel: 'basic'
    }
  };
}

// GENERIC JOB SAVING
async function saveJobsGeneric(analyzedJobs, userId, searchId, search) {
  let savedCount = 0;
  const maxJobsPerSearch = 8;
  
  console.log(`💾 Starting to save ${Math.min(analyzedJobs.length, maxJobsPerSearch)} generic jobs...`);
  
  for (const jobData of analyzedJobs.slice(0, maxJobsPerSearch)) {
    try {
      // Check for duplicates
      const existing = await Job.findOne({
        userId,
        $or: [
          { sourceUrl: jobData.jobUrl || jobData.sourceUrl },
          { 
            title: { $regex: new RegExp(`^${escapeRegex(jobData.title)}$`, 'i') },
            company: { $regex: new RegExp(`^${escapeRegex(jobData.company)}$`, 'i') }
          }
        ]
      });
      
      if (existing) {
        console.log(`⚠️ Skipping duplicate: "${jobData.title}" at ${jobData.company}`);
        continue;
      }
      
      // Validate and normalize data
      const experienceLevel = ValidationUtils.normalizeExperienceLevel(jobData.analysis?.experienceLevel || 'mid');
      const workArrangement = ValidationUtils.normalizeWorkArrangement(jobData.analysis?.workArrangement || 'unknown');
      const normalizedSkills = ValidationUtils.validateAndNormalizeSkills(jobData.analysis?.keySkills || []);
      
      // Create job record
      const job = new Job({
        userId,
        title: jobData.title,
        company: jobData.company,
        location: parseLocation(jobData.location),
        description: jobData.fullContent || jobData.description,
        sourceUrl: jobData.jobUrl || jobData.sourceUrl,
        sourcePlatform: createValidSourcePlatform(jobData.sourcePlatform),
        isAiGenerated: true,
        applicationStatus: 'NOT_APPLIED',
        aiSearchId: searchId,
        salary: jobData.salary || {},
        jobType: jobData.jobType || 'FULL_TIME',
        
        analysisStatus: {
          status: 'completed',
          progress: 100,
          message: `Generic analysis complete! Found ${normalizedSkills.length} key skills for this ${jobData.analysis?.analysisMetadata?.careerField || 'professional'} role.`,
          updatedAt: new Date(),
          completedAt: new Date(),
          canViewJob: true,
          skillsFound: normalizedSkills.length,
          experienceLevel: experienceLevel,
          modelUsed: 'gpt-4o-generic',
          analysisType: 'generic_adzuna_api_analysis',
          searchApproach: '3-phase-intelligent-adzuna-api', // Valid enum value
          qualityLevel: 'adzuna-api-enhanced' // Valid enum value
        },
        
        parsedData: {
          requirements: jobData.analysis?.requirements || [],
          responsibilities: jobData.analysis?.responsibilities || [],
          qualifications: jobData.analysis?.qualifications || { required: [], preferred: [] },
          benefits: jobData.analysis?.benefits || [],
          keySkills: normalizedSkills,
          experienceLevel: experienceLevel,
          yearsOfExperience: jobData.analysis?.yearsOfExperience || { minimum: 3, preferred: 5 },
          educationRequirements: jobData.analysis?.educationRequirements || [],
          workArrangement: workArrangement,
          industryContext: jobData.analysis?.industryContext || 'technology',
          roleCategory: jobData.analysis?.roleCategory || 'general',
          technicalComplexity: jobData.analysis?.technicalComplexity || 'medium',
          leadershipRequired: jobData.analysis?.leadershipRequired || false,
          extractedAt: new Date(),
          extractionMethod: 'generic_adzuna_api_analysis',
          
          adzunaApiData: {
            platform: jobData.sourcePlatform,
            originalUrl: jobData.jobUrl,
            postedDate: jobData.postedDate,
            adzunaId: jobData.adzunaData?.id,
            category: jobData.adzunaData?.category,
            discoveryMethod: 'generic_adzuna_api_aggregation'
          },
          
          analysisMetadata: jobData.analysis?.analysisMetadata || {
            analyzedAt: new Date(),
            algorithmVersion: '4.0-generic-adzuna-api',
            analysisType: 'generic_adzuna_api_analysis',
            qualityLevel: 'standard'
          }
        },
        
        aiSearchMetadata: {
          searchScore: jobData.relevanceScore || 75,
          discoveryMethod: 'generic_adzuna_api_discovery',
          extractionSuccess: !jobData.analysisError,
          contentQuality: jobData.contentQuality || 'high',
          premiumAnalysis: true,
          intelligentDiscovery: true,
          adzunaApiDiscovery: true,
          phase: '3-phase-intelligent-adzuna-api',
          originalPlatform: jobData.sourcePlatform,
          relevanceScore: jobData.relevanceScore || 75,
          
          adzunaApiMetadata: {
            discoveryMethod: 'generic_adzuna_api_aggregation',
            apiProvider: 'adzuna',
            genericRelevanceFiltering: true,
            worksForAllJobTypes: true
          }
        }
      });
      
      await job.save();
      savedCount++;
      
      // Update search progress
      await AiJobSearch.findByIdAndUpdate(searchId, {
        $inc: { jobsFoundToday: 1, totalJobsFound: 1 },
        $push: {
          jobsFound: {
            jobId: job._id,
            title: job.title,
            company: job.company,
            foundAt: new Date(),
            extractionMethod: 'generic_adzuna_api_discovery',
            contentQuality: jobData.contentQuality || 'high',
            matchScore: jobData.relevanceScore || 75,
            premiumAnalysis: true,
            sourcePlatform: jobData.sourcePlatform,
            relevanceScore: jobData.relevanceScore || 75,
            apiSource: 'adzuna_aggregator'
          }
        }
      });
      
      console.log(`✅ GENERIC SAVE: ${job.title} at ${job.company} (Relevance: ${jobData.relevanceScore || 75}%) [${savedCount}/${maxJobsPerSearch}]`);
      
    } catch (error) {
      console.error(`❌ ERROR saving generic job ${jobData.title}:`, error);
    }
  }
  
  console.log(`💾 Generic job saving completed: ${savedCount} jobs saved`);
  return savedCount;
}

// UTILITY FUNCTIONS
function parseLocation(locationString) {
  if (!locationString) return { remote: true };
  
  const lower = locationString.toLowerCase();
  if (lower.includes('remote')) {
    return { remote: true, city: null, country: 'USA' };
  }
  
  const parts = locationString.split(',').map(p => p.trim());
  return {
    city: parts[0] || null,
    state: parts[1] || null,
    country: parts[2] || 'USA',
    remote: false
  };
}

function createValidSourcePlatform(originalPlatform) {
  if (!originalPlatform) return 'AI_FOUND_ADZUNA_OTHER';
  
  const platform = originalPlatform.toLowerCase();
  
  const platformMap = {
    'indeed': 'AI_FOUND_ADZUNA_INDEED',
    'linkedin': 'AI_FOUND_ADZUNA_LINKEDIN',
    'monster': 'AI_FOUND_ADZUNA_MONSTER',
    'careerbuilder': 'AI_FOUND_ADZUNA_CAREERBUILDER',
    'glassdoor': 'AI_FOUND_ADZUNA_GLASSDOOR'
  };
  
  for (const [key, value] of Object.entries(platformMap)) {
    if (platform.includes(key)) {
      return value;
    }
  }
  
  return 'AI_FOUND_ADZUNA_OTHER';
}

function extractSearchCriteria(resumeData) {
  return {
    jobTitle: resumeData.experience?.[0]?.title || 'Professional',
    skills: resumeData.skills?.slice(0, 10).map(s => typeof s === 'string' ? s : s.name) || [],
    location: resumeData.contactInfo?.location || 'Remote',
    experienceLevel: 'Mid'
  };
}

async function isDailyLimitReached(search) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  if (!search.lastSearchDate || search.lastSearchDate < today) {
    search.jobsFoundToday = 0;
    search.lastSearchDate = today;
    await search.save();
    return false;
  }
  
  return search.jobsFoundToday >= search.dailyLimit;
}

async function updateSearchStatus(searchId, status, message) {
  await AiJobSearch.findByIdAndUpdate(searchId, {
    status,
    lastUpdateMessage: message,
    lastUpdated: new Date()
  });
  console.log(`Search ${searchId}: ${status} - ${message}`);
}

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// EXISTING EXPORTS (maintained for compatibility)
exports.getUserAiSearches = async (userId) => {
  return await AiJobSearch.find({ userId }).sort({ createdAt: -1 });
};

exports.pauseAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Generic Adzuna API search paused by user request',
    { phase: 'user_pause', pausedAt: new Date() }
  );
  
  search.status = 'paused';
  search.lastUpdateMessage = 'Paused by user';
  await search.save();
  
  return { message: 'Generic search paused successfully' };
};

exports.resumeAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'initialization',
    'Generic Adzuna API search resumed by user - continuing with field-agnostic filtering that works for any job type',
    { 
      phase: 'user_resume', 
      resumedAt: new Date(),
      searchMethod: 'Generic Adzuna API with field-agnostic filtering'
    }
  );
  
  search.status = 'running';
  search.lastUpdateMessage = 'Resumed by user - Generic approach';
  await search.save();
  
  const resume = await Resume.findById(search.resumeId);
  if (resume) {
    performGenericAdzunaJobSearch(searchId, userId, resume).catch(error => {
      console.error('Error resuming generic search:', error);
    });
  }
  
  return { message: 'Generic search resumed successfully' };
};

exports.deleteAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Generic Adzuna API search cancelled by user request',
    { 
      phase: 'user_cancellation', 
      cancelledAt: new Date(),
      searchMethod: 'Generic Adzuna API aggregation'
    }
  );
  
  search.status = 'cancelled';
  search.lastUpdateMessage = 'Cancelled by user';
  await search.save();
  
  return { message: 'Generic search cancelled successfully' };
};

================
File: backend/services/memoryService.js
================
// backend/services/memoryService.js
const { openai } = require('../config/openai');
const UserMemory = require('../models/mongodb/userMemory.model');
const Conversation = require('../models/mongodb/conversation.model');
const Resume = require('../models/mongodb/resume.model');
const Job = require('../models/mongodb/job.model');

class MemoryService {
  /**
   * Extract memories from a conversation message using AI
   */
  static async extractMemoriesFromMessage(userId, message, conversationContext = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId) || 
                        await UserMemory.createForUser(userId);

      // Get existing memories for context
      const existingMemories = userMemory.getRelevantMemories({
        types: ['preference', 'skill', 'career_goal', 'personality_trait'],
        tags: conversationContext.tags || []
      }, 5);

      const systemPrompt = this.buildMemoryExtractionPrompt(existingMemories, conversationContext);
      
      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: message }
        ],
        temperature: 0.3,
        max_tokens: 800,
        response_format: { type: 'json_object' }
      });

      const extractedData = JSON.parse(response.choices[0].message.content);
      const memories = [];

      // Process extracted memories
      if (extractedData.memories && extractedData.memories.length > 0) {
        for (const memoryData of extractedData.memories) {
          const memory = await this.addMemoryToUser(userId, {
            ...memoryData,
            source: {
              conversationId: conversationContext.conversationId,
              messageId: conversationContext.messageId,
              extractionMethod: 'ai_extracted',
              model: 'gpt-4-turbo-preview'
            },
            context: conversationContext
          });
          memories.push(memory);
        }
      }

      return {
        memories,
        insights: extractedData.insights || [],
        profileUpdates: extractedData.profileUpdates || {}
      };

    } catch (error) {
      console.error('Memory extraction error:', error);
      return { memories: [], insights: [], profileUpdates: {} };
    }
  }

  /**
   * Add a memory to user's memory system
   */
  static async addMemoryToUser(userId, memoryData) {
    try {
      let userMemory = await UserMemory.findByUserId(userId);
      
      if (!userMemory) {
        userMemory = await UserMemory.createForUser(userId);
      }

      const memory = userMemory.addMemory(memoryData);
      await userMemory.save();

      return memory;

    } catch (error) {
      console.error('Add memory error:', error);
      throw error;
    }
  }

  /**
   * Get relevant memories for AI context
   */
  static async getRelevantMemoriesForContext(userId, context) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return [];

      const relevantMemories = userMemory.getRelevantMemories(context, 15);
      
      // Update access count for retrieved memories
      relevantMemories.forEach(memory => {
        memory.usage.accessCount += 1;
        memory.usage.lastAccessedAt = new Date();
      });

      await userMemory.save();

      return relevantMemories;

    } catch (error) {
      console.error('Get relevant memories error:', error);
      return [];
    }
  }

  /**
   * Build context for AI assistant using memories
   */
  static async buildAIContext(userId, currentContext = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return '';

      // Get different types of relevant memories
      const personalityMemories = userMemory.getMemoriesByType('personality_trait', { 
        minConfidence: 0.6, 
        sortBy: 'confidence' 
      }).slice(0, 3);

      const preferenceMemories = userMemory.getMemoriesByType('preference', { 
        minConfidence: 0.6, 
        sortBy: 'recent' 
      }).slice(0, 5);

      const skillMemories = userMemory.getMemoriesByType('skill', { 
        minConfidence: 0.7, 
        sortBy: 'confidence' 
      }).slice(0, 5);

      const goalMemories = userMemory.getMemoriesByType('career_goal', { 
        minConfidence: 0.6, 
        sortBy: 'recent' 
      }).slice(0, 3);

      // Build context string
      let context = '\n=== USER MEMORY CONTEXT ===\n';

      if (personalityMemories.length > 0) {
        context += '\nPersonality & Communication Style:\n';
        personalityMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (preferenceMemories.length > 0) {
        context += '\nPreferences & Work Style:\n';
        preferenceMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (skillMemories.length > 0) {
        context += '\nSkills & Experience:\n';
        skillMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      if (goalMemories.length > 0) {
        context += '\nCareer Goals & Aspirations:\n';
        goalMemories.forEach(memory => {
          context += `- ${memory.content} (confidence: ${Math.round(memory.confidence * 100)}%)\n`;
        });
      }

      // Add profile insights
      if (userMemory.profile && Object.keys(userMemory.profile).length > 0) {
        context += '\nUser Profile Insights:\n';
        
        if (userMemory.profile.careerStage) {
          context += `- Career Stage: ${userMemory.profile.careerStage}\n`;
        }
        
        if (userMemory.profile.communicationStyle) {
          const style = userMemory.profile.communicationStyle;
          context += `- Communication Preference: ${style.formality || 'neutral'} formality, ${style.detail_preference || 'moderate'} detail level\n`;
        }
      }

      context += '\n=== END MEMORY CONTEXT ===\n\n';
      context += 'IMPORTANT: Use this memory context to personalize your responses, but don\'t explicitly mention that you\'re using memory unless directly asked about it.\n';

      return context;

    } catch (error) {
      console.error('Build AI context error:', error);
      return '';
    }
  }

  /**
   * Update user profile based on conversation patterns
   */
  static async updateUserProfile(userId, conversationData) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return;

      // Analyze conversation patterns
      const analysis = await this.analyzeConversationPatterns(conversationData);
      
      // Update profile based on analysis
      if (analysis.communicationStyle) {
        userMemory.profile.communicationStyle = {
          ...userMemory.profile.communicationStyle,
          ...analysis.communicationStyle
        };
      }

      if (analysis.skills && analysis.skills.length > 0) {
        userMemory.profile.skills = userMemory.profile.skills || [];
        analysis.skills.forEach(skill => {
          const existingSkill = userMemory.profile.skills.find(s => s.name === skill.name);
          if (existingSkill) {
            existingSkill.confidence = Math.max(existingSkill.confidence, skill.confidence);
            existingSkill.lastMentioned = new Date();
          } else {
            userMemory.profile.skills.push({
              ...skill,
              lastMentioned: new Date()
            });
          }
        });
      }

      await userMemory.save();

    } catch (error) {
      console.error('Update user profile error:', error);
    }
  }

  /**
   * Generate conversation summary with memory extraction
   */
  static async generateConversationSummary(conversationId) {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) throw new Error('Conversation not found');

      const messages = conversation.messages.slice(-20); // Last 20 messages
      const messageText = messages.map(m => `${m.type.toUpperCase()}: ${m.content}`).join('\n');

      const systemPrompt = `You are an AI assistant that creates intelligent conversation summaries with memory extraction.

Analyze this conversation and provide:
1. A concise summary of what was discussed
2. Key topics covered
3. Action items or outcomes
4. Important memories that should be retained about the user
5. User preferences or patterns observed

Format your response as JSON:
{
  "summary": "Brief summary of the conversation",
  "keyTopics": ["topic1", "topic2", "topic3"],
  "actionItems": ["action1", "action2"],
  "outcomes": ["outcome1", "outcome2"],
  "memories": [
    {
      "type": "preference|skill|career_goal|personality_trait|etc",
      "category": "personal|professional|technical|behavioral|contextual",
      "content": "What you learned about the user",
      "confidence": 0.8,
      "importance": "low|medium|high|critical",
      "tags": ["tag1", "tag2"]
    }
  ],
  "insights": ["insight1", "insight2"]
}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: messageText }
        ],
        temperature: 0.3,
        max_tokens: 1000,
        response_format: { type: 'json_object' }
      });

      const summaryData = JSON.parse(response.choices[0].message.content);

      // Update conversation with summary
      conversation.updateSummary({
        content: summaryData.summary,
        keyTopics: summaryData.keyTopics || [],
        actionItems: summaryData.actionItems || [],
        outcomes: summaryData.outcomes || []
      });

      await conversation.save();

      // Extract and store memories
      if (summaryData.memories && summaryData.memories.length > 0) {
        for (const memoryData of summaryData.memories) {
          await this.addMemoryToUser(conversation.userId, {
            ...memoryData,
            source: {
              conversationId: conversationId,
              extractionMethod: 'summary_extracted',
              model: 'gpt-4-turbo-preview'
            }
          });
        }
      }

      return summaryData;

    } catch (error) {
      console.error('Generate conversation summary error:', error);
      throw error;
    }
  }

  /**
   * Search memories with intelligent ranking
   */
  static async searchMemories(userId, query, options = {}) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return [];

      // First, do a basic text search
      let memories = userMemory.searchMemories(query, options);

      // If we have few results, use AI for semantic search
      if (memories.length < 5) {
        const semanticMemories = await this.semanticMemorySearch(userMemory, query);
        memories = [...memories, ...semanticMemories];
        
        // Remove duplicates
        memories = memories.filter((memory, index, self) => 
          index === self.findIndex(m => m.id === memory.id)
        );
      }

      // Rank memories by relevance
      return memories.sort((a, b) => {
        const aScore = this.calculateSearchRelevance(a, query);
        const bScore = this.calculateSearchRelevance(b, query);
        return bScore - aScore;
      });

    } catch (error) {
      console.error('Search memories error:', error);
      return [];
    }
  }

  /**
   * Perform memory cleanup and optimization
   */
  static async performMemoryMaintenance(userId) {
    try {
      const userMemory = await UserMemory.findByUserId(userId);
      if (!userMemory) return;

      // Decay old memories
      const decayedCount = userMemory.decayMemories();

      // Merge similar memories
      const mergedCount = await this.mergeSimilarMemories(userMemory);

      // Update profile
      userMemory.updateProfile();

      await userMemory.save();

      return {
        decayedMemories: decayedCount,
        mergedMemories: mergedCount,
        totalMemories: userMemory.analytics.totalMemories
      };

    } catch (error) {
      console.error('Memory maintenance error:', error);
      return null;
    }
  }

  // ===================================================================
  // PRIVATE HELPER METHODS
  // ===================================================================

  /**
   * Build system prompt for memory extraction
   */
  static buildMemoryExtractionPrompt(existingMemories, context) {
    let prompt = `You are an AI memory extraction system. Analyze user messages to extract meaningful memories about their preferences, skills, goals, personality, and work style.

EXISTING MEMORIES (to avoid duplicates):
${existingMemories.map(m => `- ${m.type}: ${m.content}`).join('\n')}

CONTEXT:
- Page: ${context.page || 'unknown'}
- Category: ${context.category || 'general'}

Extract memories in this JSON format:
{
  "memories": [
    {
      "type": "preference|skill|career_goal|experience|achievement|challenge|personality_trait|communication_style|work_style|industry_knowledge|tool_preference|feedback_pattern",
      "category": "personal|professional|technical|behavioral|contextual",
      "content": "Clear, specific statement about the user",
      "confidence": 0.1-1.0,
      "importance": "low|medium|high|critical",
      "tags": ["relevant", "tags"]
    }
  ],
  "insights": ["Observable patterns or insights about the user"],
  "profileUpdates": {
    "communicationStyle": {
      "formality": "very_formal|formal|neutral|casual|very_casual",
      "detail_preference": "brief|moderate|detailed|comprehensive"
    }
  }
}

Only extract memories that are:
1. Specific and actionable
2. Likely to be useful for future conversations
3. Not duplicating existing memories
4. Expressed with reasonable confidence

IMPORTANT: Only extract memories if the user message contains clear, specific information. Don't infer too much from brief responses.`;

    return prompt;
  }

  /**
   * Analyze conversation patterns
   */
  static async analyzeConversationPatterns(conversationData) {
    try {
      // Simple pattern analysis - can be enhanced with ML
      const analysis = {
        communicationStyle: {},
        skills: [],
        preferences: []
      };

      // Analyze message length patterns
      const avgMessageLength = conversationData.userMessages?.reduce((sum, msg) => 
        sum + msg.content.length, 0) / (conversationData.userMessages?.length || 1);

      if (avgMessageLength < 50) {
        analysis.communicationStyle.detail_preference = 'brief';
      } else if (avgMessageLength > 200) {
        analysis.communicationStyle.detail_preference = 'detailed';
      } else {
        analysis.communicationStyle.detail_preference = 'moderate';
      }

      // Analyze formality
      const formalWords = ['please', 'thank you', 'would you', 'could you'];
      const casualWords = ['hey', 'thanks', 'cool', 'awesome'];
      
      let formalCount = 0;
      let casualCount = 0;

      conversationData.userMessages?.forEach(msg => {
        const content = msg.content.toLowerCase();
        formalWords.forEach(word => {
          if (content.includes(word)) formalCount++;
        });
        casualWords.forEach(word => {
          if (content.includes(word)) casualCount++;
        });
      });

      if (formalCount > casualCount) {
        analysis.communicationStyle.formality = 'formal';
      } else if (casualCount > formalCount) {
        analysis.communicationStyle.formality = 'casual';
      } else {
        analysis.communicationStyle.formality = 'neutral';
      }

      return analysis;

    } catch (error) {
      console.error('Analyze conversation patterns error:', error);
      return {};
    }
  }

/**
 * Semantic memory search using AI - FIXED VERSION
 */
static async semanticMemorySearch(userMemory, query) {
  try {
    const allMemories = userMemory.memories.filter(m => m.isActive);
    if (allMemories.length === 0) {
      return [];
    }

    const memoryContents = allMemories.map(m => `${m.id}: ${m.content}`).join('\n');

    const systemPrompt = `Find memories that are semantically related to the user's query, even if they don't contain exact keywords.

MEMORIES:
${memoryContents}

USER QUERY: ${query}

Return ONLY a JSON array of memory IDs that are relevant: ["memory_id_1", "memory_id_2"]
If no memories are relevant, return an empty array: []`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: query }
      ],
      temperature: 0.3,
      max_tokens: 200,
      response_format: { type: 'json_object' }
    });

    console.log('🔍 Semantic search response:', response.choices[0].message.content);

    // FIXED: Proper JSON parsing and validation
    let parsedResponse;
    try {
      parsedResponse = JSON.parse(response.choices[0].message.content);
    } catch (parseError) {
      console.warn('Failed to parse semantic search response:', parseError);
      return [];
    }

    // FIXED: Handle different response formats
    let relevantIds = [];
    if (Array.isArray(parsedResponse)) {
      relevantIds = parsedResponse;
    } else if (parsedResponse.ids && Array.isArray(parsedResponse.ids)) {
      relevantIds = parsedResponse.ids;
    } else if (parsedResponse.results && Array.isArray(parsedResponse.results)) {
      relevantIds = parsedResponse.results;
    } else if (parsedResponse.relevant_memories && Array.isArray(parsedResponse.relevant_memories)) {
      // FIXED: Handle the actual response format the AI is using
      relevantIds = parsedResponse.relevant_memories;
    } else {
      console.warn('Unexpected semantic search response format:', parsedResponse);
      return [];
    }

    // FIXED: Ensure relevantIds is an array before using includes
    if (!Array.isArray(relevantIds)) {
      console.warn('relevantIds is not an array:', relevantIds);
      return [];
    }

    console.log('✅ Found relevant memory IDs:', relevantIds);
    const foundMemories = allMemories.filter(m => relevantIds.includes(m.id));
    console.log('✅ Returning', foundMemories.length, 'relevant memories');
    
    return foundMemories;

  } catch (error) {
    console.error('Semantic memory search error:', error);
    return [];
  }
}

  /**
   * Calculate search relevance score
   */
  static calculateSearchRelevance(memory, query) {
    const queryLower = query.toLowerCase();
    const contentLower = memory.content.toLowerCase();
    
    let score = memory.confidence;

    // Exact phrase match
    if (contentLower.includes(queryLower)) {
      score += 0.5;
    }

    // Word matches
    const queryWords = queryLower.split(' ');
    const contentWords = contentLower.split(' ');
    const matchedWords = queryWords.filter(word => contentWords.includes(word));
    score += (matchedWords.length / queryWords.length) * 0.3;

    // Tag matches
    const tagMatches = memory.tags.filter(tag => 
      tag.includes(queryLower) || queryLower.includes(tag)
    );
    score += tagMatches.length * 0.2;

    // Importance boost
    const importanceBoost = {
      'critical': 0.3,
      'high': 0.2,
      'medium': 0.1,
      'low': 0
    };
    score += importanceBoost[memory.importance] || 0;

    return Math.min(score, 1);
  }

  /**
   * Merge similar memories to reduce redundancy
   */
  static async mergeSimilarMemories(userMemory) {
    let mergedCount = 0;
    const memoriesToRemove = [];

    for (let i = 0; i < userMemory.memories.length; i++) {
      for (let j = i + 1; j < userMemory.memories.length; j++) {
        const memory1 = userMemory.memories[i];
        const memory2 = userMemory.memories[j];

        if (memory1.type === memory2.type && 
            memory1.category === memory2.category &&
            userMemory.calculateSimilarity(memory1.content, memory2.content) > 0.85) {
          
          // Merge the memories
          const strongerMemory = memory1.confidence >= memory2.confidence ? memory1 : memory2;
          const weakerMemory = memory1.confidence < memory2.confidence ? memory1 : memory2;

          strongerMemory.confidence = Math.min(1, strongerMemory.confidence + 0.1);
          strongerMemory.decay.reinforcementCount += weakerMemory.decay.reinforcementCount;
          strongerMemory.tags = [...new Set([...strongerMemory.tags, ...weakerMemory.tags])];

          memoriesToRemove.push(weakerMemory.id);
          mergedCount++;
        }
      }
    }

    // Remove merged memories
    userMemory.memories = userMemory.memories.filter(m => !memoriesToRemove.includes(m.id));

    return mergedCount;
  }
}

module.exports = MemoryService;

================
File: backend/services/recruiterImport.service.js
================
// backend/services/recruiterImport.service.js - OPTIMIZED VERSION
const csv = require('csv-parser');
const fs = require('fs');
const db = require('../config/postgresql');

class RecruiterImportService {
  static async importFromCSV(filePath) {
    const companies = new Map();
    const recruiters = [];
    let processedCount = 0;
    let errorCount = 0;

    console.log('🚀 Starting recruiter import from CSV...');

    return new Promise((resolve, reject) => {
      fs.createReadStream(filePath)
        .pipe(csv())
        .on('data', (row) => {
          try {
            // Process company data
            const companyData = this.extractCompanyData(row);
            const companyKey = `${companyData.name}_${companyData.website || 'no-website'}`;
            
            if (!companies.has(companyKey) && companyData.name) {
              companies.set(companyKey, companyData);
            }

            // Process recruiter data
            const recruiterData = this.extractRecruiterData(row, companyKey);
            if (recruiterData.firstName && recruiterData.lastName) {
              recruiters.push(recruiterData);
            }
            
            processedCount++;
            
            if (processedCount % 1000 === 0) {
              console.log(`📊 Processed ${processedCount} records...`);
            }
          } catch (error) {
            console.error(`❌ Error processing row ${processedCount}:`, error.message);
            errorCount++;
          }
        })
        .on('end', async () => {
          try {
            console.log(`📥 CSV parsing complete. Processing ${companies.size} companies and ${recruiters.length} recruiters...`);
            
            // Import to database
            const result = await this.bulkInsertData(Array.from(companies.values()), recruiters);
            
            resolve({
              companiesImported: result.companiesImported,
              recruitersImported: result.recruitersImported,
              totalProcessed: processedCount,
              errors: errorCount
            });
          } catch (error) {
            reject(error);
          }
        })
        .on('error', reject);
    });
  }

  static extractCompanyData(row) {
    return {
      name: row['Company Name'] || '',
      website: row['Website'] || '',
      foundedYear: this.parseInteger(row['Founded Year']),
      phone: row['Company HQ Phone'] || '',
      fax: row['Fax'] || '',
      stockTicker: row['Ticker'] || '',
      revenueRange: row['Revenue Range (in USD)'] || '',
      revenueUsdThousands: this.parseInteger(row['Revenue (in 000s USD)']),
      employeeCount: this.parseInteger(row['Employees']),
      employeeRange: row['Employee Range'] || '',
      ownershipType: row['Ownership Type'] || '',
      businessModel: row['Business Model'] || '',
      primaryIndustry: row['Primary Industry'] || '',
      subIndustry: row['Primary Sub-Industry'] || '',
      allIndustries: this.parseArray(row['All Industries']),
      allSubIndustries: this.parseArray(row['All Sub-Industries']),
      sicCodes: this.parseArray(row['SIC Codes']),
      naicsCodes: this.parseArray(row['NAICS Codes']),
      linkedinUrl: row['LinkedIn Company Profile URL'] || '',
      facebookUrl: row['Facebook Company Profile URL'] || '',
      twitterUrl: row['Twitter Company Profile URL'] || '',
      zoominfoUrl: row['ZoomInfo Company Profile URL'] || '',
      zoominfoId: row['ZoomInfo Company ID'] || '',
      alexaRank: this.parseInteger(row['Alexa Rank']),
      locationCount: this.parseInteger(row['Number of Locations']),
      fundingTotalUsdThousands: this.parseInteger(row['Total Funding Amount (in 000s USD)']),
      recentFundingUsdThousands: this.parseInteger(row['Recent Funding Amount (in 000s USD)']),
      recentFundingRound: row['Recent Funding Round'] || '',
      recentFundingDate: this.parseDate(row['Recent Funding Date']),
      recentInvestors: this.parseArray(row['Recent Investors']),
      allInvestors: this.parseArray(row['All Investors']),
      isCertifiedActive: row['Certified Active Company'] === 'Yes',
      certificationDate: this.parseDate(row['Certification Date'])
    };
  }

  static extractRecruiterData(row, companyKey) {
    return {
      firstName: row['First Name'] || '',
      lastName: row['Last Name'] || '',
      middleName: row['Middle Name'] || '',
      salutation: row['Salutation'] || '',
      suffix: row['Suffix'] || '',
      email: row['Email Address'] || '',
      emailDomain: row['Email Domain'] || '',
      supplementalEmail: row['Supplemental Email'] || '',
      mobilePhone: row['Mobile phone'] || '',
      directPhone: row['Direct Phone Number'] || '',
      title: row['Job Title'] || '',
      jobTitleHierarchyLevel: this.parseInteger(row['Job Title Hierarchy Level']),
      managementLevel: row['Management Level'] || '',
      jobStartDate: this.parseDate(row['Job Start Date']),
      jobFunction: row['Job Function'] || '',
      department: row['Department'] || '',
      companyDivision: row['Company Division Name'] || '',
      companyKey: companyKey,
      highestEducation: row['Highest Level of Education'] || '',
      contactAccuracyScore: this.parseInteger(row['Contact Accuracy Score']),
      contactAccuracyGrade: row['Contact Accuracy Grade'] || '',
      zoominfoProfileUrl: row['ZoomInfo Contact Profile URL'] || '',
      linkedinProfileUrl: row['LinkedIn Contact Profile URL'] || '',
      noticeProvidedDate: this.parseDate(row['Notice Provided Date']),
      personStreet: row['Person Street'] || '',
      personCity: row['Person City'] || '',
      personState: row['Person State'] || '',
      personZipCode: row['Person Zip Code'] || '',
      personCountry: row['Country'] || ''
    };
  }

  static async bulkInsertData(companies, recruiters) {
    let companiesImported = 0;
    let recruitersImported = 0;

    try {
      // First, insert/find industries in batch
      console.log('📥 Processing industries...');
      const industryMap = new Map();
      const uniqueIndustries = [...new Set(companies.map(c => c.primaryIndustry).filter(Boolean))];
      
      // Batch insert industries
      if (uniqueIndustries.length > 0) {
        const industryValues = uniqueIndustries.map((name, index) => 
          `($${index + 1}, $${index + 1})`
        ).join(', ');
        
        const industryQuery = `
          INSERT INTO industries (name, primary_category) 
          VALUES ${industryValues}
          ON CONFLICT (name) DO UPDATE SET updated_at = NOW()
          RETURNING id, name
        `;
        
        const result = await db.query(industryQuery, uniqueIndustries);
        result.rows.forEach(row => {
          industryMap.set(row.name, row.id);
        });
        
        console.log(`✅ Processed ${uniqueIndustries.length} industries`);
      }

      // Insert companies in batches
      console.log('📥 Importing companies in batches...');
      const companyMap = new Map();
      const batchSize = 100; // Reduced batch size for stability
      
      for (let i = 0; i < companies.length; i += batchSize) {
        const batch = companies.slice(i, i + batchSize);
        
        try {
          // Build batch insert query
          const values = [];
          const placeholders = [];
          let paramCount = 0;
          
          for (const company of batch) {
            const industryId = industryMap.get(company.primaryIndustry);
            const emailDomain = company.website ? 
              company.website.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] : 
              null;

            const companyValues = [
              company.name, company.website, company.foundedYear, company.phone,
              company.fax, company.stockTicker, company.revenueRange, company.revenueUsdThousands,
              company.employeeCount, company.employeeRange, company.ownershipType,
              company.businessModel, emailDomain, company.sicCodes, company.naicsCodes, 
              company.linkedinUrl, company.facebookUrl, company.twitterUrl, company.zoominfoUrl,
              company.zoominfoId, company.alexaRank, company.fundingTotalUsdThousands,
              company.recentFundingUsdThousands, company.recentFundingRound,
              company.recentFundingDate, company.recentInvestors, company.allInvestors,
              company.locationCount, company.isCertifiedActive, company.certificationDate,
              industryId
            ];

            values.push(...companyValues);
            
            const startParam = paramCount + 1;
            paramCount += companyValues.length;
            const endParam = paramCount;
            
            const placeholder = `($${Array.from({length: companyValues.length}, (_, j) => startParam + j).join(', $')})`;
            placeholders.push(placeholder);
          }

          const batchQuery = `
            INSERT INTO companies (
              name, website, founded_year, phone, fax, stock_ticker, revenue_range,
              revenue_usd_thousands, employee_count, employee_range, ownership_type,
              business_model, email_domain, sic_codes, naics_codes, linkedin_url,
              facebook_url, twitter_url, zoominfo_url, zoominfo_id, alexa_rank,
              funding_total_usd_thousands, recent_funding_usd_thousands, 
              recent_funding_round, recent_funding_date, recent_investors, 
              all_investors, location_count, is_certified_active, 
              certification_date, industry_id
            ) VALUES ${placeholders.join(', ')}
            ON CONFLICT (name, website) DO UPDATE SET 
              updated_at = NOW(),
              industry_id = EXCLUDED.industry_id,
              employee_count = EXCLUDED.employee_count,
              revenue_usd_thousands = EXCLUDED.revenue_usd_thousands
            RETURNING id, name, website
          `;

          const result = await db.query(batchQuery, values);
          
          // Map results back to company keys
          for (let j = 0; j < batch.length; j++) {
            const company = batch[j];
            const resultRow = result.rows[j];
            if (resultRow) {
              const companyKey = `${company.name}_${company.website || 'no-website'}`;
              companyMap.set(companyKey, resultRow.id);
              companiesImported++;
            }
          }

          console.log(`📊 Imported ${Math.min(i + batchSize, companies.length)} / ${companies.length} companies`);
          
        } catch (error) {
          console.error(`Error in company batch ${i}-${i + batchSize}:`, error.message);
          // Try individual inserts for this batch
          for (const company of batch) {
            try {
              const industryId = industryMap.get(company.primaryIndustry);
              const emailDomain = company.website ? 
                company.website.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] : 
                null;

              const query = `
                INSERT INTO companies (
                  name, website, founded_year, phone, fax, stock_ticker, revenue_range,
                  revenue_usd_thousands, employee_count, employee_range, ownership_type,
                  business_model, email_domain, sic_codes, naics_codes, linkedin_url,
                  facebook_url, twitter_url, zoominfo_url, zoominfo_id, alexa_rank,
                  funding_total_usd_thousands, recent_funding_usd_thousands, 
                  recent_funding_round, recent_funding_date, recent_investors, 
                  all_investors, location_count, is_certified_active, 
                  certification_date, industry_id
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31)
                ON CONFLICT (name, website) DO UPDATE SET 
                  updated_at = NOW(),
                  industry_id = EXCLUDED.industry_id,
                  employee_count = EXCLUDED.employee_count,
                  revenue_usd_thousands = EXCLUDED.revenue_usd_thousands
                RETURNING id
              `;

              const values = [
                company.name, company.website, company.foundedYear, company.phone,
                company.fax, company.stockTicker, company.revenueRange, company.revenueUsdThousands,
                company.employeeCount, company.employeeRange, company.ownershipType,
                company.businessModel, emailDomain, company.sicCodes, company.naicsCodes, 
                company.linkedinUrl, company.facebookUrl, company.twitterUrl, company.zoominfoUrl,
                company.zoominfoId, company.alexaRank, company.fundingTotalUsdThousands,
                company.recentFundingUsdThousands, company.recentFundingRound,
                company.recentFundingDate, company.recentInvestors, company.allInvestors,
                company.locationCount, company.isCertifiedActive, company.certificationDate,
                industryId
              ];

              const result = await db.query(query, values);
              const companyKey = `${company.name}_${company.website || 'no-website'}`;
              companyMap.set(companyKey, result.rows[0].id);
              companiesImported++;

            } catch (individualError) {
              // Skip this company
              console.log(`Skipping company ${company.name}: ${individualError.message}`);
            }
          }
        }
      }

      // Insert recruiters in batches
      console.log('📥 Importing recruiters in batches...');
      const recruiterBatchSize = 500;
      
      for (let i = 0; i < recruiters.length; i += recruiterBatchSize) {
        const batch = recruiters.slice(i, i + recruiterBatchSize);
        
        for (const recruiter of batch) {
          try {
            const companyId = companyMap.get(recruiter.companyKey);
            
            const query = `
              INSERT INTO recruiters (
                first_name, last_name, middle_name, salutation, suffix,
                email, email_domain, supplemental_email, mobile_phone,
                direct_phone, title, job_title_hierarchy_level,
                management_level, job_start_date, job_function, department,
                company_division, current_company_id, highest_education,
                contact_accuracy_score, contact_accuracy_grade,
                zoominfo_profile_url, linkedin_profile_url,
                notice_provided_date, person_street, person_city, person_state,
                person_zip_code, person_country
              ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29)
              ON CONFLICT (email) DO UPDATE SET 
                title = EXCLUDED.title,
                current_company_id = EXCLUDED.current_company_id,
                updated_at = NOW()
            `;

            const values = [
              recruiter.firstName, recruiter.lastName, recruiter.middleName,
              recruiter.salutation, recruiter.suffix, recruiter.email,
              recruiter.emailDomain, recruiter.supplementalEmail,
              recruiter.mobilePhone, recruiter.directPhone, recruiter.title,
              recruiter.jobTitleHierarchyLevel, recruiter.managementLevel,
              recruiter.jobStartDate, recruiter.jobFunction, recruiter.department,
              recruiter.companyDivision, companyId, recruiter.highestEducation,
              recruiter.contactAccuracyScore, recruiter.contactAccuracyGrade,
              recruiter.zoominfoProfileUrl, recruiter.linkedinProfileUrl,
              recruiter.noticeProvidedDate, recruiter.personStreet,
              recruiter.personCity, recruiter.personState, recruiter.personZipCode,
              recruiter.personCountry
            ];

            await db.query(query, values);
            recruitersImported++;

          } catch (error) {
            // Skip duplicates and other errors
            if (!error.message.includes('duplicate key')) {
              console.error(`Error inserting recruiter ${recruiter.firstName} ${recruiter.lastName}:`, error.message);
            }
          }
        }

        console.log(`📊 Imported ${Math.min(i + recruiterBatchSize, recruiters.length)} / ${recruiters.length} recruiters`);
      }

      console.log('✅ Import completed successfully');
      return { companiesImported, recruitersImported };

    } catch (error) {
      console.error('❌ Import failed:', error);
      throw error;
    }
  }

  // Helper methods
  static parseInteger(value) {
    if (!value || value === '') return null;
    const parsed = parseInt(value.toString().replace(/[^\d]/g, ''));
    return isNaN(parsed) ? null : parsed;
  }

  static parseDate(value) {
    if (!value || value === '') return null;
    const date = new Date(value);
    return isNaN(date.getTime()) ? null : date;
  }

  static parseArray(value) {
    if (!value || value === '') return [];
    return value.split(';').map(item => item.trim()).filter(item => item !== '');
  }
}

module.exports = RecruiterImportService;

================
File: backend/services/resumeAnalysis.service.js
================
// services/resumeAnalysis.service.js - FIXED REALISTIC SCORING
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');

/**
 * Analyze a resume using OpenAI with strict, realistic scoring criteria
 * @param {string} resumeId - MongoDB ID of the resume to analyze
 * @returns {Object} Analysis results
 */
exports.analyzeResume = async (resumeId) => {
  try {
    console.log(`Analyzing resume: ${resumeId}`);
    
    // Get the resume from the database
    const resume = await Resume.findById(resumeId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    // Check if parsed data is available
    if (!resume.parsedData || Object.keys(resume.parsedData).length === 0) {
      throw new Error('Resume parsing data not available for analysis');
    }
    
    console.log('Parsed data found, proceeding with OpenAI analysis');
    
    // Check if this is a tailored resume for enhanced analysis
    const isTailoredResume = resume.isTailored || false;
    const tailoredContext = isTailoredResume ? 
      `This is an AI-tailored resume optimized for ${resume.tailoredForJob?.jobTitle || 'a specific role'} at ${resume.tailoredForJob?.company || 'a target company'}. ` : '';
    
    // Convert parsed data to string for OpenAI
    const resumeData = JSON.stringify(resume.parsedData, null, 2);
    
    // FIXED: Much stricter and more realistic scoring prompt
    const prompt = `
    You are a STRICT resume analyst and ATS expert with 15+ years of experience. You are known for being tough but fair in your evaluations. Most resumes are mediocre and should score between 50-75.

    ${tailoredContext}Analyze this resume with STRICT professional standards. Be realistic and tough in your scoring.

    CRITICAL INSTRUCTIONS FOR REALISTIC SCORING:

    **PLACEHOLDER CONTENT DETECTION:**
    - If you find placeholder text like "Bullet 1", "Bullet 2", "Generic content", etc., this is a MAJOR red flag
    - Automatically deduct 20-30 points for placeholder content
    - These resumes should score 40-60 maximum regardless of format

    **CONTENT QUALITY REQUIREMENTS:**
    - Achievements MUST have specific numbers, percentages, or metrics
    - Generic statements like "Managed projects" or "Worked with teams" are weak
    - Strong content requires: specific metrics, technologies, business impact, team sizes, revenue figures

    Provide the analysis in JSON format:
    {
      "overallScore": 0-100,
      "atsCompatibility": 0-100,
      "profileSummary": {
        "currentRole": "",
        "careerLevel": "",
        "industries": [],
        "suggestedJobTitles": [],
        "suggestedIndustries": []
      },
      "strengths": ["strength1", "strength2", "strength3"],
      "weaknesses": ["weakness1", "weakness2", "weakness3"],
      "keywordsSuggestions": ["keyword1", "keyword2", "keyword3", "keyword4", "keyword5"],
      "improvementAreas": [
        {
          "section": "section name",
          "suggestions": ["suggestion1", "suggestion2"],
          "improvedSnippets": [
            {
              "original": "original text from resume",
              "improved": "AI-enhanced version"
            }
          ]
        }
      ]
    }
    
    **STRICT SCORING GUIDELINES - BE REALISTIC:**
    
    Overall Score (0-100):
    - 90-100: EXCEPTIONAL resume with quantified achievements, perfect keyword optimization, industry leadership examples, specific metrics throughout
    - 80-89: STRONG resume with good quantification, solid keyword presence, clear career progression, some metrics
    - 70-79: DECENT resume with basic quantification, acceptable structure, some achievements shown
    - 60-69: BELOW AVERAGE resume with weak content, generic statements, poor quantification
    - 50-59: POOR resume with placeholder content, no metrics, generic bullet points
    - Below 50: TERRIBLE resume with major content/format issues
    
    ATS Compatibility (0-100):
    - 90-100: Perfect ATS format with extensive industry keywords, optimized headers, strong keyword density (8-12%)
    - 80-89: Good ATS compatibility with solid keyword presence (6-8%), proper formatting
    - 70-79: Acceptable ATS compatibility with basic keywords (4-6%), standard formatting
    - 60-69: Poor ATS compatibility with few keywords (2-4%), weak optimization
    - Below 60: Very poor ATS compatibility with minimal keywords (<2%), bad formatting

    **CONTENT QUALITY CHECKLIST - DEDUCT POINTS FOR:**
    1. PLACEHOLDER CONTENT: "Bullet 1", "Bullet 2", generic placeholders (-25 points)
    2. NO QUANTIFICATION: Lack of numbers, percentages, metrics (-15 points)
    3. GENERIC STATEMENTS: "Responsible for...", "Worked on..." without specifics (-10 points)
    4. WEAK ACHIEVEMENTS: No business impact or measurable outcomes (-10 points)
    5. POOR KEYWORD DENSITY: Less than 3% relevant keywords for the field (-10 points)
    6. FORMATTING ISSUES: Poor structure, inconsistent formatting (-5 points)

    **KEYWORD DENSITY CALCULATION:**
    - Count industry-specific terms, technologies, methodologies
    - Calculate as percentage of total words
    - Product Management: "roadmap", "stakeholder", "KPI", "user research", "product strategy"
    - Technical: "API", "cloud", "agile", "scrum", "data analysis"

    **ACHIEVEMENT QUALITY EXAMPLES:**
    - WEAK: "Managed projects" 
    - STRONG: "Led 3 cross-functional teams to deliver $2M revenue-generating product ahead of schedule"
    
    - WEAK: "Worked with customers"
    - STRONG: "Increased customer satisfaction by 40% through data-driven UX improvements affecting 50k+ users"

    IMPORTANT: 
    - Be STRICT and REALISTIC in scoring
    - Most resumes should score 50-75, not 85-95
    - Only truly exceptional resumes with perfect content and optimization should score above 85
    - Placeholder content automatically caps scores at 60 maximum

    Return ONLY the JSON object without any markdown formatting or code blocks.
    
    Resume Data:
    ${resumeData}
    `;
    
    // Call OpenAI API with enhanced parameters for stricter analysis
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: `You are a STRICT professional resume analyst with 15+ years of experience. You are known for tough, realistic evaluations. Most resumes are mediocre (50-75 range). Only exceptional resumes with perfect quantified achievements and optimization score above 85. You automatically detect and heavily penalize placeholder content like "Bullet 1, Bullet 2". You require specific metrics, technologies, and business impact for high scores. Return ONLY valid JSON without markdown.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1, // Lower temperature for more consistent, strict scoring
      max_tokens: 3000,
    });
    
    // Get the response content
    const responseContent = response.choices[0].message.content.trim();
    
    // Clean up the response - remove any markdown code block syntax
    let cleanedResponse = responseContent;
    
    if (responseContent.startsWith('```json') || responseContent.startsWith('```')) {
      const startIndex = responseContent.indexOf('{');
      const endIndex = responseContent.lastIndexOf('}');
      
      if (startIndex !== -1 && endIndex !== -1) {
        cleanedResponse = responseContent.substring(startIndex, endIndex + 1);
      }
    }
    
    console.log('Cleaned response for parsing:', cleanedResponse.substring(0, 200) + '...');
    
    // Parse the response
    const analysisData = JSON.parse(cleanedResponse);
    console.log('Resume analysis with OpenAI completed successfully');
    
    // ENHANCED: Additional validation and scoring adjustments
    let sanitizedAnalysis = {
      overallScore: Math.max(0, Math.min(100, analysisData.overallScore || 0)),
      atsCompatibility: Math.max(0, Math.min(100, analysisData.atsCompatibility || 0)),
      profileSummary: {
        currentRole: analysisData.profileSummary?.currentRole || "Not specified",
        careerLevel: analysisData.profileSummary?.careerLevel || "Mid-level",
        industries: Array.isArray(analysisData.profileSummary?.industries) ? analysisData.profileSummary.industries : ["Technology"],
        suggestedJobTitles: Array.isArray(analysisData.profileSummary?.suggestedJobTitles) ? analysisData.profileSummary.suggestedJobTitles : ["Product Manager", "Project Manager"],
        suggestedIndustries: Array.isArray(analysisData.profileSummary?.suggestedIndustries) ? analysisData.profileSummary.suggestedIndustries : ["Technology", "Software"]
      },
      strengths: Array.isArray(analysisData.strengths) ? analysisData.strengths : [
        "Resume has a clear structure",
        "Contact information is included",
        "Work experience is detailed"
      ],
      weaknesses: Array.isArray(analysisData.weaknesses) ? analysisData.weaknesses : [
        "Could benefit from more quantifiable achievements",
        "Skills section could be more comprehensive",
        "Summary could be more impactful"
      ],
      keywordsSuggestions: Array.isArray(analysisData.keywordsSuggestions) ? analysisData.keywordsSuggestions : [
        "leadership",
        "communication",
        "problem-solving",
        "teamwork",
        "analytical"
      ],
      improvementAreas: Array.isArray(analysisData.improvementAreas) ? analysisData.improvementAreas : [
        {
          section: "Experience",
          suggestions: [
            "Add more quantifiable achievements",
            "Use more action verbs"
          ],
          improvedSnippets: [
            {
              original: "Generic bullet points need improvement",
              improved: "Specific, quantified achievements with business impact"
            }
          ]
        }
      ]
    };
    
    // CRITICAL: Detect and penalize placeholder content
    const resumeText = JSON.stringify(resume.parsedData).toLowerCase();
    const placeholderPatterns = [
      'bullet 1', 'bullet 2', 'bullet 3', 'bullet 4', 'bullet 5',
      'bullet point', 'add content', 'placeholder', 'lorem ipsum',
      'example text', 'sample text', 'generic content'
    ];
    
    let hasPlaceholders = false;
    let placeholderCount = 0;
    
    placeholderPatterns.forEach(pattern => {
      if (resumeText.includes(pattern)) {
        hasPlaceholders = true;
        placeholderCount++;
      }
    });
    
    if (hasPlaceholders) {
      console.log(`🚨 PLACEHOLDER CONTENT DETECTED: Found ${placeholderCount} placeholder patterns`);
      
      // Apply severe penalty for placeholder content
      const penalty = Math.min(30, placeholderCount * 8); // Up to 30 point penalty
      sanitizedAnalysis.overallScore = Math.max(20, sanitizedAnalysis.overallScore - penalty);
      sanitizedAnalysis.atsCompatibility = Math.max(25, sanitizedAnalysis.atsCompatibility - (penalty * 0.8));
      
      // Add to weaknesses
      sanitizedAnalysis.weaknesses.unshift("Contains placeholder content that needs to be replaced with specific achievements");
      
      // Cap maximum scores for placeholder content
      sanitizedAnalysis.overallScore = Math.min(60, sanitizedAnalysis.overallScore);
      sanitizedAnalysis.atsCompatibility = Math.min(65, sanitizedAnalysis.atsCompatibility);
      
      console.log(`Applied ${penalty} point penalty for placeholder content. New scores: ${sanitizedAnalysis.overallScore}/${sanitizedAnalysis.atsCompatibility}`);
    }
    
    // Additional content quality checks
    const experienceText = JSON.stringify(resume.parsedData.experience || []);
    
    // Check for quantification
    const hasNumbers = /\d+/.test(experienceText);
    const hasPercentages = /%/.test(experienceText);
    const hasMetrics = /\$|revenue|million|thousand|increase|decrease|improve/i.test(experienceText);
    
    if (!hasNumbers && !hasPercentages && !hasMetrics) {
      console.log('🚨 NO QUANTIFICATION DETECTED: Applying penalty');
      sanitizedAnalysis.overallScore = Math.max(30, sanitizedAnalysis.overallScore - 15);
      sanitizedAnalysis.atsCompatibility = Math.max(40, sanitizedAnalysis.atsCompatibility - 10);
      sanitizedAnalysis.weaknesses.unshift("Lacks quantified achievements and specific metrics");
    }
    
    // ENHANCED: Apply tailored resume bonus more carefully
    if (isTailoredResume && !hasPlaceholders) {
      console.log('Applying tailored resume analysis bonus...');
      
      // Check for keyword optimization indicators in the content
      const summaryText = (resume.parsedData.summary || '').toLowerCase();
      const experienceText = JSON.stringify(resume.parsedData.experience || []).toLowerCase();
      
      // Keywords that indicate technical optimization
      const techKeywords = ['api', 'cloud', 'infrastructure', 'developer', 'velocity', 'platform', 'security', 'architecture'];
      const foundKeywords = techKeywords.filter(keyword => 
        summaryText.includes(keyword) || experienceText.includes(keyword)
      );
      
      // Apply bonus based on keyword optimization (only if no placeholders)
      if (foundKeywords.length >= 3) {
        console.log(`Found ${foundKeywords.length} optimization keywords:`, foundKeywords);
        
        // Apply 3-5 point bonus for good optimization (reduced from previous)
        const bonus = Math.min(5, foundKeywords.length);
        sanitizedAnalysis.overallScore = Math.min(100, sanitizedAnalysis.overallScore + bonus);
        sanitizedAnalysis.atsCompatibility = Math.min(100, sanitizedAnalysis.atsCompatibility + bonus);
        
        console.log(`Applied ${bonus} point tailoring bonus. New scores: ${sanitizedAnalysis.overallScore}/${sanitizedAnalysis.atsCompatibility}`);
        
        // Update strengths to reflect optimization
        sanitizedAnalysis.strengths.unshift("Resume is well-optimized with relevant technical keywords");
      }
    }
    
    console.log('Final analysis scores after all adjustments:', {
      overallScore: sanitizedAnalysis.overallScore,
      atsCompatibility: sanitizedAnalysis.atsCompatibility,
      hadPlaceholders: hasPlaceholders,
      placeholderCount: placeholderCount,
      strengthsCount: sanitizedAnalysis.strengths.length,
      weaknessesCount: sanitizedAnalysis.weaknesses.length,
      isTailored: isTailoredResume
    });
    
    return sanitizedAnalysis;
  } catch (error) {
    console.error('Error analyzing resume with OpenAI:', error);
    
    // Fallback to a more realistic default analysis
    return {
      overallScore: 45, // Much lower default score
      atsCompatibility: 55,
      profileSummary: {
        currentRole: "Not identified",
        careerLevel: "Mid-level",
        industries: ["Technology"],
        suggestedJobTitles: ["Product Manager", "Project Manager"],
        suggestedIndustries: ["Technology", "Software"]
      },
      strengths: [
        "Resume has a clear structure",
        "Contact information is included"
      ],
      weaknesses: [
        "Contains placeholder content that needs specific achievements",
        "Lacks quantifiable metrics and business impact",
        "Needs more industry-specific keywords",
        "Bullet points are too generic and need improvement"
      ],
      keywordsSuggestions: [
        "leadership",
        "project management",
        "data analysis",
        "cross-functional collaboration",
        "business impact"
      ],
      improvementAreas: [
        {
          section: "Experience",
          suggestions: [
            "Replace placeholder bullets with specific quantified achievements",
            "Add metrics like percentages, dollar amounts, team sizes",
            "Include specific technologies and methodologies used"
          ],
          improvedSnippets: [
            {
              original: "Bullet 1, Bullet 2, Bullet 3",
              improved: "Led cross-functional team of 12 to deliver $2M revenue product, increasing customer satisfaction by 35% through data-driven feature improvements"
            }
          ]
        }
      ]
    };
  }
};

================
File: backend/services/resumeEditor.service.js
================
// backend/services/resumeEditor.service.js - AI-POWERED RESUME EDITOR
const { openai } = require('../config/openai');
const Resume = require('../models/mongodb/resume.model');
const { PutObjectCommand } = require('@aws-sdk/client-s3');
const { s3Client, S3_BUCKET } = require('../config/s3');
const PDFDocument = require('pdfkit');
const { Document, Packer, Paragraph, TextRun, HeadingLevel } = require('docx');
const { v4: uuid } = require('uuid'); 

class ResumeEditorService {
  /**
   * Apply AI-suggested changes to a resume
   */
  static async applyResumeChanges(resumeId, userId, changes) {
    try {
      console.log(`🤖 AJ: Applying changes to resume ${resumeId}`);
      
      const resume = await Resume.findOne({ _id: resumeId, userId });
      if (!resume) {
        throw new Error('Resume not found');
      }

      // Parse the change request using AI
      const structuredChanges = await this.parseChangeRequest(changes, resume.parsedData);
      
      // Apply changes to resume data
      const updatedResumeData = await this.applyStructuredChanges(resume.parsedData, structuredChanges);
      
      // Update resume in database
      resume.parsedData = updatedResumeData;
      resume.updatedAt = new Date();
      
      // Add version tracking
      const versionNumber = (resume.versions || []).length + 1;
      if (!resume.versions) resume.versions = [];
      
      // Create new version entry
      const newVersion = {
        versionNumber,
        createdAt: new Date(),
        fileUrl: resume.fileUrl, // Will be updated after file generation
        changesDescription: this.summarizeChanges(structuredChanges),
        aiGenerated: true
      };

      resume.versions.push(newVersion);
      await resume.save();

      // Generate updated resume file
      const updatedFileUrl = await this.generateUpdatedResumeFile(resume, updatedResumeData);
      
      // Update the version with new file URL
      resume.versions[resume.versions.length - 1].fileUrl = updatedFileUrl;
      await resume.save();

      console.log(`✅ AJ: Successfully updated resume with ${structuredChanges.length} changes`);

      return {
        success: true,
        updatedResume: resume,
        changes: structuredChanges,
        newFileUrl: updatedFileUrl,
        changesSummary: this.summarizeChanges(structuredChanges)
      };

    } catch (error) {
      console.error('Resume update error:', error);
      throw error;
    }
  }

  /**
   * Parse natural language change request into structured changes
   */
static async parseChangeRequest(changeRequest, currentResumeData) {
  try {
    const prompt = `You are an expert resume editor. Parse this change request and convert it into structured JSON changes.

CURRENT RESUME DATA:
${JSON.stringify(currentResumeData, null, 2)}

CHANGE REQUEST:
"${changeRequest}"

CRITICAL: When updating work experience highlights/achievements, generate ONE single action that replaces the entire highlights array with 3-5 detailed bullet points.

Return JSON in this EXACT format:
{
  "changes": [
    {
      "section": "experience",
      "action": "enhance",
      "target": "0",
      "field": "highlights",
      "newValue": [
        "Detailed bullet point 1 with specific metrics and technologies",
        "Detailed bullet point 2 showcasing leadership and impact", 
        "Detailed bullet point 3 with quantifiable business results",
        "Detailed bullet point 4 highlighting technical expertise",
        "Detailed bullet point 5 demonstrating strategic thinking"
      ],
      "originalValue": "current highlights array",
      "reason": "Enhanced with multiple detailed achievements"
    }
  ]
}

IMPORTANT RULES:
- Generate EXACTLY ONE change action, not multiple separate ones
- Use action: "enhance" for updating existing experience
- Set field: "highlights" for bullet points
- newValue MUST be an array of 3-5 detailed strings
- Each bullet should be 15-25 words with specific metrics
- Use strong action verbs (Led, Developed, Achieved, Implemented, etc.)
- Include technologies, numbers, percentages, and business impact
- Make bullets relevant to the current role and industry

EXAMPLE - DO THIS:
{
  "changes": [
    {
      "section": "experience",
      "action": "enhance",
      "target": "0",
      "field": "highlights", 
      "newValue": [
        "Led development of AI-powered tax platform serving 10k+ enterprise clients with 40% faster processing",
        "Architected machine learning workflows reducing manual review time by 65% and improving accuracy to 98%",
        "Managed cross-functional team of 15 engineers delivering $3.2M in new AI product revenue",
        "Implemented automated compliance checking system preventing 200+ regulatory violations annually",
        "Drove product strategy for agentic AI features resulting in 85% customer satisfaction increase"
      ],
      "reason": "Enhanced Thomson Reuters role with specific AI achievements and quantifiable impact"
    }
  ]
}

DON'T DO THIS (multiple separate actions):
{
  "changes": [
    {"action": "add", "target": "0/highlights", "newValue": "bullet 1"},
    {"action": "add", "target": "0/highlights", "newValue": "bullet 2"},
    {"action": "add", "target": "0/highlights", "newValue": "bullet 3"}
  ]
}

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        {
          role: 'system',
          content: 'You are an expert resume editor. Generate ONE comprehensive change action with an array of detailed bullet points. Return only valid JSON.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 2000
    });

    let parsedChanges;
    try {
      const responseContent = response.choices[0].message.content.trim();
      // Clean up response if it has markdown
      const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
      parsedChanges = JSON.parse(cleanedResponse);
      
      console.log('📋 Parsed changes:', JSON.stringify(parsedChanges, null, 2));
      
      // 🔧 VALIDATION: Ensure we have the right structure for experience updates
      if (parsedChanges.changes) {
        parsedChanges.changes.forEach((change, index) => {
          if (change.section === 'experience' && 
              change.action === 'enhance' && 
              change.field === 'highlights' && 
              Array.isArray(change.newValue)) {
            console.log(`✅ Valid experience enhancement found with ${change.newValue.length} bullet points`);
          }
        });
      }
      
    } catch (parseError) {
      console.error('Error parsing AI response:', parseError);
      throw new Error('Failed to parse change request');
    }

    return parsedChanges.changes || [];

  } catch (error) {
    console.error('Error parsing change request:', error);
    throw error;
  }
}

  /**
   * Apply structured changes to resume data
   */
  static async applyStructuredChanges(resumeData, changes) {
    const updatedData = JSON.parse(JSON.stringify(resumeData)); // Deep clone

    for (const change of changes) {
      try {
        console.log(`Applying change: ${change.action} to ${change.section}`);
        
        switch (change.section) {
          case 'contactInfo':
            this.updateContactInfo(updatedData, change);
            break;
          case 'summary':
            this.updateSummary(updatedData, change);
            break;
          case 'experience':
            this.updateExperience(updatedData, change);
            break;
          case 'education':
            this.updateEducation(updatedData, change);
            break;
          case 'skills':
            this.updateSkills(updatedData, change);
            break;
          case 'certifications':
            this.updateCertifications(updatedData, change);
            break;
          case 'projects':
            this.updateProjects(updatedData, change);
            break;
          case 'languages':
            this.updateLanguages(updatedData, change);
            break;
          default:
            console.warn(`Unknown section: ${change.section}`);
        }
      } catch (error) {
        console.error(`Error applying change to ${change.section}:`, error);
      }
    }

    return updatedData;
  }

  // Section-specific update methods
  static updateContactInfo(data, change) {
    if (!data.contactInfo) data.contactInfo = {};
    
    switch (change.action) {
      case 'update':
        if (change.target && change.newValue) {
          data.contactInfo[change.target] = change.newValue;
        }
        break;
      case 'add':
        if (change.target === 'websites' && change.newValue) {
          if (!data.contactInfo.websites) data.contactInfo.websites = [];
          data.contactInfo.websites.push(change.newValue);
        }
        break;
    }
  }

  static updateSummary(data, change) {
    switch (change.action) {
      case 'update':
      case 'rewrite':
      case 'enhance':
        data.summary = change.newValue;
        break;
      case 'add':
        if (!data.summary) {
          data.summary = change.newValue;
        }
        break;
    }
  }

static updateExperience(data, change) {
  if (!data.experience) data.experience = [];

  console.log(`🔧 Updating experience - Action: ${change.action}, Target: ${change.target}, Field: ${change.field}`);
  console.log(`🔧 NewValue type: ${Array.isArray(change.newValue) ? 'array' : typeof change.newValue}`);
  console.log(`🔧 NewValue content:`, change.newValue);

  switch (change.action) {
    case 'add':
      // 🎯 FIXED: Handle adding new experience vs adding to existing experience
      if (change.target && change.target.includes('/')) {
        // Adding to existing experience (e.g., "0/highlights")
        const [indexStr, field] = change.target.split('/');
        const index = parseInt(indexStr);
        
        if (data.experience[index]) {
          if (field === 'highlights') {
            // Initialize highlights array if it doesn't exist
            if (!data.experience[index].highlights) {
              data.experience[index].highlights = [];
            }
            
            if (Array.isArray(change.newValue)) {
              // 🔧 FIXED: Replace entire highlights array with new content
              console.log(`🎯 Replacing highlights array with ${change.newValue.length} items`);
              data.experience[index].highlights = change.newValue;
            } else if (typeof change.newValue === 'string') {
              // Add single highlight
              console.log(`🎯 Adding single highlight: ${change.newValue}`);
              data.experience[index].highlights.push(change.newValue);
            }
            console.log(`✅ Updated experience[${index}].highlights - now has ${data.experience[index].highlights.length} items`);
          } else {
            // Add to other fields
            data.experience[index][field] = change.newValue;
            console.log(`✅ Added to experience[${index}].${field}`);
          }
        } else {
          console.warn(`❌ Experience index ${index} not found`);
        }
      } else if (change.newValue && typeof change.newValue === 'object') {
        // Adding entirely new experience entry
        data.experience.push(change.newValue);
        console.log('✅ Added new experience entry');
      }
      break;
      
    case 'update':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        if (data.experience[index]) {
          // Update specific field or entire experience entry
          if (change.field) {
            data.experience[index][change.field] = change.newValue;
            console.log(`✅ Updated experience[${index}].${change.field}`);
          } else {
            data.experience[index] = { ...data.experience[index], ...change.newValue };
            console.log(`✅ Updated entire experience[${index}]`);
          }
        } else {
          console.warn(`❌ Experience index ${index} not found`);
        }
      }
      break;
      
    case 'delete':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        data.experience.splice(index, 1);
        console.log(`✅ Deleted experience[${index}]`);
      }
      break;
      
    case 'enhance':
      if (change.target !== undefined) {
        const index = parseInt(change.target);
        if (data.experience[index]) {
          
          // 🎯 ENHANCED: Handle highlights field specifically
          if (change.field === 'highlights' && Array.isArray(change.newValue)) {
            console.log(`🎯 Setting experience[${index}].highlights with ${change.newValue.length} bullet points`);
            data.experience[index].highlights = change.newValue;
            console.log(`✅ Enhanced experience[${index}].highlights:`, data.experience[index].highlights);
            
          } else if (change.field === 'description') {
            data.experience[index].description = change.newValue;
            console.log(`✅ Enhanced experience[${index}].description`);
            
          } else if (change.field && change.newValue) {
            // Handle other specific fields
            data.experience[index][change.field] = change.newValue;
            console.log(`✅ Enhanced experience[${index}].${change.field}`);
            
          } else if (!change.field && Array.isArray(change.newValue)) {
            // 🔧 FIXED: Default to highlights when no field specified but array provided
            console.log('🎯 No field specified, defaulting to highlights for array data');
            data.experience[index].highlights = change.newValue;
            console.log(`✅ Set experience[${index}].highlights with ${change.newValue.length} items`);
            
          } else if (!change.field && typeof change.newValue === 'object') {
            // Handle object updates
            Object.keys(change.newValue).forEach(key => {
              data.experience[index][key] = change.newValue[key];
              console.log(`✅ Updated experience[${index}].${key}`);
            });
            
          } else {
            console.warn(`❌ Cannot enhance experience[${index}] - invalid field/value combination`);
            console.warn(`Field: ${change.field}, NewValue: ${JSON.stringify(change.newValue)}`);
          }
        } else {
          console.warn(`❌ Experience index ${index} not found for enhancement`);
        }
      } else {
        console.warn('❌ No target specified for enhance action');
      }
      break;
      
    default:
      console.warn(`❌ Unknown action: ${change.action}`);
  }
}

  static updateEducation(data, change) {
    if (!data.education) data.education = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.education.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.education[index]) {
            if (change.field) {
              data.education[index][change.field] = change.newValue;
            } else {
              data.education[index] = { ...data.education[index], ...change.newValue };
            }
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.education.splice(index, 1);
        }
        break;
    }
  }

  static updateSkills(data, change) {
    if (!data.skills) data.skills = [];

    switch (change.action) {
      case 'add':
        if (change.newValue) {
          // Handle both string and object skills
          if (typeof change.newValue === 'string') {
            data.skills.push({ name: change.newValue, level: 'Intermediate' });
          } else {
            data.skills.push(change.newValue);
          }
        }
        break;
      case 'update':
        if (change.target) {
          const skillIndex = data.skills.findIndex(skill => 
            (typeof skill === 'string' ? skill : skill.name) === change.target
          );
          if (skillIndex !== -1) {
            if (typeof change.newValue === 'string') {
              data.skills[skillIndex] = { name: change.newValue, level: 'Intermediate' };
            } else {
              data.skills[skillIndex] = change.newValue;
            }
          }
        }
        break;
      case 'delete':
        if (change.target) {
          data.skills = data.skills.filter(skill => 
            (typeof skill === 'string' ? skill : skill.name) !== change.target
          );
        }
        break;
    }
  }

  static updateCertifications(data, change) {
    if (!data.certifications) data.certifications = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.certifications.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.certifications[index]) {
            data.certifications[index] = { ...data.certifications[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.certifications.splice(index, 1);
        }
        break;
    }
  }

  static updateProjects(data, change) {
    if (!data.projects) data.projects = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.projects.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.projects[index]) {
            data.projects[index] = { ...data.projects[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.projects.splice(index, 1);
        }
        break;
    }
  }

  static updateLanguages(data, change) {
    if (!data.languages) data.languages = [];

    switch (change.action) {
      case 'add':
        if (change.newValue && typeof change.newValue === 'object') {
          data.languages.push(change.newValue);
        }
        break;
      case 'update':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          if (data.languages[index]) {
            data.languages[index] = { ...data.languages[index], ...change.newValue };
          }
        }
        break;
      case 'delete':
        if (change.target !== undefined) {
          const index = parseInt(change.target);
          data.languages.splice(index, 1);
        }
        break;
    }
  }

  /**
   * Generate updated resume file (PDF/DOCX)
   */
  static async generateUpdatedResumeFile(resume, updatedData) {
    try {
      const fileType = resume.fileType;
      let buffer;
      let contentType;
      let extension;

      if (fileType === 'PDF') {
        buffer = await this.generatePDF(updatedData);
        contentType = 'application/pdf';
        extension = '.pdf';
      } else if (fileType === 'DOCX') {
        buffer = await this.generateDOCX(updatedData);
        contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        extension = '.docx';
      } else {
        throw new Error(`Unsupported file type: ${fileType}`);
      }

      // Upload to S3
      const s3Key = `resumes/${resume.userId}/updated_${uuid()}${extension}`;
      
      const uploadParams = {
        Bucket: S3_BUCKET,
        Key: s3Key,
        Body: buffer,
        ContentType: contentType
      };

      await s3Client.send(new PutObjectCommand(uploadParams));
      
      console.log(`✅ Generated updated resume file: ${s3Key}`);
      return s3Key;

    } catch (error) {
      console.error('Error generating updated resume file:', error);
      throw error;
    }
  }

/**
 * Send progress update to connected SSE clients
 */
static sendProgressUpdate(resumeId, userId, stage, percentage, message) {
  try {
    if (global.progressClients) {
      const progressData = {
        type: 'progress',
        resumeId,
        stage,
        percentage,
        message,
        timestamp: new Date().toISOString()
      };
      
      // Send to all clients for this user/resume
      global.progressClients.forEach((res, clientId) => {
        if (clientId.includes(`${userId}_${resumeId}`)) {
          try {
            res.write(`data: ${JSON.stringify(progressData)}\n\n`);
            console.log(`📡 Sent progress: ${percentage}% - ${message}`);
          } catch (error) {
            console.error('Error sending SSE progress:', error);
            global.progressClients.delete(clientId);
          }
        }
      });
    }
  } catch (error) {
    console.error('Error in sendProgressUpdate:', error);
  }
}

  /**
   * Generate PDF from resume data
   */
  static async generatePDF(resumeData) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Header
        doc.fontSize(20).text(resumeData.contactInfo?.name || 'Resume', { align: 'center' });
        doc.fontSize(12);
        
        if (resumeData.contactInfo?.email) {
          doc.text(`Email: ${resumeData.contactInfo.email}`);
        }
        if (resumeData.contactInfo?.phone) {
          doc.text(`Phone: ${resumeData.contactInfo.phone}`);
        }
        if (resumeData.contactInfo?.location) {
          doc.text(`Location: ${resumeData.contactInfo.location}`);
        }

        doc.moveDown();

        // Summary
        if (resumeData.summary) {
          doc.fontSize(14).text('Professional Summary', { underline: true });
          doc.fontSize(11).text(resumeData.summary);
          doc.moveDown();
        }

        // Experience
        if (resumeData.experience && resumeData.experience.length > 0) {
          doc.fontSize(14).text('Work Experience', { underline: true });
          resumeData.experience.forEach(exp => {
            doc.fontSize(12).text(`${exp.title} at ${exp.company}`, { bold: true });
            if (exp.startDate || exp.endDate) {
              doc.fontSize(10).text(`${exp.startDate || ''} - ${exp.endDate || 'Present'}`);
            }
            if (exp.description) {
              doc.fontSize(11).text(exp.description);
            }
            if (exp.highlights && exp.highlights.length > 0) {
              exp.highlights.forEach(highlight => {
                doc.text(`• ${highlight}`);
              });
            }
            doc.moveDown();
          });
        }

        // Education
        if (resumeData.education && resumeData.education.length > 0) {
          doc.fontSize(14).text('Education', { underline: true });
          resumeData.education.forEach(edu => {
            doc.fontSize(12).text(`${edu.degree} in ${edu.field || ''}`);
            doc.fontSize(11).text(edu.institution);
            if (edu.startDate || edu.endDate) {
              doc.fontSize(10).text(`${edu.startDate || ''} - ${edu.endDate || ''}`);
            }
            doc.moveDown();
          });
        }

        // Skills
        if (resumeData.skills && resumeData.skills.length > 0) {
          doc.fontSize(14).text('Skills', { underline: true });
          const skillsText = resumeData.skills.map(skill => 
            typeof skill === 'string' ? skill : `${skill.name} (${skill.level || ''})`
          ).join(', ');
          doc.fontSize(11).text(skillsText);
          doc.moveDown();
        }

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Generate DOCX from resume data
   */
  static async generateDOCX(resumeData) {
    try {
      const children = [];

      // Header
      children.push(
        new Paragraph({
          text: resumeData.contactInfo?.name || 'Resume',
          heading: HeadingLevel.TITLE,
          alignment: 'center'
        })
      );

      if (resumeData.contactInfo?.email) {
        children.push(new Paragraph({ text: `Email: ${resumeData.contactInfo.email}` }));
      }
      if (resumeData.contactInfo?.phone) {
        children.push(new Paragraph({ text: `Phone: ${resumeData.contactInfo.phone}` }));
      }
      if (resumeData.contactInfo?.location) {
        children.push(new Paragraph({ text: `Location: ${resumeData.contactInfo.location}` }));
      }

      // Summary
      if (resumeData.summary) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Professional Summary',
            heading: HeadingLevel.HEADING_1
          }),
          new Paragraph({ text: resumeData.summary })
        );
      }

      // Experience
      if (resumeData.experience && resumeData.experience.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Work Experience',
            heading: HeadingLevel.HEADING_1
          })
        );

        resumeData.experience.forEach(exp => {
          children.push(
            new Paragraph({
              children: [
                new TextRun({ text: `${exp.title} at ${exp.company}`, bold: true })
              ]
            })
          );
          
          if (exp.startDate || exp.endDate) {
            children.push(
              new Paragraph({ text: `${exp.startDate || ''} - ${exp.endDate || 'Present'}` })
            );
          }
          
          if (exp.description) {
            children.push(new Paragraph({ text: exp.description }));
          }
          
          if (exp.highlights && exp.highlights.length > 0) {
            exp.highlights.forEach(highlight => {
              children.push(new Paragraph({ text: `• ${highlight}` }));
            });
          }
        });
      }

      // Education, Skills, etc. (similar pattern)
      if (resumeData.education && resumeData.education.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Education',
            heading: HeadingLevel.HEADING_1
          })
        );

        resumeData.education.forEach(edu => {
          children.push(
            new Paragraph({ text: `${edu.degree} in ${edu.field || ''}` }),
            new Paragraph({ text: edu.institution })
          );
        });
      }

      if (resumeData.skills && resumeData.skills.length > 0) {
        children.push(
          new Paragraph({ text: '', spacing: { after: 200 } }),
          new Paragraph({
            text: 'Skills',
            heading: HeadingLevel.HEADING_1
          })
        );

        const skillsText = resumeData.skills.map(skill => 
          typeof skill === 'string' ? skill : `${skill.name} (${skill.level || ''})`
        ).join(', ');
        
        children.push(new Paragraph({ text: skillsText }));
      }

      const doc = new Document({
        sections: [{
          properties: {},
          children: children
        }]
      });

      return await Packer.toBuffer(doc);
    } catch (error) {
      console.error('Error generating DOCX:', error);
      throw error;
    }
  }

  /**
   * Summarize changes for version tracking
   */
  static summarizeChanges(changes) {
    if (!changes || changes.length === 0) return 'No changes applied';

    const summary = changes.map(change => {
      const action = change.action.charAt(0).toUpperCase() + change.action.slice(1);
      return `${action} ${change.section}${change.target ? ` (${change.target})` : ''}`;
    }).join(', ');

    return `AI Updates: ${summary}`;
  }

/**
 * Optimize resume for ATS with real progress tracking
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData, progressCallback = null) {
  const startTime = Date.now();
  const stages = [];
  
  const reportProgress = (stage, percentage, message) => {
    stages.push({ stage, percentage, message, timestamp: Date.now() - startTime });
    
    // Send real-time update via SSE
    this.sendProgressUpdate(resumeId, userId, stage, percentage, message);
    
    // Also call the callback if provided
    if (progressCallback) {
      progressCallback(stage, percentage, message);
    }
    
    console.log(`📊 Real Progress: ${percentage}% - ${message}`);
  };

  try {
    console.log(`🤖 AJ: Optimizing resume ${resumeId} for ATS with real progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    reportProgress('analyzing', 20, 'Analyzing resume for ATS optimizations...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Realistic delay
    
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress) 
    reportProgress('applying', 40, 'Generating enhancement suggestions...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    reportProgress('applying', 60, 'Applying ATS optimizations to resume...');
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    reportProgress('analyzing', 80, 'Re-analyzing optimized resume...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    reportProgress('comparing', 90, 'Generating before/after comparison...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;
    const processingTime = Date.now() - startTime;

    // Step 5: Complete (100% progress)
    reportProgress('complete', 100, `Optimization complete! ATS score improved from ${previousScore}% to ${newATSScore}%`);

    console.log(`✅ Real Progress: 100% - ATS optimization complete. Score: ${previousScore}% → ${newATSScore}% (${processingTime}ms)`);

    // Send completion message via SSE
    this.sendProgressUpdate(resumeId, userId, 'complete', 100, 'Optimization completed successfully!');

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison,
      processingTime: processingTime,
      stages: stages
    };

  } catch (error) {
    console.error('ATS optimization with real progress error:', error);
    
    // Send error via SSE
    this.sendProgressUpdate(resumeId, userId, 'error', 0, `Optimization failed: ${error.message}`);
    
    throw error;
  }
}

/**
 * Optimize resume for ATS with progress tracking and before/after comparison
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData) {
  try {
    console.log(`🤖 AJ: Optimizing resume ${resumeId} for ATS with progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    console.log(`📊 Progress: 20% - Analyzing resume for ATS optimizations...`);
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress)
    console.log(`📊 Progress: 60% - Applying ATS optimizations...`);
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    console.log(`📊 Progress: 80% - Re-analyzing optimized resume...`);
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    console.log(`📊 Progress: 90% - Generating before/after comparison...`);
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;

    console.log(`✅ Progress: 100% - ATS optimization complete. Score: ${previousScore}% → ${newATSScore}%`);

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison
    };

  } catch (error) {
    console.error('ATS optimization with progress error:', error);
    throw error;
  }
}

/**
 * Send progress update to connected SSE clients
 */
static sendProgressUpdate(resumeId, userId, stage, percentage, message) {
  try {
    if (global.progressClients) {
      const progressData = {
        type: 'progress',
        resumeId,
        stage,
        percentage,
        message,
        timestamp: new Date().toISOString()
      };
      
      // Send to all clients for this user/resume
      global.progressClients.forEach((res, clientId) => {
        if (clientId.includes(`${userId}_${resumeId}`)) {
          try {
            res.write(`data: ${JSON.stringify(progressData)}\n\n`);
            console.log(`📡 Sent progress: ${percentage}% - ${message}`);
          } catch (error) {
            console.error('Error sending SSE progress:', error);
            global.progressClients.delete(clientId);
          }
        }
      });
    } else {
      console.log('⚠️ No progress clients connected for SSE updates');
    }
  } catch (error) {
    console.error('Error in sendProgressUpdate:', error);
  }
}

/**
 * Optimize resume for ATS with real progress tracking
 */
static async optimizeForATSWithProgress(resumeId, userId, targetJob = null, originalData, progressCallback = null) {
  const startTime = Date.now();
  const stages = [];
  
  const reportProgress = (stage, percentage, message) => {
    stages.push({ stage, percentage, message, timestamp: Date.now() - startTime });
    
    // Send real-time update via SSE
    this.sendProgressUpdate(resumeId, userId, stage, percentage, message);
    
    // Also call the callback if provided
    if (progressCallback) {
      progressCallback(stage, percentage, message);
    }
    
    console.log(`📊 Real Progress: ${percentage}% - ${message}`);
  };

  try {
    console.log(`🤖 AJ: Optimizing resume ${resumeId} for ATS with real progress tracking`);
    
    const resume = await Resume.findOne({ _id: resumeId, userId });
    if (!resume) {
      throw new Error('Resume not found');
    }

    // Store previous ATS score
    const previousScore = resume.analysis?.atsCompatibility || 0;

    // Step 1: Generate ATS optimization suggestions (20% progress)
    reportProgress('analyzing', 20, 'Analyzing resume for ATS optimizations...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Realistic delay
    
    const optimizations = await this.generateATSOptimizations(resume.parsedData, targetJob);
    
    // Step 2: Apply optimizations (60% progress) 
    reportProgress('applying', 40, 'Generating enhancement suggestions...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    reportProgress('applying', 60, 'Applying ATS optimizations to resume...');
    const changeRequest = `Apply these ATS optimizations: ${optimizations.map(opt => opt.change).join('. ')}`;
    const result = await this.applyResumeChanges(resumeId, userId, changeRequest);

    // Step 3: Re-analyze resume (80% progress)
    reportProgress('analyzing', 80, 'Re-analyzing optimized resume...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const resumeAnalysisService = require('./resumeAnalysis.service');
    const newAnalysis = await resumeAnalysisService.analyzeResume(resumeId);
    
    // Step 4: Generate comparison data (90% progress)
    reportProgress('comparing', 90, 'Generating before/after comparison...');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const updatedResume = await Resume.findById(resumeId);
    updatedResume.analysis = newAnalysis;
    await updatedResume.save();

    // Generate detailed comparison
    const comparison = this.generateBeforeAfterComparison(originalData, {
      parsedData: updatedResume.parsedData,
      analysis: newAnalysis
    });

    const newATSScore = newAnalysis.atsCompatibility || 0;
    const processingTime = Date.now() - startTime;

    // Step 5: Complete (100% progress)
    reportProgress('complete', 100, `Optimization complete! ATS score: ${previousScore}% → ${newATSScore}%`);

    console.log(`✅ Real Progress: 100% - ATS optimization complete. Score: ${previousScore}% → ${newATSScore}% (${processingTime}ms)`);

    // Send completion message via SSE
    this.sendProgressUpdate(resumeId, userId, 'complete', 100, 'Optimization completed successfully!');

    return {
      success: true,
      optimizations: optimizations,
      newATSScore: newATSScore,
      previousScore: previousScore,
      updatedResume: updatedResume,
      comparison: comparison,
      processingTime: processingTime,
      stages: stages
    };

  } catch (error) {
    console.error('ATS optimization with real progress error:', error);
    
    // Send error via SSE
    this.sendProgressUpdate(resumeId, userId, 'error', 0, `Optimization failed: ${error.message}`);
    
    throw error;
  }
}

/**
 * Generate detailed before/after comparison
 */
static generateBeforeAfterComparison(originalData, updatedData) {
  const comparison = {
    scores: {
      before: {
        overallScore: originalData.analysis?.overallScore || 0,
        atsCompatibility: originalData.analysis?.atsCompatibility || 0
      },
      after: {
        overallScore: updatedData.analysis?.overallScore || 0,
        atsCompatibility: updatedData.analysis?.atsCompatibility || 0
      }
    },
    changes: [],
    summary: {
      sectionsModified: 0,
      improvementsCount: 0,
      keywordsAdded: 0
    }
  };

  // Compare experience section
  const originalExp = originalData.parsedData?.experience || [];
  const updatedExp = updatedData.parsedData?.experience || [];

  originalExp.forEach((origJob, index) => {
    if (updatedExp[index]) {
      const updatedJob = updatedExp[index];
      
      // Compare highlights
      if (JSON.stringify(origJob.highlights) !== JSON.stringify(updatedJob.highlights)) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'highlights',
          before: origJob.highlights || [],
          after: updatedJob.highlights || [],
          changeType: 'enhanced',
          impact: 'Improved quantification and ATS keywords'
        });
        comparison.summary.sectionsModified++;
      }

      // Compare description
      if (origJob.description !== updatedJob.description) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'description',
          before: origJob.description || '',
          after: updatedJob.description || '',
          changeType: 'optimized',
          impact: 'Enhanced for ATS compatibility'
        });
      }
    }
  });

  // Compare skills section
  const originalSkills = originalData.parsedData?.skills || [];
  const updatedSkills = updatedData.parsedData?.skills || [];
  
  if (JSON.stringify(originalSkills) !== JSON.stringify(updatedSkills)) {
    comparison.changes.push({
      section: 'skills',
      field: 'skills',
      before: originalSkills,
      after: updatedSkills,
      changeType: 'expanded',
      impact: 'Added relevant keywords and skills'
    });
    comparison.summary.sectionsModified++;
  }

  // Calculate improvement metrics
  comparison.summary.improvementsCount = comparison.changes.length;
  comparison.summary.keywordsAdded = this.countNewKeywords(originalData, updatedData);

  // Generate summary text
  const scoreImprovement = comparison.scores.after.atsCompatibility - comparison.scores.before.atsCompatibility;
  comparison.summaryText = `Enhanced ${comparison.summary.sectionsModified} section${comparison.summary.sectionsModified !== 1 ? 's' : ''} with ${comparison.summary.improvementsCount} improvement${comparison.summary.improvementsCount !== 1 ? 's' : ''}${scoreImprovement > 0 ? `, boosting ATS score by ${scoreImprovement}%` : ''}`;

  return comparison;
}

/**
 * Count new keywords added during optimization
 */
static countNewKeywords(originalData, updatedData) {
  const originalText = JSON.stringify(originalData.parsedData).toLowerCase();
  const updatedText = JSON.stringify(updatedData.parsedData).toLowerCase();
  
  // Simple keyword counting - could be enhanced with more sophisticated analysis
  const commonKeywords = ['api', 'cloud', 'agile', 'leadership', 'development', 'management', 'strategy', 'security'];
  
  let newKeywords = 0;
  commonKeywords.forEach(keyword => {
    const originalCount = (originalText.match(new RegExp(keyword, 'g')) || []).length;
    const updatedCount = (updatedText.match(new RegExp(keyword, 'g')) || []).length;
    if (updatedCount > originalCount) {
      newKeywords += (updatedCount - originalCount);
    }
  });
  
  return newKeywords;
}

/**
 * Generate detailed before/after comparison
 */
static generateBeforeAfterComparison(originalData, updatedData) {
  const comparison = {
    scores: {
      before: {
        overallScore: originalData.analysis?.overallScore || 0,
        atsCompatibility: originalData.analysis?.atsCompatibility || 0
      },
      after: {
        overallScore: updatedData.analysis?.overallScore || 0,
        atsCompatibility: updatedData.analysis?.atsCompatibility || 0
      }
    },
    changes: [],
    summary: {
      sectionsModified: 0,
      improvementsCount: 0,
      keywordsAdded: 0
    }
  };

  // Compare experience section
  const originalExp = originalData.parsedData?.experience || [];
  const updatedExp = updatedData.parsedData?.experience || [];

  originalExp.forEach((origJob, index) => {
    if (updatedExp[index]) {
      const updatedJob = updatedExp[index];
      
      // Compare highlights
      if (JSON.stringify(origJob.highlights) !== JSON.stringify(updatedJob.highlights)) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'highlights',
          before: origJob.highlights || [],
          after: updatedJob.highlights || [],
          changeType: 'enhanced',
          impact: 'Improved quantification and ATS keywords'
        });
        comparison.summary.sectionsModified++;
      }

      // Compare description
      if (origJob.description !== updatedJob.description) {
        comparison.changes.push({
          section: 'experience',
          jobTitle: origJob.title || 'Position',
          company: origJob.company || 'Company',
          field: 'description',
          before: origJob.description || '',
          after: updatedJob.description || '',
          changeType: 'optimized',
          impact: 'Enhanced for ATS compatibility'
        });
      }
    }
  });

  // Compare skills section
  const originalSkills = originalData.parsedData?.skills || [];
  const updatedSkills = updatedData.parsedData?.skills || [];
  
  if (JSON.stringify(originalSkills) !== JSON.stringify(updatedSkills)) {
    comparison.changes.push({
      section: 'skills',
      field: 'skills',
      before: originalSkills,
      after: updatedSkills,
      changeType: 'expanded',
      impact: 'Added relevant keywords and skills'
    });
    comparison.summary.sectionsModified++;
  }

  // Calculate improvement metrics
  comparison.summary.improvementsCount = comparison.changes.length;
  comparison.summary.keywordsAdded = this.countNewKeywords(originalData, updatedData);

  // Generate summary text
  const scoreImprovement = comparison.scores.after.atsCompatibility - comparison.scores.before.atsCompatibility;
  comparison.summaryText = `Enhanced ${comparison.summary.sectionsModified} section${comparison.summary.sectionsModified !== 1 ? 's' : ''} with ${comparison.summary.improvementsCount} improvement${comparison.summary.improvementsCount !== 1 ? 's' : ''}${scoreImprovement > 0 ? `, boosting ATS score by ${scoreImprovement}%` : ''}`;

  return comparison;
}

/**
 * Count new keywords added during optimization
 */
static countNewKeywords(originalData, updatedData) {
  const originalText = JSON.stringify(originalData.parsedData).toLowerCase();
  const updatedText = JSON.stringify(updatedData.parsedData).toLowerCase();
  
  // Simple keyword counting - could be enhanced with more sophisticated analysis
  const commonKeywords = ['api', 'cloud', 'agile', 'leadership', 'development', 'management', 'strategy', 'security'];
  
  let newKeywords = 0;
  commonKeywords.forEach(keyword => {
    const originalCount = (originalText.match(new RegExp(keyword, 'g')) || []).length;
    const updatedCount = (updatedText.match(new RegExp(keyword, 'g')) || []).length;
    if (updatedCount > originalCount) {
      newKeywords += (updatedCount - originalCount);
    }
  });
  
  return newKeywords;
}

  /**
   * Generate ATS optimization suggestions
   */
  static async generateATSOptimizations(resumeData, targetJob) {
    try {
      let prompt = `You are an ATS (Applicant Tracking System) optimization expert. Analyze this resume and provide specific optimizations to improve ATS compatibility.

CURRENT RESUME DATA:
${JSON.stringify(resumeData, null, 2)}`;

      if (targetJob) {
        prompt += `\n\nTARGET JOB:
Title: ${targetJob.title}
Company: ${targetJob.company}
Description: ${targetJob.description}`;
      }

      prompt += `

Provide ATS optimizations in this JSON format:
{
  "optimizations": [
    {
      "section": "summary|experience|skills|education|etc",
      "type": "keyword_addition|format_improvement|section_enhancement|ats_formatting",
      "change": "specific change to make",
      "reason": "why this improves ATS score",
      "keywords": ["relevant", "keywords", "to", "add"],
      "priority": "high|medium|low"
    }
  ],
  "atsImprovements": {
    "keywordDensity": "improvements needed",
    "formatting": "formatting changes",
    "structure": "structural improvements",
    "content": "content enhancements"
  }
}

Focus on:
1. Adding relevant keywords naturally
2. Improving section headers for ATS parsing
3. Optimizing bullet point structure
4. Enhancing skill descriptions
5. Ensuring proper formatting for ATS scanning

IMPORTANT: Return ONLY the JSON object, no markdown or additional text.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          {
            role: 'system',
            content: 'You are an ATS optimization expert. Provide specific, actionable suggestions to improve resume ATS compatibility. Return only valid JSON.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 1500
      });

      const responseContent = response.choices[0].message.content.trim();
      const cleanedResponse = responseContent.replace(/```json\n?|\n?```/g, '').trim();
      const optimizations = JSON.parse(cleanedResponse);

      return optimizations.optimizations || [];

    } catch (error) {
      console.error('Error generating ATS optimizations:', error);
      throw error;
    }
  }
}

module.exports = ResumeEditorService;

================
File: backend/services/resumeParser.service.js
================
// services/resumeParser.service.js
const { GetObjectCommand } = require('@aws-sdk/client-s3');
const { s3Client, S3_BUCKET } = require('../config/s3');
const { openai } = require('../config/openai');
const pdf = require('pdf-parse');
const mammoth = require('mammoth');

/**
 * Parse a resume file and extract structured data using OpenAI
 * @param {string} fileUrl - S3 key for the resume file
 * @param {string} fileType - Type of file (PDF, DOCX, DOC)
 * @returns {Object} Parsed resume data
 */
exports.parseResume = async (fileUrl, fileType) => {
  try {
    console.log(`Parsing resume file: ${fileUrl}, type: ${fileType}`);
    
    // Debug check for S3 bucket configuration
    console.log('S3 bucket config check:', { bucket: S3_BUCKET });
    
    if (!S3_BUCKET) {
      throw new Error('S3 bucket not configured. Please set AWS_BUCKET_NAME environment variable.');
    }
    
    // Get file from S3
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: fileUrl
    };
    
    console.log('Getting file from S3:', { bucket: S3_BUCKET, key: fileUrl });
    
    const { Body } = await s3Client.send(new GetObjectCommand(getObjectParams));
    
    // Convert readable stream to buffer
    const chunks = [];
    for await (const chunk of Body) {
      chunks.push(chunk);
    }
    const buffer = Buffer.concat(chunks);
    
    console.log(`File retrieved from S3, size: ${buffer.length} bytes`);
    
    // Extract text based on file type
    let text = '';
    if (fileType === 'PDF') {
      console.log('Parsing PDF file...');
      const pdfData = await pdf(buffer);
      text = pdfData.text;
    } else if (fileType === 'DOCX') {
      console.log('Parsing DOCX file...');
      const result = await mammoth.extractRawText({ buffer });
      text = result.value;
    } else if (fileType === 'DOC') {
      // For DOC files, we would need a different parser
      // This is a placeholder for now
      console.log('DOC parsing not fully implemented');
      text = 'DOC parsing not fully implemented';
    } else {
      throw new Error(`Unsupported file type: ${fileType}`);
    }
    
    console.log(`Text extracted, length: ${text.length} characters`);
    
    // Process the text using OpenAI to extract structured information
    return await processWithOpenAI(text);
  } catch (error) {
    console.error('Error parsing resume:', error);
    throw error;
  }
};

/**
 * Process resume text with OpenAI to extract structured data
 * @param {string} text - Extracted text from resume
 * @returns {Object} Structured resume data
 */
async function processWithOpenAI(text) {
  try {
    console.log('Processing resume text with OpenAI...');
    
    // Check if text is too long for the API
    const maxTokens = 8000; // GPT-4 can handle ~8000 tokens
    // Rough estimation: 1 token ~= 4 characters in English
    if (text.length > maxTokens * 4) {
      console.log('Text is too long, truncating...');
      text = text.substring(0, maxTokens * 4);
    }
    
    // Prompt for OpenAI to extract structured data from the resume
    const prompt = `
    Extract structured information from the following resume text. 
    Provide the information in JSON format with the following structure:
    {
      "contactInfo": {
        "name": "",
        "email": "",
        "phone": "",
        "location": "",
        "websites": []
      },
      "summary": "",
      "experience": [
        {
          "company": "",
          "title": "",
          "location": "",
          "startDate": "",
          "endDate": "",
          "description": "",
          "highlights": [],
          "skills": []
        }
      ],
      "education": [
        {
          "institution": "",
          "degree": "",
          "field": "",
          "startDate": "",
          "endDate": "",
          "gpa": null,
          "highlights": []
        }
      ],
      "skills": [
        {
          "name": "",
          "level": "",
          "yearsOfExperience": null
        }
      ],
      "certifications": [
        {
          "name": "",
          "issuer": "",
          "dateObtained": "",
          "validUntil": ""
        }
      ],
      "languages": [
        {
          "language": "",
          "proficiency": ""
        }
      ],
      "projects": [
        {
          "name": "",
          "description": "",
          "url": "",
          "startDate": "",
          "endDate": "",
          "skills": []
        }
      ]
    }

    Extract all the information accurately from the resume. For dates, use the format YYYY-MM-DD when possible. 
    If information is not available or empty, leave it as an empty string or null. 
    For arrays, if no elements are present, return an empty array [].
    Make sure to include all skills mentioned in each work experience and project.
    For skill levels, use one of: "Beginner", "Intermediate", "Advanced", or "Expert".
    
    IMPORTANT: Return ONLY the JSON object without any markdown formatting, code blocks, or additional text.

    Resume Text:
    ${text}
    `;

    // Call OpenAI API
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: "You are an expert resume parser that extracts structured information from resume text. Be precise and thorough. Return ONLY valid JSON without any markdown formatting or code blocks."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.2,
      max_tokens: 3000,
    });

    // Get the response content
    const responseContent = response.choices[0].message.content.trim();
    
    // Clean up the response - remove any markdown code block syntax
    let cleanedResponse = responseContent;
    
    // If response starts with ```json or ``` and ends with ```, remove these markers
    if (responseContent.startsWith('```json') || responseContent.startsWith('```')) {
      const startIndex = responseContent.indexOf('{');
      const endIndex = responseContent.lastIndexOf('}');
      
      if (startIndex !== -1 && endIndex !== -1) {
        cleanedResponse = responseContent.substring(startIndex, endIndex + 1);
      }
    }
    
    console.log('Cleaned response for parsing:', cleanedResponse.substring(0, 100) + '...');
    
    // Parse the response
    const parsedData = JSON.parse(cleanedResponse);
    console.log('Resume parsing with OpenAI completed successfully');
    
    return parsedData;
  } catch (error) {
    console.error('Error processing with OpenAI:', error);
    
    // Fallback to a simplified parsed data structure
    return {
      contactInfo: {
        name: 'Parsing Error',
        email: '',
        phone: '',
        location: '',
        websites: []
      },
      summary: 'Error parsing resume. Please try again or contact support.',
      experience: [],
      education: [],
      skills: [],
      certifications: [],
      languages: [],
      projects: []
    };
  }
}

================
File: backend/services/resumeTailoring.service.js
================
// services/resumeTailoring.service.js - FIXED FRESH ANALYSIS ISSUE
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const { openai } = require('../config/openai');
const { PutObjectCommand, GetObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const { s3Client, S3_BUCKET } = require('../config/s3');
const path = require('path');
const uuid = require('uuid').v4;
const resumeAnalysisService = require('./resumeAnalysis.service');
const PDFDocument = require('pdfkit');

/**
 * Get tailoring recommendations for a resume based on a job
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @returns {Object} Tailoring recommendations
 */
exports.getTailoringRecommendations = async (resumeId, jobId) => {
  try {
    console.log(`Generating tailoring recommendations for resume ${resumeId} to job ${jobId}`);
    
    // Get the resume, job, and any existing match analysis
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Get the match analysis if it exists
    const matchAnalysis = job.matchAnalysis && job.matchAnalysis.resumeId && 
                          job.matchAnalysis.resumeId.toString() === resumeId ? 
                          job.matchAnalysis : null;
    
    console.log('Generating tailoring recommendations with OpenAI');
    
    // Convert data to strings for OpenAI
    const resumeData = JSON.stringify(resume.parsedData, null, 2);
    const jobData = JSON.stringify(job.parsedData, null, 2);
    const matchData = matchAnalysis ? JSON.stringify(matchAnalysis, null, 2) : 'No match analysis available';
    
    // Prompt for OpenAI to generate tailoring recommendations
    const prompt = `
    Generate detailed recommendations for tailoring the following resume to better match the job description.

    Provide the recommendations in JSON format with the following structure:
    {
      "summary": {
        "original": "original summary text",
        "tailored": "tailored summary text"
      },
      "experienceImprovements": [
        {
          "company": "company name",
          "position": "position title",
          "original": ["original bullet point 1", "original bullet point 2"],
          "tailored": ["tailored bullet point 1", "tailored bullet point 2"]
        }
      ],
      "skillsImprovements": {
        "skillsToAdd": ["skill1", "skill2"],
        "skillsToEmphasize": ["skill3", "skill4"]
      },
      "keywordSuggestions": ["keyword1", "keyword2", "keyword3"],
      "formatSuggestions": ["format suggestion 1", "format suggestion 2"],
      "generalAdvice": "General advice for tailoring this resume to this job"
    }

    Return ONLY the JSON without any markdown formatting, code blocks, or additional explanation.
    Focus on tailoring content to highlight experience and skills that are most relevant to the job.
    The tailored content should be truthful and based on the original resume - no fabrication.
    Use relevant keywords and phrases from the job description naturally.
    Prioritize the most important skills and requirements from the job description.
    Keep the tailored version concise, impactful, and achievement-oriented.

    Resume Data:
    ${resumeData}

    Job Data:
    ${jobData}

    Match Analysis:
    ${matchData}
    `;
    
    // Call OpenAI API
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system", 
          content: "You are an expert resume writer specializing in tailoring resumes to specific job descriptions. Return ONLY JSON without markdown formatting or code blocks."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.4,
      max_tokens: 3000,
    });
    
    // Parse the response
    const content = response.choices[0].message.content;
    
    // Extract JSON from the response if it's wrapped in markdown
    let jsonStr = content;
    
    // Handle potential markdown code blocks
    if (content.includes('```')) {
      const jsonMatch = content.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        jsonStr = jsonMatch[1];
      }
    }
    
    // Clean up any extra whitespace or newlines
    jsonStr = jsonStr.trim();
    
    // Ensure it's a valid JSON object
    if (!jsonStr.startsWith('{')) {
      jsonStr = '{' + jsonStr.substring(jsonStr.indexOf('"'));
    }
    if (!jsonStr.endsWith('}')) {
      jsonStr = jsonStr.substring(0, jsonStr.lastIndexOf('}') + 1);
    }
    
    // Parse the cleaned JSON
    const recommendations = JSON.parse(jsonStr);
    console.log('Resume tailoring recommendations with OpenAI completed successfully');
    
    return recommendations;
  } catch (error) {
    console.error('Error generating tailoring recommendations with OpenAI:', error);
    
    // Fallback to a simplified recommendations structure
    return {
      summary: {
        original: "Could not retrieve original summary.",
        tailored: "Could not generate tailored summary. Please try again later."
      },
      experienceImprovements: [],
      skillsImprovements: {
        skillsToAdd: ["Technical error occurred while generating recommendations."],
        skillsToEmphasize: []
      },
      keywordSuggestions: ["Please try again later."],
      formatSuggestions: ["Ensure your resume is clear and concise."],
      generalAdvice: "Focus on highlighting relevant experience and skills that match the job requirements."
    };
  }
};

/**
 * Generate a proper PDF from resume data
 * @param {Object} resumeData - The tailored resume data
 * @param {string} resumeName - Name of the resume
 * @param {Object} jobInfo - Job information for context
 * @returns {Buffer} PDF buffer
 */
function generateResumePDF(resumeData, resumeName, jobInfo) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: 'A4'
      });
      
      const buffers = [];
      
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });
      
      // Helper function to add styled text
      const addText = (text, options = {}) => {
        const defaultOptions = {
          fontSize: 11,
          lineGap: 2
        };
        doc.text(text, { ...defaultOptions, ...options });
      };
      
      // Header with contact info
      if (resumeData.contactInfo) {
        doc.fontSize(18).font('Helvetica-Bold')
           .text(resumeData.contactInfo.name || 'Professional Resume', { align: 'center' });
        
        doc.fontSize(10).font('Helvetica')
           .text([
             resumeData.contactInfo.email,
             resumeData.contactInfo.phone,
             resumeData.contactInfo.location
           ].filter(Boolean).join(' | '), { align: 'center' });
        
        doc.moveDown(1);
      }
      
      // Professional Summary
      if (resumeData.summary) {
        doc.fontSize(14).font('Helvetica-Bold').text('PROFESSIONAL SUMMARY');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        doc.fontSize(11).font('Helvetica').text(resumeData.summary, {
          align: 'justify',
          lineGap: 2
        });
        doc.moveDown(1);
      }
      
      // Work Experience
      if (resumeData.experience && resumeData.experience.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('WORK EXPERIENCE');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.experience.forEach((exp, index) => {
          // Job title and company
          doc.fontSize(12).font('Helvetica-Bold')
             .text(`${exp.title || 'Position'} | ${exp.company || 'Company'}`, { continued: false });
          
          // Dates and location
          const dateStr = exp.startDate && exp.endDate 
            ? `${new Date(exp.startDate).toLocaleDateString()} - ${exp.endDate ? new Date(exp.endDate).toLocaleDateString() : 'Present'}`
            : exp.startDate 
              ? `From ${new Date(exp.startDate).toLocaleDateString()}`
              : 'Date not specified';
          
          doc.fontSize(10).font('Helvetica').fillColor('gray')
             .text(`${dateStr}${exp.location ? ' | ' + exp.location : ''}`, { align: 'right' });
          
          doc.fillColor('black').moveDown(0.3);
          
          // Description
          if (exp.description) {
            doc.fontSize(11).font('Helvetica').text(exp.description, { lineGap: 2 });
            doc.moveDown(0.3);
          }
          
          // Highlights/Achievements
          if (exp.highlights && exp.highlights.length > 0) {
            exp.highlights.forEach(highlight => {
              doc.fontSize(11).font('Helvetica')
                 .text(`• ${highlight}`, { 
                   indent: 15,
                   lineGap: 2,
                   paragraphGap: 2
                 });
            });
          }
          
          // Skills used
          if (exp.skills && exp.skills.length > 0) {
            doc.moveDown(0.3);
            doc.fontSize(10).font('Helvetica-Oblique').fillColor('gray')
               .text(`Technologies: ${exp.skills.join(', ')}`, { lineGap: 2 });
            doc.fillColor('black');
          }
          
          if (index < resumeData.experience.length - 1) {
            doc.moveDown(0.8);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Education
      if (resumeData.education && resumeData.education.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('EDUCATION');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.education.forEach((edu, index) => {
          doc.fontSize(12).font('Helvetica-Bold')
             .text(`${edu.degree || 'Degree'} ${edu.field ? 'in ' + edu.field : ''}`);
          
          doc.fontSize(11).font('Helvetica')
             .text(edu.institution || 'Institution');
          
          if (edu.startDate || edu.endDate) {
            const dateStr = edu.startDate && edu.endDate 
              ? `${new Date(edu.startDate).getFullYear()} - ${new Date(edu.endDate).getFullYear()}`
              : edu.endDate 
                ? new Date(edu.endDate).getFullYear().toString()
                : 'Current';
            
            doc.fontSize(10).font('Helvetica').fillColor('gray')
               .text(dateStr);
            doc.fillColor('black');
          }
          
          if (edu.gpa) {
            doc.fontSize(10).text(`GPA: ${edu.gpa}`);
          }
          
          if (index < resumeData.education.length - 1) {
            doc.moveDown(0.5);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Skills
      if (resumeData.skills && resumeData.skills.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('SKILLS & TECHNOLOGIES');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        const skillsText = resumeData.skills.map(skill => {
          if (typeof skill === 'object' && skill.name) {
            return skill.level ? `${skill.name} (${skill.level})` : skill.name;
          }
          return skill;
        }).join(' • ');
        
        doc.fontSize(11).font('Helvetica').text(skillsText, { lineGap: 2 });
        doc.moveDown(1);
      }
      
      // Certifications
      if (resumeData.certifications && resumeData.certifications.length > 0) {
        doc.fontSize(14).font('Helvetica-Bold').text('CERTIFICATIONS');
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown(0.5);
        
        resumeData.certifications.forEach((cert, index) => {
          doc.fontSize(11).font('Helvetica-Bold').text(cert.name || 'Certification');
          doc.fontSize(10).font('Helvetica').text(cert.issuer || 'Issuer');
          
          if (cert.dateObtained) {
            doc.fontSize(10).fillColor('gray')
               .text(`Obtained: ${new Date(cert.dateObtained).toLocaleDateString()}`);
            doc.fillColor('black');
          }
          
          if (index < resumeData.certifications.length - 1) {
            doc.moveDown(0.5);
          }
        });
        
        doc.moveDown(1);
      }
      
      // Footer note about tailoring
      doc.fontSize(8).font('Helvetica-Oblique').fillColor('gray')
         .text(`This resume has been AI-tailored for ${jobInfo.title} at ${jobInfo.company}`, {
           align: 'center'
         });
      
      // Finalize PDF
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Create a tailored version of a resume for a job
 * @param {string} resumeId - MongoDB ID of the resume
 * @param {string} jobId - MongoDB ID of the job
 * @param {Object} tailoringOptions - Options for tailoring
 * @returns {Object} New resume version information
 */
exports.createTailoredResume = async (resumeId, jobId, tailoringOptions) => {
  try {
    console.log(`Creating tailored resume for resumeId: ${resumeId}, jobId: ${jobId}`);
    
    // Get the resume and job
    const resume = await Resume.findById(resumeId);
    const job = await Job.findById(jobId);
    
    if (!resume) {
      throw new Error('Resume not found');
    }
    
    if (!job) {
      throw new Error('Job not found');
    }
    
    // Get tailoring recommendations if not provided
    const tailoringRecommendations = tailoringOptions?.recommendations || 
                                    await this.getTailoringRecommendations(resumeId, jobId);
    
    // Create a new resume with the tailored data
    const userId = resume.userId;
    
    // Create a unique name for the new resume
    const newResumeName = tailoringOptions?.name || 
                         `[AI Tailored] ${resume.name} for ${job.title} at ${job.company}`;
    
    // Create a deep copy of the original resume's parsed data
    const parsedData = JSON.parse(JSON.stringify(resume.parsedData));
    
    // Apply tailoring recommendations to the parsed data
    // Update summary if available
    if (tailoringRecommendations.summary && 
        tailoringRecommendations.summary.tailored && 
        tailoringRecommendations.summary.tailored !== "Could not generate tailored summary. Please try again later.") {
      parsedData.summary = tailoringRecommendations.summary.tailored;
    }
    
    // Update experience bullet points
    if (tailoringRecommendations.experienceImprovements && 
        tailoringRecommendations.experienceImprovements.length > 0) {
      
      tailoringRecommendations.experienceImprovements.forEach(improvement => {
        // Find the matching experience in the original resume
        const experienceIndex = parsedData.experience.findIndex(exp => 
          exp.company === improvement.company && exp.title === improvement.position);
        
        if (experienceIndex !== -1) {
          // If there are highlights, replace them with the tailored ones
          if (parsedData.experience[experienceIndex].highlights && improvement.tailored) {
            parsedData.experience[experienceIndex].highlights = improvement.tailored;
          }
        }
      });
    }
    
    // Add missing skills
    if (tailoringRecommendations.skillsImprovements && 
        tailoringRecommendations.skillsImprovements.skillsToAdd) {
      
      // Create a set of existing skill names for quick lookup
      const existingSkillNames = new Set(parsedData.skills.map(skill => 
        typeof skill === 'string' ? skill.toLowerCase() : skill.name.toLowerCase()));
      
      // Add new skills that don't already exist
      tailoringRecommendations.skillsImprovements.skillsToAdd.forEach(skill => {
        if (!existingSkillNames.has(skill.toLowerCase())) {
          // If existing skills are objects with name property
          if (parsedData.skills.length > 0 && typeof parsedData.skills[0] === 'object') {
            parsedData.skills.push({
              name: skill,
              level: "Intermediate", // Default level
              yearsOfExperience: null
            });
          } else {
            // If existing skills are just strings
            parsedData.skills.push(skill);
          }
        }
      });
    }
    
    console.log('Generating tailored resume PDF...');
    
    // Generate the tailored resume as a proper PDF
    const pdfBuffer = await generateResumePDF(parsedData, newResumeName, {
      title: job.title,
      company: job.company
    });
    
    // Generate a unique S3 key
    const s3Key = `resumes/${userId}/${uuid()}.pdf`;
    
    // Upload to S3
    const uploadParams = {
      Bucket: S3_BUCKET,
      Key: s3Key,
      Body: pdfBuffer,
      ContentType: 'application/pdf'
    };
    
    await s3Client.send(new PutObjectCommand(uploadParams));
    console.log('Tailored resume PDF uploaded to S3:', s3Key);
    
    // Create a new resume document in MongoDB WITHOUT ANALYSIS INITIALLY
    const newResume = new Resume({
      userId,
      name: newResumeName,
      originalFilename: `${newResumeName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`,
      fileUrl: s3Key,
      fileType: 'PDF',
      isActive: false,
      parsedData: parsedData,
      analysis: null, // CRITICAL: Set to null initially to force fresh analysis
      isTailored: true,
      tailoredForJob: {
        jobId: job._id,
        jobTitle: job.title,
        company: job.company,
        originalResumeId: resume._id
      },
      versions: [],
      processingStatus: {
        status: 'analyzing',
        progress: 75,
        message: 'Running fresh AI analysis on tailored resume...',
        updatedAt: new Date()
      }
    });
    
    // CRITICAL: Save the resume FIRST, then run analysis
    await newResume.save();
    console.log('Tailored resume created successfully with ID:', newResume._id);
    
    // CRITICAL: Add a delay to ensure the resume is fully saved before analysis
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // CRITICAL: Run fresh analysis on the tailored resume in a separate process
    console.log('Starting fresh AI analysis for tailored resume...');
    
    try {
      // Force a fresh analysis by calling the service directly
      const analysis = await resumeAnalysisService.analyzeResume(newResume._id);
      
      console.log('Fresh analysis completed:', {
        resumeId: newResume._id,
        overallScore: analysis.overallScore,
        atsCompatibility: analysis.atsCompatibility,
        hasProfileSummary: !!analysis.profileSummary,
        strengthsCount: analysis.strengths?.length || 0
      });
      
      // CRITICAL: Update the resume with the NEW analysis scores
      await Resume.findByIdAndUpdate(newResume._id, {
        $set: {
          analysis: analysis,
          processingStatus: {
            status: 'completed',
            progress: 100,
            message: 'Fresh analysis completed successfully',
            updatedAt: new Date()
          }
        }
      }, { new: true });
      
      console.log('✅ Fresh analysis saved to database successfully');
      
      // Update the local object for return
      newResume.analysis = analysis;
      newResume.processingStatus = {
        status: 'completed',
        progress: 100,
        message: 'Fresh analysis completed successfully',
        updatedAt: new Date()
      };
      
    } catch (analysisError) {
      console.error('❌ Error running fresh analysis on tailored resume:', analysisError);
      
      // Update status to show analysis failed
      await Resume.findByIdAndUpdate(newResume._id, {
        $set: {
          analysis: {
            overallScore: 0,
            atsCompatibility: 0,
            profileSummary: { currentRole: "Analysis pending", careerLevel: "Unknown", industries: [], suggestedJobTitles: [], suggestedIndustries: [] },
            strengths: ["Analysis in progress..."],
            weaknesses: ["Analysis in progress..."],
            keywordsSuggestions: ["Analysis in progress..."],
            improvementAreas: []
          },
          processingStatus: {
            status: 'error',
            progress: 50,
            message: 'Fresh analysis failed - please try manual analysis',
            error: analysisError.message,
            updatedAt: new Date()
          }
        }
      });
      
      // Set the error state in the local object
      newResume.analysis = {
        overallScore: 0,
        atsCompatibility: 0,
        profileSummary: { currentRole: "Analysis pending", careerLevel: "Unknown", industries: [], suggestedJobTitles: [], suggestedIndustries: [] },
        strengths: ["Analysis failed - please retry"],
        weaknesses: ["Analysis failed - please retry"],
        keywordsSuggestions: ["Analysis failed - please retry"],
        improvementAreas: []
      };
    }
    
    // AUTOMATIC TRIGGER: Re-match THIS SPECIFIC JOB with the new tailored resume
    console.log('🔄 Auto-triggering job re-match with new tailored resume...');
    try {
      const jobMatchingService = require('./jobMatching.service');
      
      // Force re-match this specific job with the new tailored resume
      const matchAnalysis = await jobMatchingService.matchResumeWithJob(newResume._id, jobId);
      
      // Update the job's match analysis with the new tailored resume
      job.matchAnalysis = {
        ...matchAnalysis,
        resumeId: newResume._id,
        lastAnalyzed: new Date(),
        analysisVersion: '2.0-tailored-auto',
        tailoredResumeId: newResume._id
      };
      
      await job.save();
      
      console.log('✅ Job-specific auto re-match completed:', {
        jobId: job._id,
        jobTitle: job.title,
        newScore: `${matchAnalysis.overallScore}%`,
        usedTailoredResume: newResume.name
      });
      
    } catch (rematchError) {
      console.error('❌ Auto re-match failed (non-critical):', rematchError.message);
      // Still add reference even if re-matching fails
      if (job.matchAnalysis) {
        job.matchAnalysis.tailoredResumeId = newResume._id;
        await job.save();
      }
    }
    
    // Generate a signed URL for downloading
    const getObjectParams = {
      Bucket: S3_BUCKET,
      Key: s3Key
    };
    
    const command = new GetObjectCommand(getObjectParams);
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
    
    return {
      message: "Tailored resume created successfully with fresh analysis",
      resume: {
        id: newResume._id,
        name: newResume.name,
        originalFilename: newResume.originalFilename,
        fileType: newResume.fileType,
        isTailored: newResume.isTailored,
        downloadUrl: signedUrl,
        analysis: newResume.analysis,
        processingStatus: newResume.processingStatus,
        createdAt: newResume.createdAt
      }
    };
  } catch (error) {
    console.error('Error creating tailored resume:', error);
    throw error;
  }
};

================
File: backend/services/stripe.service.js
================
// backend/services/stripe.service.js - COMPLETE MONTHLY ONLY VERSION
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const User = require('../models/mongodb/user.model');
const db = require('../config/postgresql');

class StripeService {
  /**
   * Create or retrieve a Stripe customer
   * @param {Object} user - User object from MongoDB
   * @returns {Object} Stripe customer object
   */
  async createOrGetCustomer(user) {
    try {
      // If user already has a Stripe customer ID, retrieve it
      if (user.stripeCustomerId) {
        try {
          const customer = await stripe.customers.retrieve(user.stripeCustomerId);
          return customer;
        } catch (error) {
          console.error('Error retrieving existing customer:', error);
          // If customer doesn't exist, create a new one
        }
      }

      // Create new Stripe customer
      const customer = await stripe.customers.create({
        email: user.email,
        name: `${user.firstName} ${user.lastName}`,
        metadata: {
          userId: user._id.toString(),
          plan: user.subscriptionTier
        }
      });

      // Update user with Stripe customer ID
      await User.findByIdAndUpdate(user._id, {
        stripeCustomerId: customer.id
      });

      console.log(`✅ Created Stripe customer: ${customer.id} for user: ${user.email}`);
      return customer;
    } catch (error) {
      console.error('Error creating Stripe customer:', error);
      throw new Error('Failed to create customer: ' + error.message);
    }
  }

  /**
   * Create a checkout session for subscription (Monthly only)
   * @param {Object} params - Checkout parameters
   * @returns {Object} Stripe checkout session
   */
  async createCheckoutSession({
    userId,
    priceId,
    successUrl,
    cancelUrl,
    planName
  }) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      const customer = await this.createOrGetCustomer(user);

      const sessionParams = {
        customer: customer.id,
        payment_method_types: ['card'],
        mode: 'subscription',
        line_items: [
          {
            price: priceId,
            quantity: 1,
          },
        ],
        success_url: successUrl,
        cancel_url: cancelUrl,
        metadata: {
          userId: userId,
          planName: planName,
          billingCycle: 'monthly' // Always monthly
        },
        subscription_data: {
          metadata: {
            userId: userId,
            planName: planName
          },
          trial_period_days: planName !== 'free' ? 7 : 0 // 7-day trial for paid plans
        }
      };

      const session = await stripe.checkout.sessions.create(sessionParams);

      console.log(`✅ Created checkout session: ${session.id} for plan: ${planName} (monthly)`);
      return session;
    } catch (error) {
      console.error('Error creating checkout session:', error);
      throw new Error('Failed to create checkout session: ' + error.message);
    }
  }

  /**
   * Create a customer portal session
   * @param {string} customerId - Stripe customer ID
   * @param {string} returnUrl - URL to return to after managing subscription
   * @returns {Object} Customer portal session
   */
  async createCustomerPortalSession(customerId, returnUrl) {
    try {
      const session = await stripe.billingPortal.sessions.create({
        customer: customerId,
        return_url: returnUrl,
      });

      return session;
    } catch (error) {
      console.error('Error creating customer portal session:', error);
      throw new Error('Failed to create customer portal session: ' + error.message);
    }
  }

  /**
   * Get subscription details
   * @param {string} subscriptionId - Stripe subscription ID
   * @returns {Object} Subscription object
   */
  async getSubscription(subscriptionId) {
    try {
      const subscription = await stripe.subscriptions.retrieve(subscriptionId);
      return subscription;
    } catch (error) {
      console.error('Error retrieving subscription:', error);
      throw new Error('Failed to retrieve subscription: ' + error.message);
    }
  }

  /**
   * Cancel subscription
   * @param {string} subscriptionId - Stripe subscription ID
   * @param {boolean} atPeriodEnd - Whether to cancel at period end
   * @returns {Object} Updated subscription object
   */
  async cancelSubscription(subscriptionId, atPeriodEnd = true) {
    try {
      const subscription = await stripe.subscriptions.update(subscriptionId, {
        cancel_at_period_end: atPeriodEnd,
      });

      console.log(`✅ Subscription ${subscriptionId} marked for cancellation`);
      return subscription;
    } catch (error) {
      console.error('Error canceling subscription:', error);
      throw new Error('Failed to cancel subscription: ' + error.message);
    }
  }

  /**
   * Resume subscription
   * @param {string} subscriptionId - Stripe subscription ID
   * @returns {Object} Updated subscription object
   */
  async resumeSubscription(subscriptionId) {
    try {
      const subscription = await stripe.subscriptions.update(subscriptionId, {
        cancel_at_period_end: false,
      });

      console.log(`✅ Subscription ${subscriptionId} resumed`);
      return subscription;
    } catch (error) {
      console.error('Error resuming subscription:', error);
      throw new Error('Failed to resume subscription: ' + error.message);
    }
  }

  /**
   * Change subscription plan (Monthly only)
   * @param {string} subscriptionId - Stripe subscription ID
   * @param {string} newPriceId - New monthly price ID
   * @returns {Object} Updated subscription object
   */
  async changeSubscriptionPlan(subscriptionId, newPriceId) {
    try {
      const subscription = await stripe.subscriptions.retrieve(subscriptionId);
      
      const updatedSubscription = await stripe.subscriptions.update(subscriptionId, {
        items: [
          {
            id: subscription.items.data[0].id,
            price: newPriceId,
          },
        ],
        proration_behavior: 'create_prorations',
      });

      console.log(`✅ Subscription ${subscriptionId} plan changed to ${newPriceId} (monthly)`);
      return updatedSubscription;
    } catch (error) {
      console.error('Error changing subscription plan:', error);
      throw new Error('Failed to change subscription plan: ' + error.message);
    }
  }

  /**
   * Get customer's payment methods
   * @param {string} customerId - Stripe customer ID
   * @returns {Array} Array of payment methods
   */
  async getPaymentMethods(customerId) {
    try {
      const paymentMethods = await stripe.paymentMethods.list({
        customer: customerId,
        type: 'card',
      });

      return paymentMethods.data;
    } catch (error) {
      console.error('Error retrieving payment methods:', error);
      throw new Error('Failed to retrieve payment methods: ' + error.message);
    }
  }

  /**
   * Get customer's invoices
   * @param {string} customerId - Stripe customer ID
   * @param {number} limit - Number of invoices to retrieve
   * @returns {Array} Array of invoices
   */
  async getCustomerInvoices(customerId, limit = 10) {
    try {
      const invoices = await stripe.invoices.list({
        customer: customerId,
        limit: limit,
      });

      return invoices.data;
    } catch (error) {
      console.error('Error retrieving invoices:', error);
      throw new Error('Failed to retrieve invoices: ' + error.message);
    }
  }

  /**
   * Handle webhook events
   * @param {Object} event - Stripe webhook event
   */
  async handleWebhookEvent(event) {
    try {
      console.log(`🔔 Received Stripe webhook: ${event.type}`);

      // Log webhook event to database
      await this.logWebhookEvent(event);

      switch (event.type) {
        case 'customer.subscription.created':
          await this.handleSubscriptionCreated(event.data.object);
          break;

        case 'customer.subscription.updated':
          await this.handleSubscriptionUpdated(event.data.object);
          break;

        case 'customer.subscription.deleted':
          await this.handleSubscriptionDeleted(event.data.object);
          break;

        case 'invoice.payment_succeeded':
          await this.handlePaymentSucceeded(event.data.object);
          break;

        case 'invoice.payment_failed':
          await this.handlePaymentFailed(event.data.object);
          break;

        case 'checkout.session.completed':
          await this.handleCheckoutCompleted(event.data.object);
          break;

        default:
          console.log(`⚠️ Unhandled event type: ${event.type}`);
      }

      // Mark webhook as processed
      await this.markWebhookProcessed(event.id);
    } catch (error) {
      console.error('Error handling webhook event:', error);
      await this.logWebhookError(event.id, error.message);
      throw error;
    }
  }

  /**
   * Handle subscription created event
   */
  async handleSubscriptionCreated(subscription) {
    try {
      const userId = subscription.metadata.userId;
      const planName = subscription.metadata.planName;

      if (!userId) {
        console.error('No userId in subscription metadata');
        return;
      }

      // Update user subscription in MongoDB (always monthly)
      await User.findByIdAndUpdate(userId, {
        subscriptionTier: planName,
        subscriptionStatus: subscription.status,
        subscriptionStartDate: new Date(subscription.created * 1000),
        subscriptionEndDate: new Date(subscription.current_period_end * 1000),
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        trialEndDate: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null
      });

      // Create subscription record in PostgreSQL
      await db.query(`
        INSERT INTO user_subscriptions (
          user_id, stripe_customer_id, stripe_subscription_id, status, 
          current_period_start, current_period_end,
          cancel_at_period_end, trial_start, trial_end
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        ON CONFLICT (user_id) DO UPDATE SET
          stripe_subscription_id = $3,
          status = $4,
          current_period_start = $5,
          current_period_end = $6,
          cancel_at_period_end = $7,
          trial_start = $8,
          trial_end = $9,
          updated_at = NOW()
      `, [
        userId,
        subscription.customer,
        subscription.id,
        subscription.status,
        new Date(subscription.created * 1000),
        new Date(subscription.current_period_end * 1000),
        subscription.cancel_at_period_end,
        subscription.trial_start ? new Date(subscription.trial_start * 1000) : null,
        subscription.trial_end ? new Date(subscription.trial_end * 1000) : null
      ]);

      console.log(`✅ Monthly subscription created for user ${userId}: ${subscription.id}`);
    } catch (error) {
      console.error('Error handling subscription created:', error);
      throw error;
    }
  }

  /**
   * Handle subscription updated event
   */
  async handleSubscriptionUpdated(subscription) {
    try {
      const userId = subscription.metadata.userId;

      if (!userId) {
        console.error('No userId in subscription metadata');
        return;
      }

      // Update user subscription in MongoDB
      await User.findByIdAndUpdate(userId, {
        subscriptionStatus: subscription.status,
        subscriptionEndDate: new Date(subscription.current_period_end * 1000),
        cancelAtPeriodEnd: subscription.cancel_at_period_end
      });

      // Update subscription record in PostgreSQL
      await db.query(`
        UPDATE user_subscriptions SET
          status = $1,
          current_period_end = $2,
          cancel_at_period_end = $3,
          updated_at = NOW()
        WHERE user_id = $4
      `, [
        subscription.status,
        new Date(subscription.current_period_end * 1000),
        subscription.cancel_at_period_end,
        userId
      ]);

      console.log(`✅ Monthly subscription updated for user ${userId}: ${subscription.id}`);
    } catch (error) {
      console.error('Error handling subscription updated:', error);
      throw error;
    }
  }

  /**
   * Handle subscription deleted event
   */
  async handleSubscriptionDeleted(subscription) {
    try {
      const userId = subscription.metadata.userId;

      if (!userId) {
        console.error('No userId in subscription metadata');
        return;
      }

      // Downgrade user to free plan
      await User.findByIdAndUpdate(userId, {
        subscriptionTier: 'free',
        subscriptionStatus: 'canceled',
        cancelAtPeriodEnd: false
      });

      // Update subscription record in PostgreSQL
      await db.query(`
        UPDATE user_subscriptions SET
          status = 'canceled',
          canceled_at = NOW(),
          updated_at = NOW()
        WHERE user_id = $1
      `, [userId]);

      console.log(`✅ Subscription canceled for user ${userId}: ${subscription.id}`);
    } catch (error) {
      console.error('Error handling subscription deleted:', error);
      throw error;
    }
  }

  /**
   * Handle payment succeeded event
   */
  async handlePaymentSucceeded(invoice) {
    try {
      const customerId = invoice.customer;

      // Record payment in PostgreSQL
      await db.query(`
        INSERT INTO payment_history (
          user_id, stripe_payment_intent_id, stripe_invoice_id,
          amount, currency, status, payment_method, billing_reason,
          description, invoice_url, receipt_url
        ) VALUES (
          (SELECT user_id FROM user_subscriptions WHERE stripe_customer_id = $1),
          $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
        )
      `, [
        customerId,
        invoice.payment_intent,
        invoice.id,
        invoice.amount_paid / 100, // Convert from cents
        invoice.currency,
        'succeeded',
        'card',
        invoice.billing_reason,
        invoice.description || 'Monthly subscription payment',
        invoice.hosted_invoice_url,
        invoice.receipt_url
      ]);

      console.log(`✅ Monthly payment succeeded recorded: ${invoice.id}`);
    } catch (error) {
      console.error('Error handling payment succeeded:', error);
      throw error;
    }
  }

  /**
   * Handle payment failed event
   */
  async handlePaymentFailed(invoice) {
    try {
      const customerId = invoice.customer;

      // Record failed payment in PostgreSQL
      await db.query(`
        INSERT INTO payment_history (
          user_id, stripe_invoice_id, amount, currency, status,
          billing_reason, description
        ) VALUES (
          (SELECT user_id FROM user_subscriptions WHERE stripe_customer_id = $1),
          $2, $3, $4, $5, $6, $7
        )
      `, [
        customerId,
        invoice.id,
        invoice.amount_due / 100, // Convert from cents
        invoice.currency,
        'failed',
        invoice.billing_reason,
        'Monthly payment failed for subscription'
      ]);

      console.log(`⚠️ Monthly payment failed recorded: ${invoice.id}`);
    } catch (error) {
      console.error('Error handling payment failed:', error);
      throw error;
    }
  }

  /**
   * Handle checkout session completed
   */
  async handleCheckoutCompleted(session) {
    try {
      const userId = session.metadata.userId;
      const planName = session.metadata.planName;

      if (!userId) {
        console.error('No userId in checkout session metadata');
        return;
      }

      console.log(`✅ Monthly checkout completed for user ${userId}: Plan ${planName}`);
    } catch (error) {
      console.error('Error handling checkout completed:', error);
      throw error;
    }
  }

  /**
   * Log webhook event to database
   */
  async logWebhookEvent(event) {
    try {
      await db.query(`
        INSERT INTO webhook_events (stripe_event_id, event_type, data)
        VALUES ($1, $2, $3)
        ON CONFLICT (stripe_event_id) DO NOTHING
      `, [event.id, event.type, JSON.stringify(event)]);
    } catch (error) {
      console.error('Error logging webhook event:', error);
    }
  }

  /**
   * Mark webhook as processed
   */
  async markWebhookProcessed(eventId) {
    try {
      await db.query(`
        UPDATE webhook_events SET
          processed = true,
          processed_at = NOW()
        WHERE stripe_event_id = $1
      `, [eventId]);
    } catch (error) {
      console.error('Error marking webhook processed:', error);
    }
  }

  /**
   * Log webhook error
   */
  async logWebhookError(eventId, errorMessage) {
    try {
      await db.query(`
        UPDATE webhook_events SET
          error_message = $1
        WHERE stripe_event_id = $2
      `, [errorMessage, eventId]);
    } catch (error) {
      console.error('Error logging webhook error:', error);
    }
  }

  /**
   * Get pricing information for plans (Monthly only)
   */
  async getPricingInfo() {
    try {
      const prices = await stripe.prices.list({
        active: true,
        expand: ['data.product']
      });

      return prices.data
        .filter(price => price.recurring?.interval === 'month') // Only monthly prices
        .map(price => ({
          id: price.id,
          productId: price.product.id,
          productName: price.product.name,
          amount: price.unit_amount / 100,
          currency: price.currency,
          interval: 'month',
          intervalCount: 1
        }));
    } catch (error) {
      console.error('Error getting pricing info:', error);
      throw new Error('Failed to get pricing info: ' + error.message);
    }
  }

  /**
   * Verify webhook signature
   */
  verifyWebhookSignature(payload, signature, endpointSecret) {
    try {
      return stripe.webhooks.constructEvent(payload, signature, endpointSecret);
    } catch (error) {
      console.error('Webhook signature verification failed:', error.message);
      throw new Error('Invalid webhook signature');
    }
  }
}

module.exports = new StripeService();

================
File: backend/services/subscription.service.js
================
// backend/services/subscription.service.js - COMPLETE MONTHLY ONLY VERSION
const User = require('../models/mongodb/user.model');
const db = require('../config/postgresql');
const stripeService = require('./stripe.service');

class SubscriptionService {
  /**
   * Get user's current subscription with details
   * @param {string} userId - User ID
   * @returns {Object} Subscription details
   */
  async getCurrentSubscription(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Get PostgreSQL subscription details
      const subscriptionQuery = await db.query(`
        SELECT 
          us.*,
          sp.display_name as plan_display_name,
          sp.description as plan_description,
          sp.price_monthly,
          sp.features,
          sp.limits
        FROM user_subscriptions us
        LEFT JOIN subscription_plans sp ON sp.name = $2
        WHERE us.user_id = $1
      `, [userId, user.subscriptionTier]);

      const subscription = subscriptionQuery.rows[0];

      // Get plan limits and usage
      const planLimits = user.getPlanLimits();
      const usageStats = user.getUsageStats();

      return {
        user: {
          id: user._id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          subscriptionTier: user.subscriptionTier,
          subscriptionStatus: user.subscriptionStatus,
          subscriptionStartDate: user.subscriptionStartDate,
          subscriptionEndDate: user.subscriptionEndDate,
          trialEndDate: user.trialEndDate,
          cancelAtPeriodEnd: user.cancelAtPeriodEnd,
          billingCycle: 'monthly', // Always monthly
          stripeCustomerId: user.stripeCustomerId
        },
        subscription: subscription || null,
        planLimits,
        usageStats,
        isActive: user.hasActiveSubscription()
      };
    } catch (error) {
      console.error('Error getting current subscription:', error);
      throw new Error('Failed to get subscription: ' + error.message);
    }
  }

  /**
   * Get all available subscription plans (Monthly only)
   * @returns {Array} Array of subscription plans
   */
  async getAvailablePlans() {
    try {
      const plansQuery = await db.query(`
        SELECT * FROM subscription_plans 
        WHERE is_active = true 
        ORDER BY sort_order ASC
      `);

      return plansQuery.rows.map(plan => ({
        ...plan,
        features: plan.features || {},
        limits: plan.limits || {},
        billingCycle: 'monthly' // Always monthly
      }));
    } catch (error) {
      console.error('Error getting available plans:', error);
      throw new Error('Failed to get plans: ' + error.message);
    }
  }

  /**
   * Check if user has permission for a specific feature
   * @param {string} userId - User ID
   * @param {string} feature - Feature to check
   * @param {number} quantity - Quantity needed (default: 1)
   * @returns {Object} Permission result
   */
  async checkPermission(userId, feature, quantity = 1) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      return user.canPerformAction(feature, quantity);
    } catch (error) {
      console.error('Error checking permission:', error);
      throw new Error('Failed to check permission: ' + error.message);
    }
  }

  /**
   * Track usage for a specific feature
   * @param {string} userId - User ID
   * @param {string} feature - Feature being used
   * @param {number} quantity - Quantity to track (default: 1)
   * @returns {Object} Updated usage stats
   */
  async trackUsage(userId, feature, quantity = 1) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Check if user can perform this action
      const permission = user.canPerformAction(feature, quantity);
      if (!permission.allowed) {
        throw new Error(permission.reason);
      }

      // Track the usage
      await user.trackUsage(feature, quantity);

      // Also track in PostgreSQL for analytics
      await this.trackUsageInPostgreSQL(userId, feature, quantity);

      return user.getUsageStats();
    } catch (error) {
      console.error('Error tracking usage:', error);
      throw new Error('Failed to track usage: ' + error.message);
    }
  }

  /**
   * Track usage in PostgreSQL for analytics
   * @param {string} userId - User ID
   * @param {string} feature - Feature being used
   * @param {number} quantity - Quantity to track
   */
  async trackUsageInPostgreSQL(userId, feature, quantity) {
    try {
      const currentDate = new Date();
      const usagePeriod = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);

      await db.query(`
        INSERT INTO user_usage (user_id, usage_period, ${feature})
        VALUES ($1, $2, $3)
        ON CONFLICT (user_id, usage_period) 
        DO UPDATE SET 
          ${feature} = user_usage.${feature} + $3,
          updated_at = NOW()
      `, [userId, usagePeriod, quantity]);
    } catch (error) {
      console.error('Error tracking usage in PostgreSQL:', error);
      // Don't throw error for analytics tracking failure
    }
  }

  /**
   * Create checkout session for plan upgrade (Monthly only)
   * @param {string} userId - User ID
   * @param {string} planName - Plan to upgrade to
   * @param {string} successUrl - URL to redirect on success
   * @param {string} cancelUrl - URL to redirect on cancel
   * @returns {Object} Checkout session
   */
  async createCheckoutSession(userId, planName, successUrl, cancelUrl) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Get plan details
      const planQuery = await db.query(`
        SELECT * FROM subscription_plans 
        WHERE name = $1 AND is_active = true
      `, [planName]);

      const plan = planQuery.rows[0];
      if (!plan) {
        throw new Error('Plan not found');
      }

      // Use monthly price ID only
      const priceId = plan.stripe_monthly_price_id;

      if (!priceId) {
        throw new Error(`No monthly price configured for ${planName} plan`);
      }

      // Create checkout session (always monthly)
      const session = await stripeService.createCheckoutSession({
        userId,
        priceId,
        successUrl,
        cancelUrl,
        planName
      });

      return session;
    } catch (error) {
      console.error('Error creating checkout session:', error);
      throw new Error('Failed to create checkout session: ' + error.message);
    }
  }

  /**
   * Create customer portal session
   * @param {string} userId - User ID
   * @param {string} returnUrl - URL to return to after managing subscription
   * @returns {Object} Customer portal session
   */
  async createCustomerPortalSession(userId, returnUrl) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      if (!user.stripeCustomerId) {
        throw new Error('User does not have a Stripe customer ID');
      }

      const session = await stripeService.createCustomerPortalSession(
        user.stripeCustomerId,
        returnUrl
      );

      return session;
    } catch (error) {
      console.error('Error creating customer portal session:', error);
      throw new Error('Failed to create customer portal session: ' + error.message);
    }
  }

  /**
   * Cancel subscription
   * @param {string} userId - User ID
   * @param {boolean} atPeriodEnd - Whether to cancel at period end
   * @returns {Object} Updated subscription
   */
  async cancelSubscription(userId, atPeriodEnd = true) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Get subscription details from PostgreSQL
      const subscriptionQuery = await db.query(`
        SELECT stripe_subscription_id FROM user_subscriptions 
        WHERE user_id = $1 AND status = 'active'
      `, [userId]);

      const subscription = subscriptionQuery.rows[0];
      if (!subscription) {
        throw new Error('No active subscription found');
      }

      // Cancel in Stripe
      const updatedSubscription = await stripeService.cancelSubscription(
        subscription.stripe_subscription_id,
        atPeriodEnd
      );

      // Update user in MongoDB
      await User.findByIdAndUpdate(userId, {
        cancelAtPeriodEnd: atPeriodEnd,
        subscriptionStatus: atPeriodEnd ? 'active' : 'canceled'
      });

      return updatedSubscription;
    } catch (error) {
      console.error('Error canceling subscription:', error);
      throw new Error('Failed to cancel subscription: ' + error.message);
    }
  }

  /**
   * Resume subscription
   * @param {string} userId - User ID
   * @returns {Object} Updated subscription
   */
  async resumeSubscription(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Get subscription details from PostgreSQL
      const subscriptionQuery = await db.query(`
        SELECT stripe_subscription_id FROM user_subscriptions 
        WHERE user_id = $1
      `, [userId]);

      const subscription = subscriptionQuery.rows[0];
      if (!subscription) {
        throw new Error('No subscription found');
      }

      // Resume in Stripe
      const updatedSubscription = await stripeService.resumeSubscription(
        subscription.stripe_subscription_id
      );

      // Update user in MongoDB
      await User.findByIdAndUpdate(userId, {
        cancelAtPeriodEnd: false,
        subscriptionStatus: 'active'
      });

      return updatedSubscription;
    } catch (error) {
      console.error('Error resuming subscription:', error);
      throw new Error('Failed to resume subscription: ' + error.message);
    }
  }

  /**
   * Change subscription plan (Monthly only)
   * @param {string} userId - User ID
   * @param {string} newPlanName - New plan name
   * @returns {Object} Updated subscription
   */
  async changeSubscriptionPlan(userId, newPlanName) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Get current subscription
      const subscriptionQuery = await db.query(`
        SELECT stripe_subscription_id FROM user_subscriptions 
        WHERE user_id = $1 AND status = 'active'
      `, [userId]);

      const subscription = subscriptionQuery.rows[0];
      if (!subscription) {
        throw new Error('No active subscription found');
      }

      // Get new plan details
      const planQuery = await db.query(`
        SELECT * FROM subscription_plans 
        WHERE name = $1 AND is_active = true
      `, [newPlanName]);

      const plan = planQuery.rows[0];
      if (!plan) {
        throw new Error('Plan not found');
      }

      // Get monthly price ID
      const newPriceId = plan.stripe_monthly_price_id;

      if (!newPriceId) {
        throw new Error(`No monthly price configured for ${newPlanName} plan`);
      }

      // Change plan in Stripe
      const updatedSubscription = await stripeService.changeSubscriptionPlan(
        subscription.stripe_subscription_id,
        newPriceId
      );

      // Update user in MongoDB
      await User.findByIdAndUpdate(userId, {
        subscriptionTier: newPlanName
      });

      return updatedSubscription;
    } catch (error) {
      console.error('Error changing subscription plan:', error);
      throw new Error('Failed to change subscription plan: ' + error.message);
    }
  }

  /**
   * Get user's billing history
   * @param {string} userId - User ID
   * @param {number} limit - Number of records to return
   * @returns {Array} Array of payment history records
   */
  async getBillingHistory(userId, limit = 10) {
    try {
      const historyQuery = await db.query(`
        SELECT * FROM payment_history 
        WHERE user_id = $1 
        ORDER BY created_at DESC 
        LIMIT $2
      `, [userId, limit]);

      return historyQuery.rows;
    } catch (error) {
      console.error('Error getting billing history:', error);
      throw new Error('Failed to get billing history: ' + error.message);
    }
  }

  /**
   * Get usage analytics for a user
   * @param {string} userId - User ID
   * @param {number} months - Number of months to retrieve (default: 12)
   * @returns {Array} Array of usage data
   */
  async getUsageAnalytics(userId, months = 12) {
    try {
      const analyticsQuery = await db.query(`
        SELECT * FROM user_usage 
        WHERE user_id = $1 
        ORDER BY usage_period DESC 
        LIMIT $2
      `, [userId, months]);

      return analyticsQuery.rows;
    } catch (error) {
      console.error('Error getting usage analytics:', error);
      throw new Error('Failed to get usage analytics: ' + error.message);
    }
  }

  /**
   * Sync subscription status with Stripe
   * @param {string} userId - User ID
   * @returns {Object} Updated subscription status
   */
  async syncSubscriptionStatus(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      if (!user.stripeCustomerId) {
        return { message: 'No Stripe customer found' };
      }

      // Get subscription details from PostgreSQL
      const subscriptionQuery = await db.query(`
        SELECT stripe_subscription_id FROM user_subscriptions 
        WHERE user_id = $1
      `, [userId]);

      const subscription = subscriptionQuery.rows[0];
      if (!subscription || !subscription.stripe_subscription_id) {
        return { message: 'No Stripe subscription found' };
      }

      // Get current status from Stripe
      const stripeSubscription = await stripeService.getSubscription(
        subscription.stripe_subscription_id
      );

      // Update user in MongoDB
      await User.findByIdAndUpdate(userId, {
        subscriptionStatus: stripeSubscription.status,
        subscriptionEndDate: new Date(stripeSubscription.current_period_end * 1000),
        cancelAtPeriodEnd: stripeSubscription.cancel_at_period_end
      });

      // Update PostgreSQL
      await db.query(`
        UPDATE user_subscriptions SET
          status = $1,
          current_period_end = $2,
          cancel_at_period_end = $3,
          updated_at = NOW()
        WHERE user_id = $4
      `, [
        stripeSubscription.status,
        new Date(stripeSubscription.current_period_end * 1000),
        stripeSubscription.cancel_at_period_end,
        userId
      ]);

      return { 
        message: 'Subscription status synced',
        status: stripeSubscription.status
      };
    } catch (error) {
      console.error('Error syncing subscription status:', error);
      throw new Error('Failed to sync subscription status: ' + error.message);
    }
  }

  /**
   * Handle subscription expiration
   * @param {string} userId - User ID
   */
  async handleSubscriptionExpiration(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Downgrade to free plan
      await User.findByIdAndUpdate(userId, {
        subscriptionTier: 'free',
        subscriptionStatus: 'canceled',
        cancelAtPeriodEnd: false
      });

      // Reset usage for free plan limits
      const now = new Date();
      await User.findByIdAndUpdate(userId, {
        currentUsage: {
          resumeUploads: 0,
          resumeAnalysis: 0,
          jobImports: 0,
          resumeTailoring: 0,
          recruiterUnlocks: 0,
          aiJobDiscovery: 0,
          aiConversations: 0,
          aiMessagesTotal: 0,
          resetDate: now
        }
      });

      console.log(`✅ User ${userId} downgraded to free plan due to subscription expiration`);
    } catch (error) {
      console.error('Error handling subscription expiration:', error);
      throw error;
    }
  }

  /**
   * Get plan comparison data (Monthly only)
   * @returns {Object} Plan comparison matrix
   */
  async getPlanComparison() {
    try {
      const plans = await this.getAvailablePlans();
      
      // Define feature list for comparison
      const features = [
        'resumeUploads',
        'resumeAnalysis', 
        'jobImports',
        'resumeTailoring',
        'recruiterAccess',
        'recruiterUnlocks',
        'aiJobDiscovery',
        'aiAssistant',
        'aiConversations'
      ];

      const comparison = {
        plans: plans.map(plan => ({
          name: plan.name,
          displayName: plan.display_name,
          description: plan.description,
          priceMonthly: plan.price_monthly,
          billingCycle: 'monthly', // Always monthly
          features: plan.features,
          limits: plan.limits
        })),
        featureMatrix: {}
      };

      // Build feature matrix
      features.forEach(feature => {
        comparison.featureMatrix[feature] = {};
        plans.forEach(plan => {
          const limit = plan.limits[feature];
          comparison.featureMatrix[feature][plan.name] = {
            available: plan.features[feature] || false,
            limit: limit === -1 ? 'Unlimited' : limit || 0
          };
        });
      });

      return comparison;
    } catch (error) {
      console.error('Error getting plan comparison:', error);
      throw new Error('Failed to get plan comparison: ' + error.message);
    }
  }
}

module.exports = new SubscriptionService();

================
File: backend/services/testJobSearch.service.js
================
// services/jobSearch.service.js - ENHANCED WITH CLAUDE WEB SEARCH LIKE GENERAL CHAT
const Job = require('../models/mongodb/job.model');
const Resume = require('../models/mongodb/resume.model');
const AiJobSearch = require('../models/mongodb/aiJobSearch.model');
const { anthropic } = require('../config/anthropic');
const { openai } = require('../config/openai');
const jobAnalysisService = require('./jobAnalysis.service');

/**
 * ENHANCED 3-Phase AI Job Search - Now with Claude Web Search like General Chat
 * Phase 1: Career Analysis ($0.05) - GPT-4 Turbo
 * Phase 2: ENHANCED Job Discovery & Extraction ($0.30-0.50) - Claude 3.5 Sonnet with web search API
 * Phase 3: Premium Job Analysis ($0.01-0.02) - GPT-4o batch processing
 * 
 * Uses Claude's web search API exactly like the general chat example
 * Total Cost: $0.36-0.57 per search
 */
exports.findJobsWithAi = async (userId, resumeId) => {
  try {
    console.log(`🚀 Starting ENHANCED 3-Phase AI job search with Claude web search API for user ${userId}`);
    
    const resume = await Resume.findById(resumeId);
    if (!resume || !resume.parsedData) {
      throw new Error('Resume not found or not parsed');
    }
    
    // Create search record with CORRECT enum values
    const aiJobSearch = new AiJobSearch({
      userId,
      resumeId,
      resumeName: resume.name,
      searchCriteria: extractSearchCriteria(resume.parsedData),
      status: 'running',
      dailyLimit: 10,
      jobsFoundToday: 0,
      totalJobsFound: 0,
      searchApproach: '3-phase-intelligent-claude-web-search',  // FIXED: Use correct enum value
      approachVersion: '3.2-claude-web-search-api',
      qualityLevel: 'claude-web-search'  // FIXED: Use correct enum value
    });
    
    await aiJobSearch.save();
    
    // Add initialization reasoning log
    await aiJobSearch.addReasoningLog(
      'initialization',
      `ENHANCED 3-Phase AI job search with Claude web search API initialized for resume "${resume.name}"`,
      {
        searchCriteria: aiJobSearch.searchCriteria,
        dailyLimit: aiJobSearch.dailyLimit,
        enhancedApproach: '3-Phase: Career Analysis → Claude Web Search Discovery → Premium Analysis',
        webSearchMethod: 'Claude web search API (same as general chat)',
        qualityImprovement: 'Real job URLs found and content extracted like general chat',
        costEstimate: '$0.36-0.57 per search',
        phases: [
          'Phase 1: Career Analysis (GPT-4 Turbo)',
          'Phase 2: ENHANCED Job Discovery (Claude Web Search API)',
          'Phase 3: Premium Job Analysis (GPT-4o batch)'
        ]
      }
    );
    
    // Start background search
    performEnhancedJobSearch(aiJobSearch._id, userId, resume).catch(error => {
      console.error('Enhanced job search error:', error);
      updateSearchStatus(aiJobSearch._id, 'failed', error.message);
    });
    
    return {
      success: true,
      message: 'ENHANCED AI job search with Claude web search API started successfully',
      searchId: aiJobSearch._id,
      searchMethod: 'Claude web search API (same as general chat)'
    };
    
  } catch (error) {
    console.error('Error initiating enhanced job search:', error);
    throw error;
  }
};

async function addSearchError(search, errorType, message, phase = 'general', context = '') {
  // Map old error types to new enum values if needed
  const errorTypeMapping = {
    'intelligent_discovery_failed': 'web_search_failed',
    'job_search_failed': 'job_discovery_failed',
    'content_extraction_failed': 'content_extraction_failed'
  };
  
  const mappedErrorType = errorTypeMapping[errorType] || errorType;
  
  await search.addError(mappedErrorType, message, phase, context);
}

/**
 * ENHANCED 3-Phase Job Search with Claude Web Search API
 */
async function performEnhancedJobSearch(searchId, userId, resume) {
  const searchStartTime = Date.now();
  let search;
  
  try {
    search = await AiJobSearch.findById(searchId);
    if (!search || search.status !== 'running') return;
    
    // Check daily limits
    if (await isDailyLimitReached(search)) {
      await search.addReasoningLog(
        'completion',
        `Daily limit of ${search.dailyLimit} jobs reached. Search paused until tomorrow.`,
        { 
          dailyLimit: search.dailyLimit, 
          jobsFoundToday: search.jobsFoundToday,
          reason: 'daily_limit_reached'
        }
      );
      await updateSearchStatus(searchId, 'paused', 'Daily limit reached');
      return;
    }
    
    // PHASE 1: Career Analysis (Unchanged - GPT-4 Turbo)
    console.log(`📊 Phase 1: Career Analysis...`);
    const phase1Start = Date.now();
    
    await search.addReasoningLog(
      'career_analysis',
      'Starting enhanced career trajectory analysis using GPT-4 Turbo for optimal job targeting',
      { 
        phase: 'career_analysis_start',
        model: 'gpt-4-turbo',
        costEstimate: '$0.05'
      }
    );
    
    const careerProfile = await analyzeCareerTrajectoryEnhanced(resume.parsedData);
    const phase1Duration = Date.now() - phase1Start;
    
    await search.addReasoningLog(
      'career_analysis',
      `Career analysis completed. Generated ${careerProfile.targetJobTitles?.length || 0} target job titles and ${careerProfile.targetKeywords?.length || 0} search keywords.`,
      {
        phase: 'career_analysis_complete',
        targetJobTitles: careerProfile.targetJobTitles || [],
        targetKeywords: careerProfile.targetKeywords || [],
        experienceLevel: careerProfile.experienceLevel,
        preferredLocations: careerProfile.preferredLocations || [],
        model: 'gpt-4-turbo',
        duration: phase1Duration
      },
      true,
      phase1Duration
    );
    
    if (!careerProfile.targetJobTitles || careerProfile.targetJobTitles.length === 0) {
      await search.addReasoningLog(
        'error',
        'Career analysis failed to identify target job titles. Cannot proceed with job search.',
        { 
          phase: 'career_analysis_failed',
          suggestion: 'Resume may need more detailed experience information'
        },
        false,
        phase1Duration
      );
      await updateSearchStatus(searchId, 'completed', 'Career analysis insufficient');
      return;
    }
    
    // PHASE 2: ENHANCED Job Discovery & Extraction (CLAUDE WEB SEARCH API)
    console.log(`🎯 Phase 2: ENHANCED Job Discovery with Claude Web Search API...`);
    const phase2Start = Date.now();
    
    await search.addReasoningLog(
      'intelligent_discovery',
      'Starting ENHANCED job discovery using Claude web search API (same method as general chat)',
      { 
        phase: 'enhanced_job_discovery_start',
        model: 'claude-3.5-sonnet',
        approach: 'Step 1: Find job URLs with web search → Step 2: Extract content from URLs',
        webSearchMethod: 'Claude web search API (same as general chat)',
        costEstimate: '$0.30-0.50'
      }
    );
    
    const discoveredJobs = await performRealJobBoardDiscovery(careerProfile, search);
    const phase2Duration = Date.now() - phase2Start;
    
    if (discoveredJobs.length === 0) {
      await search.addReasoningLog(
        'completion',
        'Enhanced job discovery found no matching opportunities using Claude web search API. Search criteria may need adjustment.',
        { 
          phase: 'enhanced_discovery_no_results',
          searchMethod: 'Claude web search API',
          searchedTitles: careerProfile.targetJobTitles,
          suggestion: 'Try again tomorrow or broaden search criteria'
        },
        false,
        phase2Duration
      );
      await updateSearchStatus(searchId, 'completed', 'No job opportunities found with Claude web search');
      return;
    }
    
    await search.addReasoningLog(
      'intelligent_discovery',
      `Enhanced job discovery completed successfully. Found ${discoveredJobs.length} high-quality job opportunities using Claude web search API.`,
      {
        phase: 'enhanced_job_discovery_complete',
        totalJobsFound: discoveredJobs.length,
        searchMethod: 'Claude web search API',
        platformsFound: [...new Set(discoveredJobs.map(job => job.sourcePlatform))],
        averageContentLength: discoveredJobs.length > 0 ? 
          Math.round(discoveredJobs.reduce((sum, job) => sum + (job.fullContent?.length || 0), 0) / discoveredJobs.length) : 0,
        qualityJobs: discoveredJobs.filter(job => job.contentQuality === 'high').length,
        companiesFound: [...new Set(discoveredJobs.map(job => job.company))].length,
        model: 'claude-3.5-sonnet',
        duration: phase2Duration
      },
      true,
      phase2Duration
    );
    
// PHASE 3: Premium Job Analysis (Unchanged - GPT-4o Quality)
    console.log(`🔬 Phase 3: Premium Job Analysis...`);
    const phase3Start = Date.now();
    
    await search.addReasoningLog(
      'premium_analysis',
      'Starting premium job analysis using GPT-4o for same quality as manual job uploads',
      { 
        phase: 'premium_analysis_start',
        jobsToAnalyze: discoveredJobs.length,
        model: 'gpt-4o',
        quality: 'Same as manual job uploads',
        costEstimate: '$0.01-0.02'
      }
    );
    
    const analyzedJobs = await performPremiumJobAnalysis(discoveredJobs, search);
    const phase3Duration = Date.now() - phase3Start;
    
    const successfulAnalyses = analyzedJobs.filter(job => job.analysis && !job.analysisError).length;
    
    await search.addReasoningLog(
      'premium_analysis',
      `Premium job analysis completed. Successfully analyzed ${successfulAnalyses}/${analyzedJobs.length} jobs with GPT-4o quality.`,
      {
        phase: 'premium_analysis_complete',
        totalJobs: analyzedJobs.length,
        successfulAnalyses: successfulAnalyses,
        averageSkillsFound: successfulAnalyses > 0 ? 
          Math.round(analyzedJobs
            .filter(job => job.analysis?.keySkills)
            .reduce((sum, job) => sum + (job.analysis.keySkills.length || 0), 0) / successfulAnalyses) : 0,
        model: 'gpt-4o',
        quality: 'Premium analysis (same as manual)',
        duration: phase3Duration
      },
      successfulAnalyses > 0,
      phase3Duration
    );

    function getPhaseForLogging(originalPhase) {
  const phaseMapping = {
    'intelligent_discovery': 'web_search_discovery',
    'content_extraction': 'content_extraction',
    'job_search': 'web_search_discovery'
  };
  
  return phaseMapping[originalPhase] || originalPhase;
}

    
    // Save Jobs with Enhanced Metadata
    console.log(`💾 Saving ${analyzedJobs.length} analyzed jobs from Claude web search...`);
    const saveStart = Date.now();
    
    await search.addReasoningLog(
      'job_saving',
      `Saving ${analyzedJobs.length} premium-analyzed jobs from Claude web search with enhanced metadata and deduplication`,
      { 
        phase: 'job_saving_start',
        jobsToSave: analyzedJobs.length,
        discoveryMethod: 'Claude web search API'
      }
    );
    
    const savedCount = await saveJobsWithEnhancedMetadata(analyzedJobs, userId, searchId, search);
    const saveDuration = Date.now() - saveStart;
    
    await search.addReasoningLog(
      'job_saving',
      `Job saving completed. Saved ${savedCount} new premium jobs from Claude web search, skipped ${analyzedJobs.length - savedCount} duplicates.`,
      {
        phase: 'job_saving_complete',
        savedJobs: savedCount,
        duplicatesSkipped: analyzedJobs.length - savedCount,
        discoveryMethod: 'Claude web search API',
        duration: saveDuration
      },
      savedCount > 0,
      saveDuration
    );
    
    // Final completion with Claude web search summary
    const totalDuration = Date.now() - searchStartTime;
    const searchSummary = {
      phase1: 'GPT-4 Turbo - $0.05',
      phase2: 'Claude 3.5 Sonnet + Web Search API - $0.30-0.50', 
      phase3: 'GPT-4o Premium Analysis - $0.01-0.02',
      totalCost: '$0.36-0.57',
      qualityLevel: 'Real job postings found via Claude web search API',
      searchMethod: 'Same as Claude general chat',
      enhancement: 'Claude web search API + Premium analysis'
    };
    
    await search.addReasoningLog(
      'completion',
      `ENHANCED 3-Phase AI job search with Claude web search API completed in ${Math.round(totalDuration / 1000)}s. Found ${savedCount} premium jobs using the same method as general chat.`,
      {
        phase: 'search_complete',
        totalDuration: totalDuration,
        jobsSaved: savedCount,
        searchSummary: searchSummary,
        webSearchMethod: 'Claude web search API (same as general chat)',
        intelligence: 'Claude for job discovery + GPT-4o for analysis',
        nextRun: 'Will continue tomorrow with fresh opportunities via Claude web search'
      }
    );
    
    await updateSearchStatus(searchId, savedCount > 0 ? 'running' : 'completed', 
      `Found ${savedCount} premium jobs via Claude web search API`);
    console.log(`✅ ENHANCED 3-Phase AI job search complete: ${savedCount} jobs saved via Claude web search, cost: $0.36-0.57`);
    
  } catch (error) {
    console.error('Error in enhanced Claude web search:', error);
    
    if (search) {
      await search.addReasoningLog(
        'error',
        `Enhanced job search failed: ${error.message}`,
        { 
          phase: 'search_error',
          errorType: error.name,
          errorMessage: error.message,
          searchMethod: 'Claude web search API',
          suggestion: 'Try running the search again'
        },
        false
      );
    }
    
    await updateSearchStatus(searchId, 'failed', error.message);
  }
}

async function updateAiUsageForPhase(search, phase, type, tokens = 0, cost = 0) {
  // Map phases to match new enum values
  const phaseMapping = {
    'intelligent_discovery': 'web_search_discovery',
    'job_search': 'web_search_discovery',
    'content_extraction': 'web_search_discovery'
  };
  
  const mappedPhase = phaseMapping[phase] || phase;
  await search.updateAiUsage(mappedPhase, type, tokens, cost);
}

/**
 * ENHANCED PHASE 2: Real Job Board Discovery & Extraction
 * Uses Claude's web search API exactly like the general chat example
 */
async function performRealJobBoardDiscovery(careerProfile, search) {
  try {
    console.log(`🎯 Starting ENHANCED job discovery using Claude web search for ${careerProfile.targetJobTitles?.length || 0} target roles...`);
    
    // Step 1: Find job URLs using web search (like your general chat example)
    const jobUrls = await findJobUrlsWithWebSearch(careerProfile, search);
    
    if (jobUrls.length === 0) {
      await search.addReasoningLog(
        'web_search_discovery',
        'No job URLs found with Claude web search. May need to adjust search criteria.',
        { 
          searchTargets: careerProfile.targetJobTitles,
          searchKeywords: careerProfile.targetKeywords,
          searchMethod: 'Claude web search API'
        },
        false
      );
      return [];
    }
    
    // Step 2: Extract content from each job URL (like your URL extraction example)
const discoveredJobs = await extractJobContentFromUrls(jobUrls, search, careerProfile);
    
    await search.addReasoningLog(
      'web_search_discovery',
      `Enhanced job discovery completed. Found ${discoveredJobs.length} high-quality jobs using Claude web search API.`,
      {
        jobUrlsFound: jobUrls.length,
        successfulExtractions: discoveredJobs.length,
        jobBoards: [...new Set(discoveredJobs.map(job => job.sourcePlatform))],
        averageContentLength: discoveredJobs.length > 0 ? 
          Math.round(discoveredJobs.reduce((sum, job) => sum + (job.fullContent?.length || 0), 0) / discoveredJobs.length) : 0,
        searchMethod: 'Claude web search API (same as general chat)'
      }
    );
    
    return discoveredJobs;
    
  } catch (error) {
    console.error('Error in enhanced job discovery:', error);
    await search.addReasoningLog(
      'web_search_discovery',
      `Enhanced job discovery failed: ${error.message}`,
      { error: error.message, searchMethod: 'Claude web search API' },
      false
    );
    return [];
  }
}


/**
 * Step 1: Find Job URLs using Claude Web Search - WITH LIVE URL VALIDATION
 */
async function findJobUrlsWithWebSearch(careerProfile, search) {
  try {
    const maxJobsToFind = 10;
    let validJobUrls = [];
    let searchAttempts = 0;
    const maxSearchAttempts = 3;
    
    await search.addReasoningLog(
      'web_search_discovery',
      `Starting job URL discovery with LIVE URL validation (target: ${maxJobsToFind} active jobs)`,
      { 
        targetTitles: careerProfile.targetJobTitles,
        maxJobsToFind: maxJobsToFind,
        enhancement: 'Live URL validation to ensure active job postings',
        urlValidation: 'Check each URL before processing'
      }
    );
    
    while (validJobUrls.length < maxJobsToFind && searchAttempts < maxSearchAttempts) {
      searchAttempts++;
      const jobsStillNeeded = maxJobsToFind - validJobUrls.length;
      
      console.log(`🎯 Search attempt ${searchAttempts}/${maxSearchAttempts}: Looking for ${jobsStillNeeded} more ACTIVE jobs (current: ${validJobUrls.length}/${maxJobsToFind})`);
      
      // Get URLs from Claude (same as before)
      const response = await anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 4000,
        temperature: 0.2,
        messages: [
          {
            role: "user",
            content: `I am looking for CURRENT, ACTIVE ${careerProfile.experienceLevel || 'mid-level'} ${careerProfile.targetJobTitles?.[0] || 'Software Engineer'} job openings.

TARGET PROFILE:
- Job Titles: ${careerProfile.targetJobTitles?.join(', ')}
- Experience Level: ${careerProfile.experienceLevel}
- Preferred Skills: ${careerProfile.targetKeywords?.join(', ')}

IMPORTANT: I need ${jobsStillNeeded} ACTIVE job postings that are currently open and accepting applications. Please search for:
- Jobs posted within the last 30 days
- Currently active job listings (not expired)
- Direct application links that are working
- Recent postings from company career pages

Focus on finding FRESH, ACTIVE job opportunities with working application links.

Return exactly ${jobsStillNeeded} jobs in this format:
JOB 1: [Job Title] at [Company Name]
URL: [ACTIVE job application URL with https://]
Match Reason: [Why this is a good fit]`
          }
        ],
        tools: [
          {
            type: "web_search_20250305",
            name: "web_search"
          }
        ],
        tool_choice: { type: "any" }
      });

      // Extract potential URLs (same extraction logic as before)
      const potentialJobUrls = [];
      
      for (let i = 0; i < response.content.length; i++) {
        const content = response.content[i];
        
        if (content.type === 'text') {
          const text = content.text;
          
          // Same URL extraction patterns as before
          const urlPatterns = [
            /URL:\s*(https?:\/\/[^\s\n\)]+)/gi,
            /url:\s*(https?:\/\/[^\s\n\)]+)/gi,
            /(https?:\/\/[^\s\n\)]+)/gi,
            /URL:\s*([a-zA-Z0-9][a-zA-Z0-9-._]*\.[a-zA-Z]{2,}(?:\/[^\s\n\)]*)?)/gi,
            /url:\s*([a-zA-Z0-9][a-zA-Z0-9-._]*\.[a-zA-Z]{2,}(?:\/[^\s\n\)]*)?)/gi,
            /([a-zA-Z0-9][a-zA-Z0-9-._]*\.(?:com|org|net|io|co|ai)(?:\/[^\s\n\)]*)?)/gi,
            /(greenhouse\.io\/[^\s\n\)]+)/gi,
            /(lever\.co\/[^\s\n\)]+)/gi,
            /(indeed\.com\/[^\s\n\)]+)/gi,
            /(linkedin\.com\/jobs\/[^\s\n\)]+)/gi,
            /([a-zA-Z0-9-]+\.(?:com|org|net|io|co|ai)\/careers[^\s\n\)]*)/gi,
            /([a-zA-Z0-9-]+\.(?:com|org|net|io|co|ai)\/jobs[^\s\n\)]*)/gi
          ];
          
          let foundUrls = [];
          urlPatterns.forEach((pattern) => {
            const matches = text.match(pattern);
            if (matches) {
              foundUrls = foundUrls.concat(matches);
            }
          });
          
          // Process each found URL
          for (const match of foundUrls) {
            if (validJobUrls.length >= maxJobsToFind) {
              console.log(`🛑 EARLY STOP: Reached target of ${maxJobsToFind} ACTIVE jobs`);
              break;
            }
            
            let url = cleanExtractedUrl(match);
            
            if (isValidJobUrlFixed(url)) {
              // Ensure URL has protocol
              if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
              }
              
              // CRITICAL: Validate URL is LIVE before adding
              console.log(`🔍 Validating URL: ${url}`);
              const isLive = await validateJobUrlIsLive(url);
              
              if (isLive) {
                // Check for duplicates
                const isDuplicate = validJobUrls.some(existingJob => 
                  existingJob.url === url || 
                  (existingJob.company === extractCompanyFromUrl(url))
                );
                
                if (!isDuplicate) {
                  // Extract job info from surrounding text
                  const lines = text.split('\n');
                  const urlLineIndex = lines.findIndex(line => line.includes(match));
                  
                  let title = 'Unknown Title';
                  let company = 'Unknown Company';
                  let matchReason = 'Found via Claude web search';
                  
                  if (urlLineIndex > 0) {
                    const jobLine = lines[urlLineIndex - 1] || '';
                    const matchReasonLine = lines[urlLineIndex + 1] || '';
                    
                    const jobPatterns = [
                      /JOB\s+\d+:\s*(.+?)\s+at\s+(.+?)$/i,
                      /(\w+.*?)\s+at\s+(.+?)$/i,
                      /(.+?)\s+-\s+(.+?)$/i
                    ];
                    
                    for (const pattern of jobPatterns) {
                      const jobMatch = jobLine.match(pattern);
                      if (jobMatch) {
                        title = jobMatch[1].trim();
                        company = jobMatch[2].trim();
                        break;
                      }
                    }
                    
                    if (matchReasonLine.includes('Match Reason:')) {
                      matchReason = matchReasonLine.replace(/^Match Reason:\s*/i, '').trim();
                    }
                  }
                  
                  const sourcePlatform = determineSourcePlatform(url);
                  
                  const jobUrlObj = {
                    url: url,
                    title: title,
                    company: company,
                    matchReason: matchReason,
                    sourcePlatform: sourcePlatform,
                    foundAt: new Date(),
                    extractionMethod: 'enhanced_url_extraction_with_validation',
                    isLiveValidated: true
                  };
                  
                  validJobUrls.push(jobUrlObj);
                  console.log(`✅ Added ACTIVE job ${validJobUrls.length}/${maxJobsToFind}: ${title} at ${company}`);
                  
                  await search.addReasoningLog(
                    'web_search_discovery',
                    `Found ACTIVE job: "${title}" at ${company} (URL validated as live)`,
                    {
                      url: url,
                      platform: sourcePlatform,
                      validationStatus: 'live_confirmed',
                      jobNumber: validJobUrls.length
                    }
                  );
                }
              } else {
                console.log(`❌ Dead URL rejected: ${url}`);
                await search.addReasoningLog(
                  'web_search_discovery',
                  `Rejected dead URL: ${url} (404 or expired)`,
                  {
                    url: url,
                    validationStatus: 'dead_link',
                    reason: 'URL validation failed'
                  }
                );
              }
            }
          }
        }
      }
      
      console.log(`📊 Search attempt ${searchAttempts} results: Found ${validJobUrls.length} ACTIVE jobs total`);
      
      // Early stopping if we have enough ACTIVE jobs
      if (validJobUrls.length >= maxJobsToFind) {
        console.log(`🎉 SUCCESS: Found ${validJobUrls.length} ACTIVE jobs after ${searchAttempts} attempts`);
        break;
      }
      
      // Delay between attempts
      if (validJobUrls.length < maxJobsToFind && searchAttempts < maxSearchAttempts) {
        console.log(`⏱️ Need ${maxJobsToFind - validJobUrls.length} more ACTIVE jobs, waiting before next attempt...`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    await search.addReasoningLog(
      'web_search_discovery',
      `Job URL discovery completed: ${validJobUrls.length} ACTIVE jobs found with live URL validation`,
      {
        totalActiveUrls: validJobUrls.length,
        searchAttemptsUsed: searchAttempts,
        platforms: [...new Set(validJobUrls.map(job => job.sourcePlatform))],
        companies: [...new Set(validJobUrls.map(job => job.company))],
        urlValidation: 'All URLs confirmed as live and active'
      }
    );
    
    console.log(`🎯 FINAL RESULT: Found ${validJobUrls.length} ACTIVE job URLs with live validation`);
    return validJobUrls;
    
  } catch (error) {
    console.error('🎯 Error in job URL discovery with live validation:', error);
    await search.addError('web_search_failed', error.message, 'web_search_discovery', 'Live URL validation failed');
    throw error;
  }
}


/**
 * Step 2: Extract Job Content from URLs
 * Mimics the URL content extraction from your example
 */
async function extractJobContentFromUrls(jobUrls, search, careerProfile) {
  const discoveredJobs = [];
  
  console.log(`📄 Extracting content from ${jobUrls.length} job URLs with detailed debugging...`);
  
  for (const jobUrl of jobUrls) {
    try {
      console.log(`\n🔍 === EXTRACTION DEBUG FOR: ${jobUrl.title} at ${jobUrl.company} ===`);
      console.log(`🔗 URL: ${jobUrl.url}`);
      console.log(`🏢 Platform: ${jobUrl.sourcePlatform}`);
      console.log(`💡 Match Reason: ${jobUrl.matchReason}`);
      
      await search.addReasoningLog(
        'content_extraction',
        `Starting content extraction from ${jobUrl.title} at ${jobUrl.company}`,
        {
          url: jobUrl.url,
          platform: jobUrl.sourcePlatform,
          extractionMethod: 'claude_web_fetch_debug'
        }
      );
      
      const response = await anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 4000,
        temperature: 0.1,
        messages: [
          {
            role: "user",
            content: `Please visit this job posting URL and extract the complete content: ${jobUrl.url}

Extract all job details including:
- Complete job description and overview
- Key responsibilities and duties  
- Required qualifications and skills
- Preferred qualifications
- Salary/compensation information
- Benefits and perks
- Work location and arrangement (remote/hybrid/onsite)
- Company information and culture
- Application process

Provide the comprehensive job posting content exactly as it appears on the page.`
          }
        ],
        tools: [
          {
            type: "web_search_20250305",
            name: "web_search"
          }
        ],
        tool_choice: { type: "any" }
      });

      console.log(`📡 Claude API Response Structure:`);
      console.log(`- Response content array length: ${response.content?.length || 0}`);
      
      let fullContent = '';
      let hasTextContent = false;
      let hasToolResults = false;
      let allTextFragments = []; // NEW: Collect all text fragments
      
      // FIXED: Examine the full response structure and collect ALL text content
      for (let i = 0; i < response.content.length; i++) {
        const content = response.content[i];
        console.log(`- Content[${i}] type: ${content.type}`);
        
        if (content.type === 'text') {
          hasTextContent = true;
          allTextFragments.push(content.text); // COLLECT each text fragment
          console.log(`- Text content length: ${content.text.length} characters`);
          console.log(`- Text preview: "${content.text.substring(0, 100)}..."`);
        } else if (content.type === 'tool_use') {
          hasToolResults = true;
          console.log(`- Tool use detected: ${content.name}`);
        } else if (content.type === 'tool_result') {
          console.log(`- Tool result detected`);
        }
      }
      
      // FIXED: Concatenate ALL text fragments into one complete content
      fullContent = allTextFragments.join('').trim();
      
      console.log(`📊 Content Analysis:`);
      console.log(`- Has text content: ${hasTextContent}`);
      console.log(`- Has tool results: ${hasToolResults}`);
      console.log(`- Number of text fragments: ${allTextFragments.length}`);
      console.log(`- Total concatenated content length: ${fullContent.length}`);
      console.log(`- Full content preview: "${fullContent.substring(0, 300)}..."`);
      
      // More detailed content analysis
      if (fullContent.length > 0) {
        const lowerContent = fullContent.toLowerCase();
        const hasJobKeywords = /job|position|role|career|responsibilities|qualifications|requirements/i.test(fullContent);
        const hasCompanyInfo = /company|organization|team|culture/i.test(fullContent);
        const hasSalaryInfo = /salary|compensation|\$|pay|benefits/i.test(fullContent);
        
        console.log(`📋 Content Quality Check:`);
        console.log(`- Has job keywords: ${hasJobKeywords}`);
        console.log(`- Has company info: ${hasCompanyInfo}`);
        console.log(`- Has salary info: ${hasSalaryInfo}`);
        
        // Check if content looks like an error message
        const isErrorContent = /error|not found|404|access denied|blocked|unavailable/i.test(fullContent);
        console.log(`- Is error content: ${isErrorContent}`);
        
        if (isErrorContent) {
          console.log(`❌ ERROR: Content appears to be an error message`);
          console.log(`Error content preview: "${fullContent.substring(0, 300)}"`);
        }
      }
      
      // Only proceed if we have substantial, valid content
      if (fullContent && fullContent.length > 300 && !/error|not found|404|access denied/i.test(fullContent)) {
        console.log(`✅ EXTRACTION SUCCESSFUL - Processing content...`);
        
        // Extract structured data from the content
        const extractedData = parseJobContent(fullContent, jobUrl, careerProfile);
        
        const job = {
          title: extractedData.title || jobUrl.title,
          company: extractedData.company || jobUrl.company,
          location: extractedData.location || 'Not specified',
          salary: extractedData.salary || {},
          jobUrl: jobUrl.url,
          sourcePlatform: jobUrl.sourcePlatform,
          fullContent: fullContent,
          postedDate: extractedData.postedDate || new Date().toISOString().split('T')[0],
          workArrangement: extractedData.workArrangement || 'unknown',
          matchReason: jobUrl.matchReason,
          experienceLevel: extractedData.experienceLevel || careerProfile.experienceLevel,
          keyRequirements: extractedData.keyRequirements || [],
          department: extractedData.department || 'Not specified',
          companySize: extractedData.companySize || 'Not specified',
          industry: extractedData.industry || 'Technology',
          benefits: extractedData.benefits || [],
          techStack: extractedData.techStack || [],
          extractionMethod: 'claude_web_content_extraction',
          extractedAt: new Date(),
          matchScore: calculateEnhancedMatchScore(extractedData, careerProfile),
          contentQuality: assessContentQuality(fullContent),
          metadata: {
            discoveryMethod: 'claude_web_search_and_extract',
            platform: jobUrl.sourcePlatform,
            extractedAt: new Date(),
            contentLength: fullContent.length,
            urlValidated: true,
            directCompanyPosting: true
          }
        };
        
        discoveredJobs.push(job);
        
        await search.addReasoningLog(
          'content_extraction',
          `Successfully extracted ${fullContent.length} characters from ${job.title} at ${job.company}`,
          {
            contentLength: fullContent.length,
            qualityScore: job.contentQuality,
            matchScore: job.matchScore,
            extractionSuccess: true
          },
          true
        );
        
        console.log(`✅ JOB CREATED: ${job.title} at ${job.company} (${fullContent.length} chars)`);
        
      } else {
        console.log(`❌ EXTRACTION FAILED: Insufficient or invalid content`);
        console.log(`- Content length: ${fullContent.length}`);
        console.log(`- Content preview: "${fullContent.substring(0, 200)}"`);
        
        await search.addReasoningLog(
          'content_extraction',
          `Failed to extract sufficient content from ${jobUrl.title} at ${jobUrl.company}`,
          {
            url: jobUrl.url,
            contentLength: fullContent.length,
            extractionSuccess: false,
            failureReason: fullContent.length === 0 ? 'No content returned' : 'Content too short or invalid'
          },
          false
        );
      }
      
      console.log(`=== END EXTRACTION DEBUG ===\n`);
      
      // Delay between extractions
      await new Promise(resolve => setTimeout(resolve, 3000));
      
    } catch (error) {
      console.error(`❌ EXTRACTION ERROR for ${jobUrl.url}:`, error);
      console.error(`Error details:`, {
        name: error.name,
        message: error.message,
        stack: error.stack?.split('\n')[0]
      });
      
      await search.addReasoningLog(
        'content_extraction',
        `Error extracting content from ${jobUrl.title}: ${error.message}`,
        {
          url: jobUrl.url,
          error: error.message,
          extractionSuccess: false
        },
        false
      );
    }
  }
  
  console.log(`\n📊 FINAL EXTRACTION RESULTS:`);
  console.log(`- URLs processed: ${jobUrls.length}`);
  console.log(`- Jobs successfully created: ${discoveredJobs.length}`);
  console.log(`- Success rate: ${Math.round((discoveredJobs.length / jobUrls.length) * 100)}%`);
  
  return discoveredJobs;
}

/**
 * Helper Functions
 */

function determineSourcePlatform(url) {
  const lowerUrl = url.toLowerCase();
  
  if (lowerUrl.includes('greenhouse.io')) return 'Greenhouse';
  if (lowerUrl.includes('lever.co')) return 'Lever';
  if (lowerUrl.includes('indeed.com')) return 'Indeed';
  if (lowerUrl.includes('linkedin.com')) return 'LinkedIn';
  if (lowerUrl.includes('workday.com')) return 'Workday';
  if (lowerUrl.includes('bamboohr.com')) return 'BambooHR';
  if (lowerUrl.includes('smartrecruiters.com')) return 'SmartRecruiters';
  if (lowerUrl.includes('jobvite.com')) return 'Jobvite';
  if (lowerUrl.includes('careers.') || lowerUrl.includes('/careers/')) return 'Company Career Page';
  if (lowerUrl.includes('/jobs/')) return 'Company Jobs Page';
  
  // FIXED: Detect company domains
  if (lowerUrl.match(/^https?:\/\/[^\/]+\.(com|io|co|ai|org|net)/)) {
    return 'Company Website';
  }
  
  return 'Other';
}

/**
 * Helper function to extract company from URL
 */
function extractCompanyFromUrl(url) {
  try {
    const hostname = new URL(url).hostname;
    return hostname.replace('www.', '').split('.')[0];
  } catch {
    return 'Unknown';
  }
}

/**
 * Helper function to extract title from text context
 */
function extractTitleFromText(text, url) {
  const lines = text.split('\n');
  const urlLineIndex = lines.findIndex(line => line.includes(url));
  
  if (urlLineIndex > 0) {
    const jobLine = lines[urlLineIndex - 1] || '';
    const jobMatch = jobLine.match(/JOB\s+\d+:\s*(.+?)\s+at\s+/i);
    if (jobMatch) {
      return jobMatch[1].trim();
    }
  }
  return 'Unknown';
}

/**
 * NEW: Validate that a job URL is live and accessible
 */
async function validateJobUrlIsLive(url) {
  try {
    console.log(`🔍 Checking if URL is live: ${url}`);
    
    // Use Claude to check if the URL is accessible
    const response = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 1000,
      temperature: 0.1,
      messages: [
        {
          role: "user",
          content: `Please check if this job posting URL is currently active and accessible: ${url}

I need to verify that this job posting is still live and accepting applications. Please visit the URL and tell me:

1. Is the page accessible (not 404/error)?
2. Does it show an active job posting?
3. Is there an apply button or application process visible?

Respond with just: "ACTIVE" if the job is live, or "DEAD" if it's not accessible or expired.`
        }
      ],
      tools: [
        {
          type: "web_search_20250305",
          name: "web_search"
        }
      ],
      tool_choice: { type: "any" }
    });

    // Check response for validation result
    const responseText = response.content
      .filter(content => content.type === 'text')
      .map(content => content.text)
      .join(' ')
      .toLowerCase();
    
    const isActive = responseText.includes('active') && !responseText.includes('dead');
    const isDead = responseText.includes('dead') || responseText.includes('404') || responseText.includes('not found') || responseText.includes('expired');
    
    if (isDead) {
      console.log(`❌ URL is DEAD: ${url}`);
      return false;
    } else if (isActive) {
      console.log(`✅ URL is ACTIVE: ${url}`);
      return true;
    } else {
      // If unclear, err on the side of caution but still try
      console.log(`⚠️ URL status unclear, assuming active: ${url}`);
      return true;
    }
    
  } catch (error) {
    console.error(`❌ Error validating URL ${url}:`, error);
    // If validation fails, assume URL might be valid to avoid false negatives
    return true;
  }
}

function isValidJobUrlFixed(url) {
  if (!url || typeof url !== 'string') return false;
  
  // Clean the URL first
  const cleanUrl = url.toLowerCase().trim();
  
  // FIXED: Accept URLs with or without protocol
  const hasProtocol = cleanUrl.startsWith('http://') || cleanUrl.startsWith('https://');
  const isDomainOnly = /^[a-zA-Z0-9][a-zA-Z0-9-._]*\.[a-zA-Z]{2,}/.test(cleanUrl);
  
  if (!hasProtocol && !isDomainOnly) return false;
  
  // Check if it contains job-related keywords or known job platforms
  const jobKeywords = [
    'job', 'jobs', 'career', 'careers', 'apply', 'position', 'opening', 'hiring',
    'greenhouse.io', 'lever.co', 'indeed.com', 'linkedin.com/jobs',
    'workday.com', 'bamboohr.com', 'smartrecruiters.com', 'jobvite.com'
  ];
  
  const hasJobKeywords = jobKeywords.some(keyword => cleanUrl.includes(keyword));
  
  // FIXED: Also accept company domain patterns that likely have job pages
  const companyDomainPatterns = [
    /\/careers/,
    /\/jobs/,
    /\/apply/,
    /\/hiring/,
    /\.com$/,
    /\.io$/,
    /\.co$/,
    /\.ai$/,
    /\.org$/,
    /\.net$/
  ];
  
  const isLikelyJobUrl = companyDomainPatterns.some(pattern => pattern.test(cleanUrl));
  
  // FIXED: Accept if it has job keywords OR looks like a company career page
  return hasJobKeywords || isLikelyJobUrl;
}

function cleanExtractedUrl(match) {
  let url = match;
  
  // Clean up URL extraction
  url = url.replace(/^URL:\s*/i, '').trim();
  url = url.replace(/^url:\s*/i, '').trim();
  url = url.replace(/^\[Direct job application URL\]:\s*/i, '').trim();
  url = url.replace(/^Application link:\s*/i, '').trim();
  
  // Remove trailing punctuation that might be part of sentence
  url = url.replace(/[.,;!?]+$/, '');
  url = url.replace(/\)$/, ''); // Remove closing parenthesis
  
  // Remove any surrounding quotes
  url = url.replace(/^["']|["']$/g, '');
  
  return url.trim();
}

function parseJobContent(content, jobUrl, careerProfile) {
  console.log(`🔧 Parsing job content for: ${jobUrl.title}`);
  
  const data = {
    title: jobUrl.title,
    company: jobUrl.company
  };
  
  try {
    const lowerContent = content.toLowerCase();
    
    // Extract salary with better patterns
    const salaryPatterns = [
      /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*-?\s*\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)?/g,
      /(\d{1,3}(?:,\d{3})*)\s*-\s*(\d{1,3}(?:,\d{3})*)\s*(?:per year|annually|\/year)/gi,
      /salary.*?(\d{1,3}(?:,\d{3})*)/gi
    ];
    
    for (const pattern of salaryPatterns) {
      const salaryMatches = content.match(pattern);
      if (salaryMatches && salaryMatches.length > 0) {
        const salaryMatch = salaryMatches[0].match(/(\d{1,3}(?:,\d{3})*)/g);
        if (salaryMatch) {
          data.salary = {
            min: parseInt(salaryMatch[0].replace(/,/g, '')),
            max: salaryMatch[1] ? parseInt(salaryMatch[1].replace(/,/g, '')) : undefined,
            currency: 'USD'
          };
          console.log(`💰 Found salary: $${data.salary.min}${data.salary.max ? `-$${data.salary.max}` : ''}`);
          break;
        }
      }
    }
    
    // FIXED: Extract work arrangement with proper enum values
    const workPatterns = [
      { pattern: /remote.*?first|fully remote|100%\s*remote|work from home|wfh/i, arrangement: 'remote' },
      { pattern: /hybrid|flexible|mix of remote|part remote|some remote/i, arrangement: 'hybrid' },
      { pattern: /on-?site|in-?office|office-?based|on-premise/i, arrangement: 'onsite' }
    ];
    
    // Default to remote if no pattern found
    data.workArrangement = 'remote';
    
    for (const wp of workPatterns) {
      if (wp.pattern.test(content)) {
        data.workArrangement = wp.arrangement;
        console.log(`🏠 Found work arrangement: ${data.workArrangement}`);
        break;
      }
    }
    
    // FIXED: Handle invalid work arrangement values
    const validWorkArrangements = ['remote', 'hybrid', 'onsite'];
    if (!validWorkArrangements.includes(data.workArrangement)) {
      console.log(`⚠️ Invalid work arrangement "${data.workArrangement}", defaulting to remote`);
      data.workArrangement = 'remote';
    }
    
    // Extract experience level with proper enum values
    const expPatterns = [
      { pattern: /senior|sr\.|lead/i, level: 'senior' },
      { pattern: /principal|staff|architect/i, level: 'lead' },
      { pattern: /junior|jr\.|entry|associate/i, level: 'junior' },
      { pattern: /director|vp|head of/i, level: 'executive' }
    ];
    
    // Default to mid if no pattern found
    data.experienceLevel = 'mid';
    
    for (const ep of expPatterns) {
      if (ep.pattern.test(content)) {
        data.experienceLevel = ep.level;
        console.log(`📈 Found experience level: ${data.experienceLevel}`);
        break;
      }
    }
    
    // Extract requirements with better keyword matching
    const skillKeywords = [
      'product management', 'product strategy', 'roadmap', 'analytics', 'data analysis',
      'ai', 'machine learning', 'artificial intelligence', 'python', 'sql', 'tableau',
      'javascript', 'react', 'node.js', 'aws', 'typescript', 'java', 'kubernetes',
      'agile', 'scrum', 'jira', 'figma', 'sketch', 'user research', 'a/b testing'
    ];
    
    data.keyRequirements = skillKeywords.filter(skill => 
      lowerContent.includes(skill.toLowerCase())
    );
    console.log(`🎯 Found ${data.keyRequirements.length} skill requirements`);
    
    // Extract benefits
    const benefitKeywords = [
      'health insurance', 'dental', 'vision', '401k', 'pto', 'vacation', 
      'equity', 'stock options', 'bonus', 'flexible hours', 'remote work'
    ];
    
    data.benefits = benefitKeywords.filter(benefit => 
      lowerContent.includes(benefit.toLowerCase())
    );
    console.log(`🎁 Found ${data.benefits.length} benefits`);
    
    // Extract location from content with better patterns and validation
    const locationPatterns = [
      /(?:location|located|based|headquarters?):\s*([A-Za-z\s,]+(?:CA|NY|TX|FL|WA|IL|MA|PA|OH|GA|NC|NJ|VA|MI|AZ|CO|TN|IN|SC|MO|MD|WI|MN|AL|UT|NV|KS|LA|AR|NE|IA|MS|OK|CT|OR|DE|NH|VT|ME|RI|MT|ND|SD|WY|AK|HI|DC))/i,
      /(?:office|headquarters|hq)(?:\s+(?:in|at|located))?\s*([A-Za-z\s,]+(?:CA|NY|TX|FL|WA|IL|MA|PA|OH|GA|NC|NJ|VA|MI|AZ|CO|TN|IN|SC|MO|MD|WI|MN|AL|UT|NV|KS|LA|AR|NE|IA|MS|OK|CT|OR|DE|NH|VT|ME|RI|MT|ND|SD|WY|AK|HI|DC))/i,
      /(?:remote|anywhere|distributed|global)/i
    ];
    
    // Default location
    data.location = 'Remote';
    
    for (const pattern of locationPatterns) {
      const locationMatch = content.match(pattern);
      if (locationMatch) {
        let location = locationMatch[1] ? locationMatch[1].trim() : locationMatch[0].trim();
        
        // Clean up location string
        location = location.replace(/[:;,\.]$/, '');
        location = location.replace(/^[\s,]+|[\s,]+$/g, '');
        
        // FIXED: Handle "global" and other invalid location values
        if (location.toLowerCase() === 'global' || location.toLowerCase() === 'worldwide') {
          location = 'Remote';
        }
        
        // Validate location - should not contain job-related terms
        const invalidLocationTerms = [
          'job level', 'assessed', 'interviews', 'application', 'process', 'details',
          'arrangements', 'not available', 'posting', 'content', 'provided'
        ];
        
        const isValidLocation = !invalidLocationTerms.some(term => 
          location.toLowerCase().includes(term.toLowerCase())
        );
        
        if (isValidLocation && location.length > 2 && location.length < 100) {
          data.location = location;
          console.log(`📍 Found valid location: ${data.location}`);
          break;
        }
      }
    }
    
    console.log(`✅ Content parsing completed for: ${jobUrl.title}`);
    console.log(`🔧 Final workArrangement: ${data.workArrangement}`);
    console.log(`🔧 Final experienceLevel: ${data.experienceLevel}`);
    
  } catch (error) {
    console.error(`❌ Error parsing job content for ${jobUrl.title}:`, error);
  }
  
  return data;
}


function calculateEnhancedMatchScore(jobData, careerProfile) {
  let score = 70; // Base score for Claude-discovered jobs
  
  // Title matching
  const jobTitle = (jobData.title || '').toLowerCase();
  const titleMatches = careerProfile.targetJobTitles?.some(target => 
    jobTitle.includes(target.toLowerCase()) || target.toLowerCase().includes(jobTitle)
  );
  if (titleMatches) score += 20;
  
  // Keyword matching
  const content = (jobData.fullContent || '').toLowerCase();
  const keywordMatches = careerProfile.targetKeywords?.filter(keyword => 
    content.includes(keyword.toLowerCase())
  ).length || 0;
  score += Math.min(keywordMatches * 3, 15);
  
  // Experience level matching
  if (jobData.experienceLevel && jobData.experienceLevel.toLowerCase() === careerProfile.experienceLevel?.toLowerCase()) {
    score += 10;
  }
  
  // Salary matching
  if (jobData.salary?.min && careerProfile.salaryExpectation?.min) {
    if (jobData.salary.min >= careerProfile.salaryExpectation.min * 0.8) {
      score += 10;
    }
  }
  
  // Work arrangement preference
  if (jobData.workArrangement && careerProfile.workArrangement) {
    if (jobData.workArrangement === careerProfile.workArrangement || 
        (careerProfile.workArrangement === 'remote' && jobData.workArrangement === 'hybrid')) {
      score += 5;
    }
  }
  
  return Math.min(Math.max(score, 0), 100);
}

function assessContentQuality(content) {
  if (!content) return 'low';
  
  const length = content.length;
  const hasRequirements = /requirements?|qualifications?|skills?/i.test(content);
  const hasResponsibilities = /responsibilit|duties|role|job description/i.test(content);
  const hasBenefits = /benefits?|perks|compensation|salary/i.test(content);
  const hasCompanyInfo = /company|about us|culture|mission/i.test(content);
  const hasWorkArrangement = /remote|hybrid|onsite|office|location/i.test(content);
  const hasApplyInfo = /apply|application|submit|contact/i.test(content);
  
  let qualityScore = 0;
  
  // Length scoring
  if (length > 3000) qualityScore += 4;
  else if (length > 2000) qualityScore += 3;
  else if (length > 1000) qualityScore += 2;
  else if (length > 500) qualityScore += 1;
  
  // Content sections scoring
  if (hasRequirements) qualityScore += 2;
  if (hasResponsibilities) qualityScore += 2;
  if (hasBenefits) qualityScore += 1;
  if (hasCompanyInfo) qualityScore += 1;
  if (hasWorkArrangement) qualityScore += 1;
  if (hasApplyInfo) qualityScore += 1;
  
  console.log(`📊 Content quality score: ${qualityScore}/12`);
  
  if (qualityScore >= 8) return 'high';
  else if (qualityScore >= 5) return 'medium';
  else return 'low';
}

/**
 * Enhanced save jobs function with Claude web search metadata and technical requirements
 * (Uses your existing parseJobContent and parseLocationEnhanced functions)
 */
async function saveJobsWithEnhancedMetadata(analyzedJobs, userId, searchId, search) {
  let savedCount = 0;
  const maxJobsPerSearch = 10; // FIXED: Enforce daily limit
  
  console.log(`💾 Starting to save ${Math.min(analyzedJobs.length, maxJobsPerSearch)} jobs (limited to ${maxJobsPerSearch})...`);
  
  // FIXED: Only process up to the daily limit
  const jobsToProcess = analyzedJobs.slice(0, maxJobsPerSearch);
  
  for (const jobData of jobsToProcess) {
    try {
      // ENHANCED: More comprehensive duplicate checking
      const existing = await Job.findOne({
        userId,
        $or: [
          // Check by source URL
          { sourceUrl: jobData.jobUrl },
          
          // Check by title and company combination (case insensitive)
          { 
            title: { $regex: new RegExp(`^${jobData.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i') },
            company: { $regex: new RegExp(`^${jobData.company.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i') }
          },
          
          // Check by similar title at same company (fuzzy matching)
          {
            company: { $regex: new RegExp(`^${jobData.company.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i') },
            title: { $regex: new RegExp(jobData.title.split(' ').slice(0, 3).join('|'), 'i') }
          }
        ]
      });
      
      if (existing) {
        await search.addReasoningLog(
          'job_saving',
          `Skipped duplicate: "${jobData.title}" at ${jobData.company} (already exists: ${existing.title})`,
          { 
            reason: 'enhanced_duplicate_prevention',
            originalPlatform: jobData.sourcePlatform,
            existingJobId: existing._id,
            duplicateCheckMethod: 'title_company_url_fuzzy'
          }
        );
        continue;
      }
      
      // FIXED: Check if we've reached the daily limit during processing
      if (savedCount >= maxJobsPerSearch) {
        await search.addReasoningLog(
          'job_saving',
          `Reached daily limit of ${maxJobsPerSearch} jobs. Stopping job saving.`,
          { 
            reason: 'daily_limit_enforced',
            jobsSaved: savedCount,
            jobsSkipped: analyzedJobs.length - savedCount
          }
        );
        break;
      }
      
      // Fix the sourcePlatform enum issue
      let sourcePlatform = `AI_FOUND_INTELLIGENT`;
      
      // Use your existing parseLocationEnhanced function
      const enhancedLocation = parseLocationEnhanced(jobData.location);
      
      // Extract technical requirements with FIXED regex
      const technicalRequirements = extractTechnicalRequirements(jobData);
      
      // FIXED: Validate workArrangement before saving
      let workArrangement = jobData.analysis?.workArrangement || jobData.workArrangement || 'remote';
      const validWorkArrangements = ['remote', 'hybrid', 'onsite'];
      if (!validWorkArrangements.includes(workArrangement)) {
        console.log(`⚠️ Invalid work arrangement "${workArrangement}" for ${jobData.title}, defaulting to remote`);
        workArrangement = 'remote';
      }
      
      // Create enhanced job record with Claude web search data
      const job = new Job({
        userId,
        title: jobData.title,
        company: jobData.company,
        location: enhancedLocation,
        description: jobData.fullContent,
        sourceUrl: jobData.jobUrl,
        sourcePlatform: sourcePlatform,
        isAiGenerated: true,
        applicationStatus: 'NOT_APPLIED',
        aiSearchId: searchId,
        salary: jobData.salary || {},
        jobType: jobData.jobType || 'FULL_TIME',
        
        // FIXED: Add proper analysis status
        analysisStatus: {
          status: 'completed',
          progress: 100,
          message: `Premium analysis complete! Found ${jobData.analysis?.keySkills?.length || 0} key skills via Claude web search.`,
          updatedAt: new Date(),
          completedAt: new Date(),
          canViewJob: true,
          skillsFound: jobData.analysis?.keySkills?.length || 0,
          experienceLevel: jobData.analysis?.experienceLevel,
          modelUsed: 'gpt-4o',
          analysisType: 'claude_web_search_discovery_premium',
          searchApproach: '3-phase-intelligent-claude-web-search',
          qualityLevel: 'premium'
        },
        
        // Enhanced parsed data with FIXED workArrangement
        parsedData: {
          requirements: jobData.analysis?.requirements || [],
          responsibilities: jobData.analysis?.responsibilities || [],
          qualifications: jobData.analysis?.qualifications || { required: [], preferred: [] },
          benefits: jobData.analysis?.benefits || jobData.benefits || [],
          keySkills: jobData.analysis?.keySkills || [],
          experienceLevel: jobData.analysis?.experienceLevel || jobData.experienceLevel || 'Mid',
          yearsOfExperience: jobData.analysis?.yearsOfExperience || { minimum: 3, preferred: 5 },
          educationRequirements: jobData.analysis?.educationRequirements || [],
          workArrangement: workArrangement, // FIXED: Use validated work arrangement
          industryContext: jobData.analysis?.industryContext || jobData.industry || 'technology',
          roleCategory: jobData.analysis?.roleCategory || 'general',
          technicalComplexity: jobData.analysis?.technicalComplexity || 'medium',
          leadershipRequired: jobData.analysis?.leadershipRequired || false,
          companyStage: jobData.analysis?.companyStage || jobData.companySize || 'unknown',
          extractedAt: new Date(),
          extractionMethod: 'claude_web_search_premium',
          
          // FIXED: Add the technical requirements
          technicalRequirements: jobData.analysis?.technicalRequirements || technicalRequirements,
          
          // Enhanced Claude web search specific data
          claudeWebSearchData: {
            platform: jobData.sourcePlatform,
            originalUrl: jobData.jobUrl,
            postedDate: jobData.postedDate,
            matchReason: jobData.matchReason,
            techStack: jobData.techStack || [],
            department: jobData.department,
            directCompanyPosting: true,
            discoveryMethod: 'claude_web_search_api'
          },
          analysisMetadata: jobData.analysis?.analysisMetadata || {
            analyzedAt: new Date(),
            algorithmVersion: '3.3-claude-web-search-premium-fixed',
            model: 'gpt-4o',
            analysisType: 'claude_web_search_discovery_premium',
            qualityLevel: 'same_as_manual',
            discoveryPlatform: jobData.sourcePlatform,
            hasFullTechnicalAnalysis: true
          }
        },
        
        // Enhanced AI search metadata
        aiSearchMetadata: {
          searchScore: jobData.matchScore || 85,
          discoveryMethod: 'claude_web_search_discovery',
          extractionSuccess: !jobData.analysisError,
          contentQuality: jobData.contentQuality || 'high',
          premiumAnalysis: jobData.premiumAnalysis || true,
          intelligentDiscovery: true,
          claudeWebSearchDiscovery: true,
          phase: '3-phase-intelligent-claude-web-search-fixed',
          originalPlatform: jobData.sourcePlatform,
          postedDate: jobData.postedDate,
          workArrangement: workArrangement, // FIXED: Use validated value
          experienceLevel: jobData.experienceLevel,
          department: jobData.department,
          companySize: jobData.companySize,
          industry: jobData.industry,
          keyRequirements: jobData.keyRequirements || [],
          matchReason: jobData.matchReason,
          benefits: jobData.benefits || [],
          techStack: jobData.techStack || [],
          claudeWebSearchMetadata: {
            discoveryMethod: 'claude_web_search_api',
            extractionMethod: 'claude_web_content_extraction',
            searchQuery: jobData.searchQuery,
            foundAt: jobData.foundAt
          }
        }
      });
      
      await job.save();
      savedCount++;
      
      // Update search progress
      await AiJobSearch.findByIdAndUpdate(searchId, {
        $inc: { jobsFoundToday: 1, totalJobsFound: 1 },
        $push: {
          jobsFound: {
            jobId: job._id,
            title: job.title,
            company: job.company,
            foundAt: new Date(),
            extractionMethod: 'claude_web_search_discovery',
            contentQuality: jobData.contentQuality,
            matchScore: jobData.matchScore,
            premiumAnalysis: true,
            sourcePlatform: jobData.sourcePlatform,
            directCompanyPosting: true
          }
        }
      });
      
      console.log(`✅ Saved: ${job.title} at ${job.company} (${jobData.sourcePlatform} - Claude web search discovery) [${savedCount}/${maxJobsPerSearch}]`);
      console.log(`📍 Location: ${enhancedLocation.city || (enhancedLocation.remote ? 'Remote' : 'Not specified')}`);
      console.log(`🔧 Technical Requirements: ${technicalRequirements.length} extracted`);
      
    } catch (error) {
      console.error(`Error saving job ${jobData.title}:`, error);
    }
  }
  
  console.log(`💾 Job saving completed: ${savedCount} jobs saved, enforced limit of ${maxJobsPerSearch}`);
  return savedCount;
}

/**
 * ENHANCED: Extract technical requirements from AI jobs to match manual job analysis quality
 */
function extractTechnicalRequirements(jobData) {
  const content = jobData.fullContent || '';
  const technicalRequirements = [];
  
  try {
    // FIXED: Escape special regex characters in programming languages
    const languages = [
      'JavaScript', 'Python', 'Java', 'TypeScript', 'Go', 'Rust', 'C\\+\\+', 'C#', 'PHP', 
      'Ruby', 'Swift', 'Kotlin', 'Scala', 'R', 'Dart', 'Elixir', 'Clojure', 'Haskell'
    ];
    
    languages.forEach(lang => {
      // FIXED: Properly escape the language name for regex
      const escapedLang = lang.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`\\b${escapedLang}\\b`, 'i');
      
      if (regex.test(content)) {
        technicalRequirements.push({
          category: 'Programming Languages',
          requirement: lang.replace(/\\+/g, '+'), // Convert back C\+\+ to C++
          importance: 'high'
        });
      }
    });
    
    // Extract frameworks and technologies
    const frameworks = [
      'React', 'Vue', 'Angular', 'Node.js', 'Express', 'Django', 'Flask', 'Spring', 
      'Rails', 'Laravel', 'Next.js', 'Nuxt.js', 'Svelte', 'Ember.js', 'Backbone.js',
      'jQuery', 'Bootstrap', 'Tailwind', 'Material-UI', 'Ant Design'
    ];
    frameworks.forEach(framework => {
      const escapedFramework = framework.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      if (new RegExp(`\\b${escapedFramework}\\b`, 'i').test(content)) {
        technicalRequirements.push({
          category: 'Frameworks & Technologies',
          requirement: framework,
          importance: 'medium'
        });
      }
    });
    
    // Extract cloud platforms and infrastructure
    const cloudPlatforms = [
      'AWS', 'Amazon Web Services', 'Azure', 'Google Cloud', 'GCP', 'Kubernetes', 'Docker',
      'Terraform', 'Ansible', 'Jenkins', 'GitLab CI', 'GitHub Actions', 'CircleCI',
      'Heroku', 'Vercel', 'Netlify', 'DigitalOcean', 'Linode'
    ];
    cloudPlatforms.forEach(platform => {
      const escapedPlatform = platform.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      if (new RegExp(`\\b${escapedPlatform}\\b`, 'i').test(content)) {
        technicalRequirements.push({
          category: 'Cloud & Infrastructure',
          requirement: platform,
          importance: 'medium'
        });
      }
    });
    
    // Extract databases
    const databases = [
      'MySQL', 'PostgreSQL', 'MongoDB', 'Redis', 'Elasticsearch', 'DynamoDB', 'Cassandra',
      'Oracle', 'SQL Server', 'SQLite', 'MariaDB', 'CouchDB', 'Neo4j', 'InfluxDB'
    ];
    databases.forEach(db => {
      const escapedDb = db.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      if (new RegExp(`\\b${escapedDb}\\b`, 'i').test(content)) {
        technicalRequirements.push({
          category: 'Databases',
          requirement: db,
          importance: 'medium'
        });
      }
    });
    
    // Remove duplicates based on requirement name
    const uniqueRequirements = technicalRequirements.filter((req, index, self) =>
      index === self.findIndex(r => r.requirement === req.requirement)
    );
    
    console.log(`🔧 Extracted ${uniqueRequirements.length} technical requirements for ${jobData.title}`);
    return uniqueRequirements;
    
  } catch (error) {
    console.error(`❌ Error extracting technical requirements for ${jobData.title}:`, error);
    return [];
  }
}
/**
 * Enhanced Phase 3: Premium Job Analysis (unchanged but with Claude web search context)
 */
async function performPremiumJobAnalysis(discoveredJobs, search) {
  const analyzedJobs = [];
  
  console.log(`🔬 Starting premium analysis of ${discoveredJobs.length} jobs from Claude web search with GPT-4o...`);
  
  // Process jobs in batches of 3 for efficiency
  const batchSize = 3;
  for (let i = 0; i < discoveredJobs.length; i += batchSize) {
    const batch = discoveredJobs.slice(i, i + batchSize);
    
    try {
      console.log(`  📊 Analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(discoveredJobs.length/batchSize)}...`);
      
      await search.addReasoningLog(
        'premium_analysis',
        `Analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}: ${batch.map(job => `"${job.title}" at ${job.company} (${job.sourcePlatform})`).join(', ')}`,
        {
          batchNumber: Math.floor(i/batchSize) + 1,
          jobsInBatch: batch.length,
          model: 'gpt-4o',
          discoveryMethod: 'Claude web search API',
          sourcePlatforms: [...new Set(batch.map(job => job.sourcePlatform))]
        }
      );
      
      const batchResults = await analyzeBatchWithGPT4o(batch);
      
      // Process batch results
      for (let j = 0; j < batch.length; j++) {
        const job = batch[j];
        const analysis = batchResults[j];
        
        const hasGoodAnalysis = analysis && 
          (analysis.requirements?.length > 0 || analysis.responsibilities?.length > 0) &&
          analysis.keySkills?.length > 0;
        
        analyzedJobs.push({
          ...job,
          analysis: analysis,
          analysisError: !hasGoodAnalysis ? 'Analysis incomplete' : null,
          premiumAnalysis: true,
          analysisQuality: 'premium',
          claudeWebSearchDiscovery: true
        });
        
        await search.addReasoningLog(
          'content_extraction',
          `"${job.title}" at ${job.company} (${job.sourcePlatform}) - ${hasGoodAnalysis ? 'Premium analysis successful' : 'Analysis incomplete'}`,
          {
            jobTitle: job.title,
            companyName: job.company,
            discoveryPlatform: job.sourcePlatform,
            contentLength: job.fullContent?.length || 0,
            skillsFound: analysis?.keySkills?.length || 0,
            hasRequirements: !!(analysis?.requirements?.length > 0),
            hasResponsibilities: !!(analysis?.responsibilities?.length > 0),
            experienceLevel: analysis?.experienceLevel,
            model: 'gpt-4o',
            quality: 'premium',
            discoveryMethod: 'Claude web search'
          },
          hasGoodAnalysis
        );
      }
      
      // Small delay between batches to be respectful
      if (i + batchSize < discoveredJobs.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
    } catch (error) {
      console.error(`Error analyzing Claude web search batch ${Math.floor(i/batchSize) + 1}:`, error);
      
      // Add failed jobs with error
      batch.forEach(job => {
        analyzedJobs.push({
          ...job,
          analysis: null,
          analysisError: error.message,
          premiumAnalysis: false,
          claudeWebSearchDiscovery: true
        });
      });
    }
  }
  
  return analyzedJobs;
}

/**
 * Batch analysis with GPT-4o specifically for Claude web search content
 */
async function analyzeBatchWithGPT4o(jobBatch) {
  try {
    // Prepare batch content for analysis with Claude web search context
    const batchContent = jobBatch.map((job, index) => 
      `JOB ${index + 1} (${job.sourcePlatform}):
Title: ${job.title}
Company: ${job.company}
Source: ${job.sourcePlatform} (Found via Claude Web Search)
Location: ${job.location || 'Not specified'}
Tech Stack: ${job.techStack ? job.techStack.join(', ') : 'Not specified'}
Match Reason: ${job.matchReason || 'Not specified'}
Content: ${job.fullContent.substring(0, 2000)}...
---`
    ).join('\n\n');
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert job analyst providing premium analysis for jobs discovered via Claude's web search API. These are real job postings found through intelligent web search, similar to how jobs are found in general chat. Analyze multiple job postings and return detailed structured data for each. Focus on extracting comprehensive requirements, responsibilities, and skills with high accuracy. Return valid JSON array.`
        },
        {
          role: "user",
          content: `Analyze these ${jobBatch.length} job postings discovered via Claude web search and return detailed analysis for each:

${batchContent}

These jobs were discovered using Claude's web search API (same method as general chat), so they should have high-quality, comprehensive content from real job postings.

Return JSON array with ${jobBatch.length} objects in this EXACT format:
[
  {
    "requirements": ["Specific requirement 1", "Specific requirement 2"],
    "responsibilities": ["Key responsibility 1", "Key responsibility 2"],
    "qualifications": {
      "required": ["Must-have qualification 1", "Must-have qualification 2"],
      "preferred": ["Nice-to-have qualification 1", "Nice-to-have qualification 2"]
    },
    "keySkills": [
      {
        "name": "Python",
        "importance": 9,
        "category": "technical",
        "skillType": "programming"
      },
      {
        "name": "Leadership",
        "importance": 7,
        "category": "soft",
        "skillType": "management"
      }
    ],
    "experienceLevel": "mid/senior/lead",
    "yearsOfExperience": {
      "minimum": 3,
      "preferred": 5
    },
    "educationRequirements": ["Bachelor's degree in relevant field"],
    "benefits": ["Health insurance", "401k", "Remote work"],
    "salary": {
      "min": 120000,
      "max": 150000,
      "currency": "USD"
    },
    "workArrangement": "remote/hybrid/onsite",
    "industryContext": "technology/finance/healthcare",
    "roleCategory": "software-engineering/product-management",
    "technicalComplexity": "high/medium/low",
    "leadershipRequired": true/false,
    "companyStage": "startup/growth/enterprise"
  }
]

IMPORTANT:
- Skills importance: 9-10=critical, 7-8=very important, 5-6=important, 3-4=nice to have
- Extract comprehensive information from each job posting discovered via Claude web search
- These are high-quality job postings so expect detailed content
- Maintain high accuracy and detail level
- Return exactly ${jobBatch.length} analysis objects`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    
    if (jsonMatch) {
      const analyses = JSON.parse(jsonMatch[0]);
      
      // Ensure we have the right number of analyses
      if (analyses.length === jobBatch.length) {
        return analyses.map((analysis, index) => ({
          ...analysis,
          analysisMetadata: {
            analyzedAt: new Date(),
            algorithmVersion: '3.2-claude-web-search-premium',
            model: 'gpt-4o',
            analysisType: 'claude_web_search_discovery_premium',
            qualityLevel: 'same_as_manual',
            discoveryPlatform: jobBatch[index].sourcePlatform,
            claudeWebSearchDiscovery: true
          }
        }));
      }
    }
    
    // Fallback: return individual analyses
    return jobBatch.map((job) => createFallbackSingleAnalysis(job.sourcePlatform));
    
  } catch (error) {
    console.error('Error in GPT-4o batch analysis for Claude web search jobs:', error);
    return jobBatch.map((job) => createFallbackSingleAnalysis(job.sourcePlatform));
  }
}

/**
 * Create fallback single analysis for Claude web search
 */
function createFallbackSingleAnalysis(sourcePlatform = 'Unknown') {
  return {
    requirements: ['Relevant experience in the field'],
    responsibilities: ['Perform assigned duties effectively'],
    qualifications: {
      required: ['Relevant education or experience'],
      preferred: ['Additional qualifications preferred']
    },
    keySkills: [
      {
        name: 'Communication',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      },
      {
        name: 'Problem Solving',
        importance: 6,
        category: 'soft',
        skillType: 'general'
      }
    ],
    experienceLevel: 'mid',
    yearsOfExperience: { minimum: 3, preferred: 5 },
    educationRequirements: ['Bachelor\'s degree preferred'],
    benefits: ['Competitive benefits package'],
    workArrangement: 'unknown',
    industryContext: 'general',
    roleCategory: 'general',
    technicalComplexity: 'medium',
    leadershipRequired: false,
    companyStage: 'unknown',
    analysisMetadata: {
      analyzedAt: new Date(),
      algorithmVersion: '3.2-claude-web-search-fallback',
      model: 'gpt-4o-fallback',
      analysisType: 'claude_web_search_discovery_fallback',
      discoveryPlatform: sourcePlatform,
      claudeWebSearchDiscovery: true
    }
  };
}

/**
 * Enhanced career analysis for Claude web search targeting
 */
async function analyzeCareerTrajectoryEnhanced(resumeData) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      temperature: 0.1,
      messages: [
        {
          role: "system",
          content: `You are an expert career strategist. Analyze resume data to create targeted job search criteria for AI job discovery using Claude's web search API. Focus on generating specific, searchable job titles and keywords that will find the best opportunities through web search. Return only valid JSON.`
        },
        {
          role: "user",
          content: `Analyze this career data and create targeted search criteria for Claude web search job discovery:

Experience: ${JSON.stringify(resumeData.experience?.slice(0, 3), null, 2)}
Skills: ${JSON.stringify(resumeData.skills?.slice(0, 15), null, 2)}
Education: ${JSON.stringify(resumeData.education?.slice(0, 2), null, 2)}

Create targeted search criteria in this EXACT JSON format for Claude web search:
{
  "targetJobTitles": [
    "Primary Target Title",
    "Alternative Title 1", 
    "Alternative Title 2",
    "Growth Opportunity Title"
  ],
  "targetKeywords": [
    "keyword1", "keyword2", "keyword3"
  ],
  "experienceLevel": "Mid/Senior/Lead",
  "industries": ["Industry 1", "Industry 2"],
  "preferredLocations": ["Remote", "Major City"],
  "salaryExpectation": {
    "min": 120000,
    "max": 180000,
    "currency": "USD"
  },
  "mustHaveSkills": ["Critical Skill 1", "Critical Skill 2"],
  "niceToHaveSkills": ["Bonus Skill 1", "Bonus Skill 2"],
  "avoidKeywords": ["keyword to avoid"],
  "workArrangement": "remote/hybrid/onsite",
  "careerDirection": "Brief description of career goals",
  "targetCompanyTypes": ["Startup", "Scale-up", "Enterprise"],
  "webSearchPreferences": {
    "focus": "Direct company postings and reputable job boards",
    "avoid": "Recruitment agencies and low-quality job aggregators",
    "prioritize": "Greenhouse, Lever, Indeed, LinkedIn, company career pages"
  }
}

Focus on:
1. Specific job titles that match experience level and are commonly searched
2. Keywords that companies actually use in job postings
3. Realistic salary expectations based on current market
4. Skills that are in high demand
5. Company types and job boards that typically have quality postings
6. Avoiding overqualified or underqualified positions`
        }
      ]
    });

    const content = response.choices[0].message.content.trim();
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    
    return createEnhancedFallbackCareerProfile(resumeData);
    
  } catch (error) {
    console.error('Error in enhanced career trajectory analysis:', error);
    return createEnhancedFallbackCareerProfile(resumeData);
  }
}

/**
 * Enhanced fallback career profile for Claude web search
 */
function createEnhancedFallbackCareerProfile(resumeData) {
  return {
    targetJobTitles: [
      resumeData.experience?.[0]?.title || 'Software Engineer',
      'Senior Software Engineer',
      'Software Developer',
      'Full Stack Developer'
    ],
    targetKeywords: [
      'software development',
      'programming',
      'engineering',
      'technology'
    ],
    experienceLevel: calculateExperienceLevel(resumeData.experience),
    industries: ['Technology', 'Software', 'SaaS'],
    preferredLocations: ['Remote', 'San Francisco', 'New York', 'Austin'],
    salaryExpectation: {
      min: 100000,
      max: 150000,
      currency: 'USD'
    },
    mustHaveSkills: resumeData.skills?.slice(0, 3).map(s => typeof s === 'string' ? s : s.name) || [],
    niceToHaveSkills: resumeData.skills?.slice(3, 6).map(s => typeof s === 'string' ? s : s.name) || [],
    workArrangement: 'remote',
    careerDirection: 'Software engineering role with growth opportunities',
    targetCompanyTypes: ['Startup', 'Scale-up', 'Enterprise'],
    webSearchPreferences: {
      focus: 'Direct company postings and reputable job boards',
      avoid: 'Recruitment agencies and low-quality job aggregators',
      prioritize: 'Greenhouse, Lever, Indeed, LinkedIn, company career pages'
    }
  };
}

function parseLocationEnhanced(locationString) {
  if (!locationString) return { remote: true };
  
  const lower = locationString.toLowerCase();
  const remote = lower.includes('remote') || lower.includes('anywhere');
  
  if (remote) {
    return {
      remote: true,
      city: lower.includes('remote') ? null : extractCity(locationString),
      country: 'USA'
    };
  }
  
  const parts = locationString.split(',').map(p => p.trim());
  return {
    city: parts[0] || null,
    state: parts[1] || null,
    country: parts[2] || 'USA',
    remote: false
  };
}

function extractCity(locationString) {
  const parts = locationString.split(',').map(p => p.trim());
  return parts.find(part => !part.toLowerCase().includes('remote')) || null;
}

// Keep all existing utility functions
function extractSearchCriteria(resumeData) {
  return {
    jobTitle: resumeData.experience?.[0]?.title || 'Software Engineer',
    skills: resumeData.skills?.slice(0, 10).map(s => typeof s === 'string' ? s : s.name) || [],
    location: resumeData.contactInfo?.location || 'Remote',
    experienceLevel: calculateExperienceLevel(resumeData.experience)
  };
}

function calculateExperienceLevel(experiences) {
  const years = calculateYearsOfExperience(experiences);
  if (years < 2) return 'Entry';
  if (years < 5) return 'Mid';
  if (years < 10) return 'Senior';
  return 'Lead';
}

function calculateYearsOfExperience(experiences) {
  if (!experiences?.length) return 0;
  
  const sorted = experiences
    .filter(exp => exp.startDate)
    .sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
  
  if (!sorted.length) return 0;
  
  const first = new Date(sorted[0].startDate);
  const last = sorted[sorted.length - 1].endDate 
    ? new Date(sorted[sorted.length - 1].endDate)
    : new Date();
  
  return Math.round((last - first) / (1000 * 60 * 60 * 24 * 365));
}

async function isDailyLimitReached(search) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  if (!search.lastSearchDate || search.lastSearchDate < today) {
    search.jobsFoundToday = 0;
    search.lastSearchDate = today;
    await search.save();
    return false;
  }
  
  return search.jobsFoundToday >= search.dailyLimit;
}

async function updateSearchStatus(searchId, status, message) {
  await AiJobSearch.findByIdAndUpdate(searchId, {
    status,
    lastUpdateMessage: message,
    lastUpdated: new Date()
  });
  console.log(`Search ${searchId}: ${status} - ${message}`);
}

// Export existing functions for compatibility
exports.getUserAiSearches = async (userId) => {
  return await AiJobSearch.find({ userId }).sort({ createdAt: -1 });
};

exports.pauseAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Claude web search paused by user request',
    { phase: 'user_pause', pausedAt: new Date() }
  );
  
  search.status = 'paused';
  search.lastUpdateMessage = 'Paused by user';
  await search.save();
  
  return { message: 'Claude web search paused successfully' };
};

exports.resumeAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'initialization',
    'Claude web search resumed by user - continuing with ENHANCED 3-Phase approach using Claude web search API',
    { 
      phase: 'user_resume', 
      resumedAt: new Date(),
      searchMethod: 'Claude web search API (same as general chat)'
    }
  );
  
  search.status = 'running';
  search.lastUpdateMessage = 'Resumed by user - Claude web search';
  await search.save();
  
  const resume = await Resume.findById(search.resumeId);
  if (resume) {
    performEnhancedJobSearch(searchId, userId, resume).catch(error => {
      console.error('Error resuming Claude web search:', error);
    });
  }
  
  return { message: 'Claude web search resumed successfully with enhanced approach' };
};

exports.deleteAiSearch = async (userId, searchId) => {
  const search = await AiJobSearch.findOne({ _id: searchId, userId });
  if (!search) throw new Error('Search not found');
  
  await search.addReasoningLog(
    'completion',
    'Claude web search cancelled by user request',
    { 
      phase: 'user_cancellation', 
      cancelledAt: new Date(),
      searchMethod: 'Claude web search API'
    }
  );
  
  search.status = 'cancelled';
  search.lastUpdateMessage = 'Cancelled by user';
  await search.save();
  
  return { message: 'Claude web search cancelled successfully' };
};

================
File: backend/services/usage.services.js
================
// backend/services/usage.service.js
const User = require('../models/mongodb/user.model');
const db = require('../config/postgresql');

class UsageService {
  /**
   * Plan limits configuration
   */
  static PLAN_LIMITS = {
    free: {
      resumeUploads: 1,
      resumeAnalysis: 1,
      jobImports: 3,
      resumeTailoring: 1,
      recruiterAccess: false,
      recruiterUnlocks: 0,
      aiJobDiscovery: false,
      aiAssistant: false,
      aiConversations: 0,
      aiMessagesPerConversation: 0
    },
    casual: {
      resumeUploads: 5,
      resumeAnalysis: 5,
      jobImports: 25,
      resumeTailoring: 25,
      recruiterAccess: true,
      recruiterUnlocks: 25,
      aiJobDiscovery: 1,
      aiAssistant: false,
      aiConversations: 0,
      aiMessagesPerConversation: 0
    },
    hunter: {
      resumeUploads: -1, // unlimited
      resumeAnalysis: -1, // unlimited
      jobImports: -1, // unlimited
      resumeTailoring: 50,
      recruiterAccess: true,
      recruiterUnlocks: -1, // unlimited
      aiJobDiscovery: -1, // unlimited
      aiAssistant: true,
      aiConversations: 5,
      aiMessagesPerConversation: 20
    }
  };

  /**
   * Check if user can perform an action
   * @param {string} userId - User ID
   * @param {string} action - Action to check
   * @param {number} quantity - Quantity needed (default: 1)
   * @returns {Object} Permission result
   */
  async checkUsageLimit(userId, action, quantity = 1) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      const permission = user.canPerformAction(action, quantity);
      
      return {
        userId,
        action,
        quantity,
        allowed: permission.allowed,
        reason: permission.reason,
        current: permission.current || 0,
        limit: permission.limit || 0,
        remaining: permission.remaining || 0,
        plan: user.subscriptionTier,
        timestamp: new Date()
      };
    } catch (error) {
      console.error('Error checking usage limit:', error);
      throw new Error('Failed to check usage limit: ' + error.message);
    }
  }

  /**
   * Track usage for a specific action
   * @param {string} userId - User ID
   * @param {string} action - Action being performed
   * @param {number} quantity - Quantity to track (default: 1)
   * @param {Object} metadata - Additional metadata
   * @returns {Object} Updated usage information
   */
  async trackUsage(userId, action, quantity = 1, metadata = {}) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Check if user can perform this action first
      const permission = user.canPerformAction(action, quantity);
      if (!permission.allowed) {
        throw new Error(permission.reason);
      }

      // Track usage in MongoDB
      await user.trackUsage(action, quantity);

      // Track usage in PostgreSQL for analytics
      await this.trackUsageInAnalytics(userId, action, quantity, metadata);

      // Get updated usage stats
      const updatedUser = await User.findById(userId);
      const usageStats = updatedUser.getUsageStats();

      return {
        success: true,
        action,
        quantity,
        usageStats,
        remaining: permission.limit > 0 ? permission.limit - (permission.current + quantity) : -1,
        timestamp: new Date()
      };
    } catch (error) {
      console.error('Error tracking usage:', error);
      throw new Error('Failed to track usage: ' + error.message);
    }
  }

  /**
   * Track usage in PostgreSQL for analytics and reporting
   * @param {string} userId - User ID
   * @param {string} action - Action being performed
   * @param {number} quantity - Quantity tracked
   * @param {Object} metadata - Additional metadata
   */
  async trackUsageInAnalytics(userId, action, quantity, metadata = {}) {
    try {
      const currentDate = new Date();
      const usagePeriod = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);

      // Map action names to database columns
      const actionMapping = {
        resumeUploads: 'resume_uploads',
        resumeAnalysis: 'resume_analysis',
        jobImports: 'job_imports',
        resumeTailoring: 'resume_tailoring',
        recruiterUnlocks: 'recruiter_unlocks',
        aiJobDiscovery: 'ai_job_discovery',
        aiConversations: 'ai_conversations',
        aiMessagesTotal: 'ai_messages_total'
      };

      const dbColumn = actionMapping[action];
      if (!dbColumn) {
        console.warn(`Unknown action for analytics tracking: ${action}`);
        return;
      }

      // Update or insert usage record
      await db.query(`
        INSERT INTO user_usage (user_id, usage_period, ${dbColumn})
        VALUES ($1, $2, $3)
        ON CONFLICT (user_id, usage_period) 
        DO UPDATE SET 
          ${dbColumn} = COALESCE(user_usage.${dbColumn}, 0) + $3,
          updated_at = NOW()
      `, [userId, usagePeriod, quantity]);

      // For AI Assistant, also track detailed usage
      if (action === 'aiConversations' || action === 'aiMessagesTotal') {
        await this.trackAIUsageDetails(userId, action, quantity, metadata);
      }

    } catch (error) {
      console.error('Error tracking usage in analytics:', error);
      // Don't throw error for analytics tracking failure
    }
  }

  /**
   * Track detailed AI Assistant usage
   * @param {string} userId - User ID
   * @param {string} action - AI action
   * @param {number} quantity - Quantity
   * @param {Object} metadata - Metadata including conversation details
   */
  async trackAIUsageDetails(userId, action, quantity, metadata) {
    try {
      await db.query(`
        INSERT INTO ai_assistant_usage (
          user_id, conversation_id, message_count, tokens_used, 
          cost_usd, feature_type, usage_date
        ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_DATE)
      `, [
        userId,
        metadata.conversationId || null,
        action === 'aiMessagesTotal' ? quantity : 0,
        metadata.tokensUsed || 0,
        metadata.costUsd || 0,
        metadata.featureType || 'general',
      ]);
    } catch (error) {
      console.error('Error tracking AI usage details:', error);
    }
  }

  /**
   * Get current usage statistics for a user
   * @param {string} userId - User ID
   * @returns {Object} Usage statistics
   */
  async getUserUsageStats(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      const usageStats = user.getUsageStats();
      const planLimits = user.getPlanLimits();

      return {
        userId,
        plan: user.subscriptionTier,
        planLimits,
        currentUsage: user.currentUsage || {},
        usageStats,
        resetDate: user.currentUsage?.resetDate || new Date(),
        subscriptionStatus: user.subscriptionStatus,
        subscriptionEndDate: user.subscriptionEndDate,
        hasActiveSubscription: user.hasActiveSubscription()
      };
    } catch (error) {
      console.error('Error getting user usage stats:', error);
      throw new Error('Failed to get usage stats: ' + error.message);
    }
  }

  /**
   * Reset monthly usage for all users (called by cron job)
   * @returns {Object} Reset summary
   */
  async resetMonthlyUsage() {
    try {
      const now = new Date();
      const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);

      console.log('Starting monthly usage reset...');

      // Get all users that need reset
      const users = await User.find({
        'currentUsage.resetDate': { $lt: lastMonth }
      });

      let resetCount = 0;
      let errorCount = 0;

      for (const user of users) {
        try {
          // Archive current usage to history
          if (user.currentUsage && Object.keys(user.currentUsage).length > 1) {
            user.usageHistory.push({
              month: user.currentUsage.resetDate || lastMonth,
              usage: { ...user.currentUsage }
            });

            // Keep only last 12 months
            if (user.usageHistory.length > 12) {
              user.usageHistory = user.usageHistory.slice(-12);
            }
          }

          // Reset current usage
          user.currentUsage = {
            resumeUploads: 0,
            resumeAnalysis: 0,
            jobImports: 0,
            resumeTailoring: 0,
            recruiterUnlocks: 0,
            aiJobDiscovery: 0,
            aiConversations: 0,
            aiMessagesTotal: 0,
            resetDate: now
          };

          await user.save();
          resetCount++;
        } catch (userError) {
          console.error(`Error resetting usage for user ${user._id}:`, userError);
          errorCount++;
        }
      }

      console.log(`✅ Monthly usage reset completed: ${resetCount} users reset, ${errorCount} errors`);

      return {
        success: true,
        resetCount,
        errorCount,
        totalProcessed: users.length,
        resetDate: now
      };
    } catch (error) {
      console.error('Error during monthly usage reset:', error);
      throw new Error('Failed to reset monthly usage: ' + error.message);
    }
  }

  /**
   * Get usage analytics for admin dashboard
   * @param {Object} filters - Filters for analytics
   * @returns {Object} Usage analytics
   */
  async getUsageAnalytics(filters = {}) {
    try {
      const {
        startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
        endDate = new Date(),
        planTier = null,
        feature = null
      } = filters;

      // Get usage data from PostgreSQL
      let query = `
        SELECT 
          usage_period,
          COUNT(DISTINCT user_id) as active_users,
          SUM(resume_uploads) as total_resume_uploads,
          SUM(resume_analysis) as total_resume_analysis,
          SUM(job_imports) as total_job_imports,
          SUM(resume_tailoring) as total_resume_tailoring,
          SUM(recruiter_unlocks) as total_recruiter_unlocks,
          SUM(ai_job_discovery) as total_ai_job_discovery,
          SUM(ai_conversations) as total_ai_conversations,
          SUM(ai_messages_total) as total_ai_messages,
          AVG(resume_uploads) as avg_resume_uploads,
          AVG(job_imports) as avg_job_imports
        FROM user_usage 
        WHERE usage_period >= $1 AND usage_period <= $2
      `;

      const queryParams = [startDate, endDate];

      if (feature) {
        query += ` AND ${feature} > 0`;
      }

      query += ` GROUP BY usage_period ORDER BY usage_period ASC`;

      const analyticsResult = await db.query(query, queryParams);

      // Get user distribution by plan
      const planDistributionQuery = await db.query(`
        SELECT 
          us.status,
          sp.display_name as plan_name,
          COUNT(*) as user_count
        FROM user_subscriptions us
        LEFT JOIN subscription_plans sp ON sp.name = us.subscription_plan_id::text
        GROUP BY us.status, sp.display_name
        ORDER BY user_count DESC
      `);

      // Get top features by usage
      const featureUsageQuery = await db.query(`
        SELECT 
          'resume_uploads' as feature, SUM(resume_uploads) as total_usage
        FROM user_usage WHERE usage_period >= $1 AND usage_period <= $2
        UNION ALL
        SELECT 
          'job_imports' as feature, SUM(job_imports) as total_usage
        FROM user_usage WHERE usage_period >= $1 AND usage_period <= $2
        UNION ALL
        SELECT 
          'recruiter_unlocks' as feature, SUM(recruiter_unlocks) as total_usage
        FROM user_usage WHERE usage_period >= $1 AND usage_period <= $2
        ORDER BY total_usage DESC
      `, [startDate, endDate]);

      return {
        dateRange: { startDate, endDate },
        usageData: analyticsResult.rows,
        planDistribution: planDistributionQuery.rows,
        featureUsage: featureUsageQuery.rows,
        summary: {
          totalActiveUsers: analyticsResult.rows.reduce((sum, row) => 
            Math.max(sum, parseInt(row.active_users)), 0),
          totalFeatureUsage: featureUsageQuery.rows.reduce((sum, row) => 
            sum + parseInt(row.total_usage), 0)
        }
      };
    } catch (error) {
      console.error('Error getting usage analytics:', error);
      throw new Error('Failed to get usage analytics: ' + error.message);
    }
  }

  /**
   * Get user usage history
   * @param {string} userId - User ID
   * @param {number} months - Number of months to retrieve
   * @returns {Array} Usage history
   */
  async getUserUsageHistory(userId, months = 12) {
    try {
      // Get from PostgreSQL analytics
      const historyQuery = await db.query(`
        SELECT * FROM user_usage 
        WHERE user_id = $1 
        ORDER BY usage_period DESC 
        LIMIT $2
      `, [userId, months]);

      // Also get from MongoDB for current period
      const user = await User.findById(userId);
      const currentUsage = user?.currentUsage || {};

      return {
        currentPeriod: {
          period: currentUsage.resetDate || new Date(),
          usage: currentUsage
        },
        history: historyQuery.rows,
        planTier: user?.subscriptionTier || 'free'
      };
    } catch (error) {
      console.error('Error getting user usage history:', error);
      throw new Error('Failed to get usage history: ' + error.message);
    }
  }

  /**
   * Validate usage before performing action
   * @param {string} userId - User ID
   * @param {string} action - Action to validate
   * @param {number} quantity - Quantity needed
   * @returns {Object} Validation result
   */
  async validateUsage(userId, action, quantity = 1) {
    try {
      const permission = await this.checkUsageLimit(userId, action, quantity);
      
      if (!permission.allowed) {
        return {
          valid: false,
          reason: permission.reason,
          current: permission.current,
          limit: permission.limit,
          upgradeRequired: true,
          recommendedPlan: this.getRecommendedPlan(action)
        };
      }

      return {
        valid: true,
        current: permission.current,
        limit: permission.limit,
        remaining: permission.remaining
      };
    } catch (error) {
      console.error('Error validating usage:', error);
      throw new Error('Failed to validate usage: ' + error.message);
    }
  }

  /**
   * Get recommended plan for a specific feature
   * @param {string} action - Action that exceeded limit
   * @returns {string} Recommended plan name
   */
  getRecommendedPlan(action) {
    const featurePlanMap = {
      resumeUploads: 'casual',
      jobImports: 'casual',
      recruiterUnlocks: 'casual',
      aiJobDiscovery: 'casual',
      aiAssistant: 'hunter',
      aiConversations: 'hunter'
    };

    return featurePlanMap[action] || 'casual';
  }

  /**
   * Get usage warnings for users approaching limits
   * @param {string} userId - User ID
   * @returns {Array} Array of warnings
   */
  async getUsageWarnings(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      const usageStats = user.getUsageStats();
      const warnings = [];

      Object.keys(usageStats).forEach(action => {
        const stat = usageStats[action];
        if (!stat.unlimited && stat.percentage >= 80) {
          warnings.push({
            action,
            percentage: stat.percentage,
            used: stat.used,
            limit: stat.limit,
            remaining: stat.remaining,
            severity: stat.percentage >= 95 ? 'critical' : 'warning'
          });
        }
      });

      return warnings;
    } catch (error) {
      console.error('Error getting usage warnings:', error);
      throw new Error('Failed to get usage warnings: ' + error.message);
    }
  }

  /**
   * Bulk track usage for multiple actions
   * @param {string} userId - User ID
   * @param {Array} actions - Array of {action, quantity} objects
   * @returns {Object} Bulk tracking result
   */
  async bulkTrackUsage(userId, actions) {
    try {
      const results = [];
      const errors = [];

      for (const { action, quantity = 1, metadata = {} } of actions) {
        try {
          const result = await this.trackUsage(userId, action, quantity, metadata);
          results.push({ action, ...result });
        } catch (error) {
          errors.push({ action, error: error.message });
        }
      }

      return {
        success: errors.length === 0,
        results,
        errors,
        processed: results.length,
        failed: errors.length
      };
    } catch (error) {
      console.error('Error in bulk track usage:', error);
      throw new Error('Failed to bulk track usage: ' + error.message);
    }
  }

  /**
   * Get feature usage trends
   * @param {string} feature - Feature to analyze
   * @param {number} days - Number of days to analyze
   * @returns {Object} Usage trends
   */
  async getFeatureTrends(feature, days = 30) {
    try {
      const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      
      const featureMapping = {
        resumeUploads: 'resume_uploads',
        jobImports: 'job_imports',
        recruiterUnlocks: 'recruiter_unlocks',
        aiConversations: 'ai_conversations'
      };

      const dbColumn = featureMapping[feature];
      if (!dbColumn) {
        throw new Error('Invalid feature for trend analysis');
      }

      const trendsQuery = await db.query(`
        SELECT 
          DATE(created_at) as date,
          COUNT(DISTINCT user_id) as active_users,
          SUM(${dbColumn}) as total_usage,
          AVG(${dbColumn}) as avg_usage_per_user
        FROM user_usage 
        WHERE created_at >= $1 AND ${dbColumn} > 0
        GROUP BY DATE(created_at)
        ORDER BY date ASC
      `, [startDate]);

      return {
        feature,
        period: { startDate, endDate: new Date(), days },
        trends: trendsQuery.rows,
        summary: {
          totalUsers: new Set(trendsQuery.rows.map(r => r.active_users)).size,
          totalUsage: trendsQuery.rows.reduce((sum, r) => sum + parseInt(r.total_usage), 0),
          avgDailyUsage: trendsQuery.rows.reduce((sum, r) => sum + parseFloat(r.avg_usage_per_user), 0) / trendsQuery.rows.length
        }
      };
    } catch (error) {
      console.error('Error getting feature trends:', error);
      throw new Error('Failed to get feature trends: ' + error.message);
    }
  }
}

module.exports = new UsageService();

================
File: backend/test-controller.js
================
// backend/test-controller.js - Simple test to verify our controller works
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function testController() {
  try {
    console.log('🧪 TESTING BACKEND CONTROLLER');
    console.log('==============================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Simulate the exact query from the controller
    const sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
        AND (
          COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $2 OR
          COALESCE(r.title, '') ILIKE $2
        )
      ORDER BY r.first_name ASC
      LIMIT 20 OFFSET 0
    `;

    const queryParams = [userId, `%${query}%`];

    console.log('🗄️ Testing exact controller query...');
    console.log('📝 SQL Query:', sqlQuery.replace(/\s+/g, ' ').trim());
    console.log('📝 Query Params:', queryParams);

    const result = await pool.query(sqlQuery, queryParams);
    
    console.log(`📊 Query returned ${result.rows.length} rows`);
    
    if (result.rows.length > 0) {
      console.log('✅ SUCCESS: Found results!');
      console.log('👥 Sample results:');
      result.rows.slice(0, 5).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    } else {
      console.log('❌ PROBLEM: No results found');
    }

    // Test count query
    const countQuery = `
      SELECT COUNT(*) as count FROM recruiters r 
      WHERE r.is_active = true
        AND (
          COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $1 OR
          COALESCE(r.title, '') ILIKE $1
        )
    `;

    const countResult = await pool.query(countQuery, [`%${query}%`]);
    console.log(`📊 Count query returned: ${countResult.rows[0].count}`);

    console.log('\n✅ Test complete!');

  } catch (error) {
    console.error('❌ Test failed:', error);
  } finally {
    await pool.end();
  }
}

testController();

================
File: backend/test-s3.js
================
// test-s3.js
const AWS = require('aws-sdk');
const fs = require('fs');
require('dotenv').config();

// Configure AWS SDK
AWS.config.update({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1'
});

const s3 = new AWS.S3();
const bucketName = process.env.AWS_BUCKET_NAME;

// Create a test file
const testFilePath = './test-file.txt';
fs.writeFileSync(testFilePath, 'This is a test file for S3 upload');

// Test bucket connection and file upload
async function testS3() {
  try {
    // Check if bucket exists
    await s3.headBucket({ Bucket: bucketName }).promise();
    console.log(`✅ Successfully connected to bucket: ${bucketName}`);
    
    // Upload a test file
    const fileContent = fs.readFileSync(testFilePath);
    const params = {
      Bucket: bucketName,
      Key: 'test-file.txt',
      Body: fileContent
    };
    
    const uploadResult = await s3.upload(params).promise();
    console.log(`✅ Successfully uploaded file to: ${uploadResult.Location}`);
    
    // List files in bucket
    const listResult = await s3.listObjectsV2({ Bucket: bucketName }).promise();
    console.log('Files in bucket:');
    listResult.Contents.forEach(item => {
      console.log(` - ${item.Key} (${item.Size} bytes)`);
    });
    
    // Clean up - delete test file
    await s3.deleteObject({ Bucket: bucketName, Key: 'test-file.txt' }).promise();
    console.log('✅ Successfully deleted test file');
    
    console.log('All S3 tests passed! Your configuration is working.');
  } catch (error) {
    console.error('❌ S3 Test Error:', error);
  } finally {
    // Delete local test file
    fs.unlinkSync(testFilePath);
  }
}

testS3();

================
File: backend/test-stripe-setup.js
================
// backend/test-stripe-setup.js
require('dotenv').config();
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

async function testStripeSetup() {
  console.log('🧪 Testing Stripe Setup...\n');

  try {
    // Test 1: Verify API key works
    console.log('1️⃣ Testing API Key...');
    const account = await stripe.accounts.retrieve();
    console.log(`✅ Connected to Stripe account: ${account.display_name || account.id}`);
    
    // Test 2: Check if products exist
    console.log('\n2️⃣ Checking Products...');
    const products = await stripe.products.list({ limit: 10 });
    
    console.log(`Found ${products.data.length} products:`);
    products.data.forEach(product => {
      console.log(`  - ${product.name} (${product.id})`);
    });
    
    // Test 3: Check prices
    console.log('\n3️⃣ Checking Prices...');
    const prices = await stripe.prices.list({ limit: 10 });
    
    console.log(`Found ${prices.data.length} prices:`);
    prices.data.forEach(price => {
      console.log(`  - ${price.id}: ${price.currency.toUpperCase()} ${price.unit_amount / 100}/${price.recurring?.interval || 'one-time'}`);
    });
    
    // Test 4: Verify environment variables
    console.log('\n4️⃣ Checking Environment Variables...');
    const requiredVars = [
      'STRIPE_SECRET_KEY',
      'STRIPE_PUBLISHABLE_KEY', 
      'STRIPE_CASUAL_MONTHLY_PRICE_ID',
      'STRIPE_HUNTER_MONTHLY_PRICE_ID'
    ];
    
    const optionalVars = [
      'STRIPE_WEBHOOK_SECRET'
    ];
    
    requiredVars.forEach(varName => {
      const value = process.env[varName];
      if (value) {
        console.log(`  ✅ ${varName}: ${value.substring(0, 20)}...`);
      } else {
        console.log(`  ❌ ${varName}: Missing! (Required)`);
      }
    });
    
    optionalVars.forEach(varName => {
      const value = process.env[varName];
      if (value) {
        console.log(`  ✅ ${varName}: ${value.substring(0, 20)}... (Optional)`);
      } else {
        console.log(`  ⚠️ ${varName}: Missing (Optional - for webhooks)`);
      }
    });
    
    // Test 5: Test webhook endpoint creation
    console.log('\n5️⃣ Testing Webhook Configuration...');
    const webhooks = await stripe.webhookEndpoints.list();
    console.log(`Found ${webhooks.data.length} webhook endpoints:`);
    webhooks.data.forEach(webhook => {
      console.log(`  - ${webhook.url} (${webhook.enabled_events.length} events)`);
    });
    
    console.log('\n🎉 Stripe setup test completed successfully!');
    
  } catch (error) {
    console.error('\n❌ Stripe setup test failed:', error.message);
    
    if (error.type === 'StripeAuthenticationError') {
      console.log('\n💡 Fix: Check your STRIPE_SECRET_KEY in .env file');
    } else if (error.type === 'StripeAPIError') {
      console.log('\n💡 Fix: Check your internet connection and Stripe account status');
    }
  }
}

// Run the test
testStripeSetup();

================
File: backend/tests/test-auth.js
================
// backend/tests/test-auth.js
require('dotenv').config();
const axios = require('axios');
const mongoose = require('mongoose');
const connectMongoDB = require('../config/mongodb');

const API_URL = 'http://localhost:5000/api';

// Helper function to make API requests
const api = axios.create({
  baseURL: API_URL,
  withCredentials: true
});

// Test user details
const testUser = {
  firstName: 'Test',
  lastName: 'User',
  email: `testuser${Date.now()}@example.com`,
  password: 'Test@123456'
};

let token = null;

const runTests = async () => {
  try {
    console.log('Starting authentication tests...');
    
    // Connect to MongoDB
    await connectMongoDB();
    
    // Clean up any previous test users
    await mongoose.connection.collection('users').deleteMany({
      email: { $regex: /testuser.*@example.com/ }
    });
    
    // Test registration
    console.log('\nTesting user registration...');
    const registrationResponse = await api.post('/auth/register', testUser);
    console.log('Registration response status:', registrationResponse.status);
    console.log('Registration data:', registrationResponse.data);
    
    // Save token
    token = registrationResponse.data.token;
    
    // Test get current user
    console.log('\nTesting get current user...');
    const meResponse = await api.get('/auth/me', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    console.log('Get me response status:', meResponse.status);
    console.log('User data:', meResponse.data);
    
    // Test logout
    console.log('\nTesting logout...');
    const logoutResponse = await api.post('/auth/logout', {}, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    console.log('Logout response status:', logoutResponse.status);
    console.log('Logout data:', logoutResponse.data);
    
    // Test login
    console.log('\nTesting login...');
    const loginResponse = await api.post('/auth/login', {
      email: testUser.email,
      password: testUser.password
    });
    console.log('Login response status:', loginResponse.status);
    console.log('Login data:', loginResponse.data);
    
    // Save new token
    token = loginResponse.data.token;
    
    // Test updating user details
    console.log('\nTesting update user details...');
    const updateResponse = await api.put('/auth/update-details', 
      { firstName: 'Updated', lastName: 'User' },
      {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }
    );
    console.log('Update details response status:', updateResponse.status);
    console.log('Updated user data:', updateResponse.data);
    
    // Test updating password
    console.log('\nTesting update password...');
    const updatePasswordResponse = await api.put('/auth/update-password', 
      { 
        currentPassword: testUser.password,
        newPassword: 'NewTest@123456'
      },
      {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }
    );
    console.log('Update password response status:', updatePasswordResponse.status);
    console.log('Update password data:', updatePasswordResponse.data);
    
    // Test login with new password
    console.log('\nTesting login with new password...');
    const newLoginResponse = await api.post('/auth/login', {
      email: testUser.email,
      password: 'NewTest@123456'
    });
    console.log('New login response status:', newLoginResponse.status);
    console.log('New login data:', newLoginResponse.data);
    
    console.log('\nAll authentication tests completed successfully!');
  } catch (error) {
    console.error('Error in authentication tests:', error.message);
    if (error.response) {
      console.error('Response data:', error.response.data);
      console.error('Response status:', error.response.status);
    }
  } finally {
    // Clean up test user
    if (mongoose.connection.readyState === 1) {
      await mongoose.connection.collection('users').deleteMany({
        email: testUser.email
      });
      console.log('\nTest user cleaned up');
      
      // Close the MongoDB connection
      await mongoose.connection.close();
      console.log('MongoDB connection closed');
    }
    
    process.exit(0);
  }
};

runTests();

================
File: backend/tests/test-neon-connection.js
================
// backend/tests/test-neon-connection.js
require('dotenv').config();
const db = require('../config/postgresql');

const testNeonConnection = async () => {
  try {
    // Test basic connection
    const result = await db.query('SELECT NOW() as current_time');
    console.log('Connection successful!');
    console.log('Current server time:', result.rows[0].current_time);
    
    // Test creating a simple table
    await db.query(`
      CREATE TABLE IF NOT EXISTS connection_test (
        id SERIAL PRIMARY KEY,
        test_message TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('Test table created successfully');
    
    // Insert a test record
    const insertResult = await db.query(
      'INSERT INTO connection_test (test_message) VALUES ($1) RETURNING *',
      ['Connection test from job application platform']
    );
    console.log('Test record inserted:', insertResult.rows[0]);
    
    // Query the test record
    const records = await db.query('SELECT * FROM connection_test');
    console.log('All test records:', records.rows);
    
    console.log('Neon PostgreSQL connection test completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('Neon PostgreSQL connection test failed:', error);
    console.error('Error details:', error.message);
    process.exit(1);
  }
};

testNeonConnection();

================
File: backend/utils/email-templates.js
================
// backend/utils/email-templates.js
/**
 * Generate verification email HTML
 * @param {string} firstName User's first name
 * @param {string} verificationUrl Verification URL
 * @returns {string} HTML email content
 */
exports.generateVerificationEmail = (firstName, verificationUrl) => {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Verify Your Email</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .logo {
            text-align: center;
            margin-bottom: 20px;
          }
          .container {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
          }
          .button {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 20px 0;
          }
          .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #777;
            text-align: center;
          }
        </style>
      </head>
      <body>
        <div class="logo">
          <h2>Job Application Platform</h2>
        </div>
        <div class="container">
          <h2>Hello ${firstName},</h2>
          <p>Welcome to the Job Application Platform! Please verify your email address to get started.</p>
          <p>This link will expire in 24 hours.</p>
          <a href="${verificationUrl}" class="button">Verify Email Address</a>
          <p>If you didn't create an account, you can safely ignore this email.</p>
        </div>
        <div class="footer">
          <p>&copy; 2025 Job Application Platform. All rights reserved.</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </body>
      </html>
    `;
  };
  
  /**
   * Generate password reset email HTML
   * @param {string} firstName User's first name
   * @param {string} resetUrl Reset URL
   * @returns {string} HTML email content
   */
  exports.generatePasswordResetEmail = (firstName, resetUrl) => {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Reset Your Password</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .logo {
            text-align: center;
            margin-bottom: 20px;
          }
          .container {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
          }
          .button {
            display: inline-block;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 20px 0;
          }
          .footer {
            margin-top: 20px;
            font-size: 12px;
            color: #777;
            text-align: center;
          }
        </style>
      </head>
      <body>
        <div class="logo">
          <h2>Job Application Platform</h2>
        </div>
        <div class="container">
          <h2>Hello ${firstName},</h2>
          <p>We received a request to reset your password. Click the button below to create a new password.</p>
          <p>This link will expire in 10 minutes.</p>
          <a href="${resetUrl}" class="button">Reset Password</a>
          <p>If you didn't request a password reset, you can safely ignore this email.</p>
        </div>
        <div class="footer">
          <p>&copy; 2025 Job Application Platform. All rights reserved.</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </body>
      </html>
    `;
  };

================
File: backend/utils/jobBoardPatterns.js
================
// utils/jobBoardPatterns.js
/**
 * Pattern-based scraping for career pages
 * Covers ~35% additional companies with predictable patterns
 */

// Common CSS selectors for job listings
const CSS_SELECTORS = {
  jobLinks: [
    'a[href*="/job/"]',
    'a[href*="/jobs/"]',
    'a[href*="/career/"]',
    'a[href*="/careers/"]',
    'a[href*="/position/"]',
    'a[href*="/opening/"]',
    '.job-link a',
    '.job-item a',
    '.position-link a',
    '.career-item a',
    '[data-job-id] a',
    '.job-listing a',
    '.job-card a',
    '.position-card a'
  ],
  
  jobTitles: [
    '.job-title',
    '.position-title',
    '.role-title',
    'h2 a',
    'h3 a',
    '[data-job-title]',
    '.title a',
    '.job-name',
    '.position-name'
  ],
  
  jobDescriptions: [
    '.job-description',
    '.position-description',
    '.job-content',
    '.job-details',
    '.position-details',
    '.description',
    '.content'
  ],
  
  locations: [
    '.job-location',
    '.position-location',
    '.location',
    '[data-location]',
    '.office-location',
    '.work-location'
  ],
  
  departments: [
    '.job-department',
    '.department',
    '.team',
    '[data-department]',
    '.job-category',
    '.category'
  ]
};

// URL patterns for different career page types
const URL_PATTERNS = {
  workday: {
    basePattern: /myworkdayjobs\.com\/([^\/]+)/,
    jobUrlPattern: /myworkdayjobs\.com\/[^\/]+\/job\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://${company}.myworkdayjobs.com/${company}/search`,
    selectors: {
      jobLinks: 'a[data-automation-id="jobTitle"]',
      jobTitles: '[data-automation-id="jobTitle"]',
      locations: '[data-automation-id="locations"]',
      departments: '[data-automation-id="jobCategory"]'
    }
  },
  
  bamboohr: {
    basePattern: /bamboohr\.com\/jobs\/([^\/]+)/,
    jobUrlPattern: /bamboohr\.com\/jobs\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://${company}.bamboohr.com/jobs/`,
    selectors: {
      jobLinks: '.job-board-item a',
      jobTitles: '.job-board-item h3',
      locations: '.job-board-item .location',
      departments: '.job-board-item .department'
    }
  },
  
  smartrecruiters: {
    basePattern: /jobs\.smartrecruiters\.com\/([^\/]+)/,
    jobUrlPattern: /jobs\.smartrecruiters\.com\/[^\/]+\/([^\/]+)/,
    searchEndpoint: (company) => `https://jobs.smartrecruiters.com/${company}`,
    selectors: {
      jobLinks: '.opening-job a',
      jobTitles: '.opening-job h4',
      locations: '.opening-job .location',
      departments: '.opening-job .department'
    }
  },
  
  jobvite: {
    basePattern: /jobs\.jobvite\.com\/([^\/]+)/,
    jobUrlPattern: /jobs\.jobvite\.com\/[^\/]+\/job\/([^\/]+)/,
    searchEndpoint: (company) => `https://jobs.jobvite.com/${company}/search?c=&l=&t=&s=`,
    selectors: {
      jobLinks: '.jv-job-list-item a',
      jobTitles: '.jv-job-list-item h3',
      locations: '.jv-job-list-item .location',
      departments: '.jv-job-list-item .department'
    }
  },
  
  icims: {
    basePattern: /careers\.icims\.com\/jobs\/([^\/]+)/,
    jobUrlPattern: /careers\.icims\.com\/jobs\/\d+\/job/,
    searchEndpoint: (company) => `https://careers.icims.com/jobs/search?ss=1&searchCompany=${company}`,
    selectors: {
      jobLinks: '.iCIMS_JobsTable a',
      jobTitles: '.iCIMS_JobsTable .title',
      locations: '.iCIMS_JobsTable .location',
      departments: '.iCIMS_JobsTable .department'
    }
  },
  
  // Custom corporate career pages
  custom: {
    commonSelectors: CSS_SELECTORS,
    urlIndicators: [
      '/careers',
      '/jobs',
      '/work-with-us',
      '/join-us',
      '/employment',
      '/opportunities'
    ]
  }
};

// Common job title patterns for filtering
const JOB_TITLE_PATTERNS = {
  software: [
    'software engineer',
    'software developer',
    'full stack',
    'frontend',
    'backend',
    'web developer',
    'mobile developer',
    'devops',
    'sre'
  ],
  
  product: [
    'product manager',
    'product owner',
    'product marketing',
    'technical product',
    'senior product'
  ],
  
  data: [
    'data scientist',
    'data engineer',
    'data analyst',
    'machine learning',
    'ai engineer',
    'analytics'
  ],
  
  design: [
    'ux designer',
    'ui designer',
    'product designer',
    'graphic designer',
    'visual designer'
  ],
  
  marketing: [
    'marketing manager',
    'growth marketing',
    'digital marketing',
    'content marketing',
    'marketing specialist'
  ],
  
  sales: [
    'sales manager',
    'account executive',
    'sales development',
    'business development',
    'sales representative'
  ]
};

// Experience level indicators
const EXPERIENCE_INDICATORS = {
  entry: [
    'entry level',
    'junior',
    'associate',
    'new grad',
    'graduate',
    '0-2 years',
    'early career'
  ],
  
  mid: [
    'mid level',
    'intermediate',
    '3-5 years',
    '2-4 years',
    'experienced'
  ],
  
  senior: [
    'senior',
    'sr.',
    'lead',
    'principal',
    '5+ years',
    '7+ years',
    'expert'
  ],
  
  executive: [
    'director',
    'manager',
    'head of',
    'vp',
    'vice president',
    'chief',
    'executive'
  ]
};

/**
 * Detect career page type from URL
 * @param {string} url - Career page URL
 * @returns {Object} { type, pattern, config }
 */
exports.detectCareerPageType = (url) => {
  const lowerUrl = url.toLowerCase();
  
  // Check for known ATS patterns
  for (const [type, config] of Object.entries(URL_PATTERNS)) {
    if (type === 'custom') continue;
    
    if (config.basePattern && config.basePattern.test(url)) {
      return {
        type,
        pattern: config.basePattern,
        config,
        isKnownATS: true
      };
    }
  }
  
  // Check for custom corporate career pages
  const hasCareerIndicator = URL_PATTERNS.custom.urlIndicators.some(
    indicator => lowerUrl.includes(indicator)
  );
  
  if (hasCareerIndicator) {
    return {
      type: 'custom',
      pattern: null,
      config: URL_PATTERNS.custom,
      isKnownATS: false
    };
  }
  
  return {
    type: 'unknown',
    pattern: null,
    config: null,
    isKnownATS: false
  };
};

/**
 * Extract company identifier from URL
 * @param {string} url - Career page URL
 * @param {string} type - Career page type
 * @returns {string} Company identifier
 */
exports.extractCompanyId = (url, type) => {
  const config = URL_PATTERNS[type];
  if (!config || !config.basePattern) {
    return null;
  }
  
  const match = url.match(config.basePattern);
  return match ? match[1] : null;
};

/**
 * Get CSS selectors for a career page type
 * @param {string} type - Career page type
 * @returns {Object} CSS selectors object
 */
exports.getSelectorsForType = (type) => {
  const config = URL_PATTERNS[type];
  if (!config) {
    return CSS_SELECTORS;
  }
  
  return config.selectors || CSS_SELECTORS;
};

/**
 * Generate search endpoint URL for known ATS
 * @param {string} type - ATS type
 * @param {string} companyId - Company identifier
 * @returns {string} Search endpoint URL
 */
exports.generateSearchEndpoint = (type, companyId) => {
  const config = URL_PATTERNS[type];
  if (!config || !config.searchEndpoint) {
    return null;
  }
  
  return config.searchEndpoint(companyId);
};

/**
 * Check if job title matches career profile
 * @param {string} jobTitle - Job title to check
 * @param {Object} careerProfile - User career profile
 * @returns {Object} { isMatch, score, matchedCategory }
 */
exports.isJobTitleRelevant = (jobTitle, careerProfile) => {
  if (!jobTitle || !careerProfile) {
    return { isMatch: false, score: 0, matchedCategory: null };
  }
  
  const lowerTitle = jobTitle.toLowerCase();
  
  // Check against target job titles from career profile
  if (careerProfile.jobTitles) {
    for (const targetTitle of careerProfile.jobTitles) {
      const targetLower = targetTitle.toLowerCase();
      const titleWords = targetLower.split(' ');
      
      // Calculate word overlap
      const matchedWords = titleWords.filter(word => 
        word.length > 2 && lowerTitle.includes(word)
      );
      
      if (matchedWords.length > 0) {
        const score = Math.round((matchedWords.length / titleWords.length) * 100);
        if (score >= 50) { // At least 50% word match
          return { 
            isMatch: true, 
            score, 
            matchedCategory: 'direct_title_match',
            matchedTitle: targetTitle
          };
        }
      }
    }
  }
  
  // Check against job category patterns
  for (const [category, patterns] of Object.entries(JOB_TITLE_PATTERNS)) {
    for (const pattern of patterns) {
      if (lowerTitle.includes(pattern)) {
        // Check if this category aligns with user's experience
        if (careerProfile.industries && 
            careerProfile.industries.some(industry => 
              industry.toLowerCase().includes(category) ||
              category === 'software' && industry.toLowerCase().includes('tech')
            )) {
          return { 
            isMatch: true, 
            score: 70, 
            matchedCategory: category,
            matchedPattern: pattern
          };
        }
      }
    }
  }
  
  return { isMatch: false, score: 0, matchedCategory: null };
};

/**
 * Check if experience level matches career profile
 * @param {string} jobTitle - Job title or description
 * @param {Object} careerProfile - User career profile
 * @returns {boolean} Whether experience level is appropriate
 */
exports.isExperienceLevelAppropriate = (jobTitle, careerProfile) => {
  if (!jobTitle || !careerProfile || !careerProfile.experienceLevel) {
    return true; // Default to include if unclear
  }
  
  const lowerTitle = jobTitle.toLowerCase();
  const userLevel = careerProfile.experienceLevel.toLowerCase();
  
  // Check for experience indicators in job title
  for (const [level, indicators] of Object.entries(EXPERIENCE_INDICATORS)) {
    if (indicators.some(indicator => lowerTitle.includes(indicator))) {
      // Match experience levels appropriately
      if (userLevel === 'entry' && ['mid', 'senior', 'executive'].includes(level)) {
        return false; // Entry level shouldn't see senior roles
      }
      if (userLevel === 'mid' && level === 'executive') {
        return false; // Mid level shouldn't see executive roles
      }
      break;
    }
  }
  
  return true;
};

/**
 * Validate if URL is a direct job posting
 * @param {string} url - URL to validate
 * @returns {boolean} Whether URL points to a specific job
 */
exports.isDirectJobPostingUrl = (url) => {
  if (!url || typeof url !== 'string') {
    return false;
  }
  
  const lowerUrl = url.toLowerCase();
  
  // Invalid patterns (job boards, not specific jobs)
  const invalidPatterns = [
    /\/embed\/job_board/,
    /job_board\?for=/,
    /\/careers\/?$/,
    /\/jobs\/?$/,
    /\/careers\/all/,
    /\/careers\/search/,
    /\/careers\/openings\/?$/
  ];
  
  if (invalidPatterns.some(pattern => pattern.test(url))) {
    return false;
  }
  
  // Valid job posting patterns
  const validPatterns = [
    /\/job\/\d+/,
    /\/jobs\/\d+/,
    /\/careers\/\d+/,
    /\/positions\/\d+/,
    /\/job-description\/?\?.*id=/,
    /\/careers\/job\/[^\/]+/,
    /\/jobs\/[^\/\?]+$/,
    /\/position\/[^\/\?]+$/,
    /\/openings\/[^\/\?]+$/,
    /job-id[=_-]\d+/,
    /position[_-]id[=_-]\d+/,
    /req[_-]?\d+/
  ];
  
  return validPatterns.some(pattern => pattern.test(url));
};

/**
 * Get all supported ATS types
 * @returns {Array} List of supported ATS types
 */
exports.getSupportedATS = () => {
  return Object.keys(URL_PATTERNS).filter(type => type !== 'custom');
};

/**
 * Get job category from title
 * @param {string} jobTitle - Job title
 * @returns {string} Job category
 */
exports.getJobCategory = (jobTitle) => {
  if (!jobTitle) return 'general';
  
  const lowerTitle = jobTitle.toLowerCase();
  
  for (const [category, patterns] of Object.entries(JOB_TITLE_PATTERNS)) {
    if (patterns.some(pattern => lowerTitle.includes(pattern))) {
      return category;
    }
  }
  
  return 'general';
};

/**
 * Extract job metadata from HTML content
 * @param {Object} $ - Cheerio instance
 * @param {Object} selectors - CSS selectors to use
 * @returns {Array} Array of job metadata objects
 */
exports.extractJobMetadata = ($, selectors) => {
  const jobs = [];
  
  try {
    // Find all job links
    const jobElements = $(selectors.jobLinks.join(', '));
    
    jobElements.each((index, element) => {
      const $job = $(element);
      
      // Extract basic information
      const title = extractText($job, selectors.jobTitles, $);
      const location = extractText($job, selectors.locations, $);
      const department = extractText($job, selectors.departments, $);
      const url = $job.attr('href');
      
      if (title && url) {
        jobs.push({
          title: title.trim(),
          location: location ? location.trim() : 'Not specified',
          department: department ? department.trim() : null,
          url: url.startsWith('http') ? url : null,
          relativeUrl: url.startsWith('/') ? url : null,
          extractedAt: new Date()
        });
      }
    });
    
    console.log(`📊 Extracted ${jobs.length} job metadata entries`);
    return jobs;
    
  } catch (error) {
    console.error('Error extracting job metadata:', error);
    return [];
  }
};

/**
 * Helper function to extract text using multiple selectors
 * @param {Object} $element - Cheerio element
 * @param {Array} selectors - Array of CSS selectors to try
 * @param {Object} $ - Cheerio instance
 * @returns {string} Extracted text
 */
function extractText($element, selectors, $) {
  // First try within the element itself
  for (const selector of selectors) {
    const text = $element.find(selector).first().text();
    if (text && text.trim()) {
      return text.trim();
    }
  }
  
  // Then try the element's own text if it matches patterns
  const elementText = $element.text();
  if (elementText && elementText.trim()) {
    return elementText.trim();
  }
  
  // Finally try parent elements
  const $parent = $element.parent();
  for (const selector of selectors) {
    const text = $parent.find(selector).first().text();
    if (text && text.trim()) {
      return text.trim();
    }
  }
  
  return null;
}

/**
 * Build absolute URLs from relative URLs
 * @param {string} baseUrl - Base URL of the career page
 * @param {Array} jobs - Array of job objects with relative URLs
 * @returns {Array} Jobs with absolute URLs
 */
exports.buildAbsoluteUrls = (baseUrl, jobs) => {
  const base = new URL(baseUrl);
  
  return jobs.map(job => {
    if (job.url) {
      // Already absolute URL
      return job;
    }
    
    if (job.relativeUrl) {
      try {
        const absoluteUrl = new URL(job.relativeUrl, base).href;
        return {
          ...job,
          url: absoluteUrl,
          directJobUrl: absoluteUrl
        };
      } catch (error) {
        console.error(`Error building absolute URL for ${job.relativeUrl}:`, error);
        return job;
      }
    }
    
    return job;
  });
};

/**
 * Filter jobs by relevance and experience level
 * @param {Array} jobs - Array of job objects
 * @param {Object} careerProfile - User career profile
 * @returns {Array} Filtered jobs
 */
exports.filterJobsByRelevance = (jobs, careerProfile) => {
  if (!jobs || !Array.isArray(jobs)) {
    return [];
  }
  
  return jobs
    .map(job => {
      // Check title relevance
      const titleRelevance = this.isJobTitleRelevant(job.title, careerProfile);
      const experienceAppropriate = this.isExperienceLevelAppropriate(job.title, careerProfile);
      
      return {
        ...job,
        isRelevant: titleRelevance.isMatch && experienceAppropriate,
        matchScore: titleRelevance.score,
        matchReason: titleRelevance.matchedCategory,
        category: this.getJobCategory(job.title)
      };
    })
    .filter(job => job.isRelevant)
    .sort((a, b) => b.matchScore - a.matchScore) // Sort by match score
    .slice(0, 15); // Limit to top 15 matches
};

/**
 * Common patterns for job posting URLs
 */
exports.JOB_URL_PATTERNS = {
  withId: [
    /\/job\/(\d+)/,
    /\/jobs\/(\d+)/,
    /\/position\/(\d+)/,
    /\/careers\/(\d+)/,
    /job-id[=_-](\d+)/,
    /position[_-]id[=_-](\d+)/,
    /req[_-]?(\d+)/
  ],
  
  withSlug: [
    /\/job\/([^\/\?]+)/,
    /\/jobs\/([^\/\?]+)/,
    /\/position\/([^\/\?]+)/,
    /\/careers\/job\/([^\/\?]+)/,
    /\/openings\/([^\/\?]+)/
  ]
};

/**
 * Extract job ID from URL
 * @param {string} url - Job URL
 * @returns {string} Job ID or slug
 */
exports.extractJobId = (url) => {
  if (!url) return null;
  
  // Try ID patterns first
  for (const pattern of this.JOB_URL_PATTERNS.withId) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  
  // Try slug patterns
  for (const pattern of this.JOB_URL_PATTERNS.withSlug) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  
  return null;
};

// Export all patterns for external use
exports.CSS_SELECTORS = CSS_SELECTORS;
exports.URL_PATTERNS = URL_PATTERNS;
exports.JOB_TITLE_PATTERNS = JOB_TITLE_PATTERNS;
exports.EXPERIENCE_INDICATORS = EXPERIENCE_INDICATORS;

================
File: backend/utils/recruiter-importer.js
================
// backend/utils/recruiter-importer.js
const fs = require('fs');
const path = require('path');
const { parse } = require('csv-parse/sync');
const db = require('../config/postgresql');

/**
 * Import recruiters from a CSV/TSV file
 * @param {string} filePath Path to the CSV/TSV file
 * @param {boolean} isHeaderRow Whether the first row is a header row
 * @param {string} delimiter Delimiter used in the file
 */
const importRecruitersFromFile = async (filePath, isHeaderRow = true, delimiter = '\t') => {
  try {
    console.log(`Importing recruiters from ${filePath}...`);
    
    // Read the file
    const fileContent = fs.readFileSync(filePath, 'utf8');
    
    // Parse the CSV/TSV content
    const records = parse(fileContent, {
      delimiter,
      columns: isHeaderRow,
      skip_empty_lines: true,
      trim: true
    });
    
    console.log(`Found ${records.length} records to import`);
    
    // Process each record
    for (const record of records) {
      await processRecruiterRecord(record);
    }
    
    console.log('Recruiter import completed successfully');
  } catch (error) {
    console.error('Error importing recruiters:', error);
    throw error;
  }
};

/**
 * Process a single recruiter record and insert into database
 * @param {Object} record The recruiter record from the CSV/TSV
 */
const processRecruiterRecord = async (record) => {
  try {
    // 1. First, process the company information
    const companyId = await processCompany(record);
    
    // 2. Process the location information
    const locationId = await processLocation(record);
    
    // 3. Process industry information
    const industryId = await processIndustry(record);
    
    // 4. Create or update the recruiter record
    await processRecruiter(record, companyId, locationId, industryId);
    
  } catch (error) {
    console.error(`Error processing recruiter record:`, error);
    console.error('Problematic record:', record);
  }
};

/**
 * Process company data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The company ID
 */
const processCompany = async (record) => {
  try {
    // Check if company already exists
    const companyResult = await db.query(
      'SELECT id FROM companies WHERE name = $1',
      [record['Company Name']]
    );
    
    if (companyResult.rows.length > 0) {
      return companyResult.rows[0].id;
    }
    
    // Insert new company
    const result = await db.query(
      `INSERT INTO companies (
        name, website, employee_count, employee_range, founded_year,
        phone, revenue, revenue_range, ownership_type, business_model,
        stock_ticker, zoominfo_id, zoominfo_url, linkedin_url,
        facebook_url, twitter_url, email_domain
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
      RETURNING id`,
      [
        record['Company Name'] || null,
        record['Website'] || null,
        parseInt(record['Employees']) || null,
        record['Employee Range'] || null,
        parseInt(record['Founded Year']) || null,
        record['Company HQ Phone'] || null,
        parseInt(record['Revenue (in 000s USD)']) || null,
        record['Revenue Range (in USD)'] || null,
        record['Ownership Type'] || null,
        record['Business Model'] || null,
        record['Ticker'] || null,
        record['ZoomInfo Company ID'] || null,
        record['ZoomInfo Company Profile URL'] || null,
        record['LinkedIn Company Profile URL'] || null,
        record['Facebook Company Profile URL'] || null,
        record['Twitter Company Profile URL'] || null,
        record['Email Domain'] || null
      ]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing company:', error);
    throw error;
  }
};

/**
 * Process location data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The location ID
 */
const processLocation = async (record) => {
  try {
    // Check for person location first, then company location
    let street = record['Person Street'] || record['Company Street Address'] || null;
    let city = record['Person City'] || record['Company City'] || null;
    let state = record['Person State'] || record['Company State'] || null;
    let postalCode = record['Person Zip Code'] || record['Company Zip Code'] || null;
    let country = record['Country'] || record['Company Country'] || null;
    
    if (!city && !state && !country) {
      return null;
    }
    
    // Check if location already exists
    const locationResult = await db.query(
      'SELECT id FROM locations WHERE city = $1 AND state = $2 AND country = $3 AND (postal_code = $4 OR $4 IS NULL)',
      [city, state, country, postalCode]
    );
    
    if (locationResult.rows.length > 0) {
      return locationResult.rows[0].id;
    }
    
    // Create full address
    let fullAddress = '';
    if (street) fullAddress += street + ', ';
    if (city) fullAddress += city + ', ';
    if (state) fullAddress += state + ', ';
    if (postalCode) fullAddress += postalCode + ', ';
    if (country) fullAddress += country;
    
    // Insert new location
    const result = await db.query(
      `INSERT INTO locations (
        street_address, city, state, postal_code, country, full_address
      ) VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id`,
      [street, city, state, postalCode, country, fullAddress]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing location:', error);
    throw error;
  }
};

/**
 * Process industry data from the record
 * @param {Object} record The recruiter record
 * @returns {number} The industry ID
 */
const processIndustry = async (record) => {
  try {
    const primaryIndustry = record['Primary Industry'] || null;
    
    if (!primaryIndustry) {
      return null;
    }
    
    // Check if industry already exists
    const industryResult = await db.query(
      'SELECT id FROM industries WHERE name = $1',
      [primaryIndustry]
    );
    
    if (industryResult.rows.length > 0) {
      return industryResult.rows[0].id;
    }
    
    // Parse SIC and NAICS codes
    const sicCodes = [];
    if (record['SIC Code 1']) sicCodes.push(record['SIC Code 1']);
    if (record['SIC Code 2']) sicCodes.push(record['SIC Code 2']);
    if (record['SIC Codes']) {
      const additionalSIC = record['SIC Codes'].split(';').filter(Boolean);
      sicCodes.push(...additionalSIC);
    }
    
    const naicsCodes = [];
    if (record['NAICS Code 1']) naicsCodes.push(record['NAICS Code 1']);
    if (record['NAICS Code 2']) naicsCodes.push(record['NAICS Code 2']);
    if (record['NAICS Codes']) {
      const additionalNAICS = record['NAICS Codes'].split(';').filter(Boolean);
      naicsCodes.push(...additionalNAICS);
    }
    
    // Insert new industry
    const result = await db.query(
      `INSERT INTO industries (
        name, description, primary_category, sub_category, 
        hierarchical_category, sic_codes, naics_codes
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING id`,
      [
        primaryIndustry,
        null,
        record['Primary Industry'] || null,
        record['Primary Sub-Industry'] || null,
        record['Industry Hierarchical Category'] || null,
        sicCodes.length > 0 ? sicCodes : null,
        naicsCodes.length > 0 ? naicsCodes : null
      ]
    );
    
    return result.rows[0].id;
  } catch (error) {
    console.error('Error processing industry:', error);
    throw error;
  }
};

/**
 * Process recruiter data from the record
 * @param {Object} record The recruiter record
 * @param {number} companyId The company ID
 * @param {number} locationId The location ID
 * @param {number} industryId The industry ID
 */
const processRecruiter = async (record, companyId, locationId, industryId) => {
  try {
    // Check if recruiter already exists by email
    const email = record['Email Address'] || null;
    
    if (email) {
      const recruiterResult = await db.query(
        'SELECT id FROM recruiters WHERE email = $1',
        [email]
      );
      
      if (recruiterResult.rows.length > 0) {
        const recruiterId = recruiterResult.rows[0].id;
        await updateRecruiter(recruiterId, record, companyId, locationId, industryId);
        return;
      }
    }
    
    // Parse job start date
    let jobStartDate = null;
    if (record['Job Start Date']) {
      try {
        jobStartDate = new Date(record['Job Start Date']);
      } catch (e) {
        console.warn(`Could not parse job start date: ${record['Job Start Date']}`);
      }
    }
    
    // Parse notice provided date
    let noticeProvidedDate = null;
    if (record['Notice Provided Date']) {
      try {
        noticeProvidedDate = new Date(record['Notice Provided Date']);
      } catch (e) {
        console.warn(`Could not parse notice provided date: ${record['Notice Provided Date']}`);
      }
    }
    
    // Insert new recruiter
    const result = await db.query(
      `INSERT INTO recruiters (
        first_name, middle_name, last_name, salutation, suffix,
        email, email_domain, supplemental_email, direct_phone, mobile_phone,
        current_company_id, title, job_title_hierarchy_level, management_level,
        job_start_date, job_function, department, company_division,
        education_level, accuracy_score, accuracy_grade, zoominfo_url,
        linkedin_url, notice_provided_date, location_id, industry_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
        $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
      )
      RETURNING id`,
      [
        record['First Name'] || null,
        record['Middle Name'] || null,
        record['Last Name'] || null,
        record['Salutation'] || null,
        record['Suffix'] || null,
        email,
        record['Email Domain'] || null,
        record['Supplemental Email'] || null,
        record['Direct Phone Number'] || null,
        record['Mobile phone'] || null,
        companyId,
        record['Job Title'] || null,
        parseInt(record['Job Title Hierarchy Level']) || null,
        record['Management Level'] || null,
        jobStartDate,
        record['Job Function'] || null,
        record['Department'] || null,
        record['Company Division Name'] || null,
        record['Highest Level of Education'] || null,
        parseInt(record['Contact Accuracy Score']) || null,
        record['Contact Accuracy Grade'] || null,
        record['ZoomInfo Contact Profile URL'] || null,
        record['LinkedIn Contact Profile URL'] || null,
        noticeProvidedDate,
        locationId,
        industryId
      ]
    );
    
    console.log(`Created recruiter: ${record['First Name']} ${record['Last Name']}`);
  } catch (error) {
    console.error('Error processing recruiter:', error);
    throw error;
  }
};

/**
 * Update an existing recruiter
 * @param {number} recruiterId The recruiter ID
 * @param {Object} record The recruiter record
 * @param {number} companyId The company ID
 * @param {number} locationId The location ID
 * @param {number} industryId The industry ID
 */
const updateRecruiter = async (recruiterId, record, companyId, locationId, industryId) => {
  try {
    // Parse job start date
    let jobStartDate = null;
    if (record['Job Start Date']) {
      try {
        jobStartDate = new Date(record['Job Start Date']);
      } catch (e) {
        console.warn(`Could not parse job start date: ${record['Job Start Date']}`);
      }
    }
    
    // Parse notice provided date
    let noticeProvidedDate = null;
    if (record['Notice Provided Date']) {
      try {
        noticeProvidedDate = new Date(record['Notice Provided Date']);
      } catch (e) {
        console.warn(`Could not parse notice provided date: ${record['Notice Provided Date']}`);
      }
    }
    
    await db.query(
      `UPDATE recruiters SET
        first_name = $1, middle_name = $2, last_name = $3, salutation = $4,
        suffix = $5, email_domain = $6, supplemental_email = $7,
        direct_phone = $8, mobile_phone = $9, current_company_id = $10,
        title = $11, job_title_hierarchy_level = $12, management_level = $13,
        job_start_date = $14, job_function = $15, department = $16,
        company_division = $17, education_level = $18, accuracy_score = $19,
        accuracy_grade = $20, zoominfo_url = $21, linkedin_url = $22,
        notice_provided_date = $23, location_id = $24, industry_id = $25,
        updated_at = NOW()
      WHERE id = $26`,
      [
        record['First Name'] || null,
        record['Middle Name'] || null,
        record['Last Name'] || null,
        record['Salutation'] || null,
        record['Suffix'] || null,
        record['Email Domain'] || null,
        record['Supplemental Email'] || null,
        record['Direct Phone Number'] || null,
        record['Mobile phone'] || null,
        companyId,
        record['Job Title'] || null,
        parseInt(record['Job Title Hierarchy Level']) || null,
        record['Management Level'] || null,
        jobStartDate,
        record['Job Function'] || null,
        record['Department'] || null,
        record['Company Division Name'] || null,
        record['Highest Level of Education'] || null,
        parseInt(record['Contact Accuracy Score']) || null,
        record['Contact Accuracy Grade'] || null,
        record['ZoomInfo Contact Profile URL'] || null,
        record['LinkedIn Contact Profile URL'] || null,
        noticeProvidedDate,
        locationId,
        industryId,
        recruiterId
      ]
    );
    
    console.log(`Updated recruiter: ${record['First Name']} ${record['Last Name']}`);
  } catch (error) {
    console.error('Error updating recruiter:', error);
    throw error;
  }
};

module.exports = { importRecruitersFromFile };

================
File: backend/utils/send-email.js
================
// backend/utils/send-email.js
const nodemailer = require('nodemailer');

/**
 * Send email using nodemailer with Gmail
 * @param {Object} options Email options (to, subject, text, html)
 */
const sendEmail = async (options) => {
  try {
    // Create a transporter using Gmail
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD // App Password, not regular password
      }
    });
    
    // Define mail options
    const mailOptions = {
      from: `${process.env.FROM_NAME} <${process.env.GMAIL_USER}>`,
      to: options.email,
      subject: options.subject,
      html: options.html
    };
    
    // Send mail
    const info = await transporter.sendMail(mailOptions);
    console.log('Email sent: %s', info.messageId);
    return info;
  } catch (error) {
    console.error('Error sending email:', error);
    throw error;
  }
};

module.exports = sendEmail;

================
File: backend/verify-controller.js
================
// backend/verify-controller.js - Test if the controller changes are working
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function verifyControllerFix() {
  try {
    console.log('🧪 VERIFYING CONTROLLER FIX');
    console.log('=============================');

    const userId = '68161f881e8f530e01bef870';
    const query = 'Sarah';

    // Test the EXACT query from the controller (with COALESCE)
    console.log('\n1️⃣ TESTING MAIN QUERY WITH COALESCE:');
    
    let sqlQuery = `
      SELECT 
        r.id,
        r.first_name,
        r.last_name,
        r.email,
        r.direct_phone,
        r.mobile_phone,
        r.title,
        r.linkedin_url,
        r.experience_years,
        r.last_active_date,
        r.rating,
        r.current_company_id,
        r.industry_id,
        r.location_id,
        -- Check if user has contacted this recruiter
        oh.last_contact_date,
        oh.status as outreach_status
      FROM recruiters r
      LEFT JOIN outreach_history oh ON (r.id = oh.recruiter_id AND oh.mongodb_user_id = $1)
      WHERE r.is_active = true
    `;

    const queryParams = [userId.toString()];
    let paramIndex = 2;

    // Add the search filter exactly as it should be in the controller
    sqlQuery += ` AND (
      COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '') ILIKE $${paramIndex} OR
      COALESCE(r.title, '') ILIKE $${paramIndex}
    )`;
    queryParams.push(`%${query}%`);
    paramIndex++;

    // Add ordering
    sqlQuery += ` ORDER BY r.first_name ASC`;
    
    // Add pagination
    sqlQuery += ` LIMIT 20 OFFSET 0`;

    console.log('📝 Executing exact controller query...');
    console.log('📋 Params:', queryParams);
    
    const result = await pool.query(sqlQuery, queryParams);
    console.log(`📊 Main query result: ${result.rows.length} rows`);

    if (result.rows.length > 0) {
      console.log('✅ SUCCESS: Main query found results!');
      result.rows.slice(0, 3).forEach((row, index) => {
        console.log(`   ${index + 1}. ${row.first_name} ${row.last_name} - ${row.title}`);
      });
    } else {
      console.log('❌ PROBLEM: Main query returned 0 results');
    }

    // Test the count query
    console.log('\n2️⃣ TESTING COUNT QUERY:');
    const countQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
      AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE '%${query}%' OR COALESCE(r.title, '') ILIKE '%${query}%')
    `;

    console.log('📝 Count query:', countQuery);
    const countResult = await pool.query(countQuery);
    console.log(`📊 Count query result: ${countResult.rows[0].count}`);

    // Test without COALESCE to see the difference
    console.log('\n3️⃣ TESTING WITHOUT COALESCE (old version):');
    const oldQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((r.first_name || ' ' || r.last_name) ILIKE '%${query}%' OR r.title ILIKE '%${query}%')
    `;

    try {
      const oldResult = await pool.query(oldQuery);
      console.log(`📊 Old query result: ${oldResult.rows[0].count}`);
    } catch (error) {
      console.log(`❌ Old query failed: ${error.message}`);
    }

    // Test if there's an issue with the outreach_history join
    console.log('\n4️⃣ TESTING WITHOUT OUTREACH JOIN:');
    const noJoinQuery = `
      SELECT COUNT(*) as count
      FROM recruiters r
      WHERE r.is_active = true
        AND ((COALESCE(r.first_name, '') || ' ' || COALESCE(r.last_name, '')) ILIKE '%${query}%' OR COALESCE(r.title, '') ILIKE '%${query}%')
    `;

    const noJoinResult = await pool.query(noJoinQuery);
    console.log(`📊 No join query result: ${noJoinResult.rows[0].count}`);

    console.log('\n✅ Verification complete!');

  } catch (error) {
    console.error('❌ Verification failed:', error);
  } finally {
    await pool.end();
  }
}

verifyControllerFix();

================
File: frontend/.env.example
================
# API Configuration
REACT_APP_API_URL=https://your-backend-service-url.up.railway.app/api

# App Configuration
REACT_APP_NAME=Auto-Job.ai
REACT_APP_VERSION=1.0.0
REACT_APP_ENVIRONMENT=production

# Feature Flags
REACT_APP_ENABLE_DEBUG=false

================
File: frontend/.prettierignore
================
/build/

================
File: frontend/.prettierrc
================
{
  "printWidth": 100,
  "semi": false,
  "singleQuote": true,
  "trailingComma": "es5",
  "arrowParens": "avoid"
}

================
File: frontend/jsconfig.json
================
{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "*": ["node_modules/*", "src/*"]
    },
    "module": "esnext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noEmit": true,
    "skipLibCheck": true,
    "strict": false,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noFallthroughCasesInSwitch": true,
    "allowJs": true,
    "checkJs": false,
    "jsx": "react-jsx"
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "build"
  ]
}

================
File: frontend/package.json
================
{
  "name": "auto-job-frontend",
  "version": "1.0.0",
  "private": true,
  "homepage": ".",
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^5.17.1",
    "@mui/material": "^5.17.1",
    "apexcharts": "^4.7.0",
    "axios": "^1.9.0",
    "react": "^18.2.0",
    "react-apexcharts": "^1.7.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.15.0",
    "react-scripts": "5.0.1",
    "recharts": "^2.15.3",
    "serve": "^14.2.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "DISABLE_ESLINT_PLUGIN=true react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "serve": "serve -s build -p $PORT"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=8.0.0"
  }
}

================
File: frontend/public/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <title></title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

================
File: frontend/public/manifest.json
================
{
  "short_name": "",
  "name": "",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: frontend/public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: frontend/README.md
================
This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `yarn start`

Runs the app in the development mode.<br />
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br />
You will also see any lint errors in the console.

### `yarn test`

Launches the test runner in the interactive watch mode.<br />
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `yarn build`

Builds the app for production to the `build` folder.<br />
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br />
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `yarn eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting

### Analyzing the Bundle Size

This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size

### Making a Progressive Web App

This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app

### Advanced Configuration

This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration

### Deployment

This section has moved here: https://facebook.github.io/create-react-app/docs/deployment

### `yarn build` fails to minify

This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify

================
File: frontend/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-12T01:59:43.924Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
.prettierignore
.prettierrc
jsconfig.json
package.json
public/index.html
public/manifest.json
public/robots.txt
README.md
src/App.js
src/components/assistant/AiAssistantWidget.js
src/components/assistant/GlobalAiAssistant.js
src/components/auth/EmailVerification.js
src/components/auth/ForgotPassword.js
src/components/auth/Login.js
src/components/auth/ProtectedRoute.js
src/components/auth/Register.js
src/components/auth/ResetPassword.js
src/components/common/AutoJobLogo.js
src/components/common/GlobalSearch.js
src/components/common/PageHeader.js
src/components/Dashboard.js
src/components/jobs/AiSearchesPage.js
src/components/jobs/components/AiReasoningLogs.js
src/components/jobs/components/AiSearchDeleteDialog.js
src/components/jobs/components/AiSearchDetailsDialog.js
src/components/jobs/components/AiSearchExpandableRow.js
src/components/jobs/components/AiSearchSummaryCards.js
src/components/jobs/components/AiSearchTable.js
src/components/jobs/components/AiSearchTableRow.js
src/components/jobs/components/EmptySearchState.js
src/components/jobs/components/EnhancedCircularProgress.js
src/components/jobs/components/JobAnalysisStatus.js
src/components/jobs/components/JobDetailsCard.js
src/components/jobs/components/JobHeader.js
src/components/jobs/components/MatchAnalysisCard.js
src/components/jobs/components/SkillChip.js
src/components/jobs/FindJobsDialog.js
src/components/jobs/hooks/useAiSearches.js
src/components/jobs/hooks/useJobAnalysis.js
src/components/jobs/JobCreateDialog.js
src/components/jobs/JobDetail.js
src/components/jobs/JobsPage.js
src/components/jobs/ResumeTailoring.js
src/components/jobs/tabs/AnalysisTab.js
src/components/jobs/tabs/ContentTab.js
src/components/jobs/tabs/OverviewTab.js
src/components/jobs/utils/searchUtils.js
src/components/layout/Header.js
src/components/layout/MainLayout.js
src/components/layout/Sidebar.js
src/components/recruiters/OutreachComposer.js
src/components/recruiters/OutreachTracker.js
src/components/recruiters/RecruiterDetails.js
src/components/recruiters/RecruiterList.js
src/components/recruiters/RecruiterPage.js
src/components/recruiters/RecruiterSearch.js
src/components/resumes/components/AiEditingToolbar.js
src/components/resumes/components/BeforeAfterComparison.js
src/components/resumes/components/ProcessingView.js
src/components/resumes/components/ScoreDisplay.js
src/components/resumes/components/TabPanel.js
src/components/resumes/hooks/useAiIntegration.js
src/components/resumes/hooks/useResumeData.js
src/components/resumes/ResumeDetail.js
src/components/resumes/ResumesPage.js
src/components/resumes/ResumeUploadDialog.js
src/components/resumes/ResumeWithAssistant.js
src/components/resumes/tabs/AnalysisTab.js
src/components/resumes/tabs/ContentTab.js
src/components/resumes/tabs/OverviewTab.js
src/components/resumes/utils/resumeHelpers.js
src/components/search/SearchPage.js
src/components/SettingsPage.js
src/context/AiAssistantContext.js
src/context/AuthContext.js
src/hooks/useSearch.js
src/index.css
src/index.js
src/ThemeProvider.js
src/utils/assistantService.js
src/utils/axios.js
src/utils/jobService.js
src/utils/recruiterService.js
src/utils/resumeService.js
src/utils/searchService.js
src/utils/settingsService.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

================
File: .prettierignore
================
/build/

================
File: .prettierrc
================
{
  "printWidth": 100,
  "semi": false,
  "singleQuote": true,
  "trailingComma": "es5",
  "arrowParens": "avoid"
}

================
File: jsconfig.json
================
{
  "compilerOptions": {
    "baseUrl": "src",
    "incremental": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "build", "functions"]
}

================
File: package.json
================
{
  "name": "job-app-mui",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^5.17.1",
    "@mui/material": "^5.17.1",
    "apexcharts": "^4.7.0",
    "axios": "^1.9.0",
    "react": "^19.1.0",
    "react-apexcharts": "^1.7.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.5.3",
    "react-scripts": "5.0.1",
    "recharts": "^2.15.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

================
File: public/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <title></title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

================
File: public/manifest.json
================
{
  "short_name": "",
  "name": "",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: README.md
================
This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `yarn start`

Runs the app in the development mode.<br />
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br />
You will also see any lint errors in the console.

### `yarn test`

Launches the test runner in the interactive watch mode.<br />
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `yarn build`

Builds the app for production to the `build` folder.<br />
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br />
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `yarn eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting

### Analyzing the Bundle Size

This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size

### Making a Progressive Web App

This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app

### Advanced Configuration

This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration

### Deployment

This section has moved here: https://facebook.github.io/create-react-app/docs/deployment

### `yarn build` fails to minify

This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify

================
File: src/App.js
================
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import { AiAssistantProvider } from './context/AiAssistantContext';
import ThemeProvider from './ThemeProvider';
import ProtectedRoute from './components/auth/ProtectedRoute';
import Login from './components/auth/Login';
import Register from './components/auth/Register';
import ForgotPassword from './components/auth/ForgotPassword';
import ResetPassword from './components/auth/ResetPassword';
import EmailVerification from './components/auth/EmailVerification';
import Dashboard from './components/Dashboard';
import ResumesPage from './components/resumes/ResumesPage';
import ResumeUpload from './components/resumes/ResumeUploadDialog';
import ResumeDetail from './components/resumes/ResumeDetail';

// Import job-related components
import JobsPage from './components/jobs/JobsPage';
import JobDetail from './components/jobs/JobDetail';
import ResumeTailoring from './components/jobs/ResumeTailoring';
import AiSearchesPage from './components/jobs/AiSearchesPage';

// Import recruiter-related components
import RecruiterPage from './components/recruiters/RecruiterPage';
import RecruiterDetails from './components/recruiters/RecruiterDetails';
import OutreachTracker from './components/recruiters/OutreachTracker';

// Import Settings
import SettingsPage from './components/SettingsPage';

// Import Global AI Assistant
import GlobalAiAssistant from './components/assistant/GlobalAiAssistant';

// Placeholder components for other sections
const ApplicationsPage = () => <div>Applications Page (Coming Soon)</div>;
const AISettingsPage = () => <div>AI Settings Page (Coming Soon)</div>;

function App() {
  return (
    <ThemeProvider>
      <AuthProvider>
        <Router>
          <Routes>
            {/* Public Auth Routes - NO AiAssistantProvider wrapper */}
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            <Route path="/forgot-password" element={<ForgotPassword />} />
            <Route path="/reset-password/:token" element={<ResetPassword />} />
            <Route path="/verify-email/:token" element={<EmailVerification />} />
            
            {/* Protected Routes - WITH AiAssistantProvider wrapper */}
            <Route
              path="/dashboard"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <Dashboard />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Resume Routes */}
            <Route
              path="/resumes"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumesPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/resumes/upload"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumeUpload />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/resumes/:id"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumeDetail />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Job Routes */}
            <Route
              path="/jobs"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <JobsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/jobs/:id"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <JobDetail />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/jobs/:jobId/tailor/:resumeId"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumeTailoring />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/jobs/ai-searches"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <AiSearchesPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Recruiter Routes */}
            <Route
              path="/recruiters"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <RecruiterPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/recruiters/:id"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <RecruiterDetails />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/recruiters/outreach"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <OutreachTracker />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Settings Route */}
            <Route
              path="/settings"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <SettingsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Other Routes */}
            <Route
              path="/applications"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ApplicationsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/ai-settings"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <AISettingsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Default Route */}
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
          </Routes>
        </Router>
      </AuthProvider>
    </ThemeProvider>
  );
}

export default App;

================
File: src/components/assistant/AiAssistantWidget.js
================
// src/components/assistant/AiAssistantWidget.js - UPDATED VERSION
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Fab,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Paper,
  TextField,
  IconButton,
  Typography,
  Avatar,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  Chip,
  Button,
  Divider,
  Slide,
  CircularProgress,
  Tooltip,
  useTheme,
  alpha
} from '@mui/material';
import {
  SmartToy as RobotIcon,
  Send as SendIcon,
  Close as CloseIcon,
  Fullscreen as FullscreenIcon,
  FullscreenExit as FullscreenExitIcon,
  Refresh as RefreshIcon,
  Description as ResumeIcon,
  Edit as EditIcon,
  AutoFixHigh as SuggestionIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
// import assistantService from '../../utils/assistantService'; // Comment out for now

const Transition = React.forwardRef(function Transition(props, ref) {
  return <Slide direction="up" ref={ref} {...props} />;
});

const AiAssistantWidget = ({ 
  resumeId = null, 
  resumeData = null, 
  onResumeUpdate = null,
  position = { bottom: 24, right: 24 },
  // NEW: Accept external open control
  externalOpen = null,
  onExternalClose = null,
  showFab = true // NEW: Control whether to show the floating button
}) => {
  const theme = useTheme();
  const { currentUser } = useAuth();
  
  // Use external open state if provided, otherwise use internal state
  const [internalOpen, setInternalOpen] = useState(false);
  const isOpen = externalOpen !== null ? externalOpen : internalOpen;
  
  const [fullscreen, setFullscreen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState('');
  const [loading, setLoading] = useState(false);
  const [sessionId, setSessionId] = useState(null);
  const [assistantTyping, setAssistantTyping] = useState(false);
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);

  // Initialize chat session
  useEffect(() => {
    if (isOpen && !sessionId) {
      initializeSession();
    }
  }, [isOpen]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const initializeSession = async () => {
    try {
      console.log('🤖 Initializing AI Assistant session...');
      
      // For now, just add a welcome message without backend call
      const welcomeMessage = {
        id: Date.now(),
        type: 'assistant',
        content: `Hi! I'm AJ, your AI career assistant. I'm here to help you optimize your resume and discuss your career goals. ${resumeData ? `I can see you're working on your resume.` : ''} How can I help you today?`,
        timestamp: new Date(),
        suggestions: [
          'Analyze my resume strengths',
          'Suggest improvements', 
          'Help with job descriptions',
          'Review my experience section'
        ]
      };
      
      setMessages([welcomeMessage]);
      setSessionId('test-session-' + Date.now()); // Temporary session ID
      
      console.log('✅ AI Assistant session initialized (test mode)');
    } catch (error) {
      console.error('❌ Failed to initialize assistant session:', error);
    }
  };

  const handleSendMessage = async () => {
    if (!inputMessage.trim() || loading) return;

    const userMessage = {
      id: Date.now(),
      type: 'user', 
      content: inputMessage.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    const currentMessage = inputMessage.trim();
    setInputMessage('');
    setLoading(true);
    setAssistantTyping(true);

    try {
      // Simulate AI response for testing
      setTimeout(() => {
        const aiResponse = {
          id: Date.now() + 1,
          type: 'assistant',
          content: `Thanks for your message: "${currentMessage}". This is a test response! In the full version, I'll analyze your resume and provide specific suggestions based on your content.`,
          timestamp: new Date(),
          suggestions: ['Tell me more', 'Analyze my experience', 'Help with skills section']
        };

        setMessages(prev => [...prev, aiResponse]);
        setLoading(false);
        setAssistantTyping(false);
      }, 1500);

    } catch (error) {
      console.error('❌ Failed to send message:', error);
      const errorMessage = {
        id: Date.now() + 1,
        type: 'assistant',
        content: 'I apologize, but I encountered an error. This is test mode - the full AI backend is not yet connected.',
        timestamp: new Date(),
        isError: true
      };
      setMessages(prev => [...prev, errorMessage]);
      setLoading(false);
      setAssistantTyping(false);
    }
  };

  const handleSuggestionClick = (suggestion) => {
    setInputMessage(suggestion);
    inputRef.current?.focus();
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleOpen = () => {
    console.log('🤖 Opening AI Assistant...');
    if (externalOpen !== null) {
      // If externally controlled, don't set internal state
      return;
    }
    setInternalOpen(true);
  };

  const handleClose = () => {
    console.log('🤖 Closing AI Assistant...');
    setFullscreen(false);
    
    if (onExternalClose) {
      onExternalClose();
    } else {
      setInternalOpen(false);
    }
  };

  const toggleFullscreen = () => {
    setFullscreen(!fullscreen);
  };

  const MessageBubble = ({ message }) => {
    const isUser = message.type === 'user';
    const isError = message.isError;

    return (
      <ListItem 
        sx={{ 
          flexDirection: isUser ? 'row-reverse' : 'row',
          alignItems: 'flex-start',
          pb: 2
        }}
      >
        <ListItemAvatar sx={{ 
          minWidth: 'auto', 
          ml: isUser ? 1 : 0, 
          mr: isUser ? 0 : 1 
        }}>
          <Avatar 
            sx={{ 
              width: 32, 
              height: 32,
              bgcolor: isUser ? theme.palette.primary.main : theme.palette.secondary.main,
              fontSize: '0.875rem'
            }}
          >
            {isUser ? currentUser?.firstName?.[0] || 'U' : <RobotIcon fontSize="small" />}
          </Avatar>
        </ListItemAvatar>
        
        <Box sx={{ 
          maxWidth: '75%',
          display: 'flex',
          flexDirection: 'column',
          alignItems: isUser ? 'flex-end' : 'flex-start'
        }}>
          <Paper
            elevation={1}
            sx={{
              p: 2,
              bgcolor: isError 
                ? alpha(theme.palette.error.main, 0.1)
                : isUser 
                  ? theme.palette.primary.main 
                  : theme.palette.background.paper,
              color: isUser ? 'white' : 'inherit',
              borderRadius: 2,
              border: isError ? `1px solid ${theme.palette.error.main}` : 'none'
            }}
          >
            <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>
              {message.content}
            </Typography>
          </Paper>

          {/* Suggestions */}
          {message.suggestions && (
            <Box sx={{ mt: 1, display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
              {message.suggestions.map((suggestion, index) => (
                <Chip
                  key={index}
                  label={suggestion}
                  size="small"
                  variant="outlined"
                  onClick={() => handleSuggestionClick(suggestion)}
                  sx={{ 
                    cursor: 'pointer',
                    '&:hover': {
                      bgcolor: alpha(theme.palette.primary.main, 0.1)
                    }
                  }}
                />
              ))}
            </Box>
          )}

          {/* Resume Edit Actions */}
          {message.resumeEdits && (
            <Box sx={{ mt: 1 }}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 1.5, 
                  bgcolor: alpha(theme.palette.success.main, 0.1),
                  border: `1px solid ${alpha(theme.palette.success.main, 0.3)}`
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                  <EditIcon fontSize="small" color="success" sx={{ mr: 1 }} />
                  <Typography variant="body2" fontWeight={500}>
                    Resume Updates Available
                  </Typography>
                </Box>
                <Button
                  size="small"
                  variant="contained"
                  color="success"
                  onClick={() => onResumeUpdate && onResumeUpdate(message.resumeEdits)}
                  startIcon={<SuggestionIcon />}
                >
                  Apply Changes
                </Button>
              </Paper>
            </Box>
          )}

          <Typography 
            variant="caption" 
            color="text.secondary" 
            sx={{ mt: 0.5 }}
          >
            {message.timestamp.toLocaleTimeString()}
          </Typography>
        </Box>
      </ListItem>
    );
  };

  const ChatInterface = () => (
    <Box sx={{ 
      height: fullscreen ? '100vh' : 500,
      display: 'flex',
      flexDirection: 'column'
    }}>
      {/* Header */}
      <Box sx={{ 
        p: 2, 
        borderBottom: `1px solid ${theme.palette.divider}`,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        bgcolor: alpha(theme.palette.primary.main, 0.05)
      }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Avatar sx={{ 
            width: 40, 
            height: 40, 
            bgcolor: theme.palette.secondary.main, 
            mr: 2 
          }}>
            <RobotIcon />
          </Avatar>
          <Box>
            <Typography variant="h6" fontWeight={600}>
              AJ Assistant
            </Typography>
            <Typography variant="caption" color="text.secondary">
              {resumeData ? `Working on your resume` : 'Ready to help with your resume'}
            </Typography>
          </Box>
        </Box>
        
        <Box>
          <Tooltip title={fullscreen ? 'Exit Fullscreen' : 'Fullscreen'}>
            <IconButton onClick={toggleFullscreen}>
              {fullscreen ? <FullscreenExitIcon /> : <FullscreenIcon />}
            </IconButton>
          </Tooltip>
          <Tooltip title="Close">
            <IconButton onClick={handleClose}>
              <CloseIcon />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>

      {/* Messages */}
      <Box sx={{ 
        flex: 1, 
        overflow: 'auto',
        bgcolor: alpha(theme.palette.background.default, 0.3)
      }}>
        <List sx={{ p: 1 }}>
          {messages.map((message) => (
            <MessageBubble key={message.id} message={message} />
          ))}
          
          {/* Typing indicator */}
          {assistantTyping && (
            <ListItem>
              <ListItemAvatar>
                <Avatar sx={{ 
                  width: 32, 
                  height: 32, 
                  bgcolor: theme.palette.secondary.main 
                }}>
                  <RobotIcon fontSize="small" />
                </Avatar>
              </ListItemAvatar>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <CircularProgress size={16} sx={{ mr: 1 }} />
                <Typography variant="body2" color="text.secondary">
                  AJ is thinking...
                </Typography>
              </Box>
            </ListItem>
          )}
          
          <div ref={messagesEndRef} />
        </List>
      </Box>

      {/* Input */}
      <Box sx={{ 
        p: 2, 
        borderTop: `1px solid ${theme.palette.divider}`,
        bgcolor: theme.palette.background.paper
      }}>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <TextField
            ref={inputRef}
            fullWidth
            multiline
            maxRows={3}
            placeholder="Ask AJ about your resume, career goals, or get editing suggestions..."
            value={inputMessage}
            onChange={(e) => setInputMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            disabled={loading}
            variant="outlined"
            size="small"
            sx={{
              '& .MuiOutlinedInput-root': {
                borderRadius: 3
              }
            }}
          />
          <IconButton
            onClick={handleSendMessage}
            disabled={!inputMessage.trim() || loading}
            color="primary"
            sx={{
              bgcolor: theme.palette.primary.main,
              color: 'white',
              '&:hover': {
                bgcolor: theme.palette.primary.dark
              },
              '&:disabled': {
                bgcolor: theme.palette.action.disabled
              }
            }}
          >
            {loading ? <CircularProgress size={20} color="inherit" /> : <SendIcon />}
          </IconButton>
        </Box>
        
        {resumeData && (
          <Box sx={{ mt: 1, display: 'flex', alignItems: 'center' }}>
            <ResumeIcon fontSize="small" color="primary" sx={{ mr: 1 }} />
            <Typography variant="caption" color="text.secondary">
              Context: Resume with {resumeData.experience?.length || 0} jobs
            </Typography>
          </Box>
        )}
      </Box>
    </Box>
  );

  return (
    <>
      {/* Floating Action Button - Only show if not externally controlled */}
      {showFab && externalOpen === null && (
        <Tooltip title="Chat with AJ - Your AI Career Assistant">
          <Fab
            color="secondary"
            onClick={handleOpen}
            sx={{
              position: 'fixed',
              bottom: position.bottom,
              right: position.right,
              zIndex: 1000,
              background: `linear-gradient(45deg, ${theme.palette.secondary.main} 30%, ${theme.palette.secondary.light} 90%)`,
              boxShadow: '0 8px 24px rgba(0, 196, 180, 0.3)',
              '&:hover': {
                background: `linear-gradient(45deg, ${theme.palette.secondary.dark} 30%, ${theme.palette.secondary.main} 90%)`,
                transform: 'scale(1.05)',
              },
              transition: 'all 0.2s ease-in-out'
            }}
          >
            <RobotIcon sx={{ fontSize: 28 }} />
          </Fab>
        </Tooltip>
      )}

      {/* Chat Dialog */}
      <Dialog
        open={isOpen}
        onClose={handleClose}
        TransitionComponent={Transition}
        maxWidth={fullscreen ? false : 'sm'}
        fullWidth
        fullScreen={fullscreen}
        PaperProps={{
          sx: {
            borderRadius: fullscreen ? 0 : 2,
            overflow: 'hidden'
          }
        }}
      >
        <ChatInterface />
      </Dialog>
    </>
  );
};

export default AiAssistantWidget;

================
File: src/components/assistant/GlobalAiAssistant.js
================
// src/components/assistant/GlobalAiAssistant.js - COMPLETE FIXED VERSION
import React, { useState, useRef, useEffect, useCallback } from 'react';
import {
  Box,
  Paper,
  Typography,
  TextField,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Fade,
  Tooltip,
  CircularProgress,
  Alert,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  List,
  ListItem,
  ListItemButton,
  ListItemText,
  ListItemIcon,
  Menu,
  MenuItem,
  Tab,
  Tabs,
  InputAdornment,
  LinearProgress,
  Card,
  CardContent
} from '@mui/material';
import {
  Send as SendIcon,
  Close as CloseIcon,
  ExpandLess as ChevronUpIcon,
  ExpandMore as ChevronDownIcon,
  Add as AddIcon,
  Search as SearchIcon,
  History as HistoryIcon,
  Memory as MemoryIcon,
  MoreVert as MoreVertIcon,
  Chat as ChatIcon,
  Psychology as PsychologyIcon,
  Delete as DeleteIcon,
  Star as StarIcon,
  StarBorder as StarBorderIcon,
  PushPin as PushPinIcon,
  AutoFixHigh as AutoFixHighIcon,
  Description as DescriptionIcon,
  TrendingUp as TrendingUpIcon,
  CheckCircle as CheckCircleIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import { useAiAssistant } from '../../context/AiAssistantContext';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';
import assistantService from '../../utils/assistantService';

// Resume Editing Intelligence Hook
const useResumeEditingIntelligence = (currentContext, sendMessage) => {
  const [isProcessingResumeEdit, setIsProcessingResumeEdit] = useState(false);
  const [lastResumeAction, setLastResumeAction] = useState(null);

  const detectResumeEditIntent = useCallback((message) => {
    const resumeEditKeywords = [
      'update', 'improve', 'enhance', 'optimize', 'fix', 'add', 'remove', 'change',
      'work experience', 'skills', 'summary', 'education', 'ats', 'keywords',
      'bullet points', 'achievements', 'quantify', 'metrics', 'action verbs'
    ];

    const messageLower = message.toLowerCase();
    return resumeEditKeywords.some(keyword => messageLower.includes(keyword)) &&
           currentContext?.page === 'resumes' &&
           currentContext?.currentResume;
  }, [currentContext]);

  const processResumeEdit = useCallback(async (message) => {
    if (!detectResumeEditIntent(message)) {
      return sendMessage(message);
    }

    setIsProcessingResumeEdit(true);
    setLastResumeAction('Analyzing resume editing request...');

    try {
      // Enhanced message with resume context
      const enhancedMessage = `[RESUME EDITING REQUEST]
Resume: ${currentContext.currentResume.name}
Current Score: ${currentContext.currentResume.score || 'Unknown'}
Request: ${message}

Please provide specific improvements and apply them to the resume.`;

      // Send with special resume editing flag
      const response = await sendMessage(enhancedMessage, { 
        isResumeEdit: true,
        resumeId: currentContext.currentResume.id 
      });

      // Simulate resume update processing
      setLastResumeAction('Applying changes to resume...');
      
      // Dispatch resume update event
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('resumeUpdated', {
          detail: { 
            resumeId: currentContext.currentResume.id, 
            message: '✅ Resume successfully updated!',
            changes: message
          }
        }));
        setLastResumeAction('Resume updated successfully!');
        setTimeout(() => setLastResumeAction(null), 3000);
      }, 2000);

      return response;
    } catch (error) {
      console.error('Resume editing failed:', error);
      setLastResumeAction('❌ Resume editing failed. Please try again.');
      setTimeout(() => setLastResumeAction(null), 3000);
      throw error;
    } finally {
      setIsProcessingResumeEdit(false);
    }
  }, [detectResumeEditIntent, sendMessage, currentContext]);

  return {
    detectResumeEditIntent,
    processResumeEdit,
    isProcessingResumeEdit,
    lastResumeAction
  };
};

// Context-Aware Suggestions Component
const ContextualSuggestionsBar = ({ currentContext, onSuggestionClick }) => {
  const theme = useTheme();
  
  const getContextualSuggestions = () => {
    if (currentContext?.page === 'resumes' && currentContext?.currentResume) {
      const score = currentContext.currentResume.score || 0;
      return [
        score < 70 ? 'Improve my resume score' : 'Optimize for ATS',
        'Update work experience section',
        'Add missing skills',
        'Enhance summary section',
        'Check keyword optimization'
      ];
    }
    
    if (currentContext?.page === 'jobs' && currentContext?.currentJob) {
      return [
        'Match my resume to this job',
        'What skills am I missing?',
        'Write a cover letter',
        'How can I improve my match?',
        'Tailor my resume for this role'
      ];
    }

    return [
      'Help improve my resume',
      'Find job opportunities',
      'Career guidance',
      'Review my progress',
      'What should I focus on?'
    ];
  };

  const suggestions = getContextualSuggestions();

  if (!suggestions.length) return null;

  return (
    <Box sx={{ 
      p: 1.5, 
      borderBottom: `1px solid ${theme.palette.divider}`,
      bgcolor: theme.palette.background.default
    }}>
      <Typography variant="caption" color="text.secondary" sx={{ mb: 1, display: 'block' }}>
        Quick Actions:
      </Typography>
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
        {suggestions.slice(0, 3).map((suggestion, index) => (
          <Chip
            key={index}
            label={suggestion}
            size="small"
            variant="outlined"
            clickable
            onClick={() => onSuggestionClick(suggestion)}
            sx={{
              fontSize: '0.7rem',
              height: 22,
              '&:hover': {
                bgcolor: theme.palette.primary.light,
                color: 'white'
              }
            }}
          />
        ))}
      </Box>
    </Box>
  );
};

// Resume Context Display Component
const ResumeContextDisplay = ({ currentContext }) => {
  const theme = useTheme();

  if (!currentContext?.currentResume) return null;

  const getScoreColor = (score) => {
    if (score >= 80) return theme.palette.success.main;
    if (score >= 60) return theme.palette.warning.main;
    return theme.palette.error.main;
  };

  const score = currentContext.currentResume.score || 0;

  return (
    <Card sx={{ m: 1.5, mb: 0 }}>
      <CardContent sx={{ p: 1.5, '&:last-child': { pb: 1.5 } }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <DescriptionIcon fontSize="small" color="primary" />
          <Box sx={{ flex: 1, minWidth: 0 }}>
            <Typography variant="caption" color="text.secondary">
              Working on:
            </Typography>
            <Typography variant="body2" fontWeight={600} noWrap>
              {currentContext.currentResume.name}
            </Typography>
          </Box>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
            <Typography variant="caption" color="text.secondary">
              Score:
            </Typography>
            <Typography 
              variant="caption" 
              fontWeight={600}
              sx={{ color: getScoreColor(score) }}
            >
              {score}%
            </Typography>
          </Box>
        </Box>
        {score < 80 && (
          <Box sx={{ mt: 1, display: 'flex', alignItems: 'center', gap: 0.5 }}>
            <TrendingUpIcon fontSize="small" color="warning" />
            <Typography variant="caption" color="warning.main">
              Room for improvement
            </Typography>
         </Box>
       )}
     </CardContent>
   </Card>
 );
};

// Enhanced Message Component with Resume Actions
const EnhancedMessage = ({ message, theme, currentUser, onSuggestionClick, isResumeContext }) => {
 const formatTime = (timestamp) => {
   if (!timestamp) return '';
   
   try {
     const date = new Date(timestamp);
     
     if (isNaN(date.getTime())) {
       return '';
     }
     
     const now = new Date();
     const diffMs = now.getTime() - date.getTime();
     const diffMins = Math.floor(diffMs / (1000 * 60));
     const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
     const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
     
     if (diffMins < 1) return 'just now';
     if (diffMins < 60) return `${diffMins}m ago`;
     if (diffHours < 24) return `${diffHours}h ago`;
     if (diffDays < 7) return `${diffDays}d ago`;
     
     return date.toLocaleTimeString([], { 
       hour: '2-digit', 
       minute: '2-digit',
       month: 'short',
       day: 'numeric'
     });
   } catch (error) {
     console.warn('Error formatting timestamp:', error);
     return '';
   }
 };

 return (
   <Box
     sx={{
       display: 'flex',
       flexDirection: message.type === 'user' ? 'row-reverse' : 'row',
       alignItems: 'flex-start',
       gap: 1.5
     }}
   >
     {/* Avatar */}
     <Avatar
       sx={{
         width: 32,
         height: 32,
         fontSize: '0.875rem',
         fontWeight: 600,
         ...(message.type === 'user' ? {
           bgcolor: theme.palette.primary.main,
           color: 'white'
         } : {
           bgcolor: 'transparent',
           p: 0.5
         })
       }}
     >
       {message.type === 'user' ? (
         `${currentUser?.firstName?.[0] || 'U'}${currentUser?.lastName?.[0] || ''}`
       ) : (
         <AutoJobLogo 
           variant="icon-only" 
           size="small"
         />
       )}
     </Avatar>

     {/* Message Content */}
     <Box
       sx={{
         maxWidth: '75%',
         display: 'flex',
         flexDirection: 'column',
         gap: 1
       }}
     >
       <Paper
         elevation={message.type === 'user' ? 2 : 1}
         sx={{
           p: 1.5,
           borderRadius: 2,
           ...(message.type === 'user' ? {
             bgcolor: theme.palette.primary.main,
             color: 'white',
             borderBottomRightRadius: 4
           } : {
             bgcolor: message.isError ? theme.palette.error.light :
                      isResumeContext ? theme.palette.primary.light + '10' :
                      '#f5f5f5',
             color: message.isError ? theme.palette.error.contrastText :
                    theme.palette.text.primary,
             borderBottomLeftRadius: 4,
             border: isResumeContext ? `1px solid ${theme.palette.primary.light}30` : 'none'
           })
         }}
       >
            <Typography 
            variant="body2" 
            sx={{ whiteSpace: 'pre-wrap' }}
            dangerouslySetInnerHTML={{ 
                __html: assistantService.formatResponse(message.content)
            }}
            />
       </Paper>

       {/* Enhanced Suggestions with Icons */}
       {message.suggestions && message.suggestions.length > 0 && (
         <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 0.5 }}>
           {message.suggestions.map((suggestion, index) => {
             const isResumeAction = suggestion.toLowerCase().includes('resume') || 
                                  suggestion.toLowerCase().includes('improve') ||
                                  suggestion.toLowerCase().includes('optimize');
             
             return (
               <Chip
                 key={index}
                 label={suggestion}
                 size="small"
                 variant="outlined"
                 clickable
                 icon={isResumeAction ? <AutoFixHighIcon sx={{ fontSize: '0.75rem' }} /> : undefined}
                 onClick={() => onSuggestionClick(suggestion)}
                 sx={{
                   fontSize: '0.75rem',
                   height: 24,
                   '&:hover': {
                     bgcolor: isResumeAction ? theme.palette.secondary.light : theme.palette.primary.light,
                     color: 'white'
                   },
                   ...(isResumeAction && {
                     borderColor: theme.palette.secondary.main,
                     color: theme.palette.secondary.main
                   })
                 }}
               />
             );
           })}
         </Box>
       )}

       {/* Resume Action Indicators */}
       {message.metadata?.isResumeEdit && (
         <Box sx={{ 
           mt: 0.5, 
           p: 1, 
           bgcolor: theme.palette.success.light + '20',
           borderRadius: 1,
           border: `1px solid ${theme.palette.success.light}50`,
           display: 'flex',
           alignItems: 'center',
           gap: 0.5
         }}>
           <CheckCircleIcon fontSize="small" color="success" />
           <Typography variant="caption" color="success.main" fontWeight={600}>
             Resume Action Applied
           </Typography>
         </Box>
       )}

       {/* Timestamp */}
       <Typography
         variant="caption"
         sx={{
           color: theme.palette.text.disabled,
           fontSize: '0.6875rem',
           textAlign: message.type === 'user' ? 'right' : 'left'
         }}
       >
         {formatTime(message.timestamp)}
       </Typography>
     </Box>
   </Box>
 );
};

// Conversation List Component
const ConversationList = ({ 
 conversations, 
 currentConversationId, 
 onSelectConversation, 
 onCreateNew,
 onUpdateConversation,
 onDeleteConversation,
 loading 
}) => {
 const theme = useTheme();
 const [menuAnchor, setMenuAnchor] = useState(null);
 const [selectedConv, setSelectedConv] = useState(null);

 const handleMenuClick = (event, conversation) => {
   event.stopPropagation();
   setMenuAnchor(event.currentTarget);
   setSelectedConv(conversation);
 };

 const handleMenuClose = () => {
   setMenuAnchor(null);
   setSelectedConv(null);
 };

 const handleStarToggle = async () => {
   if (selectedConv) {
     await onUpdateConversation(selectedConv._id, { starred: !selectedConv.starred });
   }
   handleMenuClose();
 };

 const handlePinToggle = async () => {
   if (selectedConv) {
     await onUpdateConversation(selectedConv._id, { pinned: !selectedConv.pinned });
   }
   handleMenuClose();
 };

 const handleDelete = async () => {
   if (selectedConv && window.confirm('Are you sure you want to delete this conversation?')) {
     await onDeleteConversation(selectedConv._id);
   }
   handleMenuClose();
 };

 if (loading) {
   return (
     <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
       <CircularProgress size={24} />
     </Box>
   );
 }

 return (
   <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
     {/* Header */}
     <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}` }}>
       <Button
         fullWidth
         variant="outlined"
         startIcon={<AddIcon />}
         onClick={onCreateNew}
         sx={{ mb: 1 }}
       >
         New Conversation
       </Button>
     </Box>

     {/* Conversations */}
     <List sx={{ flex: 1, overflow: 'auto', py: 0 }}>
       {conversations.map((conversation) => (
         <ListItem key={conversation._id} disablePadding>
           <ListItemButton
             selected={conversation._id === currentConversationId}
             onClick={() => onSelectConversation(conversation._id)}
             sx={{
               py: 1.5,
               px: 2,
               borderRadius: 1,
               mx: 1,
               my: 0.5,
               '&.Mui-selected': {
                 bgcolor: theme.palette.primary.light + '20',
                 '&:hover': {
                   bgcolor: theme.palette.primary.light + '30',
                 }
               }
             }}
           >
             <ListItemIcon sx={{ minWidth: 36 }}>
               <ChatIcon 
                 fontSize="small" 
                 color={conversation._id === currentConversationId ? 'primary' : 'action'}
               />
             </ListItemIcon>
             
             <ListItemText
               primary={conversation.title}
               secondary={
                 <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mt: 0.5 }}>
                   <Typography variant="caption" color="text.secondary">
                     {conversation.messageCount || 0} messages
                   </Typography>
                   {conversation.starred && <StarIcon sx={{ fontSize: 12, color: 'gold' }} />}
                   {conversation.pinned && <PushPinIcon sx={{ fontSize: 12, color: theme.palette.primary.main }} />}
                 </Box>
               }
               primaryTypographyProps={{
                 variant: 'body2',
                 noWrap: true,
                 fontWeight: conversation._id === currentConversationId ? 600 : 400
               }}
             />
             
             <IconButton
               size="small"
               onClick={(e) => handleMenuClick(e, conversation)}
               sx={{ opacity: 0.7, '&:hover': { opacity: 1 } }}
             >
               <MoreVertIcon fontSize="small" />
             </IconButton>
           </ListItemButton>
         </ListItem>
       ))}
       
       {conversations.length === 0 && (
         <Box sx={{ p: 3, textAlign: 'center' }}>
           <Typography variant="body2" color="text.secondary">
             No conversations yet. Start a new one!
           </Typography>
         </Box>
       )}
     </List>

     {/* Context Menu */}
     <Menu
       anchorEl={menuAnchor}
       open={Boolean(menuAnchor)}
       onClose={handleMenuClose}
     >
       <MenuItem onClick={handleStarToggle}>
         {selectedConv?.starred ? <StarIcon fontSize="small" /> : <StarBorderIcon fontSize="small" />}
         <Typography sx={{ ml: 1 }}>
           {selectedConv?.starred ? 'Unstar' : 'Star'}
         </Typography>
       </MenuItem>
       <MenuItem onClick={handlePinToggle}>
         <PushPinIcon fontSize="small" />
         <Typography sx={{ ml: 1 }}>
           {selectedConv?.pinned ? 'Unpin' : 'Pin'}
         </Typography>
       </MenuItem>
       <Divider />
       <MenuItem onClick={handleDelete} sx={{ color: 'error.main' }}>
         <DeleteIcon fontSize="small" />
         <Typography sx={{ ml: 1 }}>Delete</Typography>
       </MenuItem>
     </Menu>
   </Box>
 );
};

// Main Enhanced AI Assistant Component
const GlobalAiAssistant = () => {
 const theme = useTheme();
 const { currentUser } = useAuth();
 const {
   // State
   isOpen,
   setIsOpen,
   isMinimized,
   setIsMinimized,
   
   // Conversations
   conversations,
   currentConversationId,
   currentConversation,
   conversationsLoading,
   
   // Memory & Context
   userMemories,
   memoryInsights,
   currentContext,
   contextualSuggestions,
   suggestionsCount,
   
   // Chat
   messages,
   isLoading,
   error,
   
   // Actions
   sendMessage,
   createNewConversation,
   switchConversation,
   updateConversation,
   deleteConversation,
   handleSuggestionClick,
   searchEverything,
   
   // Utilities
   setError,
   setMessages,
    setCurrentConversationId,    // ADD THIS
    setCurrentConversation       // ADD THIS
   
 } = useAiAssistant();

 // Local state
 const [inputValue, setInputValue] = useState('');
 const [showSidebar, setShowSidebar] = useState(false);
 const [activeTab, setActiveTab] = useState(0);
 const [searchQuery, setSearchQuery] = useState('');
 const [searchResults, setSearchResults] = useState(null);
 const [searchLoading, setSearchLoading] = useState(false);

 // Resume editing intelligence
 const {
   detectResumeEditIntent,
   processResumeEdit,
   isProcessingResumeEdit,
   lastResumeAction
 } = useResumeEditingIntelligence(currentContext, sendMessage);

 // Refs
 const messagesEndRef = useRef(null);
 const inputRef = useRef(null);
 const searchTimeoutRef = useRef(null);

 // Auto-scroll to bottom of messages
 const scrollToBottom = () => {
   messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
 };

 useEffect(() => {
   scrollToBottom();
 }, [messages]);

 // Enhanced close handler
const handleClose = useCallback(() => {
  setActiveTab(0);
  setSearchQuery('');
  setSearchResults(null);
  setSearchLoading(false);
  setInputValue('');
  setShowSidebar(false);
  setError(null);
  
  if (searchTimeoutRef.current) {
    clearTimeout(searchTimeoutRef.current);
  }
  
  // 🔥 PROPER CONVERSATION RESET: Use the context functions properly
  setMessages([]);
  setCurrentConversationId(null);
  setCurrentConversation(null);
  
  setIsOpen(false);
  
  console.log('🔄 AI Assistant closed - conversation reset');
}, [setIsOpen, setError, setMessages, setCurrentConversationId, setCurrentConversation]);

 // Enhanced search with debouncing
 const handleSearchChange = useCallback((query) => {
   setSearchQuery(query);
   
   if (searchTimeoutRef.current) {
     clearTimeout(searchTimeoutRef.current);
   }
   
   if (!query.trim()) {
     setSearchResults(null);
     setSearchLoading(false);
     return;
   }
   
   setSearchLoading(true);
   
   searchTimeoutRef.current = setTimeout(async () => {
     try {
       console.log('🔍 Dynamic search for:', query);
       const results = await searchEverything(query);
       setSearchResults(results);
     } catch (error) {
       console.error('Dynamic search failed:', error);
       setSearchResults(null);
     } finally {
       setSearchLoading(false);
     }
   }, 300);
 }, [searchEverything]);

 // Clean up timeout on unmount
 useEffect(() => {
   return () => {
     if (searchTimeoutRef.current) {
       clearTimeout(searchTimeoutRef.current);
     }
   };
 }, []);

 // Enhanced message sending with resume edit detection
 const handleSendMessage = async () => {
   if (!inputValue.trim() || isLoading || isProcessingResumeEdit) return;

   const messageText = inputValue.trim();
   setInputValue('');

   try {
     // Check if this is a resume editing request
     if (detectResumeEditIntent(messageText)) {
       console.log('🎯 Detected resume editing intent');
       await processResumeEdit(messageText);
     } else {
       await sendMessage(messageText);
     }
   } catch (error) {
     console.error('Failed to send message:', error);
   }
 };

 // Handle creating new conversation
 const handleCreateNewConversation = async () => {
   const title = currentContext?.currentResume 
     ? `Resume: ${currentContext.currentResume.name}`
     : `New Conversation ${conversations.length + 1}`;
   await createNewConversation(title, 'general');
   setShowSidebar(false);
 };

 // Handle conversation selection
 const handleSelectConversation = (conversationId) => {
   switchConversation(conversationId);
   setShowSidebar(false);
 };

 // Handle key press
 const handleKeyPress = (e) => {
   if (e.key === 'Enter' && !e.shiftKey) {
     e.preventDefault();
     handleSendMessage();
   }
 };

 // Handle suggestion clicks
 const handleSuggestionClickInternal = (suggestion) => {
   setInputValue(suggestion);
   inputRef.current?.focus();
 };

 // Check if we're in resume context
 const isResumeContext = currentContext?.page === 'resumes' && currentContext?.currentResume;

 // Don't render if not open - FIXED VERSION WITHOUT BADGE
 if (!isOpen) {
   return (
     <Tooltip title="Ask AJ - Your AI Job Assistant" placement="left">
       <Box
         sx={{
           position: 'fixed',
           bottom: 24,
           right: 24,
           zIndex: 1300,
           cursor: 'pointer'
         }}
         onClick={() => setIsOpen(true)}
       >
         <Paper
           elevation={8}
           sx={{
             width: 64,
             height: 64,
             borderRadius: '50%',
             display: 'flex',
             alignItems: 'center',
             justifyContent: 'center',
             background: isResumeContext 
               ? `linear-gradient(135deg, ${theme.palette.secondary.main} 0%, ${theme.palette.secondary.light} 100%)`
               : `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.light} 100%)`,
             color: 'white',
             transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
             '&:hover': {
               transform: 'translateY(-4px) scale(1.05)',
               boxShadow: isResumeContext 
                 ? '0 12px 24px rgba(0, 188, 180, 0.3)'
                 : '0 12px 24px rgba(26, 115, 232, 0.3)'
             }
           }}
         >
           <AutoJobLogo 
             variant="icon-only" 
             size="small" 
             color="white"
           />
         </Paper>
       </Box>
     </Tooltip>
   );
 }

 return (
   <>
     <Fade in={isOpen}>
       <Paper
         elevation={16}
         sx={{
           position: 'fixed',
           bottom: 24,
           right: 24,
           width: isMinimized ? 400 : 500,
           height: isMinimized ? 60 : 700,
           zIndex: 1300,
           borderRadius: 3,
           overflow: 'hidden',
           display: 'flex',
           flexDirection: 'column',
           background: 'linear-gradient(to bottom, #ffffff 0%, #f8f9fa 100%)',
           boxShadow: '0 20px 40px rgba(0, 0, 0, 0.15)',
           border: isResumeContext 
             ? `2px solid ${theme.palette.secondary.main}30`
             : `1px solid ${theme.palette.divider}`
         }}
       >
         {/* Header - FIXED VERSION */}
         <Box
           sx={{
             p: 2,
             background: isResumeContext
               ? `linear-gradient(135deg, ${theme.palette.secondary.main} 0%, ${theme.palette.secondary.light} 100%)`
               : `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.light} 100%)`,
             color: 'white',
             display: 'flex',
             alignItems: 'center',
             justifyContent: 'space-between',
             minHeight: isMinimized ? 60 : 'auto',
             overflow: 'hidden'
           }}
         >
           <Box sx={{ 
             display: 'flex', 
             alignItems: 'center', 
             gap: 1.5,
             flex: 1,
             minWidth: 0
           }}>
             <AutoJobLogo 
               variant="icon-only" 
               size="small" 
               color="white"
             />
             <Box sx={{ 
               minWidth: 0,
               flex: 1 
             }}>
               <Typography 
                 variant="subtitle1" 
                 fontWeight={600}
                 sx={{
                   overflow: 'hidden',
                   textOverflow: 'ellipsis',
                   whiteSpace: 'nowrap',
                   fontSize: isMinimized ? '0.9rem' : '1rem',
                   lineHeight: 1.2
                 }}
               >
                 AJ - Your AI Job Assistant {isResumeContext && '• Resume Mode'}
               </Typography>
               {!isMinimized && (
                 <Typography 
                   variant="caption" 
                   sx={{ 
                     opacity: 0.8,
                     overflow: 'hidden',
                     textOverflow: 'ellipsis',
                     whiteSpace: 'nowrap',
                     display: 'block'
                   }}
                 >
                   {currentConversation?.title || 'AI Career Assistant'}
                 </Typography>
               )}
             </Box>
           </Box>
           <Box sx={{ 
             display: 'flex', 
             alignItems: 'center', 
             gap: 0.5,
             flexShrink: 0
           }}>
            <IconButton
               size="small"
               onClick={() => setShowSidebar(!showSidebar)}
               sx={{ 
                 color: 'white',
                 display: isMinimized ? 'none' : 'flex'
               }}
             >
               <HistoryIcon />
             </IconButton>
             <IconButton
               size="small"
               onClick={() => setIsMinimized(!isMinimized)}
               sx={{ color: 'white' }}
             >
               {isMinimized ? <ChevronUpIcon /> : <ChevronDownIcon />}
             </IconButton>
             <IconButton
               size="small"
               onClick={handleClose}
               sx={{ color: 'white' }}
             >
               <CloseIcon />
             </IconButton>
           </Box>
         </Box>

         {/* Resume Context Display */}
         {!isMinimized && isResumeContext && (
           <ResumeContextDisplay currentContext={currentContext} />
         )}

         {/* Resume Processing Indicator */}
         {!isMinimized && (isProcessingResumeEdit || lastResumeAction) && (
           <Box sx={{ px: 2, py: 1, bgcolor: theme.palette.info.light + '20' }}>
             {isProcessingResumeEdit && (
               <LinearProgress sx={{ mb: 1, borderRadius: 1 }} />
             )}
             <Typography variant="caption" color="info.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
               <AutoFixHighIcon fontSize="small" />
               {lastResumeAction || 'Processing resume changes...'}
             </Typography>
           </Box>
         )}

         {/* Main Content - Hidden when minimized */}
         {!isMinimized && (
           <Box sx={{ flex: 1, display: 'flex', overflow: 'hidden' }}>
             {/* Sidebar */}
             {showSidebar && (
               <Box
                 sx={{
                   width: 280,
                   borderRight: `1px solid ${theme.palette.divider}`,
                   display: 'flex',
                   flexDirection: 'column'
                 }}
               >
                 <ConversationList
                   conversations={conversations}
                   currentConversationId={currentConversationId}
                   onSelectConversation={handleSelectConversation}
                   onCreateNew={handleCreateNewConversation}
                   onUpdateConversation={updateConversation}
                   onDeleteConversation={deleteConversation}
                   loading={conversationsLoading}
                 />
               </Box>
             )}

             {/* Chat Area */}
             <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
               {/* Tabs */}
               <Tabs
                 value={activeTab}
                 onChange={(e, newValue) => setActiveTab(newValue)}
                 variant="fullWidth"
                 sx={{ borderBottom: `1px solid ${theme.palette.divider}` }}
               >
                 <Tab icon={<ChatIcon />} label="Chat" />
                 <Tab icon={<PsychologyIcon />} label="Memory" />
                 <Tab icon={<SearchIcon />} label="Search" />
               </Tabs>

               {/* Contextual Suggestions Bar */}
               {activeTab === 0 && (
                 <ContextualSuggestionsBar 
                   currentContext={currentContext}
                   onSuggestionClick={handleSuggestionClickInternal}
                 />
               )}

               {/* Tab Content */}
               {activeTab === 0 && (
                 <>
                   {/* Messages */}
                   <Box
                     sx={{
                       flex: 1,
                       overflow: 'auto',
                       p: 2,
                       display: 'flex',
                       flexDirection: 'column',
                       gap: 2
                     }}
                   >
                     {messages.map((message) => (
                       <EnhancedMessage
                         key={message.id}
                         message={message}
                         theme={theme}
                         currentUser={currentUser}
                         onSuggestionClick={handleSuggestionClickInternal}
                         isResumeContext={isResumeContext}
                       />
                     ))}

                     {/* Loading indicator */}
                     {(isLoading || isProcessingResumeEdit) && (
                       <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                         <Avatar sx={{ width: 32, height: 32, bgcolor: 'transparent', p: 0.5 }}>
                           <AutoJobLogo variant="icon-only" size="small" />
                         </Avatar>
                         <Paper
                           elevation={1}
                           sx={{
                             p: 2,
                             borderRadius: 2,
                             bgcolor: isProcessingResumeEdit ? theme.palette.secondary.light + '20' : '#f5f5f5',
                             borderBottomLeftRadius: 4,
                             display: 'flex',
                             alignItems: 'center',
                             gap: 1,
                             border: isProcessingResumeEdit ? `1px solid ${theme.palette.secondary.light}50` : 'none'
                           }}
                         >
                           <CircularProgress size={16} color={isProcessingResumeEdit ? 'secondary' : 'primary'} />
                           <Typography variant="body2" color="text.secondary">
                             {isProcessingResumeEdit ? 'AJ is updating your resume...' : 'AJ is thinking...'}
                           </Typography>
                         </Paper>
                       </Box>
                     )}

                     {/* Error message */}
                     {error && (
                       <Alert 
                         severity="error" 
                         onClose={() => setError(null)}
                         sx={{ fontSize: '0.875rem' }}
                       >
                         {error}
                       </Alert>
                     )}

                     <div ref={messagesEndRef} />
                   </Box>

                   <Divider />

                   {/* Enhanced Input with Resume Context */}
                   <Box sx={{ p: 2 }}>
                     <Box sx={{ display: 'flex', gap: 1, alignItems: 'flex-end' }}>
                       <TextField
                         ref={inputRef}
                         fullWidth
                         multiline
                         maxRows={3}
                         value={inputValue}
                         onChange={(e) => setInputValue(e.target.value)}
                         onKeyPress={handleKeyPress}
                         placeholder={
                           isResumeContext 
                             ? "Ask AJ to improve your resume: 'Update my work experience' or 'Optimize for ATS'..."
                             : "Ask AJ anything about your career, resumes, or job search..."
                         }
                         variant="outlined"
                         size="small"
                         disabled={isLoading || isProcessingResumeEdit}
                         sx={{
                           '& .MuiOutlinedInput-root': {
                             borderRadius: 2,
                             fontSize: '0.875rem',
                             ...(isResumeContext && {
                               borderColor: theme.palette.secondary.main + '50',
                               '&:hover': {
                                 borderColor: theme.palette.secondary.main
                               },
                               '&.Mui-focused': {
                                 borderColor: theme.palette.secondary.main
                               }
                             })
                           }
                         }}
                       />
                       <IconButton
                         color={isResumeContext ? 'secondary' : 'primary'}
                         onClick={handleSendMessage}
                         disabled={!inputValue.trim() || isLoading || isProcessingResumeEdit}
                         sx={{
                           bgcolor: isResumeContext ? theme.palette.secondary.main : theme.palette.primary.main,
                           color: 'white',
                           '&:hover': {
                             bgcolor: isResumeContext ? theme.palette.secondary.dark : theme.palette.primary.dark
                           },
                           '&:disabled': {
                             bgcolor: theme.palette.action.disabled
                           }
                         }}
                       >
                         <SendIcon fontSize="small" />
                       </IconButton>
                     </Box>
                     
                     {/* Resume Context Hint */}
                     {isResumeContext && (
                       <Typography variant="caption" color="text.secondary" sx={{ mt: 0.5, display: 'block' }}>
                         💡 Try: "Improve my summary", "Add more skills", "Optimize for ATS", or "Update work experience"
                       </Typography>
                     )}
                   </Box>
                 </>
               )}

               {/* Memory Tab */}
               {activeTab === 1 && (
                 <Box sx={{ 
                   flex: 1, 
                   display: 'flex', 
                   flexDirection: 'column',
                   overflow: 'hidden'
                 }}>
                   <Box sx={{ 
                     p: 2, 
                     borderBottom: `1px solid ${theme.palette.divider}`,
                     flexShrink: 0
                   }}>
                     <Typography variant="h6" gutterBottom>
                       Memory Insights
                     </Typography>
                     <Typography variant="body2" color="text.secondary">
                       AJ remembers your preferences, skills, and career goals to provide personalized assistance.
                     </Typography>
                   </Box>
                   
                   <Box sx={{ 
                     flex: 1, 
                     overflow: 'auto',
                     p: 2 
                   }}>
                     {memoryInsights.length > 0 ? (
                       <Box>
                         {memoryInsights.map((insight, index) => (
                           <Paper 
                             key={index} 
                             sx={{ 
                               p: 2, 
                               mb: 1.5,
                               borderRadius: 2,
                               border: `1px solid ${theme.palette.divider}`,
                               '&:hover': {
                                 bgcolor: theme.palette.action.hover
                               }
                             }}
                           >
                             <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1, mb: 1 }}>
                               <Chip 
                                 label={insight.type} 
                                 size="small" 
                                 variant="outlined"
                                 color={
                                   insight.type === 'strength' ? 'success' :
                                   insight.type === 'opportunity' ? 'primary' :
                                   insight.type === 'challenge' ? 'warning' :
                                   insight.type === 'recommendation' ? 'info' : 'default'
                                 }
                                 sx={{ fontSize: '0.75rem', height: 20 }}
                               />
                               <Typography 
                                 variant="caption" 
                                 color="text.secondary"
                                 sx={{ ml: 'auto' }}
                               >
                                 {Math.round((insight.confidence || 0.8) * 100)}% confidence
                               </Typography>
                             </Box>
                             <Typography variant="body2" sx={{ lineHeight: 1.5 }}>
                               {insight.description}
                             </Typography>
                           </Paper>
                         ))}
                       </Box>
                     ) : (
                       <Box sx={{ 
                         textAlign: 'center', 
                         mt: 4,
                         display: 'flex',
                         flexDirection: 'column',
                         alignItems: 'center',
                         gap: 2
                       }}>
                         <MemoryIcon sx={{ fontSize: 48, color: 'text.disabled' }} />
                         <Box>
                           <Typography variant="body2" color="text.secondary" gutterBottom>
                             No memory insights yet. Start chatting to build your profile!
                           </Typography>
                           <Typography variant="caption" color="text.disabled">
                             AJ learns about your preferences, skills, and goals over time.
                           </Typography>
                         </Box>
                       </Box>
                     )}
                   </Box>
                 </Box>
               )}

               {/* Search Tab */}
               {activeTab === 2 && (
                 <Box sx={{ 
                   flex: 1, 
                   display: 'flex', 
                   flexDirection: 'column',
                   overflow: 'hidden'
                 }}>
                   <Box sx={{ 
                     p: 2, 
                     borderBottom: `1px solid ${theme.palette.divider}`,
                     flexShrink: 0
                   }}>
                     <TextField
                       fullWidth
                       value={searchQuery}
                       onChange={(e) => handleSearchChange(e.target.value)}
                       placeholder="Search conversations and memories..."
                       variant="outlined"
                       size="small"
                       InputProps={{
                         endAdornment: (
                           <InputAdornment position="end">
                             {searchLoading ? (
                               <CircularProgress size={20} />
                             ) : (
                               <SearchIcon />
                             )}
                           </InputAdornment>
                         )
                       }}
                       sx={{
                         '& .MuiOutlinedInput-root': {
                           borderRadius: 2
                         }
                       }}
                     />
                   </Box>
                   
                   <Box sx={{ 
                     flex: 1, 
                     overflow: 'auto',
                     p: 2 
                   }}>
                     {searchResults ? (
                       <Box>
                         {/* Conversations Results */}
                         {searchResults.conversations?.length > 0 && (
                           <Box sx={{ mb: 3 }}>
                             <Typography variant="subtitle2" gutterBottom sx={{ 
                               display: 'flex', 
                               alignItems: 'center', 
                               gap: 1,
                               color: theme.palette.primary.main,
                               fontWeight: 600
                             }}>
                               <ChatIcon fontSize="small" />
                               Conversations ({searchResults.conversations.length})
                             </Typography>
                             {searchResults.conversations.map((conv) => (
                               <Paper 
                                 key={conv._id} 
                                 sx={{ 
                                   p: 2, 
                                   mb: 1.5, 
                                   cursor: 'pointer',
                                   borderRadius: 2,
                                   border: `1px solid ${theme.palette.divider}`,
                                   '&:hover': {
                                     bgcolor: theme.palette.action.hover,
                                     borderColor: theme.palette.primary.light
                                   }
                                 }}
                                 onClick={() => handleSelectConversation(conv._id)}
                               >
                                 <Typography variant="body2" fontWeight={600} gutterBottom>
                                   {conv.title}
                                 </Typography>
                                 <Typography 
                                   variant="caption" 
                                   color="text.secondary"
                                   sx={{ 
                                     display: 'block',
                                     overflow: 'hidden',
                                     textOverflow: 'ellipsis',
                                     whiteSpace: 'nowrap'
                                   }}
                                 >
                                   {conv.preview || 'No preview available'}
                                 </Typography>
                                 <Typography variant="caption" color="primary.main" sx={{ mt: 0.5, display: 'block' }}>
                                   Click to view conversation →
                                 </Typography>
                               </Paper>
                             ))}
                           </Box>
                         )}
                         
                         {/* Memories Results */}
                         {searchResults.memories?.length > 0 && (
                           <Box>
                             <Typography variant="subtitle2" gutterBottom sx={{ 
                               display: 'flex', 
                               alignItems: 'center', 
                               gap: 1,
                               color: theme.palette.secondary.main,
                               fontWeight: 600
                             }}>
                               <MemoryIcon fontSize="small" />
                               Memories ({searchResults.memories.length})
                             </Typography>
                             {searchResults.memories.map((memory, index) => (
                               <Paper 
                                 key={index} 
                                 sx={{ 
                                   p: 2, 
                                   mb: 1.5,
                                   borderRadius: 2,
                                   border: `1px solid ${theme.palette.divider}`,
                                   bgcolor: theme.palette.background.default
                                 }}
                               >
                                 <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1, mb: 1 }}>
                                   <Chip 
                                     label={memory.type} 
                                     size="small" 
                                     variant="outlined"
                                     color="secondary"
                                     sx={{ fontSize: '0.75rem', height: 20 }}
                                   />
                                   <Typography 
                                     variant="caption" 
                                     color="text.secondary"
                                     sx={{ ml: 'auto' }}
                                   >
                                     {Math.round((memory.confidence || 0.8) * 100)}% confidence
                                   </Typography>
                                 </Box>
                                 <Typography variant="body2" sx={{ lineHeight: 1.5 }}>
                                   {memory.content}
                                 </Typography>
                               </Paper>
                             ))}
                           </Box>
                         )}
                         
                         {/* No Results */}
                         {(!searchResults.conversations?.length && !searchResults.memories?.length) && (
                           <Box sx={{ 
                             textAlign: 'center', 
                             mt: 4,
                             display: 'flex',
                             flexDirection: 'column',
                             alignItems: 'center',
                             gap: 2
                           }}>
                             <SearchIcon sx={{ fontSize: 48, color: 'text.disabled' }} />
                             <Box>
                               <Typography variant="body2" color="text.secondary" gutterBottom>
                                 No results found for "{searchQuery}"
                               </Typography>
                               <Typography variant="caption" color="text.disabled">
                                 Try searching for skills, career goals, or conversation topics.
                               </Typography>
                             </Box>
                           </Box>
                         )}
                       </Box>
                     ) : (
                       <Box sx={{ 
                         textAlign: 'center', 
                         mt: 4,
                         display: 'flex',
                         flexDirection: 'column',
                         alignItems: 'center',
                         gap: 2
                       }}>
                         <SearchIcon sx={{ fontSize: 48, color: 'text.disabled' }} />
                         <Box>
                           <Typography variant="body2" color="text.secondary" gutterBottom>
                             Search your conversations and memories
                           </Typography>
                           <Typography variant="caption" color="text.disabled">
                             Find past discussions, skills, preferences, and career insights.
                           </Typography>
                         </Box>
                       </Box>
                     )}
                   </Box>
                 </Box>
               )}
             </Box>
           </Box>
         )}
       </Paper>
     </Fade>
   </>
 );
};

export default GlobalAiAssistant;

================
File: src/components/auth/EmailVerification.js
================
// src/components/auth/EmailVerification.js
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  Alert,
  CircularProgress,
  Card,
  CardContent,
  Container
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Email as EmailIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import settingsService from '../../utils/settingsService';
import AutoJobLogo from '../common/AutoJobLogo';

const EmailVerification = () => {
  const theme = useTheme();
  const { token } = useParams();
  const navigate = useNavigate();
  
  const [status, setStatus] = useState('verifying'); // 'verifying', 'success', 'error'
  const [message, setMessage] = useState('');
  const [isResending, setIsResending] = useState(false);

  useEffect(() => {
    if (token) {
      verifyEmail(token);
    }
  }, [token]);

  const verifyEmail = async (verificationToken) => {
    try {
      const response = await settingsService.verifyEmail(verificationToken);
      setStatus('success');
      setMessage(response.message || 'Email verified successfully!');
      
      // Redirect to dashboard after 3 seconds
      setTimeout(() => {
        navigate('/dashboard');
      }, 3000);
      
    } catch (error) {
      setStatus('error');
      setMessage(settingsService.getErrorMessage(error));
    }
  };

  const handleResendVerification = async () => {
    try {
      setIsResending(true);
      await settingsService.sendVerificationEmail();
      setMessage('Verification email sent! Please check your inbox.');
      setStatus('success');
    } catch (error) {
      setMessage(settingsService.getErrorMessage(error));
      setStatus('error');
    } finally {
      setIsResending(false);
    }
  };

  const getStatusIcon = () => {
    switch (status) {
      case 'verifying':
        return <CircularProgress size={48} color="primary" />;
      case 'success':
        return <CheckCircleIcon sx={{ fontSize: 48, color: theme.palette.success.main }} />;
      case 'error':
        return <ErrorIcon sx={{ fontSize: 48, color: theme.palette.error.main }} />;
      default:
        return null;
    }
  };

  const getStatusColor = () => {
    switch (status) {
      case 'success':
        return 'success';
      case 'error':
        return 'error';
      default:
        return 'info';
    }
  };

  return (
    <Container maxWidth="sm" sx={{ mt: 8 }}>
      <Box sx={{ textAlign: 'center', mb: 4 }}>
        <AutoJobLogo 
          variant="stacked" 
          size="large" 
          color="primary"
          showTagline={false}
        />
      </Box>

      <Card sx={{ borderRadius: 3, boxShadow: theme.shadows[8] }}>
        <CardContent sx={{ p: 4, textAlign: 'center' }}>
          <Box sx={{ mb: 3 }}>
            {getStatusIcon()}
          </Box>

          <Typography variant="h4" sx={{ fontWeight: 600, mb: 2 }}>
            {status === 'verifying' && 'Verifying Email...'}
            {status === 'success' && 'Email Verified!'}
            {status === 'error' && 'Verification Failed'}
          </Typography>

          {message && (
            <Alert 
              severity={getStatusColor()} 
              sx={{ mb: 3, textAlign: 'left', borderRadius: 2 }}
            >
              {message}
            </Alert>
          )}

          {status === 'success' && (
            <Box>
              <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
                Your email has been successfully verified. You'll be redirected to your dashboard shortly.
              </Typography>
              <Button
                variant="contained"
                onClick={() => navigate('/dashboard')}
                sx={{ borderRadius: 2 }}
              >
                Go to Dashboard
              </Button>
            </Box>
          )}

          {status === 'error' && (
            <Box>
              <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
                The verification link may have expired or is invalid.
              </Typography>
              <Box sx={{ display: 'flex', gap: 2, justifyContent: 'center' }}>
                <Button
                  variant="outlined"
                  onClick={() => navigate('/login')}
                  sx={{ borderRadius: 2 }}
                >
                  Back to Login
                </Button>
                <Button
                  variant="contained"
                  startIcon={isResending ? <CircularProgress size={20} /> : <EmailIcon />}
                  onClick={handleResendVerification}
                  disabled={isResending}
                  sx={{ borderRadius: 2 }}
                >
                  {isResending ? 'Sending...' : 'Resend Email'}
                </Button>
              </Box>
            </Box>
          )}

          {status === 'verifying' && (
            <Typography variant="body2" color="text.secondary">
              Please wait while we verify your email address...
            </Typography>
          )}
        </CardContent>
      </Card>
    </Container>
  );
};

export default EmailVerification;

================
File: src/components/auth/ForgotPassword.js
================
// src/components/auth/ForgotPassword.js
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { 
  TextField, 
  Button, 
  Typography, 
  Container, 
  Box, 
  Alert, 
  Paper,
  InputAdornment,
  Grid,
  Card,
  CardContent,
  CircularProgress
} from '@mui/material';
import { 
  Email as EmailIcon,
  ArrowBack as ArrowBackIcon,
  Help as HelpIcon,
  Security as SecurityIcon,
  CheckCircle as CheckCircleIcon,
  Send as SendIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const ForgotPassword = () => {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const { forgotPassword, loading } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    
    if (!email) {
      setError('Please enter your email address');
      return;
    }
    
    const result = await forgotPassword(email);
    
    if (result.success) {
      setSuccess('If an account with that email exists, you will receive password reset instructions shortly.');
    } else {
      setError(result.error);
    }
  };

  return (
    <Box sx={{ 
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #00c4b4 100%)',
      display: 'flex',
      alignItems: 'center',
      py: 3
    }}>
      <Container maxWidth="lg">
        <Grid container spacing={4} alignItems="center" sx={{ minHeight: '90vh' }}>
          {/* Left Side - Branding & Help */}
          <Grid item xs={12} md={6}>
            <Box sx={{ color: 'white', pr: { md: 4 } }}>
              {/* Logo Section */}
              <Box sx={{ mb: 4 }}>
                <AutoJobLogo 
                  variant="horizontal"
                  size="large"
                  color="white"
                  showTagline={true}
                />
              </Box>

              {/* Help Content */}
              <Typography 
                variant="h4" 
                sx={{ 
                  fontWeight: 600,
                  mb: 2,
                  lineHeight: 1.2
                }}
              >
                Need Help Accessing Your Account?
              </Typography>
              
              <Typography 
                variant="h6" 
                sx={{ 
                  opacity: 0.9,
                  fontWeight: 400,
                  mb: 4,
                  lineHeight: 1.4
                }}
              >
                Don't worry, it happens to the best of us. We'll help you get back 
                to your AI-powered job search in no time.
              </Typography>

              {/* Help Steps */}
              <Box sx={{ mb: 4 }}>
                <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
                  How it works:
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12}>
                    <Card sx={{ 
                      background: 'rgba(255, 255, 255, 0.15)', 
                      backdropFilter: 'blur(10px)',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      color: 'white',
                      mb: 2
                    }}>
                      <CardContent sx={{ p: 2.5 }}>
                        <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                          <Box 
                            sx={{ 
                              background: '#34a853',
                              borderRadius: '50%',
                              width: 24,
                              height: 24,
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              mr: 2,
                              mt: 0.5,
                              flexShrink: 0
                            }}
                          >
                            <Typography variant="caption" sx={{ color: 'white', fontWeight: 600 }}>
                              1
                            </Typography>
                          </Box>
                          <Box>
                            <Typography variant="subtitle1" sx={{ fontWeight: 600, mb: 0.5 }}>
                              Enter your email address
                            </Typography>
                            <Typography variant="body2" sx={{ opacity: 0.9 }}>
                              The same email you used to create your auto-job.ai account
                            </Typography>
                          </Box>
                        </Box>
                      </CardContent>
                    </Card>
                  </Grid>

                  <Grid item xs={12}>
                    <Card sx={{ 
                      background: 'rgba(255, 255, 255, 0.15)', 
                      backdropFilter: 'blur(10px)',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      color: 'white',
                      mb: 2
                    }}>
                      <CardContent sx={{ p: 2.5 }}>
                        <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                          <Box 
                            sx={{ 
                              background: '#4285f4',
                              borderRadius: '50%',
                              width: 24,
                              height: 24,
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              mr: 2,
                              mt: 0.5,
                              flexShrink: 0
                            }}
                          >
                            <Typography variant="caption" sx={{ color: 'white', fontWeight: 600 }}>
                              2
                            </Typography>
                          </Box>
                          <Box>
                            <Typography variant="subtitle1" sx={{ fontWeight: 600, mb: 0.5 }}>
                              Check your email
                            </Typography>
                            <Typography variant="body2" sx={{ opacity: 0.9 }}>
                              We'll send you a secure link to reset your password
                            </Typography>
                          </Box>
                        </Box>
                      </CardContent>
                    </Card>
                  </Grid>

                  <Grid item xs={12}>
                    <Card sx={{ 
                      background: 'rgba(255, 255, 255, 0.15)', 
                      backdropFilter: 'blur(10px)',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      color: 'white'
                    }}>
                      <CardContent sx={{ p: 2.5 }}>
                        <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                          <Box 
                            sx={{ 
                              background: '#00c4b4',
                              borderRadius: '50%',
                              width: 24,
                              height: 24,
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              mr: 2,
                              mt: 0.5,
                              flexShrink: 0
                            }}
                          >
                            <Typography variant="caption" sx={{ color: 'white', fontWeight: 600 }}>
                              3
                            </Typography>
                          </Box>
                          <Box>
                            <Typography variant="subtitle1" sx={{ fontWeight: 600, mb: 0.5 }}>
                              Create a new password
                            </Typography>
                            <Typography variant="body2" sx={{ opacity: 0.9 }}>
                              Follow the link to set up a secure new password
                            </Typography>
                          </Box>
                        </Box>
                      </CardContent>
                    </Card>
                  </Grid>
                </Grid>
              </Box>

              {/* Security Note */}
              <Box sx={{ 
                background: 'rgba(255, 255, 255, 0.1)', 
                backdropFilter: 'blur(10px)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                borderRadius: 2,
                p: 2.5
              }}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <SecurityIcon sx={{ mr: 1.5, color: '#34a853', mt: 0.5 }} />
                  <Box>
                    <Typography variant="subtitle1" sx={{ fontWeight: 600, mb: 0.5 }}>
                      Security First
                    </Typography>
                    <Typography variant="body2" sx={{ opacity: 0.9, lineHeight: 1.4 }}>
                      For your security, password reset links expire after 1 hour. 
                      If you don't see our email, check your spam folder.
                    </Typography>
                  </Box>
                </Box>
              </Box>
            </Box>
          </Grid>

          {/* Right Side - Reset Form */}
          <Grid item xs={12} md={6}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 4, 
                background: 'rgba(255, 255, 255, 0.98)',
                backdropFilter: 'blur(20px)',
                border: '1px solid rgba(255, 255, 255, 0.3)',
                boxShadow: '0 20px 40px rgba(0,0,0,0.1)'
              }}
            >
              {/* Header */}
              <Box sx={{ textAlign: 'center', mb: 3 }}>
                <AutoJobLogo 
                  variant="icon-only"
                  size="medium"
                  color="primary"
                />
                <Typography 
                  component="h1" 
                  variant="h4" 
                  sx={{ 
                    fontWeight: 600,
                    color: 'text.primary',
                    mb: 0.5,
                    mt: 1
                  }}
                >
                  Reset Your Password
                </Typography>
                <Typography 
                  variant="body1" 
                  color="text.secondary"
                  sx={{ mb: 2 }}
                >
                  Enter your email address and we'll send you instructions to reset your password
                </Typography>
              </Box>
              
              {error && (
                <Alert 
                  severity="error" 
                  sx={{ 
                    mb: 3,
                    '& .MuiAlert-icon': {
                      fontSize: '1.25rem'
                    }
                  }}
                >
                  {error}
                </Alert>
              )}
              
              {success && (
                <Alert 
                  severity="success" 
                  sx={{ 
                    mb: 3,
                    '& .MuiAlert-icon': {
                      fontSize: '1.25rem'
                    }
                  }}
                >
                  {success}
                </Alert>
              )}
              
              <Box component="form" onSubmit={handleSubmit}>
                <TextField
                  margin="normal"
                  required
                  fullWidth
                  id="email"
                  label="Email Address"
                  name="email"
                  autoComplete="email"
                  autoFocus
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <EmailIcon color="primary" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ mb: 3 }}
                />
                
                <Button
                  type="submit"
                  fullWidth
                  variant="contained"
                  size="large"
                  disabled={loading}
                  startIcon={!loading && <SendIcon />}
                  sx={{ 
                    py: 1.5,
                    fontSize: '1rem',
                    fontWeight: 600,
                    mb: 3,
                    background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 100%)',
                    '&:hover': {
                      background: 'linear-gradient(135deg, #1557b0 0%, #3367d6 100%)',
                    },
                    '&:disabled': {
                      background: theme => theme.palette.action.disabledBackground
                    }
                  }}
                >
                  {loading ? (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <CircularProgress size={20} color="inherit" />
                      Sending reset link...
                    </Box>
                  ) : (
                    'Send Reset Instructions'
                  )}
                </Button>
                
                <Button
                  component={Link}
                  to="/login"
                  fullWidth
                  variant="outlined"
                  size="large"
                  startIcon={<ArrowBackIcon />}
                  sx={{ 
                    py: 1.5,
                    fontSize: '1rem',
                    fontWeight: 500
                  }}
                >
                  Back to Sign In
                </Button>
              </Box>

              {/* Help Information */}
              <Box sx={{ 
                mt: 3, 
                pt: 3, 
                borderTop: '1px solid',
                borderColor: 'divider',
                textAlign: 'center'
              }}>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  Still having trouble? We're here to help.
                </Typography>
                <Box sx={{ 
                  display: 'flex', 
                  justifyContent: 'center', 
                  alignItems: 'center', 
                  gap: 3,
                  flexWrap: 'wrap'
                }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <HelpIcon sx={{ fontSize: 16, color: 'primary.main' }} />
                    <Typography variant="caption" color="text.secondary">
                      <Link to="/help" style={{ color: 'inherit', textDecoration: 'underline' }}>
                        Contact Support
                      </Link>
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                    <Typography variant="caption" color="text.secondary">
                      Available 24/7
                    </Typography>
                  </Box>
                </Box>
              </Box>
            </Paper>
          </Grid>
        </Grid>
      </Container>
    </Box>
  );
};

export default ForgotPassword;

================
File: src/components/auth/Login.js
================
// src/components/auth/Login.js
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { 
  TextField, 
  Button, 
  Typography, 
  Container, 
  Box, 
  Alert, 
  Paper,
  InputAdornment,
  IconButton,
  Divider,
  Grid,
  Card,
  CardContent,
  Chip,
  CircularProgress
} from '@mui/material';
import { 
  Email as EmailIcon,
  Lock as LockIcon,
  Visibility,
  VisibilityOff,
  PersonAdd as PersonAddIcon,
  Help as HelpIcon,
  SmartToy as SmartToyIcon,
  Work as WorkIcon,
  Speed as SpeedIcon,
  CheckCircle as CheckCircleIcon,
  TrendingUp as TrendingUpIcon,
  Security as SecurityIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const Login = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  const [error, setError] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const { login, loading } = useAuth();
  const navigate = useNavigate();

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    
    const result = await login(formData.email, formData.password);
    
    if (result.success) {
      navigate('/dashboard');
    } else {
      setError(result.error);
    }
  };

  const handleClickShowPassword = () => {
    setShowPassword(!showPassword);
  };

  return (
    <Box sx={{ 
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #00c4b4 100%)',
      display: 'flex',
      alignItems: 'center',
      py: 3
    }}>
      <Container maxWidth="lg">
        <Grid container spacing={4} alignItems="center" sx={{ minHeight: '90vh' }}>
          {/* Left Side - Branding & Features */}
          <Grid item xs={12} md={6}>
            <Box sx={{ color: 'white', pr: { md: 4 } }}>
              {/* Logo Section */}
              <Box sx={{ mb: 4 }}>
                <AutoJobLogo 
                  variant="horizontal"
                  size="large"
                  color="white"
                  showTagline={true}
                />
              </Box>

              {/* Value Proposition */}
              <Typography 
                variant="h4" 
                sx={{ 
                  fontWeight: 600,
                  mb: 2,
                  lineHeight: 1.2
                }}
              >
                Transform Your Job Search with AI
              </Typography>
              
              <Typography 
                variant="h6" 
                sx={{ 
                  opacity: 0.9,
                  fontWeight: 400,
                  mb: 4,
                  lineHeight: 1.4
                }}
              >
                Join thousands of professionals who've accelerated their careers 
                with our AI-powered job matching platform.
              </Typography>

              {/* Feature Grid */}
              <Grid container spacing={2} sx={{ mb: 4 }}>
                <Grid item xs={12} sm={6}>
                  <Card sx={{ 
                    background: 'rgba(255, 255, 255, 0.15)', 
                    backdropFilter: 'blur(10px)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    color: 'white',
                    transition: 'transform 0.2s ease-in-out',
                    '&:hover': {
                      transform: 'translateY(-2px)'
                    }
                  }}>
                    <CardContent sx={{ p: 2.5 }}>
                      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 1.5 }}>
                        <SpeedIcon sx={{ mr: 1.5, color: '#34a853', fontSize: '1.5rem' }} />
                        <Box>
                          <Typography variant="h6" sx={{ fontWeight: 600, mb: 0.5 }}>
                            3x Faster Results
                          </Typography>
                          <Typography variant="body2" sx={{ opacity: 0.9, lineHeight: 1.4 }}>
                            Get interview callbacks 3x faster than traditional job searching methods
                          </Typography>
                        </Box>
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Card sx={{ 
                    background: 'rgba(255, 255, 255, 0.15)', 
                    backdropFilter: 'blur(10px)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    color: 'white',
                    transition: 'transform 0.2s ease-in-out',
                    '&:hover': {
                      transform: 'translateY(-2px)'
                    }
                  }}>
                    <CardContent sx={{ p: 2.5 }}>
                      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 1.5 }}>
                        <SmartToyIcon sx={{ mr: 1.5, color: '#4285f4', fontSize: '1.5rem' }} />
                        <Box>
                          <Typography variant="h6" sx={{ fontWeight: 600, mb: 0.5 }}>
                            AI Automation
                          </Typography>
                          <Typography variant="body2" sx={{ opacity: 0.9, lineHeight: 1.4 }}>
                            24/7 AI agents handle applications, follow-ups, and scheduling
                          </Typography>
                        </Box>
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Card sx={{ 
                    background: 'rgba(255, 255, 255, 0.15)', 
                    backdropFilter: 'blur(10px)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    color: 'white',
                    transition: 'transform 0.2s ease-in-out',
                    '&:hover': {
                      transform: 'translateY(-2px)'
                    }
                  }}>
                    <CardContent sx={{ p: 2.5 }}>
                      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 1.5 }}>
                        <WorkIcon sx={{ mr: 1.5, color: '#fbbc04', fontSize: '1.5rem' }} />
                        <Box>
                          <Typography variant="h6" sx={{ fontWeight: 600, mb: 0.5 }}>
                            Smart Matching
                          </Typography>
                          <Typography variant="body2" sx={{ opacity: 0.9, lineHeight: 1.4 }}>
                            AI analyzes your profile to find perfect job matches automatically
                          </Typography>
                        </Box>
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Card sx={{ 
                    background: 'rgba(255, 255, 255, 0.15)', 
                    backdropFilter: 'blur(10px)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    color: 'white',
                    transition: 'transform 0.2s ease-in-out',
                    '&:hover': {
                      transform: 'translateY(-2px)'
                    }
                  }}>
                    <CardContent sx={{ p: 2.5 }}>
                      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 1.5 }}>
                        <TrendingUpIcon sx={{ mr: 1.5, color: '#00c4b4', fontSize: '1.5rem' }} />
                        <Box>
                          <Typography variant="h6" sx={{ fontWeight: 600, mb: 0.5 }}>
                            Higher Success
                          </Typography>
                          <Typography variant="body2" sx={{ opacity: 0.9, lineHeight: 1.4 }}>
                            85% higher interview callback rate compared to manual applications
                          </Typography>
                        </Box>
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>
              </Grid>

              {/* Social Proof */}
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, flexWrap: 'wrap' }}>
                <Chip 
                  label="10,000+ Active Users" 
                  variant="outlined" 
                  sx={{ 
                    color: 'white', 
                    borderColor: 'rgba(255,255,255,0.4)',
                    background: 'rgba(255,255,255,0.1)',
                    fontWeight: 500
                  }} 
                  icon={<CheckCircleIcon sx={{ color: '#34a853 !important' }} />}
                />
                <Chip 
                  label="4.9/5 User Rating" 
                  variant="outlined" 
                  sx={{ 
                    color: 'white', 
                    borderColor: 'rgba(255,255,255,0.4)',
                    background: 'rgba(255,255,255,0.1)',
                    fontWeight: 500
                  }} 
                  icon={<CheckCircleIcon sx={{ color: '#fbbc04 !important' }} />}
                />
                <Chip 
                  label="50K+ Jobs Matched" 
                  variant="outlined" 
                  sx={{ 
                    color: 'white', 
                    borderColor: 'rgba(255,255,255,0.4)',
                    background: 'rgba(255,255,255,0.1)',
                    fontWeight: 500
                  }} 
                  icon={<CheckCircleIcon sx={{ color: '#00c4b4 !important' }} />}
                />
              </Box>
            </Box>
          </Grid>

          {/* Right Side - Login Form */}
          <Grid item xs={12} md={6}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 4, 
                background: 'rgba(255, 255, 255, 0.98)',
                backdropFilter: 'blur(20px)',
                border: '1px solid rgba(255, 255, 255, 0.3)',
                boxShadow: '0 20px 40px rgba(0,0,0,0.1)'
              }}
            >
              {/* Header */}
              <Box sx={{ textAlign: 'center', mb: 3 }}>
                <AutoJobLogo 
                  variant="icon-only"
                  size="medium"
                  color="primary"
                />
                <Typography 
                  component="h1" 
                  variant="h4" 
                  sx={{ 
                    fontWeight: 600,
                    color: 'text.primary',
                    mb: 0.5,
                    mt: 1
                  }}
                >
                  Welcome Back
                </Typography>
                <Typography 
                  variant="body1" 
                  color="text.secondary"
                  sx={{ mb: 2 }}
                >
                  Sign in to continue your AI-powered job search journey
                </Typography>
              </Box>
              
              {error && (
                <Alert 
                  severity="error" 
                  sx={{ 
                    mb: 3,
                    '& .MuiAlert-icon': {
                      fontSize: '1.25rem'
                    }
                  }}
                >
                  {error}
                </Alert>
              )}
              
              <Box component="form" onSubmit={handleSubmit}>
                <TextField
                  margin="normal"
                  required
                  fullWidth
                  id="email"
                  label="Email Address"
                  name="email"
                  autoComplete="email"
                  autoFocus
                  value={formData.email}
                  onChange={handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <EmailIcon color="primary" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ mb: 2 }}
                />
                
                <TextField
                  margin="normal"
                  required
                  fullWidth
                  name="password"
                  label="Password"
                  type={showPassword ? 'text' : 'password'}
                  id="password"
                  autoComplete="current-password"
                  value={formData.password}
                  onChange={handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LockIcon color="primary" />
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          aria-label="toggle password visibility"
                          onClick={handleClickShowPassword}
                          edge="end"
                          size="small"
                        >
                          {showPassword ? <VisibilityOff /> : <Visibility />}
                        </IconButton>
                      </InputAdornment>
                    ),
                  }}
                  sx={{ mb: 3 }}
                />
                
                <Button
                  type="submit"
                  fullWidth
                  variant="contained"
                  size="large"
                  disabled={loading}
                  sx={{ 
                    py: 1.5,
                    fontSize: '1rem',
                    fontWeight: 600,
                    mb: 3,
                    background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 100%)',
                    '&:hover': {
                      background: 'linear-gradient(135deg, #1557b0 0%, #3367d6 100%)',
                    },
                    '&:disabled': {
                      background: theme => theme.palette.action.disabledBackground
                    }
                  }}
                >
                  {loading ? (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <CircularProgress size={20} color="inherit" />
                      Signing you in...
                    </Box>
                  ) : (
                    'Sign In'
                  )}
                </Button>

                <Divider sx={{ my: 2 }}>
                  <Typography variant="body2" color="text.secondary">
                    New to auto-job.ai?
                  </Typography>
                </Divider>
                
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1.5 }}>
                  <Button
                    component={Link}
                    to="/register"
                    fullWidth
                    variant="outlined"
                    size="large"
                    startIcon={<PersonAddIcon />}
                    sx={{ 
                      py: 1.5,
                      fontSize: '1rem',
                      fontWeight: 500
                    }}
                  >
                    Create Your Free Account
                  </Button>
                  
                  <Button
                    component={Link}
                    to="/forgot-password"
                    fullWidth
                    variant="text"
                    startIcon={<HelpIcon />}
                    sx={{ 
                      py: 1,
                      color: 'text.secondary'
                    }}
                  >
                    Forgot your password?
                  </Button>
                </Box>
              </Box>

              {/* Trust Indicators */}
              <Box sx={{ 
                mt: 3, 
                pt: 3, 
                borderTop: '1px solid',
                borderColor: 'divider',
                textAlign: 'center'
              }}>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 1.5 }}>
                  Trusted by professionals worldwide
                </Typography>
                <Box sx={{ 
                  display: 'flex', 
                  justifyContent: 'center', 
                  alignItems: 'center', 
                  gap: 3,
                  flexWrap: 'wrap'
                }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <SecurityIcon sx={{ fontSize: 16, color: 'success.main' }} />
                    <Typography variant="caption" color="text.secondary">
                      Bank-Level Security
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                    <Typography variant="caption" color="text.secondary">
                      GDPR Compliant
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                    <Typography variant="caption" color="text.secondary">
                      24/7 Support
                    </Typography>
                  </Box>
                </Box>
              </Box>
            </Paper>
          </Grid>
        </Grid>
      </Container>
    </Box>
  );
};

export default Login;

================
File: src/components/auth/ProtectedRoute.js
================
// src/components/auth/ProtectedRoute.js - typical implementation
import React, { useContext } from 'react';
import { Navigate } from 'react-router-dom';
import { AuthContext } from '../../context/AuthContext';

const ProtectedRoute = ({ children }) => {
  console.log('ProtectedRoute rendering');
  const { isAuthenticated, loading } = useContext(AuthContext);
  console.log('Auth in ProtectedRoute:', { isAuthenticated, loading });

  if (loading) {
    // Add a simple loading indicator here
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    console.log('Not authenticated, redirecting to login');
    return <Navigate to="/login" replace />;
  }

  console.log('Authenticated, rendering children');
  return children;
};

export default ProtectedRoute;

================
File: src/components/auth/Register.js
================
// src/components/auth/Register.js
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { 
  TextField, 
  Button, 
  Typography, 
  Container, 
  Box, 
  Alert, 
  Paper, 
  Grid,
  InputAdornment,
  IconButton,
  Divider,
  Card,
  CardContent,
  Chip,
  LinearProgress,
  CircularProgress
} from '@mui/material';
import { 
  Person as PersonIcon,
  Email as EmailIcon,
  Lock as LockIcon,
  Visibility,
  VisibilityOff,
  Login as LoginIcon,
  CheckCircle as CheckCircleIcon,
  SmartToy as SmartToyIcon,
  Speed as SpeedIcon,
  Work as WorkIcon,
  TrendingUp as TrendingUpIcon,
  Security as SecurityIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const Register = () => {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const { register, loading } = useAuth();
  const navigate = useNavigate();

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const validateForm = () => {
    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match');
      return false;
    }
    
    const passwordRegex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(formData.password)) {
      setError('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
      return false;
    }
    
    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    
    if (!validateForm()) {
      return;
    }
    
    const { confirmPassword, ...registrationData } = formData;
    const result = await register(registrationData);
    
    if (result.success) {
      setSuccess('Registration successful! Please check your email to verify your account.');
      setTimeout(() => {
        navigate('/dashboard');
      }, 3000);
    } else {
      setError(result.error);
    }
  };

  // Password strength indicator
  const getPasswordStrength = () => {
    if (!formData.password) return { score: 0, label: '', color: 'error' };
    
    let score = 0;
    const checks = {
      length: formData.password.length >= 8,
      lowercase: /[a-z]/.test(formData.password),
      uppercase: /[A-Z]/.test(formData.password),
      number: /\d/.test(formData.password),
      special: /[!@#$%^&*]/.test(formData.password)
    };
    
    score = Object.values(checks).filter(Boolean).length;
    
    if (score === 5) return { score: 100, label: 'Strong', color: 'success' };
    if (score >= 3) return { score: 60, label: 'Medium', color: 'warning' };
    return { score: 20, label: 'Weak', color: 'error' };
  };

  const passwordStrength = getPasswordStrength();

  return (
    <Box sx={{ 
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #00c4b4 100%)',
      display: 'flex',
      alignItems: 'center',
      py: 3
    }}>
      <Container maxWidth="lg">
        <Grid container spacing={4} alignItems="center" sx={{ minHeight: '90vh' }}>
          {/* Left Side - Branding & Benefits */}
          <Grid item xs={12} md={6}>
            <Box sx={{ color: 'white', pr: { md: 4 } }}>
              {/* Logo Section */}
              <Box sx={{ mb: 4 }}>
                <AutoJobLogo 
                  variant="horizontal"
                  size="large"
                  color="white"
                  showTagline={true}
                />
              </Box>

              {/* Value Proposition */}
              <Typography 
                variant="h4" 
                sx={{ 
                  fontWeight: 600,
                  mb: 2,
                  lineHeight: 1.2
                }}
              >
                Stay Ahead of The Market and Power Your Job Search Today
              </Typography>
              
              <Typography 
                variant="h6" 
                sx={{ 
                  opacity: 0.9,
                  fontWeight: 400,
                  mb: 4,
                  lineHeight: 1.4
                }}
              >
                Join thousands of professionals who've transformed their job search 
                with our AI intelligent platform and accessing our database of over 300k recruiters
              </Typography>

              {/* Benefits List */}
              <Box sx={{ mb: 4 }}>
                <Typography variant="h6" sx={{ mb: 2, fontWeight: 600 }}>
                  What you'll get with auto-job.ai:
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12}>
                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1.5 }}>
                      <CheckCircleIcon sx={{ mr: 2, color: '#34a853' }} />
                      <Typography variant="body1">
                        <strong>3x faster interview callbacks</strong> with AI-Tailored resumes
                      </Typography>
                    </Box>
                  </Grid>
                  <Grid item xs={12}>
                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1.5 }}>
                      <CheckCircleIcon sx={{ mr: 2, color: '#34a853' }} />
                      <Typography variant="body1">
                        <strong>24/7 AI agents</strong> finding you jobs and reaching out to recruiters
                      </Typography>
                    </Box>
                  </Grid>
                  <Grid item xs={12}>
                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1.5 }}>
                      <CheckCircleIcon sx={{ mr: 2, color: '#34a853' }} />
                      <Typography variant="body1">
                        <strong>Smart job matching</strong> based on your resume and preferences
                      </Typography>
                    </Box>
                  </Grid>
                  <Grid item xs={12}>
                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1.5 }}>
                      <CheckCircleIcon sx={{ mr: 2, color: '#34a853' }} />
                      <Typography variant="body1">
                        <strong>AI Assistant</strong> to help you stay ahead of the job market
                      </Typography>
                    </Box>
                  </Grid>
                </Grid>
              </Box>

              {/* Social Proof */}
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, flexWrap: 'wrap' }}>
                <Chip 
                  label="Free to Start" 
                  variant="outlined" 
                  sx={{ 
                    color: 'white', 
                    borderColor: 'rgba(255,255,255,0.4)',
                    background: 'rgba(255,255,255,0.1)',
                    fontWeight: 500
                  }} 
                  icon={<CheckCircleIcon sx={{ color: '#34a853 !important' }} />}
                />
                <Chip 
                  label="No Credit Card Required" 
                  variant="outlined" 
                  sx={{ 
                    color: 'white', 
                    borderColor: 'rgba(255,255,255,0.4)',
                    background: 'rgba(255,255,255,0.1)',
                    fontWeight: 500
                  }} 
                  icon={<SecurityIcon sx={{ color: '#4285f4 !important' }} />}
                />
              </Box>
            </Box>
          </Grid>

          {/* Right Side - Registration Form */}
          <Grid item xs={12} md={6}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 4, 
                background: 'rgba(255, 255, 255, 0.98)',
                backdropFilter: 'blur(20px)',
                border: '1px solid rgba(255, 255, 255, 0.3)',
                boxShadow: '0 20px 40px rgba(0,0,0,0.1)'
              }}
            >
              {/* Header */}
              <Box sx={{ textAlign: 'center', mb: 3 }}>
                <AutoJobLogo 
                  variant="icon-only"
                  size="medium"
                  color="primary"
                />
                <Typography 
                  component="h1" 
                  variant="h4" 
                  sx={{ 
                    fontWeight: 600,
                    color: 'text.primary',
                    mb: 0.5,
                    mt: 1
                  }}
                >
                  Create Your Account
                </Typography>
                <Typography 
                  variant="body1" 
                  color="text.secondary"
                  sx={{ mb: 2 }}
                >
                  Join auto-job.ai and accelerate your career today
                </Typography>
              </Box>
              
              {error && (
                <Alert 
                  severity="error" 
                  sx={{ 
                    mb: 3,
                    '& .MuiAlert-icon': {
                      fontSize: '1.25rem'
                    }
                  }}
                >
                  {error}
                </Alert>
              )}
              
              {success && (
                <Alert 
                  severity="success" 
                  sx={{ 
                    mb: 3,
                    '& .MuiAlert-icon': {
                      fontSize: '1.25rem'
                    }
                  }}
                >
                  {success}
                </Alert>
              )}
              
              <Box component="form" onSubmit={handleSubmit}>
                <Grid container spacing={2}>
                  <Grid item xs={12} sm={6}>
                    <TextField
                      required
                      fullWidth
                      id="firstName"
                      label="First Name"
                      name="firstName"
                      autoComplete="given-name"
                      value={formData.firstName}
                      onChange={handleChange}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <PersonIcon color="primary" />
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>
                  <Grid item xs={12} sm={6}>
                    <TextField
                      required
                      fullWidth
                      id="lastName"
                      label="Last Name"
                      name="lastName"
                      autoComplete="family-name"
                      value={formData.lastName}
                      onChange={handleChange}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <PersonIcon color="primary" />
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      required
                      fullWidth
                      id="email"
                      label="Email Address"
                      name="email"
                      autoComplete="email"
                      value={formData.email}
                      onChange={handleChange}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <EmailIcon color="primary" />
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      required
                      fullWidth
                      name="password"
                      label="Password"
                      type={showPassword ? 'text' : 'password'}
                      id="password"
                      autoComplete="new-password"
                      value={formData.password}
                      onChange={handleChange}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <LockIcon color="primary" />
                          </InputAdornment>
                        ),
                        endAdornment: (
                          <InputAdornment position="end">
                            <IconButton
                              aria-label="toggle password visibility"
                              onClick={() => setShowPassword(!showPassword)}
                              edge="end"
                              size="small"
                            >
                              {showPassword ? <VisibilityOff /> : <Visibility />}
                            </IconButton>
                          </InputAdornment>
                        ),
                      }}
                      helperText="At least 8 characters with uppercase, lowercase, number, and special character"
                    />
                    {formData.password && (
                      <Box sx={{ mt: 1 }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                          <Typography variant="caption" color="text.secondary">
                            Password strength:
                          </Typography>
                          <Typography 
                            variant="caption" 
                            color={`${passwordStrength.color}.main`}
                            sx={{ fontWeight: 500 }}
                          >
                            {passwordStrength.label}
                          </Typography>
                        </Box>
                        <LinearProgress 
                          variant="determinate" 
                          value={passwordStrength.score} 
                          color={passwordStrength.color}
                          sx={{ height: 4 }}
                        />
                      </Box>
                    )}
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      required
                      fullWidth
                      name="confirmPassword"
                      label="Confirm Password"
                      type={showConfirmPassword ? 'text' : 'password'}
                      id="confirmPassword"
                      value={formData.confirmPassword}
                      onChange={handleChange}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <LockIcon color="primary" />
                          </InputAdornment>
                        ),
                        endAdornment: (
                          <InputAdornment position="end">
                            <IconButton
                              aria-label="toggle confirm password visibility"
                              onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                              edge="end"
                              size="small"
                            >
                              {showConfirmPassword ? <VisibilityOff /> : <Visibility />}
                            </IconButton>
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>
                </Grid>
                
                <Button
                  type="submit"
                  fullWidth
                  variant="contained"
                  size="large"
                  disabled={loading}
                  sx={{ 
                    mt: 3, 
                    mb: 3,
                    py: 1.5,
                    fontSize: '1rem',
                    fontWeight: 600,
                    background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 100%)',
                    '&:hover': {
                      background: 'linear-gradient(135deg, #1557b0 0%, #3367d6 100%)',
                    },
                    '&:disabled': {
                      background: theme => theme.palette.action.disabledBackground
                    }
                  }}
                >
                  {loading ? (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <CircularProgress size={20} color="inherit" />
                      Creating your account...
                    </Box>
                  ) : (
                    'Create Your Free Account'
                  )}
                </Button>
                
                <Divider sx={{ my: 2 }}>
                  <Typography variant="body2" color="text.secondary">
                    Already have an account?
                  </Typography>
                </Divider>
                
                <Button
                  component={Link}
                  to="/login"
                  fullWidth
                  variant="outlined"
                  size="large"
                  startIcon={<LoginIcon />}
                  sx={{ 
                    py: 1.5,
                    fontSize: '1rem',
                    fontWeight: 500
                  }}
                >
                  Sign In Instead
                </Button>
              </Box>

              {/* Terms and Privacy */}
              <Box sx={{ 
                mt: 3, 
                pt: 3, 
                borderTop: '1px solid',
                borderColor: 'divider',
                textAlign: 'center'
              }}>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                  By creating an account, you agree to our{' '}
                  <Link to="/terms" style={{ color: 'inherit', textDecoration: 'underline' }}>
                    Terms of Service
                  </Link>
                  {' '}and{' '}
                  <Link to="/privacy" style={{ color: 'inherit', textDecoration: 'underline' }}>
                    Privacy Policy
                  </Link>
                </Typography>
                <Box sx={{ 
                  display: 'flex', 
                  justifyContent: 'center', 
                  alignItems: 'center', 
                  gap: 3,
                  flexWrap: 'wrap',
                  mt: 1
                }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <SecurityIcon sx={{ fontSize: 16, color: 'success.main' }} />
                    <Typography variant="caption" color="text.secondary">
                      SSL Encrypted
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                    <Typography variant="caption" color="text.secondary">
                      No Spam Guarantee
                    </Typography>
                  </Box>
                </Box>
              </Box>
            </Paper>
          </Grid>
        </Grid>
      </Container>
    </Box>
  );
};

export default Register;

================
File: src/components/auth/ResetPassword.js
================
import React, { useState } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import { TextField, Button, Typography, Container, Box, Alert, Paper } from '@mui/material';
import { useAuth } from '../../context/AuthContext';

const ResetPassword = () => {
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const { resetPassword, loading } = useAuth();
  const { token } = useParams();
  const navigate = useNavigate();

  const validateForm = () => {
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return false;
    }
    
    const passwordRegex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(password)) {
      setError('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
      return false;
    }
    
    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    
    if (!validateForm()) {
      return;
    }
    
    const result = await resetPassword(token, password);
    
    if (result.success) {
      setSuccess('Your password has been reset successfully.');
      setTimeout(() => {
        navigate('/dashboard');
      }, 3000);
    } else {
      setError(result.error);
    }
  };

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 8 }}>
        <Paper sx={{ p: 4 }}>
          <Typography component="h1" variant="h5" align="center" gutterBottom>
            Reset Password
          </Typography>
          
          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}
          
          {success && (
            <Alert severity="success" sx={{ mb: 2 }}>
              {success}
            </Alert>
          )}
          
          <Box component="form" onSubmit={handleSubmit}>
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="New Password"
              type="password"
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              helperText="At least 8 characters with uppercase, lowercase, number, and special character"
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type="password"
              id="confirmPassword"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? 'Resetting...' : 'Reset Password'}
            </Button>
            <Box sx={{ textAlign: 'center' }}>
              <Link to="/login" style={{ textDecoration: 'none' }}>
                <Typography variant="body2" color="primary">
                  Back to Login
                </Typography>
              </Link>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default ResetPassword;

================
File: src/components/common/AutoJobLogo.js
================
// src/components/common/AutoJobLogo.js
import React from 'react';
import { Box, Typography } from '@mui/material';

/**
 * Shared logo component for auto-job.ai
 * Can be used across the application with different variants and sizes
 */
const AutoJobLogo = ({ 
  variant = 'horizontal', // 'horizontal', 'stacked', 'icon-only'
  size = 'medium', // 'small', 'medium', 'large', 'xlarge'
  showTagline = true,
  customTagline = null,
  color = 'primary', // 'primary', 'white', 'gradient'
  className = '',
  onClick = null,
  sx = {}
}) => {
  // Size configurations
  const sizeConfig = {
    small: {
      icon: 32,
      logoText: '1.25rem',
      taglineText: '0.75rem',
      gap: 1
    },
    medium: {
      icon: 48,
      logoText: '1.75rem',
      taglineText: '0.875rem',
      gap: 1.5
    },
    large: {
      icon: 64,
      logoText: '2.25rem',
      taglineText: '1rem',
      gap: 2
    },
    xlarge: {
      icon: 80,
      logoText: '2.75rem',
      taglineText: '1.125rem',
      gap: 2.5
    }
  };

  const config = sizeConfig[size];

  // Color configurations
  const colorConfig = {
    primary: {
      logoText: (theme) => theme.palette.primary.main,
      taglineText: (theme) => theme.palette.text.secondary,
      robotFill: '#e3f2fd',
      robotStroke: (theme) => theme.palette.primary.main,
      antennaColor: (theme) => theme.palette.success.main,
      eyeColor: (theme) => theme.palette.primary.main,
      mouthColor: (theme) => theme.palette.success.main,
      sidePanelColor: (theme) => theme.palette.warning.main
    },
    white: {
      logoText: '#ffffff',
      taglineText: 'rgba(255, 255, 255, 0.8)',
      robotFill: 'rgba(255, 255, 255, 0.9)',
      robotStroke: '#ffffff',
      antennaColor: '#4caf50',
      eyeColor: '#2196f3',
      mouthColor: '#4caf50',
      sidePanelColor: '#ff9800'
    },
    gradient: {
      logoText: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #34a853 100%)',
      taglineText: (theme) => theme.palette.text.secondary,
      robotFill: '#e3f2fd',
      robotStroke: '#1a73e8',
      antennaColor: '#34a853',
      eyeColor: '#1a73e8',
      mouthColor: '#34a853',
      sidePanelColor: '#fbbc04'
    }
  };

  const colors = colorConfig[color];

  // Robot SVG Component
  const RobotIcon = () => (
    <svg 
      width={config.icon} 
      height={config.icon} 
      viewBox="0 0 64 64" 
      xmlns="http://www.w3.org/2000/svg"
      style={{ display: 'block' }}
    >
      {/* Robot Head Background */}
      <rect 
        x="8" 
        y="12" 
        width="48" 
        height="40" 
        rx="8" 
        ry="8" 
        fill={typeof colors.robotFill === 'function' ? colors.robotFill : colors.robotFill}
        stroke={typeof colors.robotStroke === 'function' ? colors.robotStroke : colors.robotStroke}
        strokeWidth="2"
      />
      
      {/* Antenna */}
      <circle 
        cx="32" 
        cy="8" 
        r="2" 
        fill={colors.antennaColor}
      />
      <line 
        x1="32" 
        y1="10" 
        x2="32" 
        y2="12" 
        stroke={colors.antennaColor}
        strokeWidth="2"
      />
      
      {/* Eyes */}
      <circle cx="22" cy="26" r="4" fill="#ffffff"/>
      <circle cx="42" cy="26" r="4" fill="#ffffff"/>
      <circle cx="22" cy="26" r="2" fill={colors.eyeColor}/>
      <circle cx="42" cy="26" r="2" fill={colors.eyeColor}/>
      
      {/* Mouth */}
      <rect 
        x="26" 
        y="36" 
        width="12" 
        height="6" 
        rx="3" 
        ry="3" 
        fill={colors.mouthColor}
      />
      <rect x="28" y="38" width="2" height="2" fill="#ffffff"/>
      <rect x="32" y="38" width="2" height="2" fill="#ffffff"/>
      <rect x="36" y="38" width="2" height="2" fill="#ffffff"/>
      
      {/* Side panels */}
      <rect 
        x="4" 
        y="20" 
        width="6" 
        height="16" 
        rx="3" 
        ry="3" 
        fill={colors.sidePanelColor}
      />
      <rect 
        x="54" 
        y="20" 
        width="6" 
        height="16" 
        rx="3" 
        ry="3" 
        fill={colors.sidePanelColor}
      />
    </svg>
  );

  // Logo text styles
  const logoTextStyle = {
    fontSize: config.logoText,
    fontWeight: 700,
    lineHeight: 1,
    ...(color === 'gradient' ? {
      background: colors.logoText,
      WebkitBackgroundClip: 'text',
      WebkitTextFillColor: 'transparent',
      backgroundClip: 'text'
    } : {
      color: typeof colors.logoText === 'function' ? colors.logoText : colors.logoText
    })
  };

  const taglineTextStyle = {
    fontSize: config.taglineText,
    fontWeight: 500,
    color: typeof colors.taglineText === 'function' ? colors.taglineText : colors.taglineText,
    mt: 0.5
  };

  // Default tagline
  const taglineText = customTagline || 'Secure interviews faster with AI agents';

  // Render based on variant
  const renderLogo = () => {
    switch (variant) {
      case 'stacked':
        return (
          <Box
            sx={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              gap: config.gap / 2,
              cursor: onClick ? 'pointer' : 'default',
              ...sx
            }}
            className={className}
            onClick={onClick}
          >
            <RobotIcon />
            <Box sx={{ textAlign: 'center' }}>
              <Typography sx={logoTextStyle}>
                auto-job.ai
              </Typography>
              {showTagline && (
                <Typography sx={taglineTextStyle}>
                  {taglineText}
                </Typography>
              )}
            </Box>
          </Box>
        );

      case 'icon-only':
        return (
          <Box
            sx={{
              display: 'inline-flex',
              cursor: onClick ? 'pointer' : 'default',
              ...sx
            }}
            className={className}
            onClick={onClick}
          >
            <RobotIcon />
          </Box>
        );

      case 'horizontal':
      default:
        return (
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              gap: config.gap,
              cursor: onClick ? 'pointer' : 'default',
              ...sx
            }}
            className={className}
            onClick={onClick}
          >
            <RobotIcon />
            <Box>
              <Typography sx={logoTextStyle}>
                auto-job.ai
              </Typography>
              {showTagline && (
                <Typography sx={taglineTextStyle}>
                  {taglineText}
                </Typography>
              )}
            </Box>
          </Box>
        );
    }
  };

  return renderLogo();
};

export default AutoJobLogo;

================
File: src/components/common/GlobalSearch.js
================
// src/components/common/GlobalSearch.js
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  InputBase,
  IconButton,
  Paper,
  Typography,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Divider,
  CircularProgress,
  Tabs,
  Tab,
  Badge,
  useTheme,
  alpha,
  ClickAwayListener,
  Popper,
  Fade,
  ListItemButton
} from '@mui/material';
import {
  Search as SearchIcon,
  Work as WorkIcon,
  Description as DescriptionIcon,
  Person as PersonIcon,
  Clear as ClearIcon,
  History as HistoryIcon,
  TrendingUp as TrendingUpIcon,
  KeyboardArrowRight as KeyboardArrowRightIcon,
  Close as CloseIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import searchService from '../../utils/searchService';
import RecruiterDetails from '../recruiters/RecruiterDetails';

const GlobalSearch = ({ sx = {} }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const [query, setQuery] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [results, setResults] = useState(null);
  const [suggestions, setSuggestions] = useState([]);
  const [recentSearches, setRecentSearches] = useState([]);
  const [popularSearches, setPopularSearches] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const [error, setError] = useState(null);
  const [selectedRecruiter, setSelectedRecruiter] = useState(null);
  const [recruiterModalOpen, setRecruiterModalOpen] = useState(false);
  
  const inputRef = useRef(null);
  const resultsRef = useRef(null);
  const debouncedSearchRef = useRef(null);

  // Search categories
  const categories = searchService.getSearchCategories();

  // Initialize debounced search with dependency on selectedCategory
  useEffect(() => {
    debouncedSearchRef.current = searchService.createDebouncedSearch(
      async (searchQuery) => {
        if (searchQuery.trim().length >= 2) {
          await performSearch(searchQuery);
        } else {
          setResults(null);
          if (searchQuery.length >= 1) {
            await loadSuggestions(searchQuery);
          }
        }
      },
      300
    );
  }, []); // Remove selectedCategory dependency to prevent recreating debounced function

  // Load initial data when search opens
  useEffect(() => {
    if (isOpen) {
      loadInitialData();
    }
  }, [isOpen]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event) => {
      // Global search shortcut (Ctrl/Cmd + K or /)
      if ((event.ctrlKey || event.metaKey) && event.key === 'k' || event.key === '/') {
        event.preventDefault();
        openSearch();
      }
      
      // Escape to close
      if (event.key === 'Escape' && isOpen) {
        closeSearch();
      }
      
      // Arrow navigation
      if (isOpen && results) {
        if (event.key === 'ArrowDown') {
          event.preventDefault();
          navigateResults(1);
        } else if (event.key === 'ArrowUp') {
          event.preventDefault();
          navigateResults(-1);
        } else if (event.key === 'Enter' && selectedIndex >= 0) {
          event.preventDefault();
          selectResult();
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, results, selectedIndex]);

  const loadInitialData = async () => {
    try {
      // Load recent searches
      const recent = searchService.getRecentSearches();
      setRecentSearches(recent);
      
      // Load popular searches
      const popular = await searchService.getPopularSearches();
      setPopularSearches(popular.searches || []);
    } catch (error) {
      console.error('Error loading initial data:', error);
    }
  };

  const loadSuggestions = async (searchQuery) => {
    try {
      const suggestionsData = await searchService.getSuggestions(searchQuery);
      setSuggestions(suggestionsData.suggestions || []);
    } catch (error) {
      console.error('Error loading suggestions:', error);
    }
  };

  const performSearch = async (searchQuery) => {
    try {
      setIsLoading(true);
      const searchResults = await searchService.globalSearch(searchQuery, {
        category: selectedCategory,
        limit: 20
      });
      
      if (searchResults.success) {
        const formattedResults = searchService.formatSearchResults(searchResults.data.results);
        setResults(formattedResults);
        
        // Save to recent searches
        searchService.saveRecentSearch(searchQuery, searchResults.data.results);
      }
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleInputChange = (event) => {
    const value = event.target.value;
    setQuery(value);
    setSelectedIndex(-1);
    
    // Clear previous results when query changes and reset to 'all' category
    if (value.trim().length < 2) {
      setResults(null);
      setError(null);
      // Also clear recruiter modal state when query changes
      setSelectedRecruiter(null);
      setRecruiterModalOpen(false);
      if (value.trim().length === 0) {
        setSelectedCategory('all'); // Reset category when query is completely cleared
      }
    }
    
    if (debouncedSearchRef.current) {
      debouncedSearchRef.current(value);
    }
  };

  const openSearch = () => {
    setIsOpen(true);
    // Don't reset category when opening search - keep user's current tab
    setTimeout(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, 100);
  };

  const closeSearch = () => {
    setIsOpen(false);
    // Don't clear query and results when closing - keep them for when user reopens
    setSelectedIndex(-1);
  };

  const handleRecruiterModalClose = () => {
    setRecruiterModalOpen(false);
    setSelectedRecruiter(null);
    // Don't clear the search results when closing the recruiter modal
    // This keeps the search context intact
  };

  const handleStartOutreach = (recruiter) => {
    // Close the modal and search
    handleRecruiterModalClose();
    closeSearch();
    // Navigate to outreach page or handle outreach
    console.log('Starting outreach for:', recruiter);
    // You can add navigation logic here if needed
  };

  const clearAll = () => {
    setQuery('');
    setResults(null);
    setSuggestions([]);
    setSelectedIndex(-1);
    setError(null);
  };

  const navigateResults = (direction) => {
    if (!results) return;
    
    const currentResults = results[selectedCategory] || [];
    const maxIndex = currentResults.length - 1;
    
    if (direction === 1) {
      setSelectedIndex(prev => prev < maxIndex ? prev + 1 : 0);
    } else {
      setSelectedIndex(prev => prev > 0 ? prev - 1 : maxIndex);
    }
  };

  const selectResult = () => {
    if (!results || selectedIndex < 0) return;
    
    const currentResults = results[selectedCategory] || [];
    const selectedResult = currentResults[selectedIndex];
    
    if (selectedResult) {
      navigate(selectedResult.url);
      closeSearch();
    }
  };

  const handleResultClick = (result) => {
    // Handle recruiter results differently - open modal instead of navigating
    if (result.type === 'recruiter') {
      setSelectedRecruiter(result.id);
      setRecruiterModalOpen(true);
    } else {
      // For jobs and resumes, navigate normally
      navigate(result.url);
      closeSearch();
    }
  };

  const handleCategoryChange = (event, newCategory) => {
    console.log(`🔄 Switching category from ${selectedCategory} to ${newCategory}`);
    const oldCategory = selectedCategory;
    setSelectedCategory(newCategory);
    setSelectedIndex(-1);
    
    // Don't re-search when switching categories - just show the existing results
    // The search was already performed with category 'all', so we have all the data
    console.log(`📊 Showing results for ${newCategory} from existing search results`);
    
    if (results) {
      console.log(`📊 Available results:`, {
        totalCount: results.totalCount,
        jobs: results.jobs?.length || 0,
        resumes: results.resumes?.length || 0,
        recruiters: results.recruiters?.length || 0,
        currentCategory: newCategory,
        resultsForCategory: getResultsForCategory(newCategory).length
      });
    }
  };

  const handleSuggestionClick = (suggestion) => {
    setQuery(suggestion.text);
    performSearch(suggestion.text);
  };

  const handleRecentSearchClick = (recentSearch) => {
    setQuery(recentSearch.query);
    performSearch(recentSearch.query);
  };

  const clearQuery = () => {
    setQuery('');
    setResults(null);
    setSuggestions([]);
    setSelectedIndex(-1);
    setError(null);
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  const getResultIcon = (type) => {
    switch (type) {
      case 'job': return <WorkIcon fontSize="small" />;
      case 'resume': return <DescriptionIcon fontSize="small" />;
      case 'recruiter': return <PersonIcon fontSize="small" />;
      default: return <SearchIcon fontSize="small" />;
    }
  };

  const getResultsForCategory = (category) => {
    if (!results) return [];
    
    // Handle 'all' category by combining results
    if (category === 'all') {
      const allResults = [
        ...(results.jobs || []),
        ...(results.resumes || []),
        ...(results.recruiters || [])
      ];
      
      // Sort by relevance/type
      return allResults.sort((a, b) => {
        // Prioritize by match score if available
        if (a.matchScore && b.matchScore) {
          return b.matchScore - a.matchScore;
        }
        // Then by creation date
        const aDate = new Date(a.createdAt || a.lastActiveDate || 0);
        const bDate = new Date(b.createdAt || b.lastActiveDate || 0);
        return bDate - aDate;
      });
    }
    
    // Return specific category results
    return results[category] || [];
  };

  const getResultCount = (category) => {
    if (!results) return 0;
    return results[category]?.length || 0;
  };

  const renderEmptyState = () => {
    if (query.trim().length === 0) {
      return (
        <Box sx={{ p: 3 }}>
          {/* Recent Searches */}
          {recentSearches.length > 0 && (
            <Box sx={{ mb: 3 }}>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <HistoryIcon fontSize="small" sx={{ mr: 1 }} />
                Recent Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {recentSearches.slice(0, 5).map((search, index) => (
                  <Chip
                    key={index}
                    label={search.query}
                    size="small"
                    onClick={() => handleRecentSearchClick(search)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
          
          {/* Popular Searches */}
          {popularSearches.length > 0 && (
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <TrendingUpIcon fontSize="small" sx={{ mr: 1 }} />
                Popular Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {popularSearches.slice(0, 6).map((search, index) => (
                  <Chip
                    key={index}
                    label={search}
                    size="small"
                    variant="outlined"
                    onClick={() => handleSuggestionClick({ text: search })}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
          
          {/* Keyboard Shortcuts */}
          <Box sx={{ mt: 3, pt: 2, borderTop: '1px solid', borderColor: 'divider' }}>
            <Typography variant="caption" color="text.secondary">
              Tip: Use <kbd>/</kbd> or <kbd>Ctrl+K</kbd> to search from anywhere
            </Typography>
          </Box>
        </Box>
      );
    }

    if (query.trim().length >= 2 && results && results.totalCount === 0) {
      return (
        <Box sx={{ p: 3, textAlign: 'center' }}>
          <SearchIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2 }} />
          <Typography variant="h6" gutterBottom>
            No results found
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Try different keywords or check spelling
          </Typography>
          
          {/* Suggestions */}
          {suggestions.length > 0 && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Did you mean:
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, justifyContent: 'center' }}>
                {suggestions.map((suggestion, index) => (
                  <Chip
                    key={index}
                    label={suggestion.text}
                    size="small"
                    onClick={() => handleSuggestionClick(suggestion)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
        </Box>
      );
    }

    return null;
  };

  const renderResults = () => {
    if (!results || results.totalCount === 0) {
      return renderEmptyState();
    }

    const currentResults = results[selectedCategory] || [];

    return (
      <Box>
        {/* Category Tabs */}
        <Tabs
          value={selectedCategory}
          onChange={handleCategoryChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{ borderBottom: 1, borderColor: 'divider', px: 2 }}
        >
          {categories.map((category) => (
            <Tab
              key={category.value}
              value={category.value}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  {category.label}
                  {getResultCount(category.value) > 0 && (
                    <Badge
                      badgeContent={getResultCount(category.value)}
                      color="primary"
                      sx={{
                        '& .MuiBadge-badge': {
                          fontSize: '0.7rem',
                          height: 16,
                          minWidth: 16
                        }
                      }}
                    />
                  )}
                </Box>
              }
            />
          ))}
        </Tabs>

        {/* Results List */}
        <List sx={{ maxHeight: 400, overflow: 'auto' }}>
          {currentResults.map((result, index) => {
            const isSelected = index === selectedIndex;
            const typeDisplay = searchService.getResultTypeDisplay(result.type);
            
            return (
              <ListItemButton
                key={`${result.type}-${result.id}`}
                selected={isSelected}
                onClick={() => handleResultClick(result)}
                sx={{
                  py: 1.5,
                  '&.Mui-selected': {
                    backgroundColor: alpha(theme.palette.primary.main, 0.08),
                  }
                }}
              >
                <ListItemIcon sx={{ minWidth: 40 }}>
                  <Box
                    sx={{
                      width: 32,
                      height: 32,
                      borderRadius: 1,
                      backgroundColor: alpha(typeDisplay.color, 0.1),
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      color: typeDisplay.color
                    }}
                  >
                    {getResultIcon(result.type)}
                  </Box>
                </ListItemIcon>
                
                <ListItemText
                  primary={
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>
                        {result.title}
                      </Typography>
                      {result.matchScore && (
                        <Chip
                          label={`${result.matchScore}% match`}
                          size="small"
                          color={result.matchScore >= 80 ? 'success' : result.matchScore >= 60 ? 'info' : 'warning'}
                          sx={{ height: 20, fontSize: '0.7rem' }}
                        />
                      )}
                      {result.isActive && (
                        <Chip
                          label="Active"
                          size="small"
                          color="success"
                          sx={{ height: 20, fontSize: '0.7rem' }}
                        />
                      )}
                    </Box>
                  }
                  secondary={
                    <Box>
                      <Typography variant="caption" color="text.secondary">
                        {result.subtitle}
                      </Typography>
                      {result.description && (
                        <Typography variant="caption" display="block" color="text.secondary">
                          {result.description}
                        </Typography>
                      )}
                      {result.skills && result.skills.length > 0 && (
                        <Box sx={{ mt: 0.5, display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                          {result.skills.slice(0, 3).map((skill, skillIndex) => (
                            <Chip
                              key={skillIndex}
                              label={typeof skill === 'string' ? skill : skill.name}
                              size="small"
                              variant="outlined"
                              sx={{ height: 18, fontSize: '0.65rem' }}
                            />
                          ))}
                          {result.skills.length > 3 && (
                            <Typography variant="caption" color="text.secondary">
                              +{result.skills.length - 3} more
                            </Typography>
                          )}
                        </Box>
                      )}
                    </Box>
                  }
                />
                
                <KeyboardArrowRightIcon fontSize="small" color="action" />
              </ListItemButton>
            );
          })}
        </List>
      </Box>
    );
  };

  return (
    <>
      <ClickAwayListener onClickAway={() => {
        if (isOpen) {
          closeSearch();
        }
      }}>
        <Box sx={{ position: 'relative', ...sx }}>
          {/* Search Input */}
          <Box
            sx={{
              display: 'flex',
              position: 'relative',
              borderRadius: 2,
              backgroundColor: alpha(theme.palette.common.black, 0.04),
              '&:hover': {
                backgroundColor: alpha(theme.palette.common.black, 0.06),
              },
              '&:focus-within': {
                backgroundColor: alpha(theme.palette.primary.main, 0.08),
                outline: `2px solid ${alpha(theme.palette.primary.main, 0.2)}`,
              },
              width: '100%',
              maxWidth: { xs: '100%', sm: 400, md: 500 },
              transition: 'all 0.2s ease-in-out',
            }}
          >
            <IconButton 
              sx={{ 
                p: 1.5,
                color: 'text.secondary',
                '&:hover': {
                  color: 'primary.main'
                }
              }} 
              aria-label="search"
              onClick={openSearch}
            >
              <SearchIcon />
            </IconButton>
            
            <InputBase
              ref={inputRef}
              placeholder="Search jobs, companies, skills..."
              value={query}
              onChange={handleInputChange}
              onFocus={openSearch}
              sx={{
                color: 'text.primary',
                flex: 1,
                '& .MuiInputBase-input': {
                  padding: theme.spacing(1.5, 1, 1.5, 0),
                  width: '100%',
                  fontSize: '0.95rem',
                  '&::placeholder': {
                    color: 'text.secondary',
                    opacity: 0.7
                  }
                },
              }}
            />
            
            {isLoading && (
              <Box sx={{ display: 'flex', alignItems: 'center', pr: 1 }}>
                <CircularProgress size={20} />
              </Box>
            )}
            
            {query && !isLoading && (
              <IconButton
                onClick={clearQuery}
                size="small"
                sx={{ mr: 1 }}
              >
                <ClearIcon fontSize="small" />
              </IconButton>
            )}
          </Box>

          {/* Search Results Dropdown */}
          {isOpen && (
            <Paper
              ref={resultsRef}
              elevation={8}
              sx={{
                position: 'absolute',
                top: '100%',
                left: 0,
                right: 0,
                mt: 1,
                maxHeight: 500,
                overflow: 'hidden',
                boxShadow: '0 8px 32px rgba(0,0,0,0.12)',
                border: '1px solid',
                borderColor: 'divider',
                zIndex: theme.zIndex.modal + 1,
                width: inputRef.current?.offsetWidth || '100%'
              }}
            >
              {/* Close button for mobile */}
              <Box sx={{ 
                display: { xs: 'block', md: 'none' },
                p: 1,
                borderBottom: '1px solid',
                borderColor: 'divider'
              }}>
                <IconButton
                  onClick={closeSearch}
                  size="small"
                  sx={{ float: 'right' }}
                >
                  <CloseIcon />
                </IconButton>
                <Typography variant="subtitle2" sx={{ pt: 1 }}>
                  Search Results
                </Typography>
              </Box>

              {renderResults()}
            </Paper>
          )}
        </Box>
      </ClickAwayListener>

      {/* Recruiter Details Modal */}
      <RecruiterDetails
        open={recruiterModalOpen}
        onClose={handleRecruiterModalClose}
        recruiterId={selectedRecruiter}
        onStartOutreach={handleStartOutreach}
      />
    </>
  );
};

export default GlobalSearch;

================
File: src/components/common/PageHeader.js
================
// src/components/common/PageHeader.js
import React from 'react';
import { Typography, Box, Paper, Breadcrumbs, Link } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';

const PageHeader = ({ title, breadcrumbs }) => {
  return (
    <Paper 
      elevation={0} 
      sx={{ 
        backgroundColor: 'background.default', 
        padding: 2, 
        marginBottom: 3,
        borderRadius: 1
      }}
    >
      <Typography variant="h4" component="h1" gutterBottom>
        {title}
      </Typography>
      
      {breadcrumbs && (
        <Breadcrumbs aria-label="breadcrumb">
          <Link component={RouterLink} to="/" color="inherit">
            Dashboard
          </Link>
          {breadcrumbs.map((crumb, index) => (
            <React.Fragment key={index}>
              {index === breadcrumbs.length - 1 ? (
                <Typography color="text.primary">{crumb.label}</Typography>
              ) : (
                <Link component={RouterLink} to={crumb.link} color="inherit">
                  {crumb.label}
                </Link>
              )}
            </React.Fragment>
          ))}
        </Breadcrumbs>
      )}
    </Paper>
  );
};

export default PageHeader;

================
File: src/components/Dashboard.js
================
// src/components/Dashboard.js - Redesigned Dashboard
import React, { useState, useEffect, useContext } from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  LinearProgress,
  Chip,
  useTheme,
  Paper,
  Alert,
  Skeleton,
  Avatar,
} from '@mui/material';
import {
  Description as DescriptionIcon,
  Work as WorkIcon,
  Assignment as AssignmentIcon,
  CheckCircle as CheckCircleIcon,
  Search as SearchIcon,
  People as PeopleIcon,
  Speed as SpeedIcon,
  AutoAwesome as AutoAwesomeIcon,
  Send as SendIcon,
  SmartToy as SmartToyIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';
import MainLayout from './layout/MainLayout';
import AutoJobLogo from './common/AutoJobLogo';
import resumeService from '../utils/resumeService';
import jobService from '../utils/jobService';

const Dashboard = () => {
  const theme = useTheme();
  const { currentUser } = useContext(AuthContext);
  const navigate = useNavigate();
  
  // State management
  const [loading, setLoading] = useState(true);
  const [resumes, setResumes] = useState([]);
  const [jobs, setJobs] = useState([]);
  const [stats, setStats] = useState({
    resumeCount: 0,
    jobMatches: 0,
    applications: 0,
    resumeScore: 0,
    hasActiveResume: false,
    hasAnalyzedResumes: false
  });

  // Load dashboard data
  useEffect(() => {
    const loadDashboardData = async () => {
      try {
        setLoading(true);
        
        // Load resumes and jobs in parallel
        const [resumesData, jobsData] = await Promise.all([
          resumeService.getUserResumes().catch(() => []),
          jobService.getUserJobs().catch(() => [])
        ]);
        
        setResumes(resumesData);
        setJobs(jobsData);
        
        // Calculate stats
        const activeResume = resumesData.find(r => r.isActive);
        const completedJobs = jobsData.filter(j => j.analysisStatus?.status === 'completed');
        const applications = jobsData.filter(j => j.applicationStatus && j.applicationStatus !== 'Not Applied');
        
        // Calculate average resume score from all analyzed resumes
        let resumeScore = 0;
        const analyzedResumes = resumesData.filter(r => r.analysis?.overallScore);
        if (analyzedResumes.length > 0) {
          const totalScore = analyzedResumes.reduce((sum, r) => sum + r.analysis.overallScore, 0);
          resumeScore = Math.round(totalScore / analyzedResumes.length);
        }
        
        setStats({
          resumeCount: resumesData.length,
          jobMatches: completedJobs.length,
          applications: applications.length,
          resumeScore: resumeScore,
          hasActiveResume: !!activeResume
        });
        
      } catch (error) {
        console.error('Error loading dashboard data:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadDashboardData();
  }, []);

  // Get user's first name
  const firstName = currentUser?.firstName || 'there';
  
  // Determine user journey stage
  const isFirstTimeUser = stats.resumeCount === 0;
  const hasResumes = stats.resumeCount > 0;
  const hasJobs = stats.jobMatches > 0;
  const hasApplications = stats.applications > 0;

  // Get contextual message based on user journey
  const getContextualMessage = () => {
    if (isFirstTimeUser) {
      return {
        title: `Welcome to auto-job.ai, ${firstName}!`,
        message: "Let's get you started! Upload your resume and I'll analyze it with AI to help you find perfect job matches and optimize your applications."
      };
    }
    
    if (!stats.hasAnalyzedResumes) {
      return {
        title: `Hi ${firstName}! Let's analyze your resumes`,
        message: "I see you have resumes uploaded. Let me analyze them with AI to identify strengths, weaknesses, and optimization opportunities for better job matches."
      };
    }
    
    if (stats.resumeScore > 0 && stats.resumeScore < 70) {
      return {
        title: `Hi ${firstName}! Your resume shows potential`,
        message: `Your average resume score is ${stats.resumeScore}/100. Let's work together to boost that score and find you better job opportunities!`
      };
    }
    
    if (stats.resumeScore >= 70 && stats.resumeScore < 85 && !hasJobs) {
      return {
        title: `Great progress, ${firstName}! Ready to find jobs?`,
        message: `Your resumes average ${stats.resumeScore}/100 - solid! Now let's put my AI agents to work finding you the perfect job matches.`
      };
    }

    if (stats.resumeScore >= 85 && !hasJobs) {
      return {
        title: `Excellent work, ${firstName}! Time to hunt for jobs`,
        message: `Your resumes average ${stats.resumeScore}/100 - outstanding! With scores like these, let's find you some amazing opportunities.`
      };
    }
    
    if (hasJobs && !hasApplications) {
      return {
        title: `Perfect timing, ${firstName}!`,
        message: `I found ${stats.jobMatches} job matches for you! Ready to start applying? I can help you tailor your applications for better results.`
      };
    }
    
    if (hasApplications && stats.applications < 10) {
      return {
        title: `You're building momentum, ${firstName}!`,
        message: `You've applied to ${stats.applications} positions - great start! Let's keep the applications flowing and find even more opportunities.`
      };
    }
    
    return {
      title: `You're crushing it, ${firstName}!`,
      message: `With ${stats.applications} applications and ${stats.jobMatches} matches, you're in full job-hunting mode! I'm continuously finding new opportunities that match your profile.`
    };
  };

  // Welcome Speech Bubble Component
  const WelcomeSpeechBubble = () => {
    const contextMessage = getContextualMessage();
    
    return (
      <Paper
        elevation={0}
        sx={{
          p: 3,
          mb: 4,
          background: `linear-gradient(135deg, ${theme.palette.primary.main}12 0%, ${theme.palette.secondary.main}08 100%)`,
          border: `2px solid ${theme.palette.primary.main}25`,
          borderRadius: 3,
          position: 'relative',
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 2 }}>
          <Box sx={{ flexShrink: 0, mt: 0.5 }}>
            <AutoJobLogo variant="icon-only" size="medium" />
          </Box>
          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" gutterBottom sx={{ fontWeight: 600, color: 'primary.main' }}>
              {contextMessage.title}
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ lineHeight: 1.6 }}>
              {contextMessage.message}
            </Typography>
          </Box>
        </Box>
      </Paper>
    );
  };

  // Progress Steps Component
  const ProgressSteps = () => {
    const steps = [
      {
        id: 'upload',
        title: 'Upload Resume',
        description: 'Add your resume files',
        completed: hasResumes,
        action: () => navigate('/resumes'),
        icon: <DescriptionIcon />,
        actionText: hasResumes ? 'Add More Resumes' : 'Upload Resume'
      },
      {
        id: 'analyze',
        title: 'Analysis',
        description: 'Get resume insights',
        completed: stats.hasAnalyzedResumes,
        action: () => navigate('/resumes'),
        icon: <AutoAwesomeIcon />,
        actionText: stats.hasAnalyzedResumes ? 'View Analysis' : 'Analyze Resumes'
      },
      {
        id: 'search',
        title: 'Find Jobs',
        description: 'Discover opportunities',
        completed: hasJobs,
        action: () => hasJobs ? navigate('/jobs') : navigate('/jobs/ai-searches'),
        icon: <SearchIcon />,
        actionText: hasJobs ? 'View Matches' : 'Start Job Search'
      },
      {
        id: 'apply',
        title: 'Apply & Track',
        description: 'Submit applications',
        completed: hasApplications,
        action: () => navigate('/jobs'),
        icon: <SendIcon />,
        actionText: hasApplications ? 'Track Applications' : 'Start Applying'
      }
    ];

    const completedSteps = steps.filter(s => s.completed).length;
    const progressPercentage = (completedSteps / steps.length) * 100;

    return (
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h6" sx={{ fontWeight: 600 }}>
              Your Journey Progress
            </Typography>
            <Chip 
              label={`${completedSteps}/${steps.length} Complete`}
              color={completedSteps === steps.length ? 'success' : 'primary'}
              variant="outlined"
              size="small"
            />
          </Box>
          
          <LinearProgress 
            variant="determinate" 
            value={progressPercentage} 
            sx={{ 
              height: 8, 
              borderRadius: 4, 
              mb: 3,
              backgroundColor: theme.palette.grey[200],
              '& .MuiLinearProgress-bar': {
                borderRadius: 4,
                background: `linear-gradient(90deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`
              }
            }} 
          />
          
          <Grid container spacing={2}>
            {steps.map((step, index) => (
              <Grid item xs={12} sm={6} md={3} key={step.id}>
                <Box
                  sx={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    p: 2,
                    height: 140, // Fixed height for consistency
                    borderRadius: 2,
                    backgroundColor: step.completed ? 'success.main' : 'background.paper',
                    color: step.completed ? 'white' : 'text.primary',
                    border: step.completed ? 'none' : `2px solid ${theme.palette.grey[200]}`,
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    '&:hover': {
                      transform: 'translateY(-2px)',
                      boxShadow: theme.shadows[4],
                      borderColor: step.completed ? 'transparent' : theme.palette.primary.main,
                      backgroundColor: step.completed ? 'success.dark' : 'background.paper'
                    }
                  }}
                  onClick={step.action}
                >
                  <Box sx={{ color: step.completed ? 'white' : theme.palette.primary.main, mb: 1 }}>
                    {step.completed ? <CheckCircleIcon /> : step.icon}
                  </Box>
                  
                  <Box sx={{ textAlign: 'center', flex: 1 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 600, mb: 0.5 }}>
                      {step.title}
                    </Typography>
                    <Typography variant="caption" sx={{ opacity: 0.8, display: 'block', mb: 1 }}>
                      {step.description}
                    </Typography>
                  </Box>
                  
                  {!step.completed && (
                    <Button
                      size="small"
                      variant="text"
                      sx={{ 
                        fontSize: '0.7rem', 
                        minHeight: 'auto',
                        py: 0.5,
                        px: 1,
                        color: 'primary.main',
                        '&:hover': {
                          backgroundColor: 'primary.main',
                          color: 'white'
                        }
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        step.action();
                      }}
                    >
                      {step.actionText}
                    </Button>
                  )}
                </Box>
              </Grid>
            ))}
          </Grid>
        </CardContent>
      </Card>
    );
  };

  // Stats Overview for existing users
  const StatsOverview = () => {
    if (isFirstTimeUser) return null;

    return (
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <SpeedIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.resumeScore}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Resume Score
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.info.main} 0%, ${theme.palette.info.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <WorkIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.jobMatches}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Job Matches
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.success.main} 0%, ${theme.palette.success.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <AssignmentIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.applications}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Applications
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.secondary.main} 0%, ${theme.palette.secondary.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <DescriptionIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.resumeCount}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Resumes
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    );
  };

  // Feature Discovery Component
  const FeatureDiscovery = () => (
    <Card sx={{ mb: 3 }}>
      <CardContent>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <AutoJobLogo variant="icon-only" size="small" sx={{ mr: 1 }} />
          <Typography variant="h6" sx={{ fontWeight: 600 }}>
            AI-Powered Features
          </Typography>
        </Box>
        <Grid container spacing={2}>
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
              <Avatar sx={{ bgcolor: 'primary.main', width: 32, height: 32, mr: 2, mt: 0.5 }}>
                <AutoAwesomeIcon fontSize="small" />
              </Avatar>
              <Box>
                <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                  Smart Resume Analysis
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  AI analyzes your resume and suggests improvements for better job matches
                </Typography>
              </Box>
            </Box>
          </Grid>
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
              <Avatar sx={{ bgcolor: 'secondary.main', width: 32, height: 32, mr: 2, mt: 0.5 }}>
                <SearchIcon fontSize="small" />
              </Avatar>
              <Box>
                <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                  Intelligent Job Discovery
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Our AI agents continuously search for jobs that match your profile
                </Typography>
              </Box>
            </Box>
          </Grid>
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
              <Avatar sx={{ bgcolor: 'success.main', width: 32, height: 32, mr: 2, mt: 0.5 }}>
                <PeopleIcon fontSize="small" />
              </Avatar>
              <Box>
                <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                  Recruiter Outreach
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Connect directly with recruiters and hiring managers in your field
                </Typography>
              </Box>
            </Box>
          </Grid>
        </Grid>
      </CardContent>
    </Card>
  );

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Skeleton variant="rectangular" height={120} sx={{ borderRadius: 3, mb: 3 }} />
          <Skeleton variant="rectangular" height={200} sx={{ borderRadius: 2, mb: 3 }} />
          <Grid container spacing={3}>
            {[...Array(4)].map((_, i) => (
              <Grid item xs={12} sm={6} md={3} key={i}>
                <Skeleton variant="rectangular" height={150} sx={{ borderRadius: 2 }} />
              </Grid>
            ))}
          </Grid>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <WelcomeSpeechBubble />
        
        {!isFirstTimeUser && <StatsOverview />}
        
        <ProgressSteps />
        
        {!isFirstTimeUser && <FeatureDiscovery />}
        
        {/* First-time user special prompt */}
        {isFirstTimeUser && (
          <Alert 
            severity="info" 
            sx={{ 
              mb: 3,
              borderRadius: 2,
              '& .MuiAlert-icon': {
                fontSize: 28
              }
            }}
            action={
              <Button 
                color="inherit" 
                size="small" 
                onClick={() => navigate('/resumes')}
                sx={{ fontWeight: 600 }}
              >
                Upload Now
              </Button>
            }
          >
            <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
              Ready to get started?
            </Typography>
            Upload your resume to unlock AI-powered job matching, resume optimization, and recruiter connections.
          </Alert>
        )}
      </Box>
    </MainLayout>
  );
};

export default Dashboard;

================
File: src/components/jobs/AiSearchesPage.js
================
// src/components/jobs/AiSearchesPage.js
import React, { useState } from 'react';
import {
  Box,
  Typography,
  Button,
  CircularProgress,
  Alert,
  Grid,
  Snackbar
} from '@mui/material';
import {
  SmartToy as SmartToyIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import MainLayout from '../layout/MainLayout';
import PageHeader from '../common/PageHeader';
import { useAiSearches } from './hooks/useAiSearches';
import EmptySearchState from './components/EmptySearchState';
import AiSearchSummaryCards from './components/AiSearchSummaryCards';
import AiSearchTable from './components/AiSearchTable';
import AiSearchDetailsDialog from './components/AiSearchDetailsDialog';
import AiSearchDeleteDialog from './components/AiSearchDeleteDialog';

const AiSearchesPage = () => {
  const navigate = useNavigate();
  const {
    searches,
    loading,
    error,
    actionLoading,
    setError,
    fetchSearches,
    handlePauseResume,
    handleDelete
  } = useAiSearches();

  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [selectedSearch, setSelectedSearch] = useState(null);
  const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
  const [expandedRows, setExpandedRows] = useState({});
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  const toggleRowExpansion = (searchId) => {
    setExpandedRows(prev => ({
      ...prev,
      [searchId]: !prev[searchId]
    }));
  };

  const showSnackbar = (message, severity) => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };

  const handleCloseSnackbar = () => {
    setSnackbar({
      ...snackbar,
      open: false
    });
  };

  const openDeleteDialog = (search) => {
    setSelectedSearch(search);
    setDeleteDialogOpen(true);
  };

  const closeDeleteDialog = () => {
    setDeleteDialogOpen(false);
    setSelectedSearch(null);
  };

  const openDetailsDialog = (search) => {
    setSelectedSearch(search);
    setDetailsDialogOpen(true);
  };

  const closeDetailsDialog = () => {
    setDetailsDialogOpen(false);
    setSelectedSearch(null);
  };

  const handlePauseResumeWithFeedback = async (searchId, currentStatus) => {
    const result = await handlePauseResume(searchId, currentStatus);
    if (result) {
      showSnackbar(result.message, result.success ? 'success' : 'error');
    }
  };

  const handleDeleteWithFeedback = async () => {
    if (!selectedSearch) return;
    
    const result = await handleDelete(selectedSearch._id);
    if (result) {
      showSnackbar(result.message, result.success ? 'success' : 'error');
      if (result.success) {
        closeDeleteDialog();
      }
    }
  };

  const handleStartSearch = () => {
    navigate('/jobs');
  };

  const handleViewJobs = () => {
    closeDetailsDialog();
    navigate('/jobs');
  };

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', height: '60vh' }}>
          <CircularProgress size={60} thickness={4} color="primary" />
          <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
            Loading your AI searches...
          </Typography>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      {/* Removed maxWidth constraint to match other pages */}
      <Box sx={{ p: 3 }}>
        <PageHeader
          title="Agent Job Searches"
          subtitle="Manage your automated AI job searches"
          icon={<SmartToyIcon />}
          action={
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={fetchSearches}
              >
                Refresh
              </Button>
              <Button
                variant="contained"
                color="primary"
                onClick={() => navigate('/jobs')}
              >
                View Jobs
              </Button>
            </Box>
          }
        />

        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError('')}>
            {error}
          </Alert>
        )}

        {searches.length === 0 ? (
          <EmptySearchState onStartSearch={handleStartSearch} />
        ) : (
          <Grid container spacing={3}>
            {/* Summary Cards */}
            <Grid item xs={12}>
              <AiSearchSummaryCards searches={searches} />
            </Grid>

            {/* Enhanced Searches Table */}
            <Grid item xs={12}>
              <AiSearchTable
                searches={searches}
                expandedRows={expandedRows}
                onToggleExpansion={toggleRowExpansion}
                onPauseResume={handlePauseResumeWithFeedback}
                onDelete={openDeleteDialog}
                onViewDetails={openDetailsDialog}
                actionLoading={actionLoading}
              />
            </Grid>
          </Grid>
        )}

        {/* Delete Confirmation Dialog */}
        <AiSearchDeleteDialog
          open={deleteDialogOpen}
          onClose={closeDeleteDialog}
          onConfirm={handleDeleteWithFeedback}
          selectedSearch={selectedSearch}
          isLoading={actionLoading[selectedSearch?._id]}
        />

        {/* Enhanced Details Dialog */}
        <AiSearchDetailsDialog
          open={detailsDialogOpen}
          onClose={closeDetailsDialog}
          selectedSearch={selectedSearch}
          onViewJobs={handleViewJobs}
        />

        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={handleCloseSnackbar}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        >
          <Alert 
            onClose={handleCloseSnackbar} 
            severity={snackbar.severity}
            variant="filled"
            sx={{ width: '100%' }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </Box>
    </MainLayout>
  );
};

export default AiSearchesPage;

================
File: src/components/jobs/components/AiReasoningLogs.js
================
// src/components/jobs/components/AiReasoningLogs.js
import React from 'react';
import {
  Box,
  Typography,
  Paper,
  Stack,
  Avatar,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  useTheme
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  AccessTime as TimeIcon,
  Speed as SpeedIcon,
  ExpandMore as ExpandMoreIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';
import { getReasoningIcon, getReasoningColor, formatDate, formatDuration } from '../utils/searchUtils';

const AiReasoningLogs = ({ search }) => {
  const theme = useTheme();

  if (!search.reasoningLogs || search.reasoningLogs.length === 0) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography variant="body2" color="text.secondary">
          No reasoning logs available for this search yet.
        </Typography>
      </Box>
    );
  }

  // Sort logs by timestamp, most recent first
  const sortedLogs = [...search.reasoningLogs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  
  return (
    <Box sx={{ maxHeight: 400, overflow: 'auto', p: 2 }}>
      <Stack spacing={2}>
        {sortedLogs.slice(0, 10).map((log, index) => (
          <Paper 
            key={index}
            elevation={1} 
            sx={{ 
              p: 2.5, 
              backgroundColor: log.success === false ? 'rgba(234, 67, 53, 0.04)' : 
                             log.success === true ? 'rgba(52, 168, 83, 0.04)' : 
                             'rgba(0, 0, 0, 0.02)',
              border: `1px solid ${log.success === false ? 'rgba(234, 67, 53, 0.2)' : 
                                  log.success === true ? 'rgba(52, 168, 83, 0.2)' : 
                                  theme.palette.divider}`,
              borderRadius: 2,
              position: 'relative',
              transition: 'all 0.2s ease-in-out',
              '&:hover': {
                backgroundColor: log.success === false ? 'rgba(234, 67, 53, 0.06)' : 
                               log.success === true ? 'rgba(52, 168, 83, 0.06)' : 
                               'rgba(26, 115, 232, 0.02)',
                borderColor: log.success === false ? 'rgba(234, 67, 53, 0.3)' : 
                            log.success === true ? 'rgba(52, 168, 83, 0.3)' : 
                            'rgba(26, 115, 232, 0.2)',
                transform: 'translateY(-1px)',
                boxShadow: '0px 6px 12px rgba(0, 0, 0, 0.08)'
              }
            }}
          >
            {/* Custom Timeline Connection Line */}
            {index < sortedLogs.slice(0, 10).length - 1 && (
              <Box sx={{
                position: 'absolute',
                left: 18,
                top: 50,
                bottom: -16,
                width: 2,
                backgroundColor: theme.palette.divider,
                zIndex: 0
              }} />
            )}

            <Box sx={{ display: 'flex', gap: 2, position: 'relative', zIndex: 1 }}>
              {/* Custom Avatar Timeline Dot */}
              <Avatar sx={{ 
                width: 36, 
                height: 36,
                backgroundColor: getReasoningColor(log.phase, log.success, theme),
                border: `2px solid ${theme.palette.background.paper}`,
                boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                '& .MuiSvgIcon-root': {
                  color: theme.palette.background.paper,
                  fontSize: '18px'
                }
              }}>
                {getReasoningIcon(log.phase)}
              </Avatar>

              <Box sx={{ flex: 1, minWidth: 0 }}>
                {/* Header with phase, success indicator, and timestamp */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <Typography variant="subtitle2" sx={{ 
                      fontWeight: 600,
                      color: log.success === false ? theme.palette.error.main : 
                             log.success === true ? theme.palette.success.main : 
                             theme.palette.text.primary
                    }}>
                      {log.phase ? log.phase.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown Phase'}
                    </Typography>
                    {log.success === true && (
                      <CheckCircleIcon sx={{ fontSize: '16px', color: theme.palette.success.main }} />
                    )}
                    {log.success === false && (
                      <ErrorIcon sx={{ fontSize: '16px', color: theme.palette.error.main }} />
                    )}
                  </Box>
                  <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                      <TimeIcon sx={{ fontSize: '12px', color: 'text.secondary' }} />
                      <Typography variant="caption" color="text.secondary">
                        {formatDate(log.timestamp)}
                      </Typography>
                    </Box>
                    {log.duration && log.duration > 0 && (
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mt: 0.5 }}>
                        <SpeedIcon sx={{ fontSize: '12px', color: 'text.secondary' }} />
                        <Typography variant="caption" color="text.secondary">
                          {formatDuration(log.duration)}
                        </Typography>
                      </Box>
                    )}
                  </Box>
                </Box>

                {/* Message */}
                <Typography variant="body2" sx={{ 
                  mb: 1.5, 
                  lineHeight: 1.5,
                  color: log.success === false ? theme.palette.error.dark : theme.palette.text.primary
                }}>
                  {log.message}
                </Typography>
                
                {/* Details/Metadata Accordion */}
                {((log.details && Object.keys(log.details).length > 0) || 
                  (log.metadata && Object.keys(log.metadata).length > 0)) && (
                  <Accordion 
                    elevation={0} 
                    sx={{ 
                      backgroundColor: 'transparent',
                      '&:before': { display: 'none' },
                      '& .MuiAccordionSummary-root': {
                        minHeight: 'auto',
                        padding: 0,
                        '& .MuiAccordionSummary-content': { 
                          margin: '8px 0',
                          '&.Mui-expanded': { margin: '8px 0' }
                        }
                      }
                    }}
                  >
                    <AccordionSummary
                      expandIcon={<ExpandMoreIcon sx={{ fontSize: '18px', color: theme.palette.primary.main }} />}
                    >
                      <Typography variant="caption" color="primary.main" sx={{ fontWeight: 500 }}>
                        View Technical Details
                      </Typography>
                    </AccordionSummary>
                    <AccordionDetails sx={{ pt: 0, pb: 1 }}>
                      {log.details && Object.keys(log.details).length > 0 && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="caption" fontWeight={600} color="primary.main">
                            Details:
                          </Typography>
                          <Box component="pre" sx={{ 
                            fontSize: '0.75rem', 
                            backgroundColor: theme.palette.background.default, 
                            p: 1.5, 
                            borderRadius: 1,
                            overflow: 'auto',
                            maxHeight: 150,
                            fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                            whiteSpace: 'pre-wrap',
                            lineHeight: 1.4,
                            border: `1px solid ${theme.palette.divider}`,
                            mt: 1
                          }}>
                            {JSON.stringify(log.details, null, 2)}
                          </Box>
                        </Box>
                      )}
                      
                      {log.metadata && Object.keys(log.metadata).length > 0 && (
                        <Box>
                          <Typography variant="caption" fontWeight={600} color="secondary.main">
                            Metadata:
                          </Typography>
                          <Box component="pre" sx={{ 
                            fontSize: '0.75rem', 
                            backgroundColor: theme.palette.background.default, 
                            p: 1.5, 
                            borderRadius: 1,
                            overflow: 'auto',
                            maxHeight: 150,
                            fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                            whiteSpace: 'pre-wrap',
                            lineHeight: 1.4,
                            border: `1px solid ${theme.palette.divider}`,
                            mt: 1
                          }}>
                            {JSON.stringify(log.metadata, null, 2)}
                          </Box>
                        </Box>
                      )}
                    </AccordionDetails>
                  </Accordion>
                )}
              </Box>
            </Box>
          </Paper>
        ))}
      </Stack>
      
      {sortedLogs.length > 10 && (
        <Box sx={{ textAlign: 'center', mt: 3, p: 2 }}>
          <Typography variant="caption" color="text.secondary" sx={{ 
            fontStyle: 'italic',
            backgroundColor: theme.palette.background.default,
            px: 2,
            py: 1,
            borderRadius: 1,
            border: `1px dashed ${theme.palette.divider}`
          }}>
            Showing latest 10 of {sortedLogs.length} reasoning logs
          </Typography>
        </Box>
      )}
    </Box>
  );
};

export default AiReasoningLogs;

================
File: src/components/jobs/components/AiSearchDeleteDialog.js
================
// src/components/jobs/components/AiSearchDeleteDialog.js
import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  CircularProgress,
  useTheme
} from '@mui/material';
import {
  Delete as DeleteIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  Assessment as AssessmentIcon
} from '@mui/icons-material';

const AiSearchDeleteDialog = ({ 
  open, 
  onClose, 
  onConfirm, 
  selectedSearch, 
  isLoading 
}) => {
  const theme = useTheme();

  return (
    <Dialog 
      open={open} 
      onClose={onClose}
      PaperProps={{
        sx: {
          borderRadius: 2,
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12)'
        }
      }}
    >
      <DialogTitle sx={{ pb: 1 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <DeleteIcon color="error" />
          <Typography variant="h6">Cancel Agent Job Search?</Typography>
        </Box>
      </DialogTitle>
      <DialogContent sx={{ pt: 2 }}>
        <Typography>
          Are you sure you want to cancel this Agent job search? This action cannot be undone.
          The search will be stopped and removed from your active searches.
        </Typography>
        {selectedSearch && (
          <Box sx={{ mt: 3, p: 2, backgroundColor: 'rgba(0, 0, 0, 0.03)', borderRadius: 1 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <DescriptionIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
              <Typography variant="body2" fontWeight={500}>
                Resume: {selectedSearch.resumeName}
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <WorkIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
              <Typography variant="body2" fontWeight={500}>
                Jobs found: {selectedSearch.totalJobsFound}
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <AssessmentIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
              <Typography variant="body2" fontWeight={500}>
                Status: {selectedSearch.status}
              </Typography>
            </Box>
          </Box>
        )}
      </DialogContent>
      <DialogActions sx={{ px: 3, pb: 2 }}>
        <Button 
          onClick={onClose}
          variant="outlined"
        >
          Keep Search
        </Button>
        <Button
          onClick={onConfirm}
          color="error"
          variant="contained"
          disabled={isLoading}
          startIcon={isLoading ? <CircularProgress size={20} /> : <DeleteIcon />}
        >
          Cancel Search
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default AiSearchDeleteDialog;

================
File: src/components/jobs/components/AiSearchDetailsDialog.js
================
// src/components/jobs/components/AiSearchDetailsDialog.js
import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Grid,
  Paper,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Divider,
  useTheme
} from '@mui/material';
import {
  Description as DescriptionIcon,
  Work as WorkIcon,
  LocationOn as LocationIcon,
  TrendingUp as TrendingUpIcon,
  CalendarToday as CalendarIcon,
  Assessment as AssessmentIcon,
  Code as CodeIcon,
  Search as SearchIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';
import { getStatusColor, getStatusIcon, formatDate } from '../utils/searchUtils';
import AiReasoningLogs from './AiReasoningLogs';

const AiSearchDetailsDialog = ({ 
  open, 
  onClose, 
  selectedSearch, 
  onViewJobs 
}) => {
  const theme = useTheme();

  if (!selectedSearch) return null;

  return (
    <Dialog 
      open={open} 
      onClose={onClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2,
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12)',
          maxHeight: '90vh'
        }
      }}
    >
      <DialogTitle sx={{ 
        pb: 2,
        background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.primary.light} 90%)`,
        color: 'white',
        borderBottom: '1px solid rgba(0, 0, 0, 0.1)'
      }}>
        <Box sx={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: 1.5,
          minHeight: '32px' // Ensure consistent height
        }}>
          <AutoJobLogo 
            variant="icon-only" 
            size="medium" 
            color="white"
            sx={{ 
              width: 32, 
              height: 32,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          />
          <Typography 
            variant="h6" 
            sx={{ 
              lineHeight: 1.2,
              display: 'flex',
              alignItems: 'center'
            }}
          >
            AI Search Details & Reasoning
          </Typography>
        </Box>
      </DialogTitle>
      <DialogContent sx={{ pt: 3, pb: 1 }}>
        <Box>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(26, 115, 232, 0.04)',
                  borderRadius: 2,
                  height: '100%'
                }}
              >
                <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.primary.main }}>
                  Search Configuration
                </Typography>
                <List disablePadding>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <DescriptionIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Resume</Typography>}
                      secondary={selectedSearch.resumeName}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <WorkIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Target Job Title</Typography>}
                      secondary={selectedSearch.searchCriteria.jobTitle}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <LocationIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Location</Typography>}
                      secondary={selectedSearch.searchCriteria.location}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <TrendingUpIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Experience Level</Typography>}
                      secondary={selectedSearch.searchCriteria.experienceLevel}
                    />
                  </ListItem>
                </List>
              </Paper>
            </Grid>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(0, 196, 180, 0.04)',
                  borderRadius: 2,
                  height: '100%'
                }}
              >
                <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.secondary.main }}>
                  Search Performance
                </Typography>
                <List disablePadding>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <CalendarIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Started</Typography>}
                      secondary={formatDate(selectedSearch.createdAt)}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <WorkIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Total Jobs Found</Typography>}
                      secondary={`${selectedSearch.totalJobsFound} jobs`}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <TrendingUpIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Today's Progress</Typography>}
                      secondary={`${selectedSearch.jobsFoundToday}/${selectedSearch.dailyLimit} jobs`}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <AssessmentIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Current Status</Typography>}
                      secondary={
                        <Chip 
                          label={selectedSearch.status} 
                          size="small" 
                          color={getStatusColor(selectedSearch.status)}
                          icon={getStatusIcon(selectedSearch.status)}
                        />
                      }
                    />
                  </ListItem>
                </List>
              </Paper>
            </Grid>
          </Grid>

          {selectedSearch.searchCriteria.skills && selectedSearch.searchCriteria.skills.length > 0 && (
            <Box sx={{ mt: 3 }}>
              <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.info.main }}>
                Target Skills
              </Typography>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(33, 150, 243, 0.04)',
                  borderRadius: 2
                }}
              >
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {selectedSearch.searchCriteria.skills.slice(0, 10).map((skill, index) => (
                    <Chip 
                      key={index}
                      label={skill} 
                      size="small" 
                      variant="outlined"
                      color="info"
                      icon={<CodeIcon />}
                    />
                  ))}
                  {selectedSearch.searchCriteria.skills.length > 10 && (
                    <Chip 
                      label={`+${selectedSearch.searchCriteria.skills.length - 10} more`}
                      size="small" 
                      variant="outlined"
                      color="default"
                    />
                  )}
                </Box>
              </Paper>
            </Box>
          )}

          {selectedSearch.jobsFound && selectedSearch.jobsFound.length > 0 && (
            <Box sx={{ mt: 3 }}>
              <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.success.main }}>
                Recent Jobs Found
              </Typography>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(52, 168, 83, 0.04)',
                  borderRadius: 2,
                  maxHeight: 200,
                  overflow: 'auto'
                }}
              >
                {selectedSearch.jobsFound.slice(-5).reverse().map((job, index) => (
                  <Box key={index} sx={{ mb: index < 4 ? 2 : 0 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <WorkIcon 
                          fontSize="small" 
                          sx={{ mr: 1, color: theme.palette.success.main }} 
                        />
                        <Typography variant="body2" fontWeight={500}>
                          {job.title} at {job.company}
                        </Typography>
                      </Box>
                      <Typography 
                        variant="caption" 
                        color="text.secondary"
                        sx={{ ml: 2 }}
                      >
                        {formatDate(job.foundAt)}
                      </Typography>
                    </Box>
                    {index < 4 && <Divider sx={{ mt: 1.5 }} />}
                  </Box>
                ))}
              </Paper>
            </Box>
          )}

          {/* AI Reasoning Logs Section */}
          <Box sx={{ mt: 3 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, mb: 2 }}>
              <AutoJobLogo 
                variant="icon-only" 
                size="small" 
                sx={{ width: 24, height: 24 }}
              />
              <Typography variant="subtitle1" fontWeight={600} color="primary.main">
                AI Reasoning & Decision Making
              </Typography>
              <Chip 
                label={`${selectedSearch.reasoningLogs?.length || 0} entries`}
                size="small" 
                color="primary"
                variant="outlined"
              />
            </Box>
            <Paper 
              elevation={0} 
              sx={{ 
                backgroundColor: 'rgba(26, 115, 232, 0.02)',
                borderRadius: 2,
                border: '1px solid rgba(26, 115, 232, 0.1)',
                maxHeight: 400,
                overflow: 'hidden'
              }}
            >
              <AiReasoningLogs search={selectedSearch} />
            </Paper>
          </Box>
        </Box>
      </DialogContent>
      <DialogActions sx={{ px: 3, pb: 2 }}>
        <Button 
          onClick={onClose}
          variant="outlined"
        >
          Close
        </Button>
        <Button
          variant="contained"
          onClick={onViewJobs}
          startIcon={<SearchIcon />}
        >
          View All Jobs
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default AiSearchDetailsDialog;

================
File: src/components/jobs/components/AiSearchExpandableRow.js
================
// src/components/jobs/components/AiSearchExpandableRow.js
import React from 'react';
import {
  TableRow,
  TableCell,
  Collapse,
  Box,
  Typography,
  Chip,
  useTheme
} from '@mui/material';
import AutoJobLogo from '../../common/AutoJobLogo';
import AiReasoningLogs from './AiReasoningLogs';

const AiSearchExpandableRow = ({ search, expanded }) => {
  const theme = useTheme();

  return (
    <TableRow>
      <TableCell 
        style={{ paddingBottom: 0, paddingTop: 0 }} 
        colSpan={8}
      >
        <Collapse 
          in={expanded} 
          timeout="auto" 
          unmountOnExit
        >
          <Box sx={{ 
            margin: 2, 
            backgroundColor: 'rgba(26, 115, 232, 0.02)',
            borderRadius: 2,
            border: '1px solid rgba(26, 115, 232, 0.1)'
          }}>
            <Box sx={{ 
              p: 2.5, 
              borderBottom: '1px solid rgba(26, 115, 232, 0.1)',
              backgroundColor: 'rgba(26, 115, 232, 0.05)'
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                <AutoJobLogo 
                  variant="icon-only" 
                  size="small" 
                  sx={{ width: 28, height: 28 }}
                />
                <Box>
                  <Typography variant="h6" fontWeight={600}>
                    AI Search Reasoning & Progress
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Detailed step-by-step AI reasoning and decision-making process
                  </Typography>
                </Box>
                <Box sx={{ ml: 'auto' }}>
                  <Chip 
                    label={`${search.reasoningLogs?.length || 0} logs`}
                    size="small" 
                    color="primary"
                    variant="outlined"
                    sx={{ fontWeight: 500 }}
                  />
                </Box>
              </Box>
            </Box>
            
            <AiReasoningLogs search={search} />
          </Box>
        </Collapse>
      </TableCell>
    </TableRow>
  );
};

export default AiSearchExpandableRow;

================
File: src/components/jobs/components/AiSearchSummaryCards.js
================
// src/components/jobs/components/AiSearchSummaryCards.js
import React from 'react';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Box,
  useTheme
} from '@mui/material';
import {
  PlayArrow as PlayIcon,
  Work as WorkIcon,
  TrendingUp as TrendingUpIcon,
  Schedule as ScheduleIcon
} from '@mui/icons-material';

const AiSearchSummaryCards = ({ searches }) => {
  const theme = useTheme();

  const summaryData = [
    {
      title: 'Active Searches',
      value: searches.filter(s => s.status === 'running').length,
      subtitle: 'Currently running',
      icon: <PlayIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.primary.light} 90%)`,
      shadowColor: 'rgba(26, 115, 232, 0.25)'
    },
    {
      title: 'Total Jobs Found',
      value: searches.reduce((sum, s) => sum + s.totalJobsFound, 0),
      subtitle: 'Across all searches',
      icon: <WorkIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.secondary.main} 30%, ${theme.palette.secondary.light} 90%)`,
      shadowColor: 'rgba(0, 196, 180, 0.25)'
    },
    {
      title: 'Jobs Found Today',
      value: searches.reduce((sum, s) => sum + s.jobsFoundToday, 0),
      subtitle: 'New discoveries',
      icon: <TrendingUpIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.success.main} 30%, ${theme.palette.success.light} 90%)`,
      shadowColor: 'rgba(52, 168, 83, 0.25)'
    },
    {
      title: 'Daily Limit',
      value: searches.reduce((sum, s) => sum + s.dailyLimit, 0),
      subtitle: 'Maximum per day',
      icon: <ScheduleIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.warning.main} 30%, ${theme.palette.warning.light} 90%)`,
      shadowColor: 'rgba(251, 188, 4, 0.25)'
    }
  ];

  return (
    <Grid container spacing={2}>
      {summaryData.map((item, index) => (
        <Grid item xs={12} sm={6} md={3} key={index}>
          <Card sx={{ 
            background: item.gradient,
            color: 'white',
            boxShadow: `0 4px 20px ${item.shadowColor}`,
            transition: 'transform 0.2s',
            '&:hover': {
              transform: 'translateY(-4px)',
            }
          }}>
            <CardContent>
              <Typography variant="overline" sx={{ opacity: 0.8 }} gutterBottom>
                {item.title}
              </Typography>
              <Typography variant="h3" sx={{ fontWeight: 600 }}>
                {item.value}
              </Typography>
              <Box sx={{ mt: 1, display: 'flex', alignItems: 'center' }}>
                {item.icon}
                <Typography variant="body2" sx={{ opacity: 0.8 }}>
                  {item.subtitle}
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      ))}
    </Grid>
  );
};

export default AiSearchSummaryCards;

================
File: src/components/jobs/components/AiSearchTable.js
================
// src/components/jobs/components/AiSearchTable.js
import React from 'react';
import {
  TableContainer,
  Table,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  Paper
} from '@mui/material';
import AiSearchTableRow from './AiSearchTableRow';
import AiSearchExpandableRow from './AiSearchExpandableRow';

const AiSearchTable = ({ 
  searches, 
  expandedRows, 
  onToggleExpansion, 
  onPauseResume, 
  onDelete, 
  onViewDetails, 
  actionLoading 
}) => {
  return (
    <TableContainer 
      component={Paper} 
      sx={{ 
        borderRadius: 2, 
        overflow: 'hidden',
        boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)'
      }}
    >
      <Table>
        <TableHead>
          <TableRow sx={{ backgroundColor: 'rgba(26, 115, 232, 0.08)' }}>
            <TableCell sx={{ fontWeight: 600, width: 50 }}>Details</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Resume</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Search Criteria</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Status</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Progress Today</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Total Found</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Last Update</TableCell>
            <TableCell align="right" sx={{ fontWeight: 600 }}>Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {searches.map((search) => (
            <React.Fragment key={search._id}>
              <AiSearchTableRow
                search={search}
                expanded={expandedRows[search._id]}
                onToggleExpansion={onToggleExpansion}
                onPauseResume={onPauseResume}
                onDelete={onDelete}
                onViewDetails={onViewDetails}
                actionLoading={actionLoading}
              />
              <AiSearchExpandableRow
                search={search}
                expanded={expandedRows[search._id]}
              />
            </React.Fragment>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default AiSearchTable;

================
File: src/components/jobs/components/AiSearchTableRow.js
================
// src/components/jobs/components/AiSearchTableRow.js
import React from 'react';
import {
  TableRow,
  TableCell,
  Box,
  Typography,
  Chip,
  Badge,
  LinearProgress,
  IconButton,
  Tooltip,
  CircularProgress,
  useTheme
} from '@mui/material';
import {
  Description as DescriptionIcon,
  LocationOn as LocationIcon,
  Work as WorkIcon,
  PlayArrow as PlayIcon,
  Pause as PauseIcon,
  Delete as DeleteIcon,
  Info as InfoIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { getStatusColor, getStatusIcon, getProgressPercentage, formatDate } from '../utils/searchUtils';

const AiSearchTableRow = ({ 
  search, 
  expanded, 
  onToggleExpansion, 
  onPauseResume, 
  onDelete, 
  onViewDetails, 
  actionLoading 
}) => {
  const theme = useTheme();

  return (
    <TableRow 
      sx={{ 
        '&:hover': { 
          backgroundColor: 'rgba(0, 0, 0, 0.04)' 
        },
        transition: 'background-color 0.2s'
      }}
    >
      <TableCell>
        <Tooltip title={expanded ? 'Hide AI Reasoning' : 'Show AI Reasoning'}>
          <IconButton
            size="small"
            onClick={() => onToggleExpansion(search._id)}
            sx={{ 
              backgroundColor: 'rgba(26, 115, 232, 0.08)',
              '&:hover': { backgroundColor: 'rgba(26, 115, 232, 0.15)' }
            }}
          >
            {expanded ? 
              <VisibilityOffIcon fontSize="small" /> : 
              <VisibilityIcon fontSize="small" />
            }
          </IconButton>
        </Tooltip>
      </TableCell>
      <TableCell>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <DescriptionIcon 
            color="primary" 
            fontSize="small" 
            sx={{ mr: 1, opacity: 0.7 }} 
          />
          <Typography variant="body2" fontWeight={500}>
            {search.resumeName}
          </Typography>
        </Box>
      </TableCell>
      <TableCell>
        <Box>
          <Typography variant="body2" fontWeight={500}>
            {search.searchCriteria.jobTitle}
          </Typography>
          <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
            <LocationIcon 
              fontSize="small" 
              sx={{ mr: 0.5, color: theme.palette.text.secondary, fontSize: '0.875rem' }} 
            />
            <Typography variant="caption" color="text.secondary">
              {search.searchCriteria.location}
            </Typography>
          </Box>
        </Box>
      </TableCell>
      <TableCell>
        <Chip
          icon={getStatusIcon(search.status)}
          label={search.status}
          color={getStatusColor(search.status)}
          size="small"
          sx={{ 
            fontWeight: 500,
            boxShadow: '0 2px 5px rgba(0, 0, 0, 0.08)'
          }}
        />
      </TableCell>
      <TableCell>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Box sx={{ flex: 1 }}>
            <LinearProgress
              variant="determinate"
              value={getProgressPercentage(search)}
              color={search.status === 'running' ? 'primary' : 'inherit'}
              sx={{
                height: 8,
                borderRadius: 4,
                backgroundColor: 'rgba(0, 0, 0, 0.06)',
                '& .MuiLinearProgress-bar': {
                  borderRadius: 4,
                  backgroundImage: search.status === 'running' 
                    ? `linear-gradient(90deg, ${theme.palette.primary.main}, ${theme.palette.primary.light})`
                    : undefined
                }
              }}
            />
          </Box>
          <Typography 
            variant="caption" 
            fontWeight={500}
            sx={{ 
              minWidth: '45px', 
              textAlign: 'right',
              color: search.jobsFoundToday >= search.dailyLimit 
                ? theme.palette.success.main 
                : 'inherit'
            }}
          >
            {search.jobsFoundToday}/{search.dailyLimit}
          </Typography>
        </Box>
      </TableCell>
      <TableCell>
        <Badge 
          badgeContent={search.totalJobsFound} 
          color="primary"
          sx={{ 
            '& .MuiBadge-badge': { 
              fontWeight: 600,
              boxShadow: '0 2px 5px rgba(0, 0, 0, 0.1)'
            }
          }}
        >
          <WorkIcon color="action" />
        </Badge>
      </TableCell>
      <TableCell>
        <Box>
          <Typography variant="caption" fontWeight={500}>
            {formatDate(search.lastUpdated)}
          </Typography>
          {search.lastUpdateMessage && (
            <Typography 
              variant="caption" 
              display="block" 
              color="text.secondary"
              sx={{ 
                mt: 0.5,
                maxWidth: 200,
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
              }}
            >
              {search.lastUpdateMessage}
            </Typography>
          )}
        </Box>
      </TableCell>
      <TableCell align="right">
        <Box sx={{ display: 'flex', gap: 1, justifyContent: 'flex-end' }}>
          <Tooltip title="View Details">
            <IconButton
              size="small"
              color="primary"
              onClick={() => onViewDetails(search)}
              sx={{ 
                backgroundColor: 'rgba(26, 115, 232, 0.08)',
                '&:hover': { backgroundColor: 'rgba(26, 115, 232, 0.15)' }
              }}
            >
              <InfoIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          {(search.status === 'running' || search.status === 'paused') && (
            <Tooltip title={search.status === 'running' ? 'Pause' : 'Resume'}>
              <IconButton
                size="small"
                color={search.status === 'running' ? 'warning' : 'success'}
                onClick={() => onPauseResume(search._id, search.status)}
                disabled={actionLoading[search._id]}
                sx={{ 
                  backgroundColor: search.status === 'running' 
                    ? 'rgba(251, 188, 4, 0.08)'
                    : 'rgba(52, 168, 83, 0.08)',
                  '&:hover': { 
                    backgroundColor: search.status === 'running' 
                      ? 'rgba(251, 188, 4, 0.15)'
                      : 'rgba(52, 168, 83, 0.15)'
                  }
                }}
              >
                {actionLoading[search._id] ? (
                  <CircularProgress size={20} />
                ) : search.status === 'running' ? (
                  <PauseIcon fontSize="small" />
                ) : (
                  <PlayIcon fontSize="small" />
                )}
              </IconButton>
            </Tooltip>
          )}
          <Tooltip title="Cancel Search">
            <IconButton
              size="small"
              color="error"
              onClick={() => onDelete(search)}
              disabled={actionLoading[search._id]}
              sx={{ 
                backgroundColor: 'rgba(234, 67, 53, 0.08)',
                '&:hover': { backgroundColor: 'rgba(234, 67, 53, 0.15)' }
              }}
            >
              <DeleteIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        </Box>
      </TableCell>
    </TableRow>
  );
};

export default AiSearchTableRow;

================
File: src/components/jobs/components/EmptySearchState.js
================
// src/components/jobs/components/EmptySearchState.js
import React from 'react';
import {
  Box,
  Typography,
  Button,
  Paper,
  Grid,
  Alert
} from '@mui/material';
import {
  TrendingUp as TrendingUpIcon,
  Notifications as NotificationsIcon,
  Assessment as AssessmentIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

const EmptySearchState = ({ onStartSearch }) => {
  return (
    <Box sx={{ mt: 2 }}>
      <Paper 
        elevation={0} 
        sx={{ 
          p: 4, // Reduced from 5
          textAlign: 'center', 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center',
          backgroundColor: 'rgba(26, 115, 232, 0.04)',
          border: '1px dashed rgba(26, 115, 232, 0.3)',
          borderRadius: 2,
          mb: 4 // Reduced from 5
        }}
      >
        <Box sx={{ mb: 2 }}> {/* Reduced from 3 */}
          <AutoJobLogo 
            variant="icon-only" 
            size="medium" // Changed from large to medium
            color="primary"
            sx={{ 
              opacity: 0.7,
              filter: 'drop-shadow(0 2px 8px rgba(26, 115, 232, 0.2))'
            }}
          />
        </Box>
        <Typography variant="h5" gutterBottom fontWeight={600}> {/* Changed from h4 to h5 */}
          Start Your AI Agent Job Search
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 3, maxWidth: 600, fontSize: '0.95rem' }}> {/* Reduced mb and maxWidth, added smaller fontSize */}
          Let our AI Agent continuously search for job opportunities that match your resume.
          Our platform will analyze matches, find relevant positions, and track your search progress automatically.
        </Typography>
        <Box sx={{ display: 'flex', gap: 2 }}>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<AutoJobLogo variant="icon-only" size="small" />} // Changed icon to AutoJobLogo
            onClick={onStartSearch}
            size="medium" // Changed from large to medium
            sx={{ 
              py: 1.2, // Reduced from 1.5
              px: 3, // Reduced from 4
              fontSize: '1rem', // Reduced from 1.1rem
              fontWeight: 500,
              boxShadow: '0 4px 12px rgba(26, 115, 232, 0.2)'
            }}
          >
            Begin AI Job Search {/* Updated text */}
          </Button>
        </Box>
        <Alert severity="info" sx={{ mt: 2.5, maxWidth: 550, fontSize: '0.875rem' }}> {/* Reduced mt and maxWidth, added smaller fontSize */}
          You need at least one active resume to use the AI Agent search feature.
          Please upload and activate a resume first.
        </Alert>
      </Paper>

      <Typography variant="h6" sx={{ mb: 2.5, fontWeight: 600 }}> {/* Changed from h5 to h6, reduced mb */}
        How Our AI Agent Search Works
      </Typography>

      <Grid container spacing={2.5} sx={{ mb: 3 }}> {/* Reduced spacing and mb */}
        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #4caf50',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              1. AI Resume Analysis
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <AutoJobLogo 
                variant="icon-only" 
                size="medium" // Reduced from large equivalent
                color="primary"
                sx={{ opacity: 0.7 }}
              />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Our AI analyzes your resume and career preferences to understand your ideal job profile
              and search criteria.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #2196f3',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              2. Continuous Job Discovery
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <TrendingUpIcon sx={{ fontSize: 60, color: '#2196f3', opacity: 0.7 }} /> {/* Reduced from 80 */}
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Searches multiple job boards and company websites 24/7 to find relevant opportunities
              matching your profile.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #ff9800',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              3. Smart Notifications
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <NotificationsIcon sx={{ fontSize: 60, color: '#ff9800', opacity: 0.7 }} /> {/* Reduced from 80 */}
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Get notified when new relevant jobs are found and receive detailed AI reasoning
              for each match.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={6}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #9c27b0',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              4. Intelligent Matching
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <AssessmentIcon sx={{ fontSize: 60, color: '#9c27b0', opacity: 0.7 }} /> {/* Reduced from 80 */}
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Each found job is automatically analyzed for compatibility with your resume,
              providing match scores and improvement suggestions.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={6}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #00bcd4',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              5. Progress Tracking
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <AutoJobLogo 
                variant="icon-only" 
                size="medium" // Reduced from large equivalent
                color="primary"
                sx={{ opacity: 0.7 }}
              />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Monitor your AI Agent's progress, view detailed reasoning logs, and manage
              your automated job search campaigns.
            </Typography>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default EmptySearchState;

================
File: src/components/jobs/components/EnhancedCircularProgress.js
================
// src/components/jobs/components/EnhancedCircularProgress.js
import React from 'react';
import {
  Box,
  Typography,
  CircularProgress,
  useTheme
} from '@mui/material';

export const EnhancedCircularProgress = ({ value, size = 120 }) => {
  const theme = useTheme();
  
  const getColor = (score) => {
    if (score >= 85) return theme.palette.success.main;
    if (score >= 70) return theme.palette.info.main;
    if (score >= 55) return theme.palette.warning.main;
    return theme.palette.error.main;
  };

  const getQualityLabel = (score) => {
    if (score >= 85) return 'Excellent';
    if (score >= 70) return 'Good';
    if (score >= 55) return 'Fair';
    return 'Needs Work';
  };

  return (
    <Box sx={{ position: 'relative', display: 'inline-flex', flexDirection: 'column', alignItems: 'center' }}>
      <Box sx={{ position: 'relative', display: 'inline-flex' }}>
        {/* Background circle */}
        <CircularProgress
          variant="determinate"
          size={size}
          thickness={6}
          value={100}
          sx={{ 
            color: getColor(value),
            opacity: 0.1,
            position: 'absolute'
          }}
        />
        {/* Progress circle */}
        <CircularProgress
          variant="determinate"
          size={size}
          thickness={6}
          value={value}
          sx={{ 
            color: getColor(value),
            transition: 'all 0.3s ease',
            '& .MuiCircularProgress-circle': {
              strokeLinecap: 'round',
            }
          }}
        />
        <Box
          sx={{
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
            position: 'absolute',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column'
          }}
        >
          <Typography variant="h3" component="div" fontWeight="bold" color={getColor(value)}>
            {Math.round(value)}%
          </Typography>
          <Typography variant="body2" color="text.secondary" fontWeight={500}>
            {getQualityLabel(value)}
          </Typography>
        </Box>
      </Box>
    </Box>
  );
};

================
File: src/components/jobs/components/JobAnalysisStatus.js
================
// src/components/jobs/components/JobAnalysisStatus.js
import React from 'react';
import {
  Box,
  Typography,
  LinearProgress,
  Chip,
  CircularProgress,
  Tooltip,
  Alert
} from '@mui/material';
import {
  HourglassEmpty as HourglassEmptyIcon,
  AutoAwesome as AutoAwesomeIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  SmartToy as SmartToyIcon
} from '@mui/icons-material';

const JobAnalysisStatus = ({ 
  analysisStatus, 
  size = 'normal', // 'small', 'normal', 'large'
  variant = 'full', // 'full', 'chip', 'progress-only'
  showDetails = true 
}) => {
  if (!analysisStatus) {
    return null;
  }

  const { status, progress, message, skillsFound, experienceLevel } = analysisStatus;

  // Status configuration
  const statusConfig = {
    pending: {
      label: 'Analysis Queued',
      color: 'info',
      icon: HourglassEmptyIcon,
      bgColor: 'rgba(2, 136, 209, 0.1)',
      textColor: '#0288d1'
    },
    analyzing: {
      label: 'Analyzing Job',
      color: 'primary',
      icon: AutoAwesomeIcon,
      bgColor: 'rgba(26, 115, 232, 0.1)',
      textColor: '#1a73e8'
    },
    completed: {
      label: 'Analysis Complete',
      color: 'success',
      icon: CheckCircleIcon,
      bgColor: 'rgba(52, 168, 83, 0.1)',
      textColor: '#34a853'
    },
    error: {
      label: 'Analysis Failed',
      color: 'error',
      icon: ErrorIcon,
      bgColor: 'rgba(234, 67, 53, 0.1)',
      textColor: '#ea4335'
    }
  };

  const config = statusConfig[status] || statusConfig.pending;
  const IconComponent = config.icon;

  // Size configurations
  const sizeConfig = {
    small: {
      iconSize: 16,
      chipHeight: 24,
      typography: 'caption',
      progressHeight: 4
    },
    normal: {
      iconSize: 20,
      chipHeight: 28,
      typography: 'body2',
      progressHeight: 6
    },
    large: {
      iconSize: 24,
      chipHeight: 32,
      typography: 'body1',
      progressHeight: 8
    }
  };

  const currentSize = sizeConfig[size];

  // Render chip variant
  if (variant === 'chip') {
    return (
      <Chip
        icon={
          status === 'analyzing' ? (
            <CircularProgress 
              size={currentSize.iconSize} 
              thickness={6} 
              color={config.color}
            />
          ) : (
            <IconComponent 
              sx={{ 
                fontSize: `${currentSize.iconSize}px !important`,
                color: config.textColor 
              }} 
            />
          )
        }
        label={config.label}
        size={size}
        sx={{
          height: currentSize.chipHeight,
          backgroundColor: config.bgColor,
          color: config.textColor,
          border: `1px solid ${config.textColor}`,
          fontWeight: 500,
          '& .MuiChip-icon': {
            color: `${config.textColor} !important`
          }
        }}
      />
    );
  }

  // Render progress only
  if (variant === 'progress-only') {
    return (
      <Box sx={{ width: '100%' }}>
        <LinearProgress
          variant="determinate"
          value={progress}
          color={config.color}
          sx={{
            height: currentSize.progressHeight,
            borderRadius: currentSize.progressHeight / 2,
            backgroundColor: config.bgColor,
            '& .MuiLinearProgress-bar': {
              borderRadius: currentSize.progressHeight / 2,
            }
          }}
        />
        {showDetails && (
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
            <Typography variant={currentSize.typography} color="text.secondary">
              {message}
            </Typography>
            <Typography variant={currentSize.typography} color="text.secondary">
              {progress}%
            </Typography>
          </Box>
        )}
      </Box>
    );
  }

  // Render full variant
  return (
    <Box
      sx={{
        p: size === 'small' ? 1.5 : 2,
        borderRadius: 2,
        backgroundColor: config.bgColor,
        border: `1px solid ${config.textColor}`,
        display: 'flex',
        alignItems: 'center',
        gap: 1.5
      }}
    >
      {/* Status Icon */}
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        {status === 'analyzing' ? (
          <CircularProgress 
            size={currentSize.iconSize} 
            thickness={6} 
            color={config.color}
          />
        ) : (
          <IconComponent 
            sx={{ 
              fontSize: currentSize.iconSize,
              color: config.textColor 
            }} 
          />
        )}
      </Box>

      {/* Status Content */}
      <Box sx={{ flex: 1, minWidth: 0 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
          <Typography 
            variant={currentSize.typography} 
            fontWeight={600}
            color={config.textColor}
            noWrap
          >
            {config.label}
          </Typography>
          
          {/* AI Badge for analyzing status */}
          {status === 'analyzing' && (
            <Chip
              icon={<SmartToyIcon sx={{ fontSize: '14px !important' }} />}
              label="AI"
              size="small"
              sx={{
                height: 18,
                fontSize: '0.7rem',
                backgroundColor: config.textColor,
                color: 'white',
                '& .MuiChip-icon': {
                  color: 'white !important'
                }
              }}
            />
          )}
        </Box>

        {/* Progress Bar for non-completed status */}
        {status !== 'completed' && status !== 'error' && (
          <Box sx={{ mb: 1 }}>
            <LinearProgress
              variant="determinate"
              value={progress}
              color={config.color}
              sx={{
                height: currentSize.progressHeight,
                borderRadius: currentSize.progressHeight / 2,
                backgroundColor: 'rgba(255,255,255,0.3)',
                '& .MuiLinearProgress-bar': {
                  borderRadius: currentSize.progressHeight / 2,
                }
              }}
            />
          </Box>
        )}

        {/* Status Message */}
        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          color={config.textColor}
          sx={{ opacity: 0.9 }}
        >
          {message}
        </Typography>

        {/* Success Details */}
        {status === 'completed' && showDetails && skillsFound !== undefined && (
          <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            <Chip
              label={`${skillsFound} skills found`}
              size="small"
              variant="outlined"
              sx={{
                height: 20,
                fontSize: '0.7rem',
                borderColor: config.textColor,
                color: config.textColor
              }}
            />
            {experienceLevel && (
              <Chip
                label={`${experienceLevel} level`}
                size="small"
                variant="outlined"
                sx={{
                  height: 20,
                  fontSize: '0.7rem',
                  borderColor: config.textColor,
                  color: config.textColor
                }}
              />
            )}
          </Box>
        )}

        {/* Error Details */}
        {status === 'error' && showDetails && (
          <Alert 
            severity="error" 
            sx={{ 
              mt: 1, 
              py: 0.5,
              fontSize: '0.75rem',
              '& .MuiAlert-icon': {
                fontSize: '1rem'
              }
            }}
          >
            Analysis failed. You can still view the job, but some features may be limited.
          </Alert>
        )}
      </Box>

      {/* Progress Percentage */}
      {(status === 'analyzing' || status === 'pending') && (
        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          fontWeight={600}
          color={config.textColor}
        >
          {progress}%
        </Typography>
      )}
    </Box>
  );
};

export default JobAnalysisStatus;

================
File: src/components/jobs/components/JobDetailsCard.js
================
// src/components/jobs/components/JobDetailsCard.js
import React from 'react';
import {
  Card,
  CardHeader,
  CardContent,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Typography,
  Divider
} from '@mui/material';
import {
  Work as WorkIcon,
  Business as BusinessIcon,
  LocationOn as LocationOnIcon,
  Schedule as ScheduleIcon,
  TrendingUp as TrendingUpIcon,
  AttachMoney as AttachMoneyIcon
} from '@mui/icons-material';

const JobDetailsCard = ({ job }) => {
  return (
    <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
      <CardHeader 
        title="Job Details" 
        avatar={<WorkIcon color="primary" />}
        sx={{ 
          pb: 1, 
          '& .MuiCardHeader-title': { fontWeight: 600 } 
        }}
      />
      <CardContent>
        <List sx={{ '& .MuiListItem-root': { py: 1.5 } }}>
          <ListItem>
            <ListItemIcon>
              <BusinessIcon color="primary" />
            </ListItemIcon>
            <ListItemText
              primary={<Typography variant="body2" color="text.secondary">Company</Typography>}
              secondary={<Typography variant="body1" fontWeight={500}>{job.company}</Typography>}
            />
          </ListItem>
          <Divider variant="inset" component="li" />
          
          <ListItem>
            <ListItemIcon>
              <LocationOnIcon color="primary" />
            </ListItemIcon>
            <ListItemText
              primary={<Typography variant="body2" color="text.secondary">Location</Typography>}
              secondary={
                <Typography variant="body1" fontWeight={500}>
                  {job.location?.city 
                    ? `${job.location.city}${job.location.state ? `, ${job.location.state}` : ''}`
                    : job.location?.remote ? 'Remote' : 'Location not specified'}
                </Typography>
              }
            />
          </ListItem>
          <Divider variant="inset" component="li" />
          
          <ListItem>
            <ListItemIcon>
              <ScheduleIcon color="primary" />
            </ListItemIcon>
            <ListItemText
              primary={<Typography variant="body2" color="text.secondary">Job Type</Typography>}
              secondary={<Typography variant="body1" fontWeight={500}>{job.jobType?.replace('_', ' ') || 'Full-time'}</Typography>}
            />
          </ListItem>
          
          {job.parsedData?.yearsOfExperience && (
            <>
              <Divider variant="inset" component="li" />
              <ListItem>
                <ListItemIcon>
                  <TrendingUpIcon color="primary" />
                </ListItemIcon>
                <ListItemText
                  primary={<Typography variant="body2" color="text.secondary">Experience Required</Typography>}
                  secondary={
                    <Typography variant="body1" fontWeight={500}>
                      {job.parsedData.yearsOfExperience.minimum || 0}
                      {job.parsedData.yearsOfExperience.preferred && job.parsedData.yearsOfExperience.preferred !== job.parsedData.yearsOfExperience.minimum 
                        ? `-${job.parsedData.yearsOfExperience.preferred}` 
                        : '+'} years
                    </Typography>
                  }
                />
              </ListItem>
            </>
          )}
          
          {job.salary?.min && (
            <>
              <Divider variant="inset" component="li" />
              <ListItem>
                <ListItemIcon>
                  <AttachMoneyIcon color="primary" />
                </ListItemIcon>
                <ListItemText
                  primary={<Typography variant="body2" color="text.secondary">Salary Range</Typography>}
                  secondary={
                    <Typography variant="body1" fontWeight={500}>
                      {`${job.salary.currency || '$'}${job.salary.min}${job.salary.max ? ` - ${job.salary.max}` : '+'}`}
                    </Typography>
                  }
                />
              </ListItem>
            </>
          )}
        </List>
      </CardContent>
    </Card>
  );
};

export default JobDetailsCard;

================
File: src/components/jobs/components/JobHeader.js
================
// src/components/jobs/components/JobHeader.js
import React from 'react';
import {
  Paper,
  Typography,
  Box,
  Chip,
  Button,
  IconButton,
  useTheme
} from '@mui/material';
import {
  Business as BusinessIcon,
  LocationOn as LocationOnIcon,
  SmartToy as SmartToyIcon,
  OpenInNew as OpenInNewIcon,
  MoreVert as MoreVertIcon,
  TrendingUp as TrendingUpIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

const JobHeader = ({ 
  job, 
  onTailorClick, 
  onMenuClick, 
  onOpenOriginal 
}) => {
  const theme = useTheme();

  // Safe AutoJobLogo wrapper component
  const SafeAutoJobLogo = ({ size = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={size} 
          showTagline={false}
        />
      );
    } catch (error) {
      // Fallback to SmartToy icon if AutoJobLogo fails
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: size === 'small' ? 16 : 20 }} />;
    }
  };

  // Custom chip icon for discovered jobs - properly sized and positioned
  const DiscoveredChipIcon = () => {
    try {
      return (
        <Box sx={{ 
          display: 'flex', 
          alignItems: 'center', 
          justifyContent: 'center', 
          width: 18, 
          height: 18,
          ml: 0.5  // Add left margin to bring logo closer to "Discovered" text
        }}>
          <AutoJobLogo 
            variant="icon-only" 
            size="small"
            showTagline={false}
            sx={{ 
              '& svg': { 
                width: 14, 
                height: 14,
                display: 'block'
              } 
            }}
          />
        </Box>
      );
    } catch (error) {
      console.warn('AutoJobLogo failed to render in chip:', error);
      return <SmartToyIcon sx={{ fontSize: 16 }} />;
    }
  };

  return (
    <Paper 
      elevation={2} 
      sx={{ 
        p: 3, 
        mb: 4, 
        borderRadius: 3,
        backgroundImage: `linear-gradient(135deg, ${theme.palette.background.paper} 0%, ${theme.palette.primary.light}15 100%)` 
      }}
    >
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap' }}>
        <Box>
          <Typography variant="h4" component="h1" fontWeight={700} color="primary">
            {job.title}
          </Typography>
          <Box sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
            <Chip 
              icon={<BusinessIcon />} 
              label={job.company} 
              size="small" 
              sx={{ mr: 1 }} 
            />
            {job.location && (
              <Chip 
                icon={<LocationOnIcon />} 
                label={job.location.city ? 
                  `${job.location.city}${job.location.state ? `, ${job.location.state}` : ''}` : 
                  job.location.remote ? 'Remote' : 'Location not specified'} 
                size="small"
                sx={{ mr: 1 }} 
              />
            )}
            {job.isAiGenerated && (
              <Chip 
                icon={<DiscoveredChipIcon />} 
                label="Discovered" 
                size="small"
                sx={{ 
                  mr: 1,
                  backgroundColor: '#00c4b4',
                  color: 'white',
                  '& .MuiChip-icon': {
                    color: 'white'
                  }
                }} 
              />
            )}
            {job.parsedData?.experienceLevel && (
              <Chip 
                icon={<TrendingUpIcon />} 
                label={job.parsedData.experienceLevel.charAt(0).toUpperCase() + job.parsedData.experienceLevel.slice(1)} 
                size="small"
                color="secondary"
                sx={{ mr: 1 }} 
              />
            )}
          </Box>
        </Box>
        
        <Box sx={{ display: 'flex', gap: 1 }}>
          {job.sourceUrl && (
            <Button
              variant="outlined"
              startIcon={<OpenInNewIcon />}
              onClick={onOpenOriginal}
              sx={{ borderRadius: 2 }}
            >
              Open Original
            </Button>
          )}
          <Button
            variant="contained"
            color="secondary"
            startIcon={<SafeAutoJobLogo size="small" />}
            onClick={onTailorClick}
            sx={{ borderRadius: 2 }}
          >
            Get Tailored Resume
          </Button>
          <IconButton
            onClick={onMenuClick}
            size="large"
            sx={{ ml: 1, border: '1px solid', borderColor: 'divider', borderRadius: 2 }}
          >
            <MoreVertIcon />
          </IconButton>
        </Box>
      </Box>
    </Paper>
  );
};

export default JobHeader;

================
File: src/components/jobs/components/MatchAnalysisCard.js
================
// src/components/jobs/components/MatchAnalysisCard.js
import React from 'react';
import {
  Card,
  CardHeader,
  CardContent,
  Box,
  Typography,
  LinearProgress,
  Chip,
  useTheme
} from '@mui/material';
import {
  Speed as SpeedIcon,
  CheckCircle as CheckCircleIcon,
  Info as InfoIcon,
  Warning as WarningIcon,
  Error as ErrorIcon
} from '@mui/icons-material';
import { EnhancedCircularProgress } from './EnhancedCircularProgress';

const MatchAnalysisCard = ({ job }) => {
  const theme = useTheme();

  const getScoreColor = (score) => {
    if (score >= 85) return 'success';
    if (score >= 70) return 'info';
    if (score >= 55) return 'warning';
    return 'error';
  };

  const getScoreIcon = (score) => {
    if (score >= 85) return <CheckCircleIcon color="success" />;
    if (score >= 70) return <InfoIcon color="info" />;
    if (score >= 55) return <WarningIcon color="warning" />;
    return <ErrorIcon color="error" />;
  };

  if (!job.matchAnalysis?.overallScore) {
    return null;
  }

  return (
    <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
      <CardHeader 
        title="Match Analysis" 
        avatar={<SpeedIcon color="primary" />}
        sx={{ 
          pb: 1, 
          '& .MuiCardHeader-title': { fontWeight: 600 } 
        }}
      />
      <CardContent sx={{ display: 'flex', justifyContent: 'center', flexDirection: 'column', alignItems: 'center' }}>
        <EnhancedCircularProgress 
          value={job.matchAnalysis.overallScore}
          size={120}
        />
        
        <Box sx={{ width: '100%', mt: 3 }}>
          {['skills', 'experience', 'education'].map((category) => {
            const score = job.matchAnalysis.categoryScores?.[category] || 0;
            return (
              <Box key={category} sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body1" sx={{ textTransform: 'capitalize' }}>
                    {category} Match
                  </Typography>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    {getScoreIcon(score)}
                    <Typography variant="h6" fontWeight="medium" color={getScoreColor(score)}>
                      {score}%
                    </Typography>
                  </Box>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={score}
                  sx={{
                    height: 8,
                    borderRadius: 4,
                    bgcolor: 'rgba(0,0,0,0.1)',
                    '& .MuiLinearProgress-bar': {
                      borderRadius: 4,
                      bgcolor: theme.palette[getScoreColor(score)].main,
                    }
                  }}
                />
              </Box>
            );
          })}
        </Box>

        {job.matchAnalysis.matchedSkills && (
          <Box sx={{ width: '100%', mt: 2, p: 2, bgcolor: 'action.hover', borderRadius: 2 }}>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              <strong>Skills:</strong> {job.matchAnalysis.matchedSkills.filter(s => s.found).length} of {job.matchAnalysis.matchedSkills.length} matched
            </Typography>
            {job.matchAnalysis.experienceAnalysis && (
              <Typography variant="body2" color="text.secondary">
                <strong>Experience:</strong> {job.matchAnalysis.experienceAnalysis.relevantYearsExperience || 0} years relevant
              </Typography>
            )}
          </Box>
        )}
      </CardContent>
    </Card>
  );
};

export default MatchAnalysisCard;

================
File: src/components/jobs/components/SkillChip.js
================
// src/components/jobs/components/SkillChip.js
import React from 'react';
import {
  Chip,
  Tooltip,
  Box,
  Typography,
  useTheme
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  Info as InfoIcon
} from '@mui/icons-material';

const SkillChip = ({ skill, isMatched, importance, matchQuality }) => {
  const theme = useTheme();
  
  // Extract skill name safely from different skill object structures
  const getSkillName = (skillObj) => {
    if (!skillObj) return 'Unknown Skill';
    if (typeof skillObj === 'string') return skillObj;
    if (typeof skillObj === 'object') {
      return skillObj.name || skillObj.skill || (skillObj.toString && typeof skillObj.toString === 'function' ? skillObj.toString() : 'Unknown Skill');
    }
    return 'Unknown Skill';
  };

  const skillName = getSkillName(skill);
  
  const getImportanceColor = (imp) => {
    if (!imp && imp !== 0) return theme.palette.info.main;
    if (imp >= 8) return theme.palette.error.main;
    if (imp >= 6) return theme.palette.warning.main;
    return theme.palette.info.main;
  };

  const getMatchQualityIcon = (quality) => {
    if (!quality) return null;
    switch (quality) {
      case 'exact': return <CheckCircleIcon fontSize="small" />;
      case 'partial': return <WarningIcon fontSize="small" />;
      case 'related': return <InfoIcon fontSize="small" />;
      default: return null;
    }
  };

  return (
    <Tooltip 
      title={
        <Box>
          <Typography variant="body2" fontWeight="bold">{skillName}</Typography>
          {importance && <Typography variant="caption">Importance: {importance}/10</Typography>}
          {matchQuality && <Typography variant="caption" display="block">Match: {matchQuality}</Typography>}
        </Box>
      }
    >
      <Chip 
        label={skillName}
        icon={isMatched ? getMatchQualityIcon(matchQuality) : null}
        variant={isMatched ? 'filled' : 'outlined'}
        color={isMatched ? 'success' : 'default'}
        size="medium"
        sx={{ 
          bgcolor: isMatched ? `${theme.palette.success.main}30` : 'transparent',
          color: isMatched ? theme.palette.success.dark : theme.palette.text.primary,
          fontWeight: 500,
          borderRadius: 2,
          border: isMatched 
            ? `2px solid ${theme.palette.success.main}` 
            : `1px solid ${getImportanceColor(importance || 5)}40`,
          borderLeftWidth: 4,
          borderLeftColor: getImportanceColor(importance || 5),
          transition: 'all 0.2s ease',
          '&:hover': {
            transform: 'translateY(-1px)',
            boxShadow: 2,
            bgcolor: isMatched ? `${theme.palette.success.main}40` : `${getImportanceColor(importance || 5)}10`,
          }
        }}
      />
    </Tooltip>
  );
};

export default SkillChip;

================
File: src/components/jobs/FindJobsDialog.js
================
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Stepper,
  Step,
  StepLabel,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  CircularProgress,
  IconButton,
  Chip,
  Paper,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Divider,
  StepConnector,
  stepConnectorClasses,
  styled
} from '@mui/material';
import {
  Close as CloseIcon,
  Description as DescriptionIcon,
  Search as SearchIcon,
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
  TrendingUp as TrendingUpIcon,
  Work as WorkIcon,
  CalendarToday as CalendarIcon,
  Speed as SpeedIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import resumeService from '../../utils/resumeService';
import jobService from '../../utils/jobService';
import AutoJobLogo from '../common/AutoJobLogo';

// Custom styled components for better theming
const CustomStepConnector = styled(StepConnector)(({ theme }) => ({
  [`&.${stepConnectorClasses.alternativeLabel}`]: {
    top: 22,
  },
  [`&.${stepConnectorClasses.active}`]: {
    [`& .${stepConnectorClasses.line}`]: {
      backgroundColor: theme.palette.primary.main,
    },
  },
  [`&.${stepConnectorClasses.completed}`]: {
    [`& .${stepConnectorClasses.line}`]: {
      backgroundColor: theme.palette.success.main,
    },
  },
  [`& .${stepConnectorClasses.line}`]: {
    height: 3,
    border: 0,
    backgroundColor: theme.palette.divider,
    borderRadius: 1,
  },
}));

const FeatureBox = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(2.5),
  backgroundColor: theme.palette.background.default,
  border: `1px solid ${theme.palette.divider}`,
  borderRadius: theme.spacing(1.5),
  transition: 'all 0.2s ease-in-out',
  '&:hover': {
    borderColor: theme.palette.primary.light,
    backgroundColor: theme.palette.background.paper,
  },
}));

const SuccessBox = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(3),
  backgroundColor: theme.palette.success.light,
  border: `1px solid ${theme.palette.success.main}`,
  borderRadius: theme.spacing(1.5),
  '& .MuiTypography-root': {
    color: theme.palette.success.contrastText,
  },
}));

const FindJobsDialog = ({ open, onClose }) => {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  const [resumes, setResumes] = useState([]);
  const [selectedResumeId, setSelectedResumeId] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [searchStarted, setSearchStarted] = useState(false);
  const [resumesLoading, setResumesLoading] = useState(true);

  const steps = ['Select Resume', 'Confirm Search', 'Search Started'];

  useEffect(() => {
    if (open) {
      fetchResumes();
      // Reset state when dialog opens
      setActiveStep(0);
      setSelectedResumeId('');
      setError('');
      setSearchStarted(false);
    }
  }, [open]);

  const fetchResumes = async () => {
    try {
      setResumesLoading(true);
      setError('');
      const resumesData = await resumeService.getUserResumes();
      setResumes(resumesData || []);
      
      if (resumesData && resumesData.length === 1) {
        setSelectedResumeId(resumesData[0]._id);
      }
    } catch (err) {
      console.error('Error fetching resumes:', err);
      setError('Failed to load resumes. Please try again.');
    } finally {
      setResumesLoading(false);
    }
  };

  const handleNext = () => {
    if (activeStep === 0 && !selectedResumeId) {
      setError('Please select a resume to continue');
      return;
    }
    
    if (activeStep === 1) {
      handleStartSearch();
    } else {
      setActiveStep((prevStep) => prevStep + 1);
      setError('');
    }
  };

  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
    setError('');
  };

  const handleClose = () => {
    if (!searchStarted || activeStep === 2) {
      setActiveStep(0);
      setSelectedResumeId('');
      setError('');
      setSearchStarted(false);
      onClose();
    }
  };

  const handleStartSearch = async () => {
    try {
      setLoading(true);
      setError('');
      setSearchStarted(true);

      const response = await jobService.findJobsWithAi(selectedResumeId);
      
      // The backend returns a 202 status with a message
      // This is actually a success response, not an error
      console.log('AI Search Response:', response);
      
      // Move to success step
      setActiveStep(2);
    } catch (err) {
      console.error('Error starting AI job search:', err);
      
      // Check if this is actually a success response (202 status)
      if (err.response && err.response.status === 202) {
        // This is actually success - the backend returns 202 for async operations
        setActiveStep(2);
      } else {
        // This is a real error
        setError(err.response?.data?.message || err.message || 'Failed to start job search. Please try again.');
        setSearchStarted(false);
      }
    } finally {
      setLoading(false);
    }
  };

  const getSelectedResume = () => {
    return resumes.find(r => r._id === selectedResumeId);
  };

  const renderStepContent = () => {
    switch (activeStep) {
      case 0:
        return (
          <Box sx={{ mt: 2 }}>
            <Typography variant="body1" paragraph color="text.secondary">
              Select a resume to use for AI job discovery. AJ will analyze your resume and search for relevant job opportunities for you.
            </Typography>
            
            {resumesLoading ? (
              <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                <CircularProgress size={40} thickness={4} />
              </Box>
            ) : resumes.length === 0 ? (
              <Alert 
                severity="warning" 
                sx={{ 
                  mt: 2,
                  borderRadius: 2,
                  '& .MuiAlert-icon': {
                    fontSize: '1.5rem'
                  }
                }}
              >
                <Typography variant="body2" fontWeight={500} gutterBottom>
                  You don't have any resumes uploaded yet.
                </Typography>
                <Typography variant="body2">
                  Please upload a resume first before using the AI job search feature.
                </Typography>
              </Alert>
            ) : (
              <>
                <FormControl fullWidth sx={{ mt: 3 }}>
                  <InputLabel id="resume-select-label">Select Resume</InputLabel>
                  <Select
                    labelId="resume-select-label"
                    value={selectedResumeId}
                    onChange={(e) => setSelectedResumeId(e.target.value)}
                    label="Select Resume"
                    sx={{
                      borderRadius: 2,
                      '& .MuiSelect-select': {
                        py: 1.5,
                      }
                    }}
                  >
                    {resumes.map((resume) => (
                      <MenuItem key={resume._id} value={resume._id}>
                        <Box sx={{ width: '100%' }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                            <Typography variant="body1" fontWeight={500}>{resume.name}</Typography>
                            {resume.isTailored && (
                              <Chip 
                                label="AI Tailored" 
                                size="small" 
                                color="secondary"
                                sx={{ ml: 1, borderRadius: 1 }}
                              />
                            )}
                          </Box>
                          <Typography variant="caption" color="text.secondary">
                            Updated: {new Date(resume.updatedAt || resume.createdAt).toLocaleDateString()}
                            {resume.analysis?.overallScore && ` • Score: ${resume.analysis.overallScore}/100`}
                          </Typography>
                        </Box>
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>

                {selectedResumeId && getSelectedResume() && (
                  <FeatureBox sx={{ mt: 3 }}>
                    <Typography variant="subtitle2" fontWeight={600} gutterBottom color="primary">
                      Selected Resume Details
                    </Typography>
                    {(() => {
                      const selected = getSelectedResume();
                      return (
                        <List dense disablePadding>
                          <ListItem disableGutters>
                            <ListItemIcon sx={{ minWidth: 36 }}>
                              <DescriptionIcon fontSize="small" color="primary" />
                            </ListItemIcon>
                            <ListItemText 
                              primary={selected.name}
                              secondary={`File type: ${selected.fileType}`}
                              primaryTypographyProps={{ fontWeight: 500 }}
                            />
                          </ListItem>
                          {selected.parsedData?.experience?.[0] && (
                            <ListItem disableGutters>
                              <ListItemIcon sx={{ minWidth: 36 }}>
                                <WorkIcon fontSize="small" color="info" />
                              </ListItemIcon>
                              <ListItemText 
                                primary="Current/Recent Role"
                                secondary={`${selected.parsedData.experience[0].title} at ${selected.parsedData.experience[0].company}`}
                                primaryTypographyProps={{ fontWeight: 500 }}
                              />
                            </ListItem>
                          )}
                        </List>
                      );
                    })()}
                  </FeatureBox>
                )}
              </>
            )}
          </Box>
        );

      case 1:
        const selectedResume = getSelectedResume();
        return (
          <Box sx={{ mt: 2 }}>
            <Box sx={{ textAlign: 'center', mb: 3 }}>
              <AutoJobLogo 
                variant="icon-only" 
                size="large" 
                color="primary"
                sx={{ mb: 2 }}
              />
              <Typography variant="h6" gutterBottom fontWeight={600} color="text.primary">
                Ready to Let AJ our AI Agent Do Your Job Search?
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Our trained AI Agent will search for real job openings that match your profile
              </Typography>
            </Box>

            <Alert 
              severity="info" 
              icon={<InfoIcon />} 
              sx={{ 
                mb: 3,
                borderRadius: 2,
                backgroundColor: 'info.light',
                border: '1px solid',
                borderColor: 'info.main',
                '& .MuiAlert-icon': {
                  fontSize: '1.5rem'
                }
              }}
            >
              <Typography variant="body2" fontWeight={600} gutterBottom>
                Daily Job Limit: Up to 10 Jobs
              </Typography>
              <Typography variant="body2">
                AJ will find and add up to 10 relevant job openings per day to your job list. 
                The search will continue running daily until you pause or cancel it.
              </Typography>
            </Alert>

            <FeatureBox sx={{ mb: 3 }}>
              <Typography variant="subtitle2" fontWeight={600} gutterBottom color="primary">
                How it works:
              </Typography>
              <List dense>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <SearchIcon fontSize="small" color="success" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Real Job Search"
                    secondary="Our AI Agent acts like a human and searches for real openings"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <CalendarIcon fontSize="small" color="info" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Daily Updates"
                    secondary="Finds up to 10 new jobs per day matching your profile"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <SpeedIcon fontSize="small" color="warning" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Automatic Process"
                    secondary="Runs in the background - you can close this and check back later"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <CheckCircleIcon fontSize="small" color="success" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Quality Matches"
                    secondary="Only adds jobs that closely match your skills and experience"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
              </List>
            </FeatureBox>

            <Alert 
              severity="warning" 
              icon={<WarningIcon />}
              sx={{
                borderRadius: 2,
                backgroundColor: 'warning.light',
                border: '1px solid',
                borderColor: 'warning.main',
                '& .MuiAlert-icon': {
                  fontSize: '1.5rem'
                }
              }}
            >
              <Typography variant="body2">
                <strong>Note:</strong> If no matching jobs are found, the search will notify you and provide suggestions for improving your search criteria.
              </Typography>
            </Alert>

            {loading && (
              <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                <CircularProgress size={40} thickness={4} />
              </Box>
            )}
          </Box>
        );

      case 2:
        return (
          <Box sx={{ mt: 2, textAlign: 'center' }}>
            <CheckCircleIcon sx={{ fontSize: 80, color: 'success.main', mb: 2 }} />
            <Typography variant="h6" gutterBottom fontWeight={600}>
              AI Job Search Started!
            </Typography>
            <Typography variant="body1" paragraph color="text.secondary">
              Your AI job search is now running in the background.
            </Typography>
            
            <SuccessBox sx={{ mb: 3 }}>
              <Typography variant="body1" fontWeight={600} gutterBottom sx={{ color: 'success.dark !important' }}>
                What happens next:
              </Typography>
              <List dense>
                <ListItem sx={{ px: 0 }}>
                  <ListItemText 
                    primary="• Up to 10 relevant jobs will be added daily"
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      sx: { color: 'success.dark' }
                    }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemText 
                    primary="• Jobs will appear in your job list marked with 'AI Found'"
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      sx: { color: 'success.dark' }
                    }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemText 
                    primary="• You'll receive notifications for new matches"
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      sx: { color: 'success.dark' }
                    }}
                  />
                </ListItem>
              </List>
            </SuccessBox>
            
            <Button
              variant="contained"
              color="primary"
              onClick={() => {
                handleClose();
                navigate('/jobs/ai-searches');
              }}
              sx={{ 
                mb: 2,
                px: 4,
                py: 1.5,
                borderRadius: 2,
                fontWeight: 600,
                textTransform: 'none'
              }}
            >
              View AI Searches
            </Button>
            
            <Typography variant="body2" color="text.secondary">
              You can manage your AI job searches from the AI Discovery page
            </Typography>
          </Box>
        );

      default:
        return null;
    }
  };

  return (
    <Dialog 
      open={open} 
      onClose={handleClose}
      maxWidth="sm"
      fullWidth
      disableEscapeKeyDown={searchStarted && activeStep !== 2}
      PaperProps={{
        sx: {
          borderRadius: 3,
          boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.12)',
        }
      }}
    >
      <DialogTitle>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <AutoJobLogo 
              variant="icon-only" 
              size="small" 
              color="primary"
              sx={{ mr: 1.5 }}
            />
            <Typography variant="h6" fontWeight={600}>Find Jobs with AJ</Typography>
          </Box>
          <IconButton 
            onClick={handleClose} 
            size="small"
            disabled={searchStarted && activeStep !== 2}
            sx={{
              '&:hover': {
                backgroundColor: 'action.hover',
              }
            }}
          >
            <CloseIcon />
          </IconButton>
        </Box>
      </DialogTitle>
      
      <DialogContent sx={{ px: 3 }}>
        <Stepper 
          activeStep={activeStep} 
          connector={<CustomStepConnector />}
          sx={{ 
            mb: 3,
            '& .MuiStepLabel-label': {
              fontWeight: 500,
              fontSize: '0.875rem'
            },
            '& .MuiStepLabel-label.Mui-active': {
              fontWeight: 600,
              color: 'primary.main'
            },
            '& .MuiStepLabel-label.Mui-completed': {
              color: 'success.main'
            }
          }}
        >
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {error && (
          <Alert 
            severity="error" 
            sx={{ 
              mb: 2,
              borderRadius: 2,
              '& .MuiAlert-icon': {
                fontSize: '1.5rem'
              }
            }} 
            onClose={() => setError('')}
          >
            {error}
          </Alert>
        )}
        
        {renderStepContent()}
      </DialogContent>
      
      <DialogActions sx={{ px: 3, pb: 3, gap: 1 }}>
        {activeStep === 0 && (
          <>
            <Button 
              onClick={handleClose}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 500
              }}
            >
              Cancel
            </Button>
            <Button 
              variant="contained" 
              onClick={handleNext}
              disabled={!selectedResumeId || resumesLoading}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 600,
                px: 3
              }}
            >
              Next
            </Button>
          </>
        )}
        
        {activeStep === 1 && (
          <>
            <Button 
              onClick={handleBack} 
              disabled={loading}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 500
              }}
            >
              Back
            </Button>
            <Button 
              variant="contained" 
              onClick={handleNext}
              disabled={loading}
              startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <SearchIcon />}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 600,
                px: 3
              }}
            >
              {loading ? 'Starting...' : 'Start AI Search'}
            </Button>
          </>
        )}
        
        {activeStep === 2 && (
          <Button 
            variant="contained" 
            onClick={handleClose}
            sx={{ 
              borderRadius: 2,
              textTransform: 'none',
              fontWeight: 600,
              px: 4
            }}
          >
            Done
          </Button>
        )}
      </DialogActions>
    </Dialog>
  );
};

export default FindJobsDialog;

================
File: src/components/jobs/hooks/useAiSearches.js
================
// src/components/jobs/hooks/useAiSearches.js
import { useState, useEffect } from 'react';
import jobService from '../../../utils/jobService';

export const useAiSearches = () => {
  const [searches, setSearches] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [actionLoading, setActionLoading] = useState({});

  const fetchSearches = async () => {
    try {
      const data = await jobService.getAiSearches();
      // Filter out cancelled searches from the UI
      const activeSearches = data.filter(search => search.status !== 'cancelled');
      setSearches(activeSearches);
      setError('');
    } catch (err) {
      console.error('Error fetching AI searches:', err);
      setError('Failed to load AI searches');
    } finally {
      setLoading(false);
    }
  };

  const handlePauseResume = async (searchId, currentStatus) => {
    setActionLoading(prev => ({ ...prev, [searchId]: true }));
    try {
      if (currentStatus === 'running') {
        await jobService.pauseAiSearch(searchId);
        return { success: true, message: 'Search paused successfully' };
      } else if (currentStatus === 'paused') {
        await jobService.resumeAiSearch(searchId);
        return { success: true, message: 'Search resumed successfully' };
      }
      await fetchSearches();
    } catch (err) {
      console.error('Error updating search:', err);
      setError('Failed to update search status');
      return { success: false, message: 'Failed to update search status' };
    } finally {
      setActionLoading(prev => ({ ...prev, [searchId]: false }));
    }
  };

  const handleDelete = async (searchId) => {
    setActionLoading(prev => ({ ...prev, [searchId]: true }));
    try {
      await jobService.deleteAiSearch(searchId);
      await fetchSearches();
      return { success: true, message: 'Search cancelled successfully' };
    } catch (err) {
      console.error('Error deleting search:', err);
      setError('Failed to delete search');
      return { success: false, message: 'Failed to cancel search' };
    } finally {
      setActionLoading(prev => ({ ...prev, [searchId]: false }));
    }
  };

  useEffect(() => {
    fetchSearches();
    // Refresh every 30 seconds to show updates
    const interval = setInterval(fetchSearches, 30000);
    return () => clearInterval(interval);
  }, []);

  return {
    searches,
    loading,
    error,
    actionLoading,
    setError,
    fetchSearches,
    handlePauseResume,
    handleDelete
  };
};

================
File: src/components/jobs/hooks/useJobAnalysis.js
================
// src/components/jobs/hooks/useJobAnalysis.js
import { useState, useEffect, useCallback } from 'react';
import jobService from '../../../utils/jobService';

/**
 * Custom hook for managing job analysis status and polling
 * @param {string} jobId - The ID of the job to monitor
 * @param {Object} options - Configuration options
 * @returns {Object} Analysis status and control functions
 */
export const useJobAnalysis = (jobId, options = {}) => {
  const {
    autoStart = true,
    pollInterval = 2000,
    maxAttempts = 30,
    onComplete = null,
    onError = null,
    onProgress = null
  } = options;

  const [analysisStatus, setAnalysisStatus] = useState(null);
  const [isPolling, setIsPolling] = useState(false);
  const [error, setError] = useState(null);
  const [attempts, setAttempts] = useState(0);

  // Check if analysis is complete
  const isComplete = analysisStatus?.status === 'completed' || analysisStatus?.status === 'error';
  const canViewJob = analysisStatus?.canViewJob === true;

  // Fetch current status
  const fetchStatus = useCallback(async () => {
    if (!jobId) return null;

    try {
      const response = await jobService.getJobAnalysisStatus(jobId);
      const status = response.analysisStatus;
      
      setAnalysisStatus(status);
      setError(null);
      
      // Call progress callback
      if (onProgress && typeof onProgress === 'function') {
        onProgress(status);
      }
      
      return status;
    } catch (err) {
      console.error('Error fetching job analysis status:', err);
      setError(err.message || 'Failed to fetch analysis status');
      
      if (onError && typeof onError === 'function') {
        onError(err);
      }
      
      return null;
    }
  }, [jobId, onProgress, onError]);

  // Start polling for status updates
  const startPolling = useCallback(async () => {
    if (!jobId || isPolling) return;

    setIsPolling(true);
    setAttempts(0);
    setError(null);

    let currentAttempts = 0;
    let pollTimeoutId;

    const poll = async () => {
      try {
        currentAttempts++;
        setAttempts(currentAttempts);

        const status = await fetchStatus();
        
        if (!status) {
          throw new Error('Failed to fetch status');
        }

        // Check if analysis is complete
        if (status.status === 'completed' || status.status === 'error') {
          setIsPolling(false);
          
          if (onComplete && typeof onComplete === 'function') {
            onComplete(status);
          }
          
          return;
        }

        // Check if we've reached max attempts
        if (currentAttempts >= maxAttempts) {
          setIsPolling(false);
          const timeoutError = new Error('Analysis polling timed out');
          setError(timeoutError.message);
          
          if (onError && typeof onError === 'function') {
            onError(timeoutError);
          }
          
          return;
        }

        // Schedule next poll
        pollTimeoutId = setTimeout(poll, pollInterval);
        
      } catch (err) {
        console.error('Error during polling:', err);
        setIsPolling(false);
        setError(err.message || 'Polling failed');
        
        if (onError && typeof onError === 'function') {
          onError(err);
        }
      }
    };

    // Start polling
    await poll();

    // Return cleanup function
    return () => {
      if (pollTimeoutId) {
        clearTimeout(pollTimeoutId);
      }
      setIsPolling(false);
    };
  }, [jobId, isPolling, fetchStatus, pollInterval, maxAttempts, onComplete, onError]);

  // Stop polling
  const stopPolling = useCallback(() => {
    setIsPolling(false);
  }, []);

  // Reset analysis status
  const reset = useCallback(() => {
    setAnalysisStatus(null);
    setError(null);
    setAttempts(0);
    setIsPolling(false);
  }, []);

  // Auto-start polling if job needs analysis
  useEffect(() => {
    if (!autoStart || !jobId) return;

    const initializeAnalysis = async () => {
      const status = await fetchStatus();
      
      // Start polling if analysis is in progress
      if (status && (status.status === 'pending' || status.status === 'analyzing')) {
        startPolling();
      }
    };

    initializeAnalysis();
  }, [jobId, autoStart, fetchStatus, startPolling]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      setIsPolling(false);
    };
  }, []);

  return {
    // Status data
    analysisStatus,
    isPolling,
    error,
    attempts,
    
    // Computed states
    isComplete,
    canViewJob,
    isPending: analysisStatus?.status === 'pending',
    isAnalyzing: analysisStatus?.status === 'analyzing',
    hasError: analysisStatus?.status === 'error',
    progress: analysisStatus?.progress || 0,
    message: analysisStatus?.message || '',
    skillsFound: analysisStatus?.skillsFound || 0,
    experienceLevel: analysisStatus?.experienceLevel,
    
    // Control functions
    startPolling,
    stopPolling,
    fetchStatus,
    reset
  };
};

/**
 * Hook for managing multiple job analysis statuses
 * @param {Array} jobIds - Array of job IDs to monitor
 * @param {Object} options - Configuration options
 * @returns {Object} Analysis statuses and control functions
 */
export const useMultipleJobAnalysis = (jobIds = [], options = {}) => {
  const [statuses, setStatuses] = useState({});
  const [pollingJobs, setPollingJobs] = useState(new Set());

  const updateJobStatus = useCallback((jobId, status) => {
    setStatuses(prev => ({
      ...prev,
      [jobId]: status
    }));
  }, []);

  const startPollingJob = useCallback(async (jobId) => {
    if (pollingJobs.has(jobId)) return;

    setPollingJobs(prev => new Set([...prev, jobId]));

    try {
      await jobService.pollJobAnalysisStatus(
        jobId,
        (status) => updateJobStatus(jobId, status),
        options.maxAttempts || 30
      );
    } catch (error) {
      console.error(`Polling failed for job ${jobId}:`, error);
      updateJobStatus(jobId, {
        status: 'error',
        message: 'Polling failed',
        progress: 0
      });
    } finally {
      setPollingJobs(prev => {
        const newSet = new Set(prev);
        newSet.delete(jobId);
        return newSet;
      });
    }
  }, [pollingJobs, updateJobStatus, options.maxAttempts]);

  // Initialize polling for jobs that need it
  useEffect(() => {
    jobIds.forEach(async (jobId) => {
      if (!statuses[jobId] && !pollingJobs.has(jobId)) {
        try {
          const response = await jobService.getJobAnalysisStatus(jobId);
          const status = response.analysisStatus;
          
          updateJobStatus(jobId, status);
          
          // Start polling if needed
          if (status.status === 'pending' || status.status === 'analyzing') {
            startPollingJob(jobId);
          }
        } catch (error) {
          console.error(`Error fetching status for job ${jobId}:`, error);
        }
      }
    });
  }, [jobIds, statuses, pollingJobs, updateJobStatus, startPollingJob]);

  const getJobStatus = useCallback((jobId) => {
    return statuses[jobId] || null;
  }, [statuses]);

  const isJobPolling = useCallback((jobId) => {
    return pollingJobs.has(jobId);
  }, [pollingJobs]);

  const getAnalyzingCount = useCallback(() => {
    return Object.values(statuses).filter(status => 
      status.status === 'pending' || status.status === 'analyzing'
    ).length;
  }, [statuses]);

  const getCompletedCount = useCallback(() => {
    return Object.values(statuses).filter(status => 
      status.status === 'completed'
    ).length;
  }, [statuses]);

  const getErrorCount = useCallback(() => {
    return Object.values(statuses).filter(status => 
      status.status === 'error'
    ).length;
  }, [statuses]);

  return {
    statuses,
    pollingJobs,
    getJobStatus,
    isJobPolling,
    getAnalyzingCount,
    getCompletedCount,
    getErrorCount,
    updateJobStatus,
    startPollingJob
  };
};

export default useJobAnalysis;

================
File: src/components/jobs/JobCreateDialog.js
================
// src/components/jobs/JobCreateDialog.js
import React, { useState } from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Button, 
  TextField, 
  Grid, 
  Box, 
  FormControl, 
  InputLabel, 
  Select, 
  MenuItem, 
  Switch, 
  FormControlLabel, 
  Typography, 
  Divider, 
  Alert,
  CircularProgress,
  Paper,
  InputAdornment,
  useTheme
} from '@mui/material';
import { 
  Add as AddIcon,
  Close as CloseIcon,
  Work as WorkIcon,
  Business as BusinessIcon,
  Link as LinkIcon,
  LocationOn as LocationOnIcon,
  Public as PublicIcon,
  Schedule as ScheduleIcon,
  AttachMoney as AttachMoneyIcon,
  Description as DescriptionIcon,
  Home as HomeIcon
} from '@mui/icons-material';
import jobService from '../../utils/jobService';

const JobCreateDialog = ({ open, onClose, onJobCreated }) => {
  const theme = useTheme();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  const [jobData, setJobData] = useState({
    title: '',
    company: '',
    location: {
      city: '',
      state: '',
      country: 'US',
      remote: false
    },
    description: '',
    sourceUrl: '',
    salary: {
      min: '',
      max: '',
      currency: 'USD'
    },
    jobType: 'FULL_TIME'
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    
    // Handle nested properties
    if (name.includes('.')) {
      const [parent, child] = name.split('.');
      setJobData(prev => ({
        ...prev,
        [parent]: {
          ...prev[parent],
          [child]: value
        }
      }));
    } else {
      setJobData(prev => ({
        ...prev,
        [name]: value
      }));
    }
  };

  const handleSwitchChange = (e) => {
    const { name, checked } = e.target;
    
    if (name === 'location.remote') {
      setJobData(prev => ({
        ...prev,
        location: {
          ...prev.location,
          remote: checked
        }
      }));
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate form
    if (!jobData.title || !jobData.company || !jobData.description) {
      setError('Job title, company, and description are required');
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      // Clean up salary data
      const formattedJobData = {
        ...jobData,
        salary: {
          ...jobData.salary,
          min: jobData.salary.min ? Number(jobData.salary.min) : undefined,
          max: jobData.salary.max ? Number(jobData.salary.max) : undefined
        }
      };
      
      await jobService.createJob(formattedJobData);
      
      // Clear form and close dialog
      setJobData({
        title: '',
        company: '',
        location: {
          city: '',
          state: '',
          country: 'US',
          remote: false
        },
        description: '',
        sourceUrl: '',
        salary: {
          min: '',
          max: '',
          currency: 'USD'
        },
        jobType: 'FULL_TIME'
      });
      
      onJobCreated();
    } catch (err) {
      console.error('Error creating job:', err);
      setError(err.response?.data?.message || 'Failed to create job. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleCancel = () => {
    // Clear form
    setJobData({
      title: '',
      company: '',
      location: {
        city: '',
        state: '',
        country: 'US',
        remote: false
      },
      description: '',
      sourceUrl: '',
      salary: {
        min: '',
        max: '',
        currency: 'USD'
      },
      jobType: 'FULL_TIME'
    });
    setError('');
    onClose();
  };

  return (
    <Dialog 
      open={open} 
      onClose={loading ? null : handleCancel}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: { 
          borderRadius: 3,
          // Custom scrollbar styling specifically for this dialog
          '& .MuiDialogContent-root': {
            // Override scrollbar for dialog content
            '&::-webkit-scrollbar': {
              width: '4px',
            },
            '&::-webkit-scrollbar-track': {
              backgroundColor: 'transparent',
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0, 0, 0, 0.2)',
              borderRadius: '2px',
              '&:hover': {
                backgroundColor: 'rgba(0, 0, 0, 0.3)',
              },
              '&:active': {
                backgroundColor: 'rgba(0, 0, 0, 0.4)',
              },
            },
            '&::-webkit-scrollbar-corner': {
              backgroundColor: 'transparent',
            },
            // Firefox scrollbar styling
            scrollbarWidth: 'thin',
            scrollbarColor: 'rgba(0, 0, 0, 0.2) transparent',
          }
        }
      }}
    >
      <DialogTitle sx={{ 
        background: `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.light} 100%)`,
        color: 'white',
        py: 2
      }}>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
            <WorkIcon sx={{ fontSize: 28 }} />
            <Typography variant="h6" fontWeight={600}>Add New Job</Typography>
          </Box>
          <Button 
            color="inherit" 
            onClick={handleCancel}
            disabled={loading}
            sx={{ 
              minWidth: 'auto', 
              p: 1,
              borderRadius: 2,
              '&:hover': {
                bgcolor: 'rgba(255,255,255,0.1)'
              }
            }}
          >
            <CloseIcon />
          </Button>
        </Box>
      </DialogTitle>
      
      <form onSubmit={handleSubmit}>
        <DialogContent sx={{ 
          p: 3,
          // Enhanced scrollbar styling for the content area
          maxHeight: '70vh',
          overflowY: 'auto',
          // Custom scrollbar that matches your theme
          '&::-webkit-scrollbar': {
            width: '4px',
          },
          '&::-webkit-scrollbar-track': {
            backgroundColor: 'transparent',
          },
          '&::-webkit-scrollbar-thumb': {
            backgroundColor: 'rgba(0, 0, 0, 0.2)',
            borderRadius: '2px',
            '&:hover': {
              backgroundColor: 'rgba(0, 0, 0, 0.3)',
            },
            '&:active': {
              backgroundColor: 'rgba(0, 0, 0, 0.4)',
            },
          },
          '&::-webkit-scrollbar-corner': {
            backgroundColor: 'transparent',
          },
          // Firefox scrollbar styling
          scrollbarWidth: 'thin',
          scrollbarColor: 'rgba(0, 0, 0, 0.2) transparent',
        }}>
          {error && (
            <Alert 
              severity="error" 
              sx={{ 
                mb: 3, 
                borderRadius: 2,
                '& .MuiAlert-icon': {
                  fontSize: '1.2rem'
                }
              }}
            >
              {error}
            </Alert>
          )}
          
          {/* Basic Job Information Section */}
          <Paper elevation={1} sx={{ p: 2.5, mb: 3, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <WorkIcon color="primary" />
              <Typography variant="subtitle1" fontWeight={600} color="primary">
                Basic Job Information
              </Typography>
            </Box>
            
            <Grid container spacing={2.5}>
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Job Title"
                  name="title"
                  value={jobData.title}
                  onChange={handleChange}
                  fullWidth
                  required
                  disabled={loading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <WorkIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Company"
                  name="company"
                  value={jobData.company}
                  onChange={handleChange}
                  fullWidth
                  required
                  disabled={loading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <BusinessIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12}>
                <TextField
                  label="Job URL (Original Listing)"
                  name="sourceUrl"
                  value={jobData.sourceUrl}
                  onChange={handleChange}
                  fullWidth
                  placeholder="https://example.com/job-listing"
                  disabled={loading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LinkIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
            </Grid>
          </Paper>
          
          {/* Location Section */}
          <Paper elevation={1} sx={{ p: 2.5, mb: 3, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <LocationOnIcon color="secondary" />
              <Typography variant="subtitle1" fontWeight={600} color="secondary">
                Location
              </Typography>
            </Box>
            
            <Grid container spacing={2.5}>
              <Grid item xs={12}>
                <FormControlLabel
                  control={
                    <Switch 
                      checked={jobData.location.remote} 
                      onChange={handleSwitchChange}
                      name="location.remote"
                      disabled={loading}
                      color="secondary"
                    />
                  }
                  label={
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <HomeIcon fontSize="small" color="secondary" />
                      <Typography variant="body2" fontWeight={500}>Remote Position</Typography>
                    </Box>
                  }
                />
              </Grid>
              
              <Grid item xs={12} sm={4}>
                <TextField
                  label="City"
                  name="location.city"
                  value={jobData.location.city}
                  onChange={handleChange}
                  fullWidth
                  disabled={loading || jobData.location.remote}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LocationOnIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={4}>
                <TextField
                  label="State/Province"
                  name="location.state"
                  value={jobData.location.state}
                  onChange={handleChange}
                  fullWidth
                  disabled={loading || jobData.location.remote}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={4}>
                <FormControl fullWidth disabled={loading || jobData.location.remote}>
                  <InputLabel>Country</InputLabel>
                  <Select
                    name="location.country"
                    value={jobData.location.country}
                    onChange={handleChange}
                    label="Country"
                    startAdornment={
                      <InputAdornment position="start">
                        <PublicIcon color="action" fontSize="small" />
                      </InputAdornment>
                    }
                    sx={{ borderRadius: 2 }}
                  >
                    <MenuItem value="US">🇺🇸 United States</MenuItem>
                    <MenuItem value="CA">🇨🇦 Canada</MenuItem>
                    <MenuItem value="UK">🇬🇧 United Kingdom</MenuItem>
                    <MenuItem value="AU">🇦🇺 Australia</MenuItem>
                    <MenuItem value="IN">🇮🇳 India</MenuItem>
                    <MenuItem value="DE">🇩🇪 Germany</MenuItem>
                    <MenuItem value="FR">🇫🇷 France</MenuItem>
                    <MenuItem value="OTHER">🌍 Other</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          </Paper>
          
          {/* Job Details Section */}
          <Paper elevation={1} sx={{ p: 2.5, mb: 3, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <ScheduleIcon color="success" />
              <Typography variant="subtitle1" fontWeight={600} color="success.main">
                Job Details
              </Typography>
            </Box>
            
            <Grid container spacing={2.5}>
              <Grid item xs={12} sm={6}>
                <FormControl fullWidth disabled={loading}>
                  <InputLabel>Job Type</InputLabel>
                  <Select
                    name="jobType"
                    value={jobData.jobType}
                    onChange={handleChange}
                    label="Job Type"
                    startAdornment={
                      <InputAdornment position="start">
                        <ScheduleIcon color="action" fontSize="small" />
                      </InputAdornment>
                    }
                    sx={{ borderRadius: 2 }}
                  >
                    <MenuItem value="FULL_TIME">💼 Full-time</MenuItem>
                    <MenuItem value="PART_TIME">⏰ Part-time</MenuItem>
                    <MenuItem value="CONTRACT">📋 Contract</MenuItem>
                    <MenuItem value="FREELANCE">🎯 Freelance</MenuItem>
                    <MenuItem value="INTERNSHIP">🎓 Internship</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <FormControl fullWidth disabled={loading}>
                  <InputLabel>Currency</InputLabel>
                  <Select
                    name="salary.currency"
                    value={jobData.salary.currency}
                    onChange={handleChange}
                    label="Currency"
                    startAdornment={
                      <InputAdornment position="start">
                        <AttachMoneyIcon color="action" fontSize="small" />
                      </InputAdornment>
                    }
                    sx={{ borderRadius: 2 }}
                  >
                    <MenuItem value="USD">💵 USD ($)</MenuItem>
                    <MenuItem value="EUR">💶 EUR (€)</MenuItem>
                    <MenuItem value="GBP">💷 GBP (£)</MenuItem>
                    <MenuItem value="CAD">🍁 CAD (C$)</MenuItem>
                    <MenuItem value="AUD">🦘 AUD (A$)</MenuItem>
                    <MenuItem value="INR">🇮🇳 INR (₹)</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Minimum Salary"
                  name="salary.min"
                  value={jobData.salary.min}
                  onChange={handleChange}
                  fullWidth
                  type="number"
                  InputProps={{ 
                    inputProps: { min: 0 },
                    startAdornment: (
                      <InputAdornment position="start">
                        <AttachMoneyIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  disabled={loading}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Maximum Salary"
                  name="salary.max"
                  value={jobData.salary.max}
                  onChange={handleChange}
                  fullWidth
                  type="number"
                  InputProps={{ 
                    inputProps: { min: 0 },
                    startAdornment: (
                      <InputAdornment position="start">
                        <AttachMoneyIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  disabled={loading}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
            </Grid>
          </Paper>

          {/* Job Description Section */}
          <Paper elevation={1} sx={{ p: 2.5, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <DescriptionIcon color="warning" />
              <Typography variant="subtitle1" fontWeight={600} color="warning.main">
                Job Description
              </Typography>
            </Box>
            
            <TextField
              label="Job Description"
              name="description"
              value={jobData.description}
              onChange={handleChange}
              fullWidth
              required
              multiline
              rows={8}
              placeholder="Paste the full job description here..."
              disabled={loading}
              sx={{ 
                '& .MuiOutlinedInput-root': { 
                  borderRadius: 2,
                  '& textarea': {
                    fontSize: '0.9rem',
                    lineHeight: 1.5,
                    // Custom scrollbar for textarea
                    '&::-webkit-scrollbar': {
                      width: '4px',
                    },
                    '&::-webkit-scrollbar-track': {
                      backgroundColor: 'transparent',
                    },
                    '&::-webkit-scrollbar-thumb': {
                      backgroundColor: 'rgba(0, 0, 0, 0.2)',
                      borderRadius: '2px',
                      '&:hover': {
                        backgroundColor: 'rgba(0, 0, 0, 0.3)',
                      },
                    },
                    '&::-webkit-scrollbar-corner': {
                      backgroundColor: 'transparent',
                    },
                  }
                } 
              }}
            />
          </Paper>
        </DialogContent>
        
        <DialogActions sx={{ 
          px: 3, 
          py: 2, 
          borderTop: `1px solid ${theme.palette.divider}`,
          bgcolor: 'rgba(0,0,0,0.02)'
        }}>
          <Button 
            onClick={handleCancel} 
            disabled={loading}
            variant="outlined"
            sx={{ 
              borderRadius: 2,
              px: 3
            }}
          >
            Cancel
          </Button>
          <Button 
            type="submit" 
            variant="contained" 
            color="primary" 
            disabled={loading}
            startIcon={loading ? <CircularProgress size={18} color="inherit" /> : <AddIcon />}
            sx={{ 
              borderRadius: 2,
              px: 3,
              py: 1
            }}
          >
            {loading ? 'Creating...' : 'Create Job'}
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
};

export default JobCreateDialog;

================
File: src/components/jobs/JobDetail.js
================
// src/components/jobs/JobDetail.js - Final refactored version with improved dialog
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  Tabs,
  Tab,
  CircularProgress,
  Alert,
  Snackbar,
  Menu,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  useTheme,
  Tooltip,
  Paper,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Card,
  CardContent,
  Divider,
  IconButton,
  Stack,
  Fade,
  alpha
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  SmartToy as SmartToyIcon,
  Description as DescriptionIcon,
  Lightbulb as LightbulbIcon,
  CheckCircle as CheckCircleIcon,
  AutoFixHigh as AutoFixHighIcon,
  Psychology as PsychologyIcon,
  TrendingUp as TrendingUpIcon,
  Speed as SpeedIcon,
  Insights as InsightsIcon,
  Close as CloseIcon,
  Stars as StarsIcon,
  Rocket as RocketIcon
} from '@mui/icons-material';

// Import our component files
import JobHeader from './components/JobHeader';
import OverviewTab from './tabs/OverviewTab';
import AnalysisTab from './tabs/AnalysisTab';
import ContentTab from './tabs/ContentTab';
import AutoJobLogo from '../common/AutoJobLogo';

import jobService from '../../utils/jobService';
import resumeService from '../../utils/resumeService';
import MainLayout from '../layout/MainLayout';

// Tab panel component
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`job-tabpanel-${index}`}
      aria-labelledby={`job-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const JobDetail = () => {
  const theme = useTheme();
  const { id } = useParams();
  const navigate = useNavigate();
  const [job, setJob] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [tabValue, setTabValue] = useState(0);
  const [alert, setAlert] = useState({ open: false, message: '', severity: 'success' });
  const [allResumes, setAllResumes] = useState([]);
  const [resumeMatchStatus, setResumeMatchStatus] = useState({});
  const [anchorEl, setAnchorEl] = useState(null);
  const [tailorDialogOpen, setTailorDialogOpen] = useState(false);
  const [selectedResumeId, setSelectedResumeId] = useState('');
  const [matchLoading, setMatchLoading] = useState(false);

  useEffect(() => {
    fetchJobDetails();
    fetchAllResumes();
  }, [id]);

  const fetchJobDetails = async () => {
    try {
      setLoading(true);
      const jobData = await jobService.getJobById(id);
      setJob(jobData);
      
      // Fetch resume match status
      const matchStatus = await jobService.getResumeMatchStatus(id);
      setResumeMatchStatus(matchStatus.resumeStatusMap || {});
    } catch (error) {
      console.error('Error fetching job details:', error);
      setError('Failed to load job details. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const fetchAllResumes = async () => {
    try {
      const resumesData = await resumeService.getUserResumes();
      setAllResumes(resumesData || []);
    } catch (err) {
      console.error('Error fetching resumes:', err);
    }
  };

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  const handleAlertClose = () => {
    setAlert({ ...alert, open: false });
  };

  const handleMenuClick = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleDeleteJob = async () => {
    try {
      await jobService.deleteJob(id);
      navigate('/jobs');
    } catch (error) {
      console.error('Error deleting job:', error);
      setAlert({
        open: true,
        message: 'Failed to delete job. Please try again.',
        severity: 'error'
      });
    }
  };

  const handleOpenTailorDialog = () => {
    setTailorDialogOpen(true);
    handleMenuClose();
  };

  const handleCloseTailorDialog = () => {
    setTailorDialogOpen(false);
    setSelectedResumeId('');
  };

  const handleResumeChange = (e) => {
    setSelectedResumeId(e.target.value);
  };

  const handleTailorResume = async () => {
    if (!selectedResumeId) {
      setAlert({
        open: true,
        message: 'Please select a resume to tailor',
        severity: 'warning'
      });
      return;
    }

    setMatchLoading(true);
    
    try {
      // First match the resume with the job using enhanced matching
      const matchResult = await jobService.matchResumeWithJob(id, selectedResumeId);
      
      // Show success message with match score
      setAlert({
        open: true,
        message: `Analysis complete! Match score: ${matchResult.matchAnalysis?.overallScore || 'N/A'}%`,
        severity: 'success'
      });
      
      // Refresh job data to show new match analysis
      await fetchJobDetails();
      
      // Navigate to the tailoring page
      navigate(`/jobs/${id}/tailor/${selectedResumeId}`);
    } catch (error) {
      console.error('Error initializing resume tailoring:', error);
      setAlert({
        open: true,
        message: 'Failed to start resume tailoring process. Please try again.',
        severity: 'error'
      });
      setMatchLoading(false);
    }
  };

  const renderResumeStatusChip = (resume) => {
    const status = resumeMatchStatus[resume._id];
    
    if (!status) {
      return null;
    }

    if (status.isTailored) {
      return (
        <Tooltip title={`${status.tailoredVersions.length} tailored version(s) for this job`}>
          <Chip
            icon={<AutoFixHighIcon />}
            label="Tailored"
            color="success"
            size="small"
            sx={{ ml: 1 }}
          />
        </Tooltip>
      );
    }

    if (status.isMatched) {
      return (
        <Tooltip title="Already matched with this job">
          <Chip
            icon={<CheckCircleIcon />}
            label="Matched"
            color="info"
            size="small"
            sx={{ ml: 1 }}
          />
        </Tooltip>
      );
    }

    return null;
  };

  // Render analysis status indicator
  const renderAnalysisStatus = () => {
    if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
      return (
        <Alert severity="warning" sx={{ mb: 2 }}>
          <Typography variant="subtitle2">Job Analysis Pending</Typography>
          <Typography variant="body2">
            This job is still being analyzed. Some features may be limited.
          </Typography>
        </Alert>
      );
    }

    if (job.parsedData.analysisError) {
      return (
        <Alert severity="error" sx={{ mb: 2 }}>
          <Typography variant="subtitle2">Analysis Failed</Typography>
          <Typography variant="body2">
            {job.parsedData.analysisError}
          </Typography>
        </Alert>
      );
    }

    return null;
  };

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
          <CircularProgress size={60} thickness={4} />
          <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
            Loading job details...
          </Typography>
        </Box>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="error">{error}</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/jobs')}
            sx={{ mt: 2 }}
          >
            Back to Jobs
          </Button>
        </Box>
      </MainLayout>
    );
  }

  if (!job) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="info">Job not found.</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/jobs')}
            sx={{ mt: 2 }}
          >
            Back to Jobs
          </Button>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1200px', mx: 'auto' }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/jobs')}
          variant="outlined"
          sx={{ mb: 3 }}
        >
          Back to Jobs
        </Button>

        {/* Job Header Component */}
        <JobHeader 
          job={job}
          onTailorClick={handleOpenTailorDialog}
          onMenuClick={handleMenuClick}
          onOpenOriginal={() => window.open(job.sourceUrl, '_blank')}
        />

        {/* Analysis Status */}
        {renderAnalysisStatus()}

        {/* Tabs without white container background */}
        <Box sx={{ mb: 4 }}>
          <Paper sx={{ borderRadius: 3, overflow: 'hidden', mb: 2 }}>
            <Tabs
              value={tabValue}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ 
                borderBottom: 1, 
                borderColor: 'divider',
                bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.02)',
                '& .MuiTab-root': { 
                  py: 2,
                  fontWeight: 500
                }
              }}
            >
              <Tab label="Overview" icon={<DescriptionIcon />} iconPosition="start" />
              <Tab label="Analysis" icon={<LightbulbIcon />} iconPosition="start" />
              <Tab label="Content" icon={<DescriptionIcon />} iconPosition="start" />
            </Tabs>
          </Paper>

          {/* Tab content without Paper wrapper */}
          {/* Overview Tab */}
          {tabValue === 0 && (
            <Box sx={{ py: 1 }}>
              <OverviewTab 
                job={job} 
                onTailorClick={handleOpenTailorDialog}
              />
            </Box>
          )}

          {/* Analysis Tab */}
          {tabValue === 1 && (
            <Box sx={{ py: 1 }}>
              <AnalysisTab 
                job={job} 
                onTailorClick={handleOpenTailorDialog}
              />
            </Box>
          )}

          {/* Content Tab */}
          {tabValue === 2 && (
            <Box sx={{ py: 1 }}>
              <ContentTab job={job} />
            </Box>
          )}
        </Box>

        {/* Menu */}
        <Menu
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={handleMenuClose}
          PaperProps={{
            elevation: 3,
            sx: { borderRadius: 2 }
          }}
        >

          <MenuItem onClick={handleDeleteJob} sx={{ color: 'error.main' }}>
            <ListItemIcon>
              <DeleteIcon fontSize="small" color="error" />
            </ListItemIcon>
            <ListItemText primary="Delete Job" />
          </MenuItem>
        </Menu>

        {/* Enhanced AI Resume Analysis Dialog */}
        <Dialog
          open={tailorDialogOpen}
          onClose={handleCloseTailorDialog}
          maxWidth="sm"
          fullWidth
          PaperProps={{
            sx: { 
              borderRadius: 4,
              overflow: 'hidden',
              boxShadow: '0px 24px 38px rgba(0, 0, 0, 0.14), 0px 9px 46px rgba(0, 0, 0, 0.12), 0px 11px 15px rgba(0, 0, 0, 0.20)',
              height: 'auto',
              maxHeight: '90vh'
            }
          }}
          TransitionComponent={Fade}
          transitionDuration={300}
        >
          {/* Custom Header with Solid Teal */}
          <DialogTitle 
            sx={{ 
              backgroundColor: theme.palette.secondary.main,
              color: 'white',
              p: 0,
              position: 'relative',
              overflow: 'hidden'
            }}
          >
            {/* Background Pattern */}
            <Box
              sx={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: `radial-gradient(circle at 20% 50%, ${alpha('#ffffff', 0.1)} 0%, transparent 50%), 
                             radial-gradient(circle at 80% 20%, ${alpha('#ffffff', 0.08)} 0%, transparent 50%)`,
                zIndex: 0
              }}
            />
            
            {/* Header Content */}
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              justifyContent: 'space-between',
              p: 2.5,
              position: 'relative',
              zIndex: 1
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                <AutoJobLogo 
                  variant="icon-only" 
                  size="small" 
                  color="white"
                />
                <Box>
                  <Typography 
                    variant="h6" 
                    sx={{ 
                      fontWeight: 700,
                      mb: 0.25,
                      textShadow: '0 2px 4px rgba(0,0,0,0.1)'
                    }}
                  >
                    Enhanced AI Resume Analysis
                  </Typography>
                  <Typography 
                    variant="body2" 
                    sx={{ 
                      opacity: 0.9,
                      fontWeight: 500,
                      fontSize: '0.8rem'
                    }}
                  >
                    Powered by advanced AI agents
                  </Typography>
                </Box>
              </Box>
              
              <IconButton
                onClick={handleCloseTailorDialog}
                sx={{ 
                  color: 'white',
                  '&:hover': {
                    bgcolor: alpha('#ffffff', 0.1)
                  }
                }}
              >
                <CloseIcon />
              </IconButton>
            </Box>
          </DialogTitle>

          <DialogContent sx={{ p: 0, overflow: 'hidden' }}>
            {/* Hero Section */}
            <Box sx={{ 
              p: 2.5, 
              background: `linear-gradient(180deg, ${alpha(theme.palette.secondary.main, 0.02)} 0%, transparent 100%)`
            }}>
              <Typography 
                variant="body1" 
                sx={{ 
                  mb: 1.5,
                  fontWeight: 600,
                  color: 'text.primary',
                  fontSize: '1rem'
                }}
              >
                Select a resume for intelligent analysis and personalized recommendations.
              </Typography>
              
              <Typography 
                variant="body2" 
                sx={{ 
                  color: 'text.secondary',
                  lineHeight: 1.4,
                  fontSize: '0.875rem'
                }}
              >
                Our AI will analyze your resume against this job posting and provide detailed insights 
                to maximize your interview chances.
              </Typography>
            </Box>

            {/* AI Features Showcase */}
            <Box sx={{ px: 2.5, pb: 1.5 }}>
              <Card sx={{ 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.secondary.main, 0.12)}`,
                background: `linear-gradient(135deg, ${alpha(theme.palette.secondary.main, 0.02)} 0%, ${alpha(theme.palette.secondary.light, 0.02)} 100%)`
              }}>
                <CardContent sx={{ p: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1.5 }}>
                    <StarsIcon 
                      sx={{ 
                        color: theme.palette.warning.main,
                        mr: 1,
                        fontSize: '1.25rem'
                      }} 
                    />
                    <Typography 
                      variant="body2" 
                      sx={{ 
                        fontWeight: 600,
                        color: 'text.primary'
                      }}
                    >
                      Our enhanced AI will provide:
                    </Typography>
                  </Box>
                  
                  <Stack spacing={1.5}>
                    <Stack direction="row" spacing={1.5}>
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.success.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <TrendingUpIcon sx={{ color: 'success.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Dynamic Match Scores
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Real-time compatibility analysis
                        </Typography>
                      </Card>
                      
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.info.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <SpeedIcon sx={{ color: 'info.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Skill Importance Weighting
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Prioritized skill relevance
                        </Typography>
                      </Card>
                    </Stack>
                    
                    <Stack direction="row" spacing={1.5}>
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.warning.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <PsychologyIcon sx={{ color: 'warning.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Experience Level Compatibility
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Career stage alignment
                        </Typography>
                      </Card>
                      
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.secondary.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <InsightsIcon sx={{ color: 'secondary.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Personalized Improvement Suggestions
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Tailored enhancement recommendations
                        </Typography>
                      </Card>
                    </Stack>
                  </Stack>
                </CardContent>
              </Card>
            </Box>

            {/* Resume Selection */}
            <Box sx={{ px: 2.5, pb: 2.5 }}>
              <Divider sx={{ my: 2 }} />
              
              {allResumes.length === 0 ? (
                <Alert 
                  severity="warning" 
                  sx={{ 
                    borderRadius: 2,
                    '& .MuiAlert-icon': {
                      fontSize: '1.25rem'
                    }
                  }}
                >
                  <Typography variant="body2" sx={{ fontWeight: 600, mb: 0.25 }}>
                    No resumes found
                  </Typography>
                  <Typography variant="caption">
                    You don't have any resumes uploaded. Please upload a resume first to continue.
                  </Typography>
                </Alert>
              ) : (
                <Box>
                  <Typography 
                    variant="body2" 
                    sx={{ 
                      mb: 1.5,
                      fontWeight: 600,
                      color: 'text.primary'
                    }}
                  >
                    Choose your resume for analysis
                  </Typography>
                  
                  <FormControl 
                    fullWidth 
                    sx={{ 
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  >
                    <InputLabel id="tailor-resume-label">Select Resume for Analysis</InputLabel>
                    <Select
                      labelId="tailor-resume-label"
                      value={selectedResumeId}
                      onChange={handleResumeChange}
                      label="Select Resume for Analysis"
                    >
                      {allResumes.map((resume) => (
                        <MenuItem 
                          key={resume._id} 
                          value={resume._id}
                          sx={{ 
                            minHeight: 48,
                            py: 1
                          }}
                        >
                          <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                            <DescriptionIcon sx={{ mr: 1.5, color: 'text.secondary', fontSize: '1.25rem' }} />
                            <Box sx={{ flex: 1 }}>
                              <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                {resume.name}
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                Updated {new Date(resume.updatedAt).toLocaleDateString()}
                              </Typography>
                            </Box>
                            {renderResumeStatusChip(resume)}
                          </Box>
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}
            </Box>
          </DialogContent>

          <DialogActions sx={{ 
            p: 2.5, 
            pt: 0,
            gap: 1.5,
            background: `linear-gradient(180deg, transparent 0%, ${alpha(theme.palette.background.paper, 0.8)} 100%)`
          }}>
            <Button 
              onClick={handleCloseTailorDialog}
              variant="outlined"
              sx={{ 
                borderRadius: 2,
                px: 3,
                py: 1,
                fontWeight: 600
              }}
            >
              Cancel
            </Button>
            <Button 
              onClick={handleTailorResume}
              variant="contained" 
              color="secondary"
              disabled={!selectedResumeId || matchLoading}
              startIcon={
                matchLoading ? (
                  <CircularProgress size={18} color="inherit" />
                ) : (
                  <AutoJobLogo 
                    variant="icon-only" 
                    size="small" 
                    color="white"
                    sx={{ transform: 'scale(0.7)' }}
                  />
                )
              }
              sx={{ 
                px: 3,
                py: 1,
                borderRadius: 2,
                fontWeight: 600,
                backgroundColor: theme.palette.secondary.main,
                color: 'white',
                boxShadow: `0px 8px 16px ${alpha(theme.palette.secondary.main, 0.24)}`,
                '&:hover': {
                  backgroundColor: theme.palette.secondary.dark,
                  boxShadow: `0px 12px 20px ${alpha(theme.palette.secondary.main, 0.32)}`,
                  transform: 'translateY(-1px)'
                },
                '&:disabled': {
                  backgroundColor: alpha(theme.palette.secondary.main, 0.6),
                  color: 'white'
                },
                transition: 'all 0.2s ease-in-out'
              }}
            >
              {matchLoading ? 'Analyzing Resume...' : 'Start Enhanced Analysis'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Snackbar for notifications */}
        <Snackbar
          open={alert.open}
          autoHideDuration={6000}
          onClose={handleAlertClose}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert 
            onClose={handleAlertClose} 
            severity={alert.severity} 
            sx={{ width: '100%', borderRadius: 2 }}
            variant="filled"
          >
            {alert.message}
          </Alert>
        </Snackbar>
      </Box>
    </MainLayout>
  );
};

export default JobDetail;

================
File: src/components/jobs/JobsPage.js
================
// src/components/jobs/JobsPage.js - Fixed Analysis Status Logic
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Grid, 
  Card, 
  CardContent, 
  CardActions, 
  Divider, 
  Chip, 
  CircularProgress, 
  Alert,
  LinearProgress,
  IconButton,
  Menu,
  MenuItem,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tabs,
  Tab,
  Snackbar,
  Badge,
  Backdrop
} from '@mui/material';
import { 
  Add as AddIcon, 
  Work as WorkIcon,
  ErrorOutline as ErrorOutlineIcon,
  MoreVert as MoreVertIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  ContentCopy as ContentCopyIcon,
  SmartToy as SmartToyIcon,
  OpenInNew as OpenInNewIcon,
  Refresh as RefreshIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon,
  Schedule as ScheduleIcon,
  AutoAwesome as AutoAwesomeIcon,
  CheckCircle as CheckCircleIcon,
  HourglassEmpty as HourglassEmptyIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import jobService from '../../utils/jobService';
import resumeService from '../../utils/resumeService';
import MainLayout from '../layout/MainLayout';
import JobCreateDialog from './JobCreateDialog';
import FindJobsDialog from './FindJobsDialog';
import AutoJobLogo from '../common/AutoJobLogo';

// Helper function to determine job analysis status
const getJobAnalysisStatus = (job) => {
  // If job has explicit analysisStatus field, use it
  if (job.analysisStatus && job.analysisStatus.status) {
    return {
      status: job.analysisStatus.status,
      progress: job.analysisStatus.progress || 0,
      message: job.analysisStatus.message || 'Processing...',
      canViewJob: job.analysisStatus.canViewJob !== false,
      skillsFound: job.analysisStatus.skillsFound,
      experienceLevel: job.analysisStatus.experienceLevel
    };
  }
  
  // For existing jobs without analysisStatus field, infer status from parsedData
  if (job.parsedData && Object.keys(job.parsedData).length > 0 && !job.parsedData.analysisError) {
    return {
      status: 'completed',
      progress: 100,
      message: `Analysis complete! Found ${job.parsedData.keySkills?.length || 0} key skills.`,
      canViewJob: true,
      skillsFound: job.parsedData.keySkills?.length || 0,
      experienceLevel: job.parsedData.experienceLevel
    };
  }
  
  // If parsedData exists but has errors
  if (job.parsedData && job.parsedData.analysisError) {
    return {
      status: 'error',
      progress: 0,
      message: 'Analysis failed',
      canViewJob: true,
      error: job.parsedData.analysisError
    };
  }
  
  // No parsedData means analysis hasn't been done yet
  return {
    status: 'pending',
    progress: 0,
    message: 'Analysis pending...',
    canViewJob: false
  };
};

// Inline JobAnalysisStatus component
const JobAnalysisStatus = ({ 
  analysisStatus, 
  size = 'normal', 
  variant = 'full', 
  showDetails = true 
}) => {
  if (!analysisStatus) {
    return null;
  }

  const { status, progress, message, skillsFound, experienceLevel } = analysisStatus;

  const statusConfig = {
    pending: {
      label: 'Analysis Queued',
      color: 'info',
      icon: HourglassEmptyIcon,
      bgColor: 'rgba(2, 136, 209, 0.1)',
      textColor: '#0288d1'
    },
    analyzing: {
      label: 'Analyzing Job',
      color: 'primary',
      icon: AutoAwesomeIcon,
      bgColor: 'rgba(26, 115, 232, 0.1)',
      textColor: '#1a73e8'
    },
    completed: {
      label: 'Analysis Complete',
      color: 'success',
      icon: CheckCircleIcon,
      bgColor: 'rgba(52, 168, 83, 0.1)',
      textColor: '#34a853'
    },
    error: {
      label: 'Analysis Failed',
      color: 'error',
      icon: ErrorOutlineIcon,
      bgColor: 'rgba(234, 67, 53, 0.1)',
      textColor: '#ea4335'
    }
  };

  const config = statusConfig[status] || statusConfig.pending;
  const IconComponent = config.icon;

  const sizeConfig = {
    small: {
      iconSize: 16,
      chipHeight: 24,
      typography: 'caption',
      progressHeight: 4
    },
    normal: {
      iconSize: 20,
      chipHeight: 28,
      typography: 'body2',
      progressHeight: 6
    },
    large: {
      iconSize: 24,
      chipHeight: 32,
      typography: 'body1',
      progressHeight: 8
    }
  };

  const currentSize = sizeConfig[size];

  if (variant === 'chip') {
    return (
      <Chip
        icon={
          status === 'analyzing' ? (
            <CircularProgress 
              size={currentSize.iconSize} 
              thickness={6} 
              color={config.color}
            />
          ) : (
            <IconComponent 
              sx={{ 
                fontSize: `${currentSize.iconSize}px !important`,
                color: config.textColor 
              }} 
            />
          )
        }
        label={config.label}
        size={size}
        sx={{
          height: currentSize.chipHeight,
          backgroundColor: config.bgColor,
          color: config.textColor,
          border: `1px solid ${config.textColor}`,
          fontWeight: 500,
          '& .MuiChip-icon': {
            color: `${config.textColor} !important`
          }
        }}
      />
    );
  }

  if (variant === 'progress-only') {
    return (
      <Box sx={{ width: '100%' }}>
        <LinearProgress
          variant="determinate"
          value={progress}
          color={config.color}
          sx={{
            height: currentSize.progressHeight,
            borderRadius: currentSize.progressHeight / 2,
            backgroundColor: config.bgColor,
            '& .MuiLinearProgress-bar': {
              borderRadius: currentSize.progressHeight / 2,
            }
          }}
        />
        {showDetails && (
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
            <Typography variant={currentSize.typography} color="text.secondary">
              {message}
            </Typography>
            <Typography variant={currentSize.typography} color="text.secondary">
              {progress}%
            </Typography>
          </Box>
        )}
      </Box>
    );
  }

  return (
    <Box
      sx={{
        p: size === 'small' ? 1.5 : 2,
        borderRadius: 2,
        backgroundColor: config.bgColor,
        border: `1px solid ${config.textColor}`,
        display: 'flex',
        alignItems: 'center',
        gap: 1.5
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        {status === 'analyzing' ? (
          <CircularProgress 
            size={currentSize.iconSize} 
            thickness={6} 
            color={config.color}
          />
        ) : (
          <IconComponent 
            sx={{ 
              fontSize: currentSize.iconSize,
              color: config.textColor 
            }} 
          />
        )}
      </Box>

      <Box sx={{ flex: 1, minWidth: 0 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
          <Typography 
            variant={currentSize.typography} 
            fontWeight={600}
            color={config.textColor}
            noWrap
          >
            {config.label}
          </Typography>
          
          {status === 'analyzing' && (
            <Chip
              icon={<SmartToyIcon sx={{ fontSize: '14px !important' }} />}
              label="AI"
              size="small"
              sx={{
                height: 18,
                fontSize: '0.7rem',
                backgroundColor: config.textColor,
                color: 'white',
                '& .MuiChip-icon': {
                  color: 'white !important'
                }
              }}
            />
          )}
        </Box>

        {status !== 'completed' && status !== 'error' && (
          <Box sx={{ mb: 1 }}>
            <LinearProgress
              variant="determinate"
              value={progress}
              color={config.color}
              sx={{
                height: currentSize.progressHeight,
                borderRadius: currentSize.progressHeight / 2,
                backgroundColor: 'rgba(255,255,255,0.3)',
                '& .MuiLinearProgress-bar': {
                  borderRadius: currentSize.progressHeight / 2,
                }
              }}
            />
          </Box>
        )}

        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          color={config.textColor}
          sx={{ opacity: 0.9 }}
        >
          {message}
        </Typography>

        {status === 'completed' && showDetails && skillsFound !== undefined && (
          <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            <Chip
              label={`${skillsFound} skills found`}
              size="small"
              variant="outlined"
              sx={{
                height: 20,
                fontSize: '0.7rem',
                borderColor: config.textColor,
                color: config.textColor
              }}
            />
            {experienceLevel && (
              <Chip
                label={`${experienceLevel} level`}
                size="small"
                variant="outlined"
                sx={{
                  height: 20,
                  fontSize: '0.7rem',
                  borderColor: config.textColor,
                  color: config.textColor
                }}
              />
            )}
          </Box>
        )}

        {status === 'error' && showDetails && (
          <Alert 
            severity="error" 
            sx={{ 
              mt: 1, 
              py: 0.5,
              fontSize: '0.75rem',
              '& .MuiAlert-icon': {
                fontSize: '1rem'
              }
            }}
          >
            Analysis failed. You can still view the job, but some features may be limited.
          </Alert>
        )}
      </Box>

      {(status === 'analyzing' || status === 'pending') && (
        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          fontWeight={600}
          color={config.textColor}
        >
          {progress}%
        </Typography>
      )}
    </Box>
  );
};

// Tab panel component
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`job-tabpanel-${index}`}
      aria-labelledby={`job-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const JobsPage = () => {
  const navigate = useNavigate();
  const [jobs, setJobs] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [openCreateDialog, setOpenCreateDialog] = useState(false);
  const [openFindJobsDialog, setOpenFindJobsDialog] = useState(false);
  const [anchorEl, setAnchorEl] = useState(null);
  const [selectedJobId, setSelectedJobId] = useState(null);
  const [tabValue, setTabValue] = useState(0);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });
  const [activeResumes, setActiveResumes] = useState([]);
  const [pollingJobs, setPollingJobs] = useState(new Set());

  // Safe AutoJobLogo wrapper component
  const SafeAutoJobLogo = ({ size = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={size} 
          showTagline={false}
        />
      );
    } catch (error) {
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: size === 'small' ? 16 : 20 }} />;
    }
  };

  useEffect(() => {
    fetchJobs();
    fetchActiveResumes();
  }, []);

  // Poll analysis status for jobs that are still processing
  useEffect(() => {
    const jobsNeedingPolling = jobs.filter(job => {
      const status = getJobAnalysisStatus(job);
      return (status.status === 'pending' || status.status === 'analyzing') && !pollingJobs.has(job._id);
    });

    jobsNeedingPolling.forEach(job => {
      startPollingJobStatus(job._id);
    });
  }, [jobs]);

  const fetchJobs = async () => {
    try {
      setLoading(true);
      setError('');
      console.log('Fetching jobs...');
      const jobsData = await jobService.getAllJobs();
      setJobs(jobsData || []);
    } catch (err) {
      console.error('Error fetching jobs:', err);
      setError(err.response?.data?.message || 'Failed to load jobs. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const fetchActiveResumes = async () => {
    try {
      const resumesData = await resumeService.getUserResumes();
      setActiveResumes(resumesData.filter(r => r.isActive) || []);
    } catch (err) {
      console.error('Error fetching active resumes:', err);
    }
  };

  // Start polling for a specific job's analysis status
  const startPollingJobStatus = async (jobId) => {
    if (pollingJobs.has(jobId)) {
      return; // Already polling this job
    }

    setPollingJobs(prev => new Set([...prev, jobId]));

    try {
      // Check if jobService.pollJobAnalysisStatus exists before using it
      if (typeof jobService.pollJobAnalysisStatus === 'function') {
        await jobService.pollJobAnalysisStatus(
          jobId,
          (statusUpdate) => {
            // Update the specific job's status in real-time
            setJobs(prevJobs => prevJobs.map(job => 
              job._id === jobId 
                ? { ...job, analysisStatus: statusUpdate }
                : job
            ));
          },
          30 // Max 30 attempts (60 seconds)
        );
      } else {
        console.warn('pollJobAnalysisStatus method not available in jobService');
      }
    } catch (error) {
      console.error(`Polling failed for job ${jobId}:`, error);
      
      // Update job to show error state
      setJobs(prevJobs => prevJobs.map(job => 
        job._id === jobId 
          ? { 
              ...job, 
              analysisStatus: { 
                status: 'error', 
                message: 'Analysis status polling failed',
                progress: 0,
                canViewJob: true
              }
            }
          : job
      ));
    } finally {
      // Remove from polling set
      setPollingJobs(prev => {
        const newSet = new Set(prev);
        newSet.delete(jobId);
        return newSet;
      });
    }
  };

  const handleOpenCreateDialog = () => {
    setOpenCreateDialog(true);
  };

  const handleCloseCreateDialog = () => {
    setOpenCreateDialog(false);
  };

  const handleOpenFindJobsDialog = () => {
    setOpenFindJobsDialog(true);
  };

  const handleCloseFindJobsDialog = () => {
    setOpenFindJobsDialog(false);
  };

  const handleJobCreated = (newJob) => {
    fetchJobs(); // Refresh the entire list
    handleCloseCreateDialog();
    showSnackbar('Job created successfully - analysis in progress', 'success');
    
    // Start polling the new job if it has an ID
    if (newJob?.job?.id) {
      setTimeout(() => {
        startPollingJobStatus(newJob.job.id);
      }, 1000);
    }
  };

  const handleMenuOpen = (event, jobId) => {
    setAnchorEl(event.currentTarget);
    setSelectedJobId(jobId);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
    setSelectedJobId(null);
  };

  const handleDeleteJob = async () => {
    if (!selectedJobId) return;
    
    try {
      await jobService.deleteJob(selectedJobId);
      setJobs(prevJobs => prevJobs.filter(job => job._id !== selectedJobId));
      handleMenuClose();
      showSnackbar('Job deleted successfully', 'success');
    } catch (err) {
      console.error('Error deleting job:', err);
      showSnackbar('Failed to delete job', 'error');
    }
  };

  const handleJobClick = (job) => {
    const status = getJobAnalysisStatus(job);
    
    // Check if analysis is complete before allowing navigation
    if (!status.canViewJob) {
      showSnackbar('Please wait for job analysis to complete before viewing details', 'warning');
      return;
    }
    
    navigate(`/jobs/${job._id}`);
  };

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  const showSnackbar = (message, severity) => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };

  const handleCloseSnackbar = () => {
    setSnackbar({
      ...snackbar,
      open: false
    });
  };

  const handleJobsFindCompleted = () => {
    fetchJobs();
    handleCloseFindJobsDialog();
    showSnackbar('AI job search initiated. Jobs will appear as they are found.', 'success');
  };

  const renderEmptyState = () => (
    <Box sx={{ mt: 2 }}>
      <Paper 
        elevation={1} 
        sx={{ 
          p: 3, 
          textAlign: 'center', 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center',
          backgroundColor: theme => theme.palette.background.paper,
          border: `1px solid`,
          borderColor: 'divider',
          borderRadius: 3,
          mb: 3
        }}
      >
        <WorkIcon sx={{ fontSize: 48, color: 'primary.main', mb: 2, opacity: 0.8 }} />
        <Typography variant="h5" gutterBottom fontWeight={600}>
          Find Your Perfect Job Match
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 3, maxWidth: 560, lineHeight: 1.5 }}>
          Add jobs manually or let our AI find opportunities that match your resume.
          Our platform will help you analyze matches, tailor your application materials,
          and track your job search progress.
        </Typography>
        <Box sx={{ display: 'flex', gap: 1.5 }}>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<AddIcon />} 
            onClick={handleOpenCreateDialog}
            sx={{ 
              py: 1, 
              px: 3, 
              fontSize: '0.9rem', 
              fontWeight: 500,
              borderRadius: 2
            }}
          >
            Add Job Manually
          </Button>
          <Button 
            variant="outlined" 
            color="primary" 
            startIcon={<SafeAutoJobLogo size="small" />} 
            onClick={handleOpenFindJobsDialog}
            sx={{ 
              py: 1, 
              px: 3, 
              fontSize: '0.9rem', 
              fontWeight: 500,
              borderRadius: 2
            }}
          >
            Discover Jobs
          </Button>
        </Box>
        {activeResumes.length === 0 && (
          <Alert severity="info" sx={{ mt: 2.5, maxWidth: 480, fontSize: '0.85rem' }}>
            You need at least one active resume to use the AI job search feature.
            Please upload and activate a resume first.
          </Alert>
        )}
      </Paper>

      <Typography variant="h6" sx={{ mb: 2.5, fontWeight: 600 }}>
        How Our Job Matching Works
      </Typography>

      <Grid container spacing={2.5} sx={{ mb: 3 }}>
        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #4caf50',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              1. Find or Add Jobs
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <WorkIcon sx={{ fontSize: 56, color: '#4caf50', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Add jobs manually from listings you find, or let our AI find relevant positions 
              based on your resume.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #2196f3',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              2. Match Analysis
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <ContentCopyIcon sx={{ fontSize: 56, color: '#2196f3', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Our system analyzes how well your resume matches each job, identifying
              strengths and areas for improvement.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #ff9800',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              3. Tailor & Apply
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <SafeAutoJobLogo size="medium" />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Get AI-powered suggestions to tailor your resume for each job, increasing
              your chances of getting interviews.
            </Typography>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );

  const renderErrorState = () => (
    <Paper 
      elevation={0} 
      sx={{ 
        p: 4, 
        mt: 3,
        borderRadius: 2,
        border: '1px solid rgba(211, 47, 47, 0.2)',
        backgroundColor: 'rgba(211, 47, 47, 0.05)'
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
        <ErrorOutlineIcon color="error" sx={{ mr: 2, mt: 0.5 }} />
        <Box>
          <Typography variant="h6" color="error" gutterBottom fontWeight={500}>
            Error Loading Jobs
          </Typography>
          <Typography variant="body1" sx={{ mb: 3 }}>
            {error || 'Failed to load jobs. Please try again.'}
          </Typography>
        </Box>
      </Box>
      <Box sx={{ display: 'flex', gap: 2 }}>
        <Button 
          variant="outlined" 
          color="primary" 
          startIcon={<RefreshIcon />} 
          onClick={fetchJobs}
          sx={{ textTransform: 'none' }}
        >
          Try Again
        </Button>
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<AddIcon />} 
          onClick={handleOpenCreateDialog}
          sx={{ textTransform: 'none' }}
        >
          Add Job Manually
        </Button>
      </Box>
    </Paper>
  );

  const renderJobGrid = (filteredJobs) => (
    <Grid container spacing={3} sx={{ mt: 1 }}>
      {filteredJobs.map((job) => {
        // FIXED: Use the helper function to get consistent status
        const analysisStatus = getJobAnalysisStatus(job);
        const canView = analysisStatus.canViewJob;
        const isAnalyzing = analysisStatus.status === 'analyzing' || analysisStatus.status === 'pending';
        
        return (
          <Grid item xs={12} sm={6} md={4} key={job._id}>
            <Card sx={{ 
              height: '100%', 
              display: 'flex', 
              flexDirection: 'column',
              position: 'relative',
              transition: 'transform 0.2s, box-shadow 0.2s',
              opacity: canView ? 1 : 0.8,
              cursor: canView ? 'pointer' : 'default',
              '&:hover': canView ? {
                transform: 'translateY(-4px)',
                boxShadow: '0 8px 24px rgba(0,0,0,0.12)'
              } : {}
            }}>
              {/* FIXED: Only show analysis overlay for jobs that are actually being analyzed */}
              {isAnalyzing && (
                <Box
                  sx={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    zIndex: 10,
                    bgcolor: 'rgba(255,255,255,0.95)',
                    backdropFilter: 'blur(2px)',
                    p: 1
                  }}
                >
                  <JobAnalysisStatus 
                    analysisStatus={analysisStatus}
                    size="small"
                    variant="full"
                    showDetails={false}
                  />
                </Box>
              )}

{/* Discovered Badge */}
{job.isAiGenerated && (
  <Chip 
    icon={<SafeAutoJobLogo size="small" sx={{ '& svg': { width: 12, height: 12 } }} />}
    label="Discovered" 
    size="small" 
    sx={{ 
      position: 'absolute', 
      top: 12, 
      right: 12,
      height: '28px',
      fontWeight: 600,
      fontSize: '0.75rem',
      backgroundColor: '#00c4b4',
      color: '#ffffff',
      border: '1px solid #00c4b4',
      boxShadow: '0 2px 8px rgba(38, 166, 154, 0.3)',
      zIndex: 5,
      '& .MuiChip-icon': {
        color: '#ffffff !important'
      },
      '&:hover': {
        backgroundColor: '#00695C',
        boxShadow: '0 4px 12px rgba(38, 166, 154, 0.4)'
      }
    }}
  />
)}

              <CardContent sx={{ flexGrow: 1, pt: job.isAiGenerated ? 5 : 3 }}>
                <Typography variant="h6" gutterBottom noWrap fontWeight={500}>
                  {job.title}
                </Typography>
                <Typography variant="subtitle1" color="text.secondary" noWrap>
                  {job.company}
                </Typography>
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  {job.location?.city 
                    ? `${job.location.city}${job.location.state ? `, ${job.location.state}` : ''}`
                    : job.location?.remote ? 'Remote' : 'Location not specified'
                  }
                </Typography>
                <Divider sx={{ my: 2 }} />
                
{/* FIXED: Only show progress for jobs that are actually being analyzed */}
                {isAnalyzing && (
                  <Box sx={{ mb: 2 }}>
                    <JobAnalysisStatus 
                      analysisStatus={analysisStatus}
                      size="small"
                      variant="progress-only"
                      showDetails={true}
                    />
                  </Box>
                )}
                
                {/* Match Score - FIXED: Only show for completed analysis */}
                {job.matchAnalysis && job.matchAnalysis.overallScore && analysisStatus.status === 'completed' && (
                  <Box sx={{ mt: 2, mb: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                      <Typography variant="subtitle2" fontWeight={500}>
                        Match Score
                      </Typography>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Typography variant="h6" fontWeight={600} color={getScoreColor(job.matchAnalysis.overallScore)}>
                          {job.matchAnalysis.overallScore}
                        </Typography>
                        <Typography variant="body2" color="text.secondary" sx={{ ml: 0.5 }}>
                          /100
                        </Typography>
                      </Box>
                    </Box>
                    <LinearProgress 
                      variant="determinate" 
                      value={job.matchAnalysis.overallScore} 
                      sx={{ 
                        height: 8, 
                        borderRadius: 2,
                        backgroundColor: 'rgba(0,0,0,0.05)',
                        '& .MuiLinearProgress-bar': {
                          backgroundColor: getScoreColor(job.matchAnalysis.overallScore)
                        }
                      }}
                    />
                  </Box>
                )}
                
                <Box sx={{ mt: 2 }}>
                  <Typography variant="body2" color="text.secondary" noWrap>
                    Posted: {new Date(job.createdAt).toLocaleDateString()}
                  </Typography>
                  
                  <Box sx={{ mt: 2, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                    <Chip 
                      label={job.jobType?.replace('_', ' ') || 'Full-time'} 
                      size="small" 
                      variant="outlined" 
                    />
                    {job.salary?.min && (
                      <Chip 
                        label={`${job.salary.currency || '$'}${job.salary.min}${job.salary.max ? ` - ${job.salary.max}` : '+'}`} 
                        size="small" 
                        variant="outlined" 
                        color="success"
                      />
                    )}
                    <Chip 
                      label={job.applicationStatus?.replace('_', ' ') || 'Not Applied'} 
                      size="small" 
                      variant="outlined" 
                      color={job.applicationStatus === 'APPLIED' ? 'primary' : 'default'}
                    />
                  </Box>
                </Box>
              </CardContent>

              <CardActions sx={{ justifyContent: 'space-between', p: 2 }}>
                <Tooltip 
                  title={!canView ? "Analysis in progress - please wait" : "View job details"}
                  arrow
                >
                  <span> {/* Span wrapper needed for disabled button tooltip */}
                    <Button 
                      size="small" 
                      color="primary" 
                      onClick={() => handleJobClick(job)}
                      variant="contained"
                      disabled={!canView}
                      startIcon={
                        canView ? <VisibilityIcon /> : <ScheduleIcon />
                      }
                    >
                      {canView ? 'View Details' : 'Analyzing...'}
                    </Button>
                  </span>
                </Tooltip>
                <Box>
                  {job.sourceUrl && (
                    <Tooltip title="Open Original Listing">
                      <IconButton 
                        size="small" 
                        onClick={() => window.open(job.sourceUrl, '_blank')}
                        sx={{ mr: 1 }}
                      >
                        <OpenInNewIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                  )}
                  <IconButton 
                    size="small"
                    aria-controls={`job-menu-${job._id}`}
                    aria-haspopup="true"
                    onClick={(e) => handleMenuOpen(e, job._id)}
                  >
                    <MoreVertIcon fontSize="small" />
                  </IconButton>
                </Box>
              </CardActions>
            </Card>
          </Grid>
        );
      })}
      
      {/* Add Job Card */}
      <Grid item xs={12} sm={6} md={4}>
        <Card 
          sx={{ 
            height: '100%', 
            minHeight: 250,
            display: 'flex', 
            flexDirection: 'column', 
            justifyContent: 'center', 
            alignItems: 'center',
            p: 3,
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            border: '2px dashed',
            borderColor: 'divider',
            cursor: 'pointer',
            transition: 'all 0.2s ease-in-out',
            '&:hover': {
              borderColor: 'primary.main',
              backgroundColor: 'rgba(63, 81, 181, 0.04)'
            }
          }}
          onClick={handleOpenCreateDialog}
        >
          <AddIcon sx={{ fontSize: 40, color: 'primary.main', mb: 2 }} />
          <Typography variant="h6" align="center" fontWeight={500}>
            Add New Job
          </Typography>
          <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 1 }}>
            Manually add a job listing to your collection
          </Typography>
        </Card>
      </Grid>
    </Grid>
  );

  // Helper function to get color based on score
  const getScoreColor = (score) => {
    if (score >= 80) return 'success.main';
    if (score >= 60) return 'warning.main';
    return 'error.main';
  };

  // Filter jobs based on tab selection
  const getFilteredJobs = () => {
    switch (tabValue) {
      case 0: // All jobs
        return jobs;
      case 1: // AI-found jobs
        return jobs.filter(job => job.isAiGenerated);
      case 2: // Manually added jobs
        return jobs.filter(job => !job.isAiGenerated);
      case 3: // Not applied
        return jobs.filter(job => !job.applicationStatus || job.applicationStatus === 'NOT_APPLIED');
      case 4: // Applied
        return jobs.filter(job => job.applicationStatus && job.applicationStatus !== 'NOT_APPLIED');
      default:
        return jobs;
    }
  };

  const filteredJobs = getFilteredJobs();

  // FIXED: Count jobs by analysis status using the helper function
  const analyzingCount = jobs.filter(job => {
    const status = getJobAnalysisStatus(job);
    return status.status === 'analyzing' || status.status === 'pending';
  }).length;

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Box>
            <Typography variant="h4" component="h1" fontWeight={500}>
              Job Matches
            </Typography>
            {analyzingCount > 0 && (
              <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
                {analyzingCount} job{analyzingCount === 1 ? '' : 's'} currently being analyzed
              </Typography>
            )}
          </Box>
          {!loading && !error && jobs.length > 0 && (
            <Box sx={{ display: 'flex', gap: 2 }}>
              <Button 
                variant="outlined" 
                color="primary" 
                startIcon={<SafeAutoJobLogo size="small" />} 
                onClick={handleOpenFindJobsDialog}
                sx={{ textTransform: 'none' }}
              >
                Discover Jobs
              </Button>
              <Button 
                variant="contained" 
                color="primary" 
                startIcon={<AddIcon />} 
                onClick={handleOpenCreateDialog}
                sx={{ textTransform: 'none' }}
              >
                Add Job Manually
              </Button>
            </Box>
          )}
        </Box>

        {loading ? (
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '300px' }}>
            <CircularProgress size={60} thickness={4} color="primary" />
            <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
              Loading your jobs...
            </Typography>
          </Box>
        ) : error ? (
          renderErrorState()
        ) : jobs.length === 0 ? (
          renderEmptyState()
        ) : (
          <>
            <Tabs
              value={tabValue}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}
            >
              <Tab label={`All Jobs (${jobs.length})`} />
              <Tab label={`AI Found (${jobs.filter(job => job.isAiGenerated).length})`} />
              <Tab label={`Manually Added (${jobs.filter(job => !job.isAiGenerated).length})`} />
              <Tab label={`Not Applied (${jobs.filter(job => !job.applicationStatus || job.applicationStatus === 'NOT_APPLIED').length})`} />
              <Tab label={`Applied (${jobs.filter(job => job.applicationStatus && job.applicationStatus !== 'NOT_APPLIED').length})`} />
            </Tabs>
            
            {filteredJobs.length === 0 ? (
              <Box sx={{ textAlign: 'center', my: 6 }}>
                <Typography variant="h6" color="text.secondary">
                  No jobs found in this category
                </Typography>
              </Box>
            ) : (
              renderJobGrid(filteredJobs)
            )}
          </>
        )}
      </Box>

      {/* Job Create Dialog */}
      <JobCreateDialog 
        open={openCreateDialog}
        onClose={handleCloseCreateDialog}
        onJobCreated={handleJobCreated}
      />
      
      {/* Find Jobs Dialog */}
      <FindJobsDialog 
        open={openFindJobsDialog}
        onClose={handleCloseFindJobsDialog}
        onJobsFound={handleJobsFindCompleted}
        resumes={activeResumes}
      />
      
      {/* Job menu */}
      <Menu
        id="job-menu"
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <MenuItem onClick={handleDeleteJob} sx={{ color: 'error.main' }}>
          <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
          Delete Job
        </MenuItem>
      </Menu>

      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        message={snackbar.message}
        severity={snackbar.severity}
      />
    </MainLayout>
  );
};

export default JobsPage;

================
File: src/components/jobs/ResumeTailoring.js
================
// src/components/jobs/ResumeTailoring.js
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Grid,
  Paper,
  Button,
  CircularProgress,
  Alert,
  Card,
  CardContent,
  CardHeader,
  Divider,
  Stepper,
  Step,
  StepLabel,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  TextField,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Snackbar,
  useTheme,
  alpha
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  ExpandMore as ExpandMoreIcon,
  Save as SaveIcon,
  SmartToy as SmartToyIcon,
  Lightbulb as LightbulbIcon,
  Business as BusinessIcon,
  WorkOutline as WorkOutlineIcon,
  FormatListBulleted as FormatListBulletedIcon,
  CropFree as CropFreeIcon,
  Keyboard as KeyboardIcon,
  Info as InfoIcon
} from '@mui/icons-material';
import jobService from '../../utils/jobService';
import resumeService from '../../utils/resumeService';
import MainLayout from '../layout/MainLayout';

const ResumeTailoring = () => {
  const theme = useTheme();
  const { jobId, resumeId } = useParams();
  const navigate = useNavigate();
  
  const [job, setJob] = useState(null);
  const [resume, setResume] = useState(null);
  const [tailoringData, setTailoringData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [activeStep, setActiveStep] = useState(0);
  const [tailoringSaving, setTailoringSaving] = useState(false);
  const [versionName, setVersionName] = useState('');
  const [versionNotes, setVersionNotes] = useState('');
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  const steps = ['Analyze Match', 'Review Recommendations', 'Create Tailored Version'];

  useEffect(() => {
    fetchData();
  }, [jobId, resumeId]);

  useEffect(() => {
    if (resume && job) {
      setVersionName(`AI Tailored - ${resume.name} for ${job.title} at ${job.company}`);
    }
  }, [resume, job]);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError('');
      
      // Fetch job details
      const jobData = await jobService.getJobById(jobId);
      setJob(jobData);
      
      // Fetch resume details
      const resumeData = await resumeService.getResumeById(resumeId);
      setResume(resumeData.resume);
      
      // If no match analysis exists, create one
      if (!jobData.matchAnalysis || !jobData.matchAnalysis.overallScore) {
        await jobService.matchResumeWithJob(jobId, resumeId);
        // Refresh job data to get match analysis
        const updatedJobData = await jobService.getJobById(jobId);
        setJob(updatedJobData);
      }
      
      // Get tailoring recommendations
      const tailoringResult = await jobService.getTailoringRecommendations(jobId, resumeId);
      setTailoringData(tailoringResult.tailoringResult);
      
      setActiveStep(1); // Move to recommendations step
    } catch (err) {
      console.error('Error fetching tailoring data:', err);
      setError('Failed to load tailoring data. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleNext = () => {
    setActiveStep((prevStep) => prevStep + 1);
  };

  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
  };

  const handleCloseSnackbar = () => {
    setSnackbar({
      ...snackbar,
      open: false
    });
  };

  const showSnackbar = (message, severity) => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };

  const handleSaveTailoredResume = async () => {
    if (!versionName) {
      showSnackbar('Please provide a name for your tailored resume', 'warning');
      return;
    }
    
    setTailoringSaving(true);
    
    try {
      console.log('Creating tailored resume with options:', {
        name: versionName,
        notes: versionNotes
      });
      
      // Call API to create tailored resume
      const response = await resumeService.createTailoredResume(resumeId, jobId, {
        name: versionName,
        notes: versionNotes
      });
      
      console.log('Tailored resume creation response:', response);
      
      // Show success message with analysis info
      const analysisInfo = response.resume?.analysis?.overallScore 
        ? ` (New Resume Score: ${response.resume.analysis.overallScore}%)`
        : '';
      
      showSnackbar(`Tailored resume created successfully!${analysisInfo}`, 'success');
      
      // Wait a moment, then show success and navigate
      setTimeout(async () => {
        // Show final success message
        showSnackbar('✅ Tailored resume created and job match updated!', 'success');
        
        // Navigate to the new tailored resume detail page
        if (response.resume?.id) {
          setTimeout(() => {
            navigate(`/resumes/${response.resume.id}`);
          }, 1500);
        } else {
          // Fallback to resumes list
          setTimeout(() => {
            navigate('/resumes');
          }, 1500);
        }
      }, 1000);
      
    } catch (error) {
      console.error('Error saving tailored resume:', error);
      
      // More detailed error handling
      let errorMessage = 'Failed to create tailored resume. Please try again.';
      
      if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      showSnackbar(errorMessage, 'error');
      setTailoringSaving(false);
    }
  };

  const renderStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <Box sx={{ my: 2 }}>
            <Typography variant="body1" gutterBottom>
              Analyzing resume match with job description...
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', my: 4 }}>
              <CircularProgress size={60} />
            </Box>
          </Box>
        );
      
      case 1:
        return (
          <Box sx={{ my: 2 }}>
            <Typography variant="h6" fontWeight={500} gutterBottom>
              Tailoring Recommendations
            </Typography>
            
            <Grid container spacing={3}>
              {/* Summary Recommendations */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <SmartToyIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Professional Summary
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    <Grid container spacing={3}>
                      <Grid item xs={12} md={6}>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            height: '100%',
                            borderRadius: 2,
                            borderColor: theme.palette.divider,
                            boxShadow: 'none'
                          }}
                        >
                          <CardHeader 
                            title="Original Version" 
                            titleTypographyProps={{ 
                              variant: 'subtitle2', 
                              fontWeight: 600,
                              color: theme.palette.text.primary
                            }} 
                            sx={{ 
                              p: 2, 
                              pb: 1,
                              backgroundColor: alpha(theme.palette.primary.main, 0.05)
                            }}
                          />
                          <CardContent sx={{ p: 2 }}>
                            <Typography variant="body2" color="text.secondary">
                              {tailoringData?.summary?.original || "No summary found in original resume."}
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            height: '100%',
                            borderRadius: 2,
                            borderColor: theme.palette.success.main,
                            backgroundColor: alpha(theme.palette.success.main, 0.05),
                            boxShadow: 'none'
                          }}
                        >
                          <CardHeader 
                            title="Tailored Version" 
                            titleTypographyProps={{ 
                              variant: 'subtitle2', 
                              fontWeight: 600,
                              color: theme.palette.text.primary 
                            }} 
                            sx={{ 
                              p: 2, 
                              pb: 1,
                              backgroundColor: alpha(theme.palette.success.main, 0.12),
                              borderBottom: `1px solid ${alpha(theme.palette.success.main, 0.2)}`
                            }}
                          />
                          <CardContent sx={{ p: 2 }}>
                            <Typography variant="body2" color="text.secondary">
                              {tailoringData?.summary?.tailored || "No tailored summary available."}
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                    </Grid>
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Experience Improvements */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <WorkOutlineIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Experience Improvements
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    {tailoringData?.experienceImprovements?.length > 0 ? (
                      tailoringData.experienceImprovements.map((exp, index) => (
                        <Box key={index} sx={{ mb: 3 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <BusinessIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                            <Typography variant="subtitle1" fontWeight={600}>
                              {exp.company} - {exp.position}
                            </Typography>
                          </Box>
                          <Grid container spacing={3}>
                            <Grid item xs={12} md={6}>
                              <Card 
                                variant="outlined" 
                                sx={{ 
                                  mb: 2,
                                  borderRadius: 2,
                                  borderColor: theme.palette.divider,
                                  boxShadow: 'none'
                                }}
                              >
                                <CardHeader 
                                  title="Original Bullet Points" 
                                  titleTypographyProps={{ 
                                    variant: 'subtitle2', 
                                    fontWeight: 600,
                                    color: theme.palette.text.primary
                                  }} 
                                  sx={{ 
                                    p: 2, 
                                    pb: 1.5,
                                    backgroundColor: alpha(theme.palette.primary.main, 0.05)
                                  }}
                                />
                                <CardContent sx={{ p: 2 }}>
                                  <List dense disablePadding>
                                    {exp.original.map((bullet, i) => (
                                      <ListItem key={i} sx={{ px: 1, py: 0.5 }}>
                                        <ListItemIcon sx={{ minWidth: 32 }}>
                                          <FormatListBulletedIcon fontSize="small" color="action" />
                                        </ListItemIcon>
                                        <ListItemText 
                                          primary={bullet} 
                                          primaryTypographyProps={{ 
                                            variant: 'body2',
                                            color: 'text.secondary' 
                                          }} 
                                        />
                                      </ListItem>
                                    ))}
                                  </List>
                                </CardContent>
                              </Card>
                            </Grid>
                            <Grid item xs={12} md={6}>
                              <Card 
                                variant="outlined" 
                                sx={{ 
                                  mb: 2,
                                  borderRadius: 2,
                                  borderColor: theme.palette.success.main,
                                  backgroundColor: alpha(theme.palette.success.main, 0.05),
                                  boxShadow: 'none'
                                }}
                              >
                                <CardHeader 
                                  title="Tailored Bullet Points" 
                                  titleTypographyProps={{ 
                                    variant: 'subtitle2', 
                                    fontWeight: 600,
                                    color: theme.palette.text.primary
                                  }} 
                                  sx={{ 
                                    p: 2, 
                                    pb: 1.5,
                                    backgroundColor: alpha(theme.palette.success.main, 0.12),
                                    borderBottom: `1px solid ${alpha(theme.palette.success.main, 0.2)}`
                                  }}
                                />
                                <CardContent sx={{ p: 2 }}>
                                  <List dense disablePadding>
                                    {exp.tailored.map((bullet, i) => (
                                      <ListItem key={i} sx={{ px: 1, py: 0.5 }}>
                                        <ListItemIcon sx={{ minWidth: 32 }}>
                                          <CheckCircleIcon fontSize="small" color="success" />
                                        </ListItemIcon>
                                        <ListItemText 
                                          primary={bullet} 
                                          primaryTypographyProps={{ 
                                            variant: 'body2',
                                            color: 'text.secondary'  
                                          }} 
                                        />
                                      </ListItem>
                                    ))}
                                  </List>
                                </CardContent>
                              </Card>
                            </Grid>
                          </Grid>
                          {index < tailoringData.experienceImprovements.length - 1 && <Divider sx={{ my: 3 }} />}
                        </Box>
                      ))
                    ) : (
                      <Alert severity="info" sx={{ borderRadius: 2 }}>
                        No experience improvements recommended.
                      </Alert>
                    )}
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Skills Improvements */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <CropFreeIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Skills Recommendations
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    <Grid container spacing={3}>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle2" fontWeight={600} gutterBottom sx={{ display: 'flex', alignItems: 'center' }}>
                          <LightbulbIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
                          Skills to Add
                        </Typography>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            p: 2, 
                            borderRadius: 2,
                            borderColor: theme.palette.primary.main,
                            backgroundColor: alpha(theme.palette.primary.main, 0.05)
                          }}
                        >
                          {tailoringData?.skillsImprovements?.skillsToAdd?.length > 0 ? (
                            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                              {tailoringData.skillsImprovements.skillsToAdd.map((skill, index) => (
                                <Chip 
                                  key={index} 
                                  label={skill} 
                                  color="primary"
                                  variant="outlined"
                                  sx={{ borderRadius: 6 }}
                                />
                              ))}
                            </Box>
                          ) : (
                            <Typography variant="body2" color="text.secondary">
                              No additional skills recommended.
                            </Typography>
                          )}
                        </Card>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle2" fontWeight={600} gutterBottom sx={{ display: 'flex', alignItems: 'center' }}>
                          <CheckCircleIcon fontSize="small" sx={{ mr: 1, color: theme.palette.success.main }} />
                          Skills to Emphasize
                        </Typography>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            p: 2, 
                            borderRadius: 2,
                            borderColor: theme.palette.success.main,
                            backgroundColor: alpha(theme.palette.success.main, 0.05)
                          }}
                        >
                          {tailoringData?.skillsImprovements?.skillsToEmphasize?.length > 0 ? (
                            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                              {tailoringData.skillsImprovements.skillsToEmphasize.map((skill, index) => (
                                <Chip 
                                  key={index} 
                                  label={skill} 
                                  color="success"
                                  variant="outlined"
                                  sx={{ borderRadius: 6 }}
                                />
                              ))}
                            </Box>
                          ) : (
                            <Typography variant="body2" color="text.secondary">
                              No skills to emphasize recommended.
                            </Typography>
                          )}
                        </Card>
                      </Grid>
                    </Grid>
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Keyword Suggestions */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <KeyboardIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Keyword Suggestions
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                      Including these keywords will boost your resume's ATS compatibility and relevance for this job:
                    </Typography>
                    {tailoringData?.keywordSuggestions?.length > 0 ? (
                      <Box sx={{ 
                        display: 'flex', 
                        flexWrap: 'wrap', 
                        gap: 1,
                        mt: 2,
                        '& .MuiChip-root': {
                          borderRadius: 6
                        }
                      }}>
                        {tailoringData.keywordSuggestions.map((keyword, index) => (
                          <Chip 
                            key={index} 
                            label={keyword} 
                            color="info"
                            variant="outlined"
                          />
                        ))}
                      </Box>
                    ) : (
                      <Alert severity="info" sx={{ mt: 1, borderRadius: 2 }}>
                        No keyword suggestions available.
                      </Alert>
                    )}
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Format Suggestions */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <WarningIcon sx={{ mr: 1.5, color: theme.palette.warning.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Format Suggestions
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    {tailoringData?.formatSuggestions?.length > 0 ? (
                      <List sx={{ bgcolor: alpha(theme.palette.warning.main, 0.05), borderRadius: 2, p: 2 }}>
                        {tailoringData.formatSuggestions.map((suggestion, index) => (
                          <ListItem key={index} sx={{ px: 1, py: 0.5 }}>
                            <ListItemIcon>
                              <WarningIcon color="warning" />
                            </ListItemIcon>
                            <ListItemText 
                              primary={suggestion} 
                              primaryTypographyProps={{ color: 'text.secondary' }}
                            />
                          </ListItem>
                        ))}
                      </List>
                    ) : (
                      <Alert severity="info" sx={{ borderRadius: 2 }}>
                        No format suggestions available.
                      </Alert>
                    )}
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* General Advice */}
              <Grid item xs={12}>
                <Card 
                  sx={{ 
                    borderRadius: 2,
                    border: `1px solid ${theme.palette.divider}`,
                    boxShadow: 'none'
                  }}
                >
                  <CardHeader 
                    title="General Advice" 
                    avatar={<InfoIcon color="primary" />}
                    titleTypographyProps={{ fontWeight: 600 }}
                    sx={{ 
                      p: 2, 
                      pb: 1.5,
                      backgroundColor: alpha(theme.palette.primary.main, 0.05)
                    }}
                  />
                  <CardContent sx={{ p: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      {tailoringData?.generalAdvice || "No general advice available."}
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Box>
        );
      
      case 2:
        return (
          <Box sx={{ my: 2 }}>
            <Typography variant="h6" fontWeight={500} gutterBottom>
              Create Tailored Resume
            </Typography>
            
            <Typography variant="body1" paragraph color="text.secondary">
              Based on the recommendations, we'll create a tailored version of your resume 
              specifically optimized for this job. The AI will apply all the suggested improvements.
            </Typography>
            
            <Box sx={{ 
              mt: 3, 
              p: 2.5, 
              bgcolor: alpha(theme.palette.info.main, 0.1), 
              borderRadius: 2, 
              display: 'flex', 
              alignItems: 'flex-start',
              border: `1px solid ${alpha(theme.palette.info.main, 0.3)}`
            }}>
              <SmartToyIcon sx={{ mr: 2, color: theme.palette.info.main, mt: 0.5 }} />
              <Typography variant="body2" color="text.secondary">
                This will create a new resume in your collection with the AI recommended improvements applied.
                Your original resume will remain unchanged.
              </Typography>
            </Box>
            
            <Typography variant="subtitle2" fontWeight={600} color="text.secondary" sx={{ mt: 3, mb: 1 }}>
              Resume Name
            </Typography>
            <TextField
              variant="outlined"
              fullWidth
              value={versionName}
              onChange={(e) => setVersionName(e.target.value)}
              placeholder="Enter a name for your tailored resume"
              size="medium"
              sx={{ 
                mb: 3,
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2
                }
              }}
            />
            
            <Typography variant="subtitle2" fontWeight={600} color="text.secondary" sx={{ mb: 1 }}>
              Notes (Optional)
            </Typography>
            <TextField
              variant="outlined"
              fullWidth
              multiline
              rows={3}
              value={versionNotes}
              onChange={(e) => setVersionNotes(e.target.value)}
              placeholder="Add any notes about this tailored version..."
              sx={{ 
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2
                }
              }}
            />
          </Box>
        );
      
      default:
        return null;
    }
  };

  if (loading && activeStep === 0) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate(`/jobs/${jobId}`)}
            sx={{ mb: 4 }}
            variant="outlined"
          >
            Back to Job
          </Button>
          
          <Paper sx={{ p: 4, borderRadius: 3 }}>
            <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
              {steps.map((label) => (
                <Step key={label}>
                  <StepLabel>{label}</StepLabel>
                </Step>
              ))}
            </Stepper>
            
            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              <Typography variant="h6" gutterBottom fontWeight={500}>
                Analyzing Resume Match
              </Typography>
              <CircularProgress size={60} thickness={4} sx={{ my: 4 }} />
              <Typography variant="body1" color="text.secondary">
                Please wait while we analyze your resume against the job requirements...
              </Typography>
            </Box>
          </Paper>
        </Box>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate(`/jobs/${jobId}`)}
            sx={{ mb: 2 }}
            variant="outlined"
          >
            Back to Job
          </Button>
          
          <Alert severity="error" sx={{ mb: 2, borderRadius: 2 }}>
            {error}
          </Alert>
          
          <Button 
            variant="contained" 
            color="primary"
            onClick={fetchData}
          >
            Try Again
          </Button>
        </Box>
      </MainLayout>
    );
  }

  if (!job || !resume || !tailoringData) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate(`/jobs/${jobId}`)}
            sx={{ mb: 2 }}
            variant="outlined"
          >
            Back to Job
          </Button>
          
          <Alert severity="info" sx={{ borderRadius: 2 }}>
            Unable to load tailoring data. Please try again.
          </Alert>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1200px', mx: 'auto' }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate(`/jobs/${jobId}`)}
          sx={{ mb: 2 }}
          variant="outlined"
        >
          Back to Job
        </Button>
        
        <Paper sx={{ p: 4, mb: 3, borderRadius: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
            <Box>
              <Typography variant="h5" gutterBottom fontWeight={600}>
                Tailor Resume for {job.title}
              </Typography>
              <Typography variant="subtitle1" color="text.secondary">
                {job.company}
              </Typography>
            </Box>
            <Box>
              <Chip 
                label={`Match Score: ${job.matchAnalysis?.overallScore || 0}%`}
                color={getScoreColor(job.matchAnalysis?.overallScore || 0)}
                sx={{ fontWeight: 500, borderRadius: 6, height: 36 }}
              />
            </Box>
          </Box>
          
          <Stepper 
            activeStep={activeStep} 
            sx={{ 
              mb: 4,
              '& .MuiStepLabel-root': {
                '& .MuiStepLabel-iconContainer': {
                  '& .MuiStepIcon-root': {
                    '&.Mui-active': {
                      color: theme.palette.primary.main,
                    },
                    '&.Mui-completed': {
                      color: theme.palette.success.main,
                    },
                  },
                },
              },
            }}
          >
            {steps.map((label) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>
          
          {renderStepContent(activeStep)}
          
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4, pt: 2, borderTop: `1px solid ${theme.palette.divider}` }}>
            <Button
              variant="outlined"
              onClick={() => navigate(`/jobs/${jobId}`)}
              sx={{ mr: 1, borderRadius: 2 }}
            >
              Cancel
            </Button>
            
            <Box>
              {activeStep === 2 && (
                <Button
                  variant="outlined"
                  onClick={handleBack}
                  startIcon={<ArrowBackIcon />}
                  sx={{ mr: 1, borderRadius: 2 }}
                  disabled={loading || tailoringSaving}
                >
                  Back to Recommendations
                </Button>
              )}
              
              {activeStep < steps.length - 1 ? (
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handleNext}
                  disabled={loading || activeStep === 0}
                  sx={{ borderRadius: 2 }}
                >
                  Next
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handleSaveTailoredResume}
                  startIcon={tailoringSaving ? <CircularProgress size={20} color="inherit" /> : <SaveIcon />}
                  disabled={tailoringSaving}
                  sx={{ borderRadius: 2, px: 3 }}
                >
                  {tailoringSaving ? 'Creating...' : 'Create Tailored Resume'}
                </Button>
              )}
            </Box>
          </Box>
        </Paper>
      </Box>
      
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert 
          onClose={handleCloseSnackbar} 
          severity={snackbar.severity} 
          sx={{ width: '100%', borderRadius: 2 }}
          variant="filled"
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </MainLayout>
  );
};

// Helper function to get color based on score
const getScoreColor = (score) => {
  if (score >= 80) return 'success';
  if (score >= 60) return 'warning';
  return 'error';
};

export default ResumeTailoring;

================
File: src/components/jobs/tabs/AnalysisTab.js
================
// src/components/jobs/tabs/AnalysisTab.js
import React from 'react';
import {
  Grid,
  Card,
  CardHeader,
  CardContent,
  Typography,
  Button,
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Alert,
  CircularProgress,
  Stack,
  Chip,
  Tooltip,
  useTheme,
  Paper
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  SmartToy as SmartToyIcon,
  Lightbulb as LightbulbIcon,
  Code as CodeIcon,
  Speed as SpeedIcon,
  AutoAwesome as AutoAwesomeIcon,
  Analytics as AnalyticsIcon,
  TrendingUp as TrendingUpIcon
} from '@mui/icons-material';

import SkillChip from '../components/SkillChip';
import AutoJobLogo from '../../common/AutoJobLogo';

const AnalysisTab = ({ job, onTailorClick }) => {
  const theme = useTheme();

  // Safe AutoJobLogo wrapper component that handles the proper props
  const SafeAutoJobLogo = ({ iconSize = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={iconSize} 
          showTagline={false}
        />
      );
    } catch (error) {
      // Fallback to SmartToy icon if AutoJobLogo fails
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: iconSize === 'small' ? 16 : 20 }} />;
    }
  };

  const getScoreColor = (score) => {
    if (score >= 85) return 'success';
    if (score >= 70) return 'info';
    if (score >= 55) return 'warning';
    return 'error';
  };

  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  if (!job.matchAnalysis?.overallScore) {
    return (
      <Box sx={{ 
        display: 'flex', 
        flexDirection: 'column', 
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '50vh',
        textAlign: 'center',
        px: 3,
        py: 6
      }}>
        {/* Main Icon Container with Diamond */}
        <Box sx={{ 
          mb: 3,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          {/* Background Circle with Gradient */}
          <Box
            sx={{
              width: 80,
              height: 80,
              background: `linear-gradient(135deg, ${theme.palette.primary.main}15 0%, ${theme.palette.secondary.main}15 100%)`,
              borderRadius: 3, // Using theme's borderRadius
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              border: `2px solid ${theme.palette.primary.main}20`,
              position: 'relative',
              boxShadow: `0px 4px 8px ${theme.palette.primary.main}20`,
            }}
          >
            <AutoAwesomeIcon sx={{ 
              fontSize: 32, 
              color: theme.palette.primary.main
            }} />
          </Box>
        </Box>

        {/* Title with Theme Typography */}
        <Typography 
          variant="h5" 
          gutterBottom 
          fontWeight={600}
          sx={{ 
            color: theme.palette.text.primary,
            mb: 1
          }}
        >
          No Match Analysis Available
        </Typography>
        
        {/* Subtitle */}
        <Typography 
          variant="body1" 
          sx={{ 
            color: theme.palette.text.secondary,
            mb: 4,
            maxWidth: 500,
            lineHeight: 1.5
          }}
        >
          Get detailed insights by matching your resume with this job. Our enhanced AI will provide:
        </Typography>

        {/* Features List in Card */}
        <Paper 
          elevation={1}
          sx={{ 
            maxWidth: 480, 
            mb: 4,
            p: 3,
            borderRadius: 3, // Using theme's enhanced borderRadius
            bgcolor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`
          }}
        >
          <List dense sx={{ '& .MuiListItem-root': { py: 0.75 } }}>
            <ListItem sx={{ px: 0 }}>
              <ListItemIcon sx={{ minWidth: 36 }}>
                <CheckCircleIcon color="primary" fontSize="small" />
              </ListItemIcon>
              <ListItemText 
                primary="Precise skill matching with importance weighting"
                primaryTypographyProps={{ 
                  variant: 'body2', 
                  fontWeight: 500,
                  color: theme.palette.text.primary
                }}
              />
            </ListItem>
            <ListItem sx={{ px: 0 }}>
              <ListItemIcon sx={{ minWidth: 36 }}>
                <TrendingUpIcon color="primary" fontSize="small" />
              </ListItemIcon>
              <ListItemText 
                primary="Experience level compatibility analysis"
                primaryTypographyProps={{ 
                  variant: 'body2', 
                  fontWeight: 500,
                  color: theme.palette.text.primary
                }}
              />
            </ListItem>
            <ListItem sx={{ px: 0 }}>
              <ListItemIcon sx={{ minWidth: 36 }}>
                <LightbulbIcon color="primary" fontSize="small" />
              </ListItemIcon>
              <ListItemText 
                primary="Personalized recommendations for improvement"
                primaryTypographyProps={{ 
                  variant: 'body2', 
                  fontWeight: 500,
                  color: theme.palette.text.primary
                }}
              />
            </ListItem>
          </List>
        </Paper>

        {/* CTA Button with Theme Styling */}
        <Button
          variant="contained"
          size="large"
          onClick={onTailorClick}
          startIcon={<SafeAutoJobLogo iconSize="small" />}
          sx={{ 
            borderRadius: 2, // Using theme's borderRadius
            px: 4,
            py: 1.2,
            fontSize: '0.95rem',
            fontWeight: 600,
            bgcolor: theme.palette.secondary.main,
            color: theme.palette.secondary.contrastText,
            boxShadow: theme.shadows[3],
            '&:hover': {
              bgcolor: theme.palette.secondary.dark,
              boxShadow: theme.shadows[6],
              transform: 'translateY(-1px)'
            },
            transition: 'all 0.2s ease'
          }}
        >
          Start Enhanced Analysis
        </Button>

        {/* Bottom Helper Text */}
        <Typography 
          variant="caption" 
          sx={{ 
            color: theme.palette.text.disabled,
            mt: 3,
            maxWidth: 400
          }}
        >
          Our AI will analyze your resume against this job posting to provide detailed compatibility scores and improvement suggestions.
        </Typography>
      </Box>
    );
  }

  return (
    <Grid container spacing={3}>
      {/* Detailed Match Breakdown */}
      <Grid item xs={12}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Detailed Match Analysis" 
            avatar={<SpeedIcon color="primary" />}
            action={
              <Stack direction="row" spacing={1}>
                <Chip 
                  label={`Analyzed ${new Date(job.matchAnalysis.lastAnalyzed || Date.now()).toLocaleDateString()}`} 
                  size="small" 
                  color="secondary"
                  variant="outlined"
                />
              </Stack>
            }
            sx={{ 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} md={4}>
                <Box sx={{ textAlign: 'center', p: 3, border: '1px solid', borderColor: 'divider', borderRadius: 3, height: '100%' }}>
                  <Box sx={{ mb: 2 }}>
                    <CircularProgress
                      variant="determinate"
                      value={job.matchAnalysis.categoryScores?.skills || 0}
                      size={80}
                      thickness={6}
                      sx={{ 
                        color: theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.skills || 0)].main,
                        mb: 1
                      }}
                    />
                  </Box>
                  <Typography variant="h5" fontWeight={600} color={theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.skills || 0)].main}>
                    {job.matchAnalysis.categoryScores?.skills || 0}%
                  </Typography>
                  <Typography variant="subtitle1" fontWeight={500} color="primary.main">
                    Skills Match
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                    {job.matchAnalysis.matchedSkills?.filter(s => s.found).length || 0} of {job.matchAnalysis.matchedSkills?.length || 0} skills matched
                  </Typography>
                  
                  {/* Skills breakdown */}
                  {job.matchAnalysis.matchedSkills && (
                    <Box sx={{ mt: 2 }}>
                      <Stack direction="row" spacing={1} justifyContent="center">
                        <Chip 
                          label={`${job.matchAnalysis.matchedSkills.filter(s => s.found && s.matchQuality === 'exact').length} exact`}
                          size="small"
                          color="success"
                        />
                        <Chip 
                          label={`${job.matchAnalysis.matchedSkills.filter(s => s.found && s.matchQuality === 'partial').length} partial`}
                          size="small"
                          color="warning"
                        />
                      </Stack>
                    </Box>
                  )}
                </Box>
              </Grid>
              
              <Grid item xs={12} md={4}>
                <Box sx={{ textAlign: 'center', p: 3, border: '1px solid', borderColor: 'divider', borderRadius: 3, height: '100%' }}>
                  <Box sx={{ mb: 2 }}>
                    <CircularProgress
                      variant="determinate"
                      value={job.matchAnalysis.categoryScores?.experience || 0}
                      size={80}
                      thickness={6}
                      sx={{ 
                        color: theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.experience || 0)].main,
                        mb: 1
                      }}
                    />
                  </Box>
                  <Typography variant="h5" fontWeight={600} color={theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.experience || 0)].main}>
                    {job.matchAnalysis.categoryScores?.experience || 0}%
                  </Typography>
                  <Typography variant="subtitle1" fontWeight={500} color="primary.main">
                    Experience Match
                  </Typography>
                  
                  {/* Enhanced experience details */}
                  {job.matchAnalysis.experienceAnalysis ? (
                    <Box sx={{ mt: 1 }}>
                      <Typography variant="body2" color="text.secondary">
                        {job.matchAnalysis.experienceAnalysis.relevantYearsExperience || 0} years relevant
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {job.matchAnalysis.experienceAnalysis.seniorityMatch && 
                          `${job.matchAnalysis.experienceAnalysis.seniorityMatch} level`}
                      </Typography>
                    </Box>
                  ) : (
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Experience level alignment
                    </Typography>
                  )}
                </Box>
              </Grid>
              
              <Grid item xs={12} md={4}>
                <Box sx={{ textAlign: 'center', p: 3, border: '1px solid', borderColor: 'divider', borderRadius: 3, height: '100%' }}>
                  <Box sx={{ mb: 2 }}>
                    <CircularProgress
                      variant="determinate"
                      value={job.matchAnalysis.categoryScores?.education || 0}
                      size={80}
                      thickness={6}
                      sx={{ 
                        color: theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.education || 0)].main,
                        mb: 1
                      }}
                    />
                  </Box>
                  <Typography variant="h5" fontWeight={600} color={theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.education || 0)].main}>
                    {job.matchAnalysis.categoryScores?.education || 0}%
                  </Typography>
                  <Typography variant="subtitle1" fontWeight={500} color="primary.main">
                    Education Match
                  </Typography>
                  
                  {/* Enhanced education details */}
                  {job.matchAnalysis.educationAnalysis ? (
                    <Box sx={{ mt: 1 }}>
                      <Typography variant="body2" color="text.secondary" sx={{ textTransform: 'capitalize' }}>
                        {job.matchAnalysis.educationAnalysis.degreeMatch} requirements
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ textTransform: 'capitalize' }}>
                        {job.matchAnalysis.educationAnalysis.fieldAlignment} field alignment
                      </Typography>
                    </Box>
                  ) : (
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Education requirements met
                    </Typography>
                  )}
                </Box>
              </Grid>
            </Grid>
            
            <Box sx={{ 
              mt: 3, 
              p: 2, 
              bgcolor: `${theme.palette.info.main}10`, 
              borderRadius: 2,
              border: `1px solid ${theme.palette.info.main}20`,
              display: 'flex',
              alignItems: 'flex-start'
            }}>
              <AnalyticsIcon color="info" sx={{ mr: 1.5, mt: 0.5 }} />
              <Box>
                <Typography variant="body2" paragraph>
                  Our enhanced AI matching algorithm analyzes your resume against this job using advanced NLP and semantic understanding. 
                  Scores are weighted: Skills (40%), Experience (35%), Education (25%).
                </Typography>
              </Box>
            </Box>
          </CardContent>
        </Card>
      </Grid>
      
      {/* Enhanced Skills Analysis */}
      <Grid item xs={12} md={6}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3, height: 'fit-content' }}>
          <CardHeader 
            title="Skills Analysis" 
            avatar={<CodeIcon color="primary" />}
            sx={{ 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            <Typography variant="subtitle1" fontWeight={600} gutterBottom sx={{ 
              color: theme.palette.success.main, 
              display: 'flex', 
              alignItems: 'center' 
            }}>
              <CheckCircleIcon sx={{ mr: 1 }} /> Matched Skills ({job.matchAnalysis.matchedSkills?.filter(s => s.found).length || 0})
            </Typography>
            
            {job.matchAnalysis.matchedSkills && job.matchAnalysis.matchedSkills.filter(s => s.found).length > 0 ? (
              <Box sx={{ 
                display: 'flex', 
                flexWrap: 'wrap', 
                gap: 1, 
                mb: 3,
                p: 2,
                bgcolor: `${theme.palette.success.main}08`,
                borderRadius: 2
              }}>
                {job.matchAnalysis.matchedSkills && job.matchAnalysis.matchedSkills.filter(s => s && s.found).map((skill, index) => (
                  <SkillChip
                    key={`matched-skill-${index}`}
                    skill={skill}
                    isMatched={true}
                    importance={skill && typeof skill === 'object' ? skill.importance : undefined}
                    matchQuality={skill && typeof skill === 'object' ? skill.matchQuality : undefined}
                  />
                ))}
              </Box>
            ) : (
              <Alert severity="info" sx={{ mb: 3, borderRadius: 2 }}>
                No matching skills found.
              </Alert>
            )}

            <Typography variant="subtitle1" fontWeight={600} gutterBottom sx={{ 
              color: theme.palette.warning.main, 
              display: 'flex', 
              alignItems: 'center',
              mt: 4
            }}>
              <WarningIcon sx={{ mr: 1 }} /> Missing Skills ({job.matchAnalysis.missingSkills?.length || 0})
            </Typography>
            
            {job.matchAnalysis.missingSkills && job.matchAnalysis.missingSkills.length > 0 ? (
              <Box sx={{ 
                display: 'flex', 
                flexWrap: 'wrap', 
                gap: 1,
                p: 2,
                bgcolor: `${theme.palette.warning.main}08`,
                borderRadius: 2
              }}>
                {job.matchAnalysis.missingSkills && job.matchAnalysis.missingSkills.map((skill, index) => (
                  <SkillChip
                    key={`missing-skill-${index}`}
                    skill={skill}
                    isMatched={false}
                    importance={skill && typeof skill === 'object' ? skill.importance : undefined}
                  />
                ))}
              </Box>
            ) : (
              <Alert severity="success" sx={{ borderRadius: 2 }}>
                Excellent! No missing skills identified. Your resume includes all required skills.
              </Alert>
            )}
          </CardContent>
        </Card>
      </Grid>

      {/* Enhanced Improvement Suggestions */}
      <Grid item xs={12} md={6}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3, height: 'fit-content' }}>
          <CardHeader 
            title="AI Recommendations" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            {job.matchAnalysis.improvementSuggestions && job.matchAnalysis.improvementSuggestions.length > 0 ? (
              <List sx={{ p: 0 }}>
                {job.matchAnalysis.improvementSuggestions.map((suggestion, index) => (
                  <ListItem key={index} sx={{ 
                    backgroundColor: `${theme.palette.info.main}08`, 
                    borderRadius: 2, 
                    mb: 2,
                    px: 2,
                    alignItems: 'flex-start'
                  }}>
                    <ListItemIcon>
                      <LightbulbIcon color="info" />
                    </ListItemIcon>
                    <ListItemText 
                      primary={suggestion}
                      primaryTypographyProps={{ variant: 'body2' }}
                    />
                  </ListItem>
                ))}
              </List>
            ) : (
              <Alert severity="success" sx={{ borderRadius: 2 }}>
                Great! No major improvements needed. Your resume looks excellent for this job.
              </Alert>
            )}

            <Box sx={{ mt: 3 }}>
              <Button
                variant="contained"
                color="secondary"
                startIcon={<SafeAutoJobLogo iconSize="small" />}
                onClick={onTailorClick}
                fullWidth
                sx={{ borderRadius: 2, py: 1.2 }}
              >
                Get Tailored Resume
              </Button>
            </Box>
          </CardContent>
        </Card>
      </Grid>
      
      {/* Enhanced Keywords Section */}
      <Grid item xs={12}>
        <Card elevation={2} sx={{ borderRadius: 3 }}>
          <CardHeader 
            title="Keyword Optimization" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ 
              pb: 1, 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            <Typography variant="body2" color="text.secondary" paragraph>
              These keywords will boost your ATS compatibility and match score for this position:
            </Typography>
            
            <Box sx={{ 
              display: 'flex', 
              flexWrap: 'wrap', 
              gap: 1.5,
              '& .MuiChip-root': {
                transition: 'all 0.2s ease',
                '&:hover': {
                  transform: 'translateY(-2px)',
                  boxShadow: 2
                }
              }
            }}>
              {job.matchAnalysis.missingSkills && job.matchAnalysis.missingSkills.map((skill, index) => {
                // Extract skill name safely
                const skillName = skill && typeof skill === 'object' ? 
                  (skill.name || skill.skill || 'Unknown Skill') : 
                  (typeof skill === 'string' ? skill : 'Unknown Skill');
                
                const importance = skill && typeof skill === 'object' ? skill.importance : 5;
                const category = skill && typeof skill === 'object' ? (skill.category || 'required') : 'required';
                
                return (
                  <Tooltip 
                    key={`keyword-skill-${index}`}
                    title={`Importance: ${importance}/10 | ${category}`}
                  >
                    <Chip 
                      label={skillName} 
                      sx={{ 
                        bgcolor: COLORS[index % COLORS.length] + '20',
                        color: COLORS[index % COLORS.length],
                        fontWeight: 500,
                        borderRadius: 2,
                        border: `1px solid ${COLORS[index % COLORS.length]}40`,
                        '&:hover': {
                          bgcolor: COLORS[index % COLORS.length] + '30',
                        }
                      }} 
                    />
                  </Tooltip>
                );
              })}
            </Box>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
};

export default AnalysisTab;

================
File: src/components/jobs/tabs/ContentTab.js
================
// src/components/jobs/tabs/ContentTab.js
import React from 'react';
import {
  Grid,
  Card,
  CardHeader,
  CardContent,
  Typography,
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  Assignment as AssignmentIcon,
  Code as CodeIcon,
  Person as PersonIcon
} from '@mui/icons-material';

const ContentTab = ({ job }) => {
  return (
    <>
      <Card elevation={2} sx={{ borderRadius: 3, mb: 3 }}>
        <CardHeader 
          title="Full Job Description" 
          avatar={<DescriptionIcon color="primary" />}
          sx={{ 
            '& .MuiCardHeader-title': { fontWeight: 600 } 
          }}
        />
        <CardContent>
          <Typography variant="body1" component="div" sx={{ whiteSpace: 'pre-line', lineHeight: 1.7 }}>
            {job.description}
          </Typography>
        </CardContent>
      </Card>
      
      {job.parsedData && (
        <Grid container spacing={3}>
          {job.parsedData.responsibilities && job.parsedData.responsibilities.length > 0 && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title={`Key Responsibilities (${job.parsedData.responsibilities.length})`}
                  avatar={<WorkIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <List>
                    {job.parsedData.responsibilities.map((resp, index) => (
                      <ListItem key={index} sx={{ py: 0.5, alignItems: 'flex-start' }}>
                        <ListItemIcon sx={{ minWidth: 28, mt: 0.5 }}>
                          <CheckCircleIcon fontSize="small" color="primary" />
                        </ListItemIcon>
                        <ListItemText 
                          primary={resp}
                          primaryTypographyProps={{ variant: 'body2' }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Grid>
          )}
          
          {job.parsedData.requirements && job.parsedData.requirements.length > 0 && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title={`Requirements (${job.parsedData.requirements.length})`}
                  avatar={<AssignmentIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <List>
                    {job.parsedData.requirements.map((req, index) => (
                      <ListItem key={index} sx={{ py: 0.5, alignItems: 'flex-start' }}>
                        <ListItemIcon sx={{ minWidth: 28, mt: 0.5 }}>
                          <CheckCircleIcon fontSize="small" color="primary" />
                        </ListItemIcon>
                        <ListItemText 
                          primary={req}
                          primaryTypographyProps={{ variant: 'body2' }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Grid>
          )}

          {/* Enhanced Technical Details */}
          {(job.parsedData.technicalSkills || job.parsedData.toolsAndTechnologies) && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title="Technical Requirements"
                  avatar={<CodeIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  {job.parsedData.technicalSkills && job.parsedData.technicalSkills.length > 0 && (
                    <Box sx={{ mb: 2 }}>
                      <Typography variant="subtitle2" gutterBottom color="primary">
                        Technical Skills:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {job.parsedData.technicalSkills && job.parsedData.technicalSkills.map((skill, index) => {
                          // Extract skill name safely
                          const skillName = skill && typeof skill === 'object' ? 
                            (skill.name || skill.skill || 'Unknown Skill') : 
                            (typeof skill === 'string' ? skill : 'Unknown Skill');
                          
                          return (
                            <Chip 
                              key={`tech-skill-${index}`} 
                              label={skillName} 
                              size="small" 
                              color="primary"
                              variant="outlined"
                            />
                          );
                        })}
                      </Box>
                    </Box>
                  )}
                  
                  {job.parsedData.toolsAndTechnologies && job.parsedData.toolsAndTechnologies.length > 0 && (
                    <Box>
                      <Typography variant="subtitle2" gutterBottom color="secondary">
                        Tools & Technologies:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {job.parsedData.toolsAndTechnologies && job.parsedData.toolsAndTechnologies.map((tool, index) => {
                          // Extract tool name safely
                          const toolName = tool && typeof tool === 'object' ? 
                            (tool.name || tool.skill || tool.tool || 'Unknown Tool') : 
                            (typeof tool === 'string' ? tool : 'Unknown Tool');
                          
                          return (
                            <Chip 
                              key={`tool-tech-${index}`} 
                              label={toolName} 
                              size="small" 
                              color="secondary"
                              variant="outlined"
                            />
                          );
                        })}
                      </Box>
                    </Box>
                  )}
                </CardContent>
              </Card>
            </Grid>
          )}

          {/* Enhanced Soft Skills */}
          {job.parsedData.softSkills && job.parsedData.softSkills.length > 0 && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title="Soft Skills & Attributes"
                  avatar={<PersonIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                    {job.parsedData.softSkills && job.parsedData.softSkills.map((skill, index) => {
                      // Extract skill name safely
                      const skillName = skill && typeof skill === 'object' ? 
                        (skill.name || skill.skill || 'Unknown Skill') : 
                        (typeof skill === 'string' ? skill : 'Unknown Skill');
                      
                      return (
                        <Chip 
                          key={`soft-skill-${index}`} 
                          label={skillName} 
                          size="small" 
                          color="info"
                          variant="outlined"
                        />
                      );
                    })}
                  </Box>
                </CardContent>
              </Card>
            </Grid>
          )}
          
          {job.parsedData.benefits && job.parsedData.benefits.length > 0 && (
            <Grid item xs={12}>
              <Card elevation={2} sx={{ borderRadius: 3 }}>
                <CardHeader 
                  title={`Benefits & Perks (${job.parsedData.benefits.length})`}
                  avatar={<WorkIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <Grid container spacing={2}>
                    {job.parsedData.benefits.map((benefit, index) => (
                      <Grid item xs={12} md={6} key={index}>
                        <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                          <CheckCircleIcon color="success" sx={{ mt: 0.5, mr: 1.5 }} />
                          <Typography variant="body2">{benefit}</Typography>
                        </Box>
                      </Grid>
                    ))}
                  </Grid>
                </CardContent>
              </Card>
            </Grid>
          )}
        </Grid>
      )}
    </>
  );
};

export default ContentTab;

================
File: src/components/jobs/tabs/OverviewTab.js
================
// src/components/jobs/tabs/OverviewTab.js
import React from 'react';
import {
  Grid,
  Card,
  CardHeader,
  CardContent,
  Typography,
  Button,
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  useTheme,
  Chip
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  SmartToy as SmartToyIcon,
  Psychology as PsychologyIcon,
  Assignment as AssignmentIcon,
  School as SchoolIcon,
  Lightbulb as LightbulbIcon,
  Code as CodeIcon,
  Info as InfoIcon,
  Star as StarIcon
} from '@mui/icons-material';

// Import our component files
import JobDetailsCard from '../components/JobDetailsCard';
import MatchAnalysisCard from '../components/MatchAnalysisCard';
import SkillChip from '../components/SkillChip';
import AutoJobLogo from '../../common/AutoJobLogo';

const OverviewTab = ({ job, onTailorClick }) => {
  const theme = useTheme();

  // Safe AutoJobLogo wrapper component
  const SafeAutoJobLogo = ({ size = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={size} 
          showTagline={false}
        />
      );
    } catch (error) {
      // Fallback to SmartToy icon if AutoJobLogo fails
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: size === 'small' ? 16 : 20 }} />;
    }
  };

  return (
    <Grid container spacing={3}>
      <Grid item xs={12} md={4}>
        {/* Job Details Card Component */}
        <JobDetailsCard job={job} />
        
        {/* Match Analysis Card Component */}
        <MatchAnalysisCard job={job} />
      </Grid>

      <Grid item xs={12} md={8}>
        {job.matchAnalysis?.overallScore ? (
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Match Insights & Recommendations" 
              avatar={<CheckCircleIcon color="primary" />}
              sx={{ 
                pb: 0, 
                '& .MuiCardHeader-title': { fontWeight: 600 } 
              }}
            />
            <CardContent>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle1" gutterBottom sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    color: theme.palette.success.main,
                    fontWeight: 600
                  }}>
                    <CheckCircleIcon sx={{ mr: 1 }} /> Your Strengths
                  </Typography>
                  
                  {/* Show strengths from new enhanced matching */}
                  {job.matchAnalysis.strengthsHighlight && job.matchAnalysis.strengthsHighlight.length > 0 ? (
                    <List dense>
                      {job.matchAnalysis.strengthsHighlight.map((strength, index) => (
                        <ListItem key={index} sx={{ 
                          backgroundColor: `${theme.palette.success.main}15`, 
                          borderRadius: 2, 
                          mb: 1,
                          px: 2
                        }}>
                          <ListItemIcon>
                            <StarIcon color="success" fontSize="small" />
                          </ListItemIcon>
                          <ListItemText primary={strength} />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    /* Fallback to matched skills */
                    <List dense>
                      {job.matchAnalysis.matchedSkills && job.matchAnalysis.matchedSkills.filter(s => s.found).length > 0 ? (
                        job.matchAnalysis.matchedSkills.filter(s => s.found).slice(0, 4).map((skill, index) => (
                          <ListItem key={index} sx={{ 
                            backgroundColor: `${theme.palette.success.main}15`, 
                            borderRadius: 2, 
                            mb: 1,
                            px: 2
                          }}>
                            <ListItemIcon>
                              <CheckCircleIcon color="success" fontSize="small" />
                            </ListItemIcon>
                            <ListItemText 
                              primary={skill.skill} 
                              secondary={skill.matchQuality ? `${skill.matchQuality} match` : null}
                            />
                          </ListItem>
                        ))
                      ) : (
                        <ListItem>
                          <ListItemText primary="No matching skills found." />
                        </ListItem>
                      )}
                    </List>
                  )}
                </Grid>

                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle1" gutterBottom sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    color: theme.palette.warning.main,
                    fontWeight: 600
                  }}>
                    <WarningIcon sx={{ mr: 1 }} /> Areas for Improvement
                  </Typography>
                  <List dense>
                    {job.matchAnalysis.improvementSuggestions && job.matchAnalysis.improvementSuggestions.length > 0 ? (
                      job.matchAnalysis.improvementSuggestions.slice(0, 4).map((suggestion, index) => (
                        <ListItem key={index} sx={{ 
                          backgroundColor: `${theme.palette.warning.main}15`, 
                          borderRadius: 2, 
                          mb: 1,
                          px: 2 
                        }}>
                          <ListItemIcon>
                            <LightbulbIcon color="warning" fontSize="small" />
                          </ListItemIcon>
                          <ListItemText primary={suggestion} />
                        </ListItem>
                      ))
                    ) : (
                      <ListItem>
                        <ListItemText primary="No improvement suggestions available." />
                      </ListItem>
                    )}
                  </List>
                </Grid>
              </Grid>
              
              <Box sx={{ mt: 3 }}>
                <Button
                  variant="contained"
                  color="secondary"
                  startIcon={<SafeAutoJobLogo size="small" />}
                  onClick={onTailorClick}
                  sx={{ borderRadius: 2, py: 1.2 }}
                >
                  Get Tailored Resume
                </Button>
              </Box>
            </CardContent>
          </Card>
        ) : (
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Tailor My Resume To This Job" 
              avatar={<PsychologyIcon color="primary" />}
              sx={{ 
                pb: 1, 
                '& .MuiCardHeader-title': { fontWeight: 600 } 
              }}
            />
            <CardContent sx={{ textAlign: 'center', py: 4 }}>
              <Box 
                sx={{ 
                  width: 100, 
                  height: 100, 
                  borderRadius: '50%', 
                  border: '3px dashed', 
                  borderColor: 'primary.main',
                  display: 'flex',
                  justifyContent: 'center',
                  alignItems: 'center',
                  mb: 3,
                  mx: 'auto'
                }}
              >
                <SafeAutoJobLogo size="medium" />
              </Box>
              <Typography variant="h5" gutterBottom fontWeight={600}>
                Tailor My Resume To This Job
              </Typography>
              <Typography variant="body1" paragraph sx={{ mb: 3, mx: 'auto', maxWidth: 600 }}>
                Get intelligent insights by matching your resume with this job. Our enhanced AI will analyze skills, experience, 
                and education to provide accurate compatibility scores and personalized recommendations.
              </Typography>
              <Button
                variant="contained"
                color="secondary"
                startIcon={<SafeAutoJobLogo size="small" />}
                onClick={onTailorClick}
                sx={{ borderRadius: 2, px: 3, py: 1.2 }}
              >
                Get Tailored Resume
              </Button>
            </CardContent>
          </Card>
        )}

        {/* Enhanced Key Requirements */}
        {job.parsedData && (
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Job Requirements Analysis" 
              avatar={<AssignmentIcon color="primary" />}
              sx={{ 
                '& .MuiCardHeader-title': { fontWeight: 600 } 
              }}
            />
            <CardContent>
              <Grid container spacing={3}>
                {job.parsedData.keySkills && job.parsedData.keySkills.length > 0 && (
                  <Grid item xs={12}>
                    <Typography variant="subtitle1" fontWeight={600} gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center' }}>
                      <CodeIcon sx={{ mr: 1 }} /> Required Skills
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                      Skills are color-coded by importance: <span style={{ color: theme.palette.error.main }}>Critical</span>, 
                      <span style={{ color: theme.palette.warning.main }}> Important</span>, 
                      <span style={{ color: theme.palette.info.main }}> Nice-to-have</span>
                    </Typography>
                    <Box sx={{ 
                      display: 'flex', 
                      flexWrap: 'wrap', 
                      gap: 1.5,
                      p: 2,
                      bgcolor: 'rgba(0,0,0,0.02)',
                      borderRadius: 2
                    }}>
                      {job.parsedData.keySkills && job.parsedData.keySkills.map((skill, index) => {
                        const skillName = skill && typeof skill === 'object' ? (skill.name || skill.skill || '') : skill;
                        const matchedSkill = job.matchAnalysis?.matchedSkills?.find(s => 
                          (s.skill === skillName) || 
                          (typeof s.skill === 'object' && s.skill.name === skillName)
                        );
                        const isMatched = matchedSkill?.found || false;
                        
                        return (
                          <SkillChip
                            key={`key-skill-${index}`}
                            skill={skill}
                            isMatched={isMatched}
                            importance={skill && typeof skill === 'object' ? skill.importance : undefined}
                            matchQuality={matchedSkill?.matchQuality}
                          />
                        );
                      })}
                    </Box>
                  </Grid>
                )}

                {job.parsedData.qualifications && (
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle1" fontWeight={600} gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center' }}>
                      <SchoolIcon sx={{ mr: 1 }} /> Qualifications
                    </Typography>
                    <Box sx={{ 
                      p: 2, 
                      bgcolor: 'rgba(0,0,0,0.02)',
                      borderRadius: 2
                    }}>
                      {job.parsedData.qualifications.required && job.parsedData.qualifications.required.length > 0 && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="subtitle2" gutterBottom sx={{ display: 'flex', alignItems: 'center', color: theme.palette.secondary.main }}>
                            Required Qualifications:
                          </Typography>
                          <List dense disablePadding>
                            {job.parsedData.qualifications.required.slice(0, 5).map((qual, index) => (
                              <ListItem key={index} sx={{ py: 0.5 }}>
                                <ListItemIcon sx={{ minWidth: 28 }}>
                                  <CheckCircleIcon fontSize="small" color="secondary" />
                                </ListItemIcon>
                                <ListItemText primary={qual} />
                              </ListItem>
                            ))}
                          </List>
                        </Box>
                      )}
                      {job.parsedData.qualifications.preferred && job.parsedData.qualifications.preferred.length > 0 && (
                        <Box>
                          <Typography variant="subtitle2" gutterBottom sx={{ display: 'flex', alignItems: 'center', color: theme.palette.info.main }}>
                            Preferred Qualifications:
                          </Typography>
                          <List dense disablePadding>
                            {job.parsedData.qualifications.preferred.slice(0, 3).map((qual, index) => (
                              <ListItem key={index} sx={{ py: 0.5 }}>
                                <ListItemIcon sx={{ minWidth: 28 }}>
                                  <CheckCircleIcon fontSize="small" color="info" />
                                </ListItemIcon>
                                <ListItemText primary={qual} />
                              </ListItem>
                            ))}
                          </List>
                        </Box>
                      )}
                    </Box>
                  </Grid>
                )}

                {/* Enhanced job metadata */}
                {(job.parsedData.industryContext || job.parsedData.roleCategory || job.parsedData.technicalComplexity) && (
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle1" fontWeight={600} gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center' }}>
                      <InfoIcon sx={{ mr: 1 }} /> Job Context
                    </Typography>
                    <Box sx={{ 
                      p: 2, 
                      bgcolor: 'rgba(0,0,0,0.02)',
                      borderRadius: 2
                    }}>
                      {job.parsedData.industryContext && (
                        <Box sx={{ mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">Industry:</Typography>
                          <Typography variant="body1" fontWeight={500} sx={{ textTransform: 'capitalize' }}>
                            {job.parsedData.industryContext}
                          </Typography>
                        </Box>
                      )}
                      {job.parsedData.roleCategory && (
                        <Box sx={{ mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">Role Category:</Typography>
                          <Typography variant="body1" fontWeight={500} sx={{ textTransform: 'capitalize' }}>
                            {job.parsedData.roleCategory.replace('-', ' ')}
                          </Typography>
                        </Box>
                      )}
                      {job.parsedData.technicalComplexity && (
                        <Box sx={{ mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">Technical Complexity:</Typography>
                          <Chip 
                            label={job.parsedData.technicalComplexity} 
                            size="small" 
                            color={
                              job.parsedData.technicalComplexity === 'high' ? 'error' :
                              job.parsedData.technicalComplexity === 'medium' ? 'warning' : 'success'
                            }
                            sx={{ textTransform: 'capitalize' }}
                          />
                        </Box>
                      )}
                    </Box>
                  </Grid>
                )}
              </Grid>
            </CardContent>
          </Card>
        )}
      </Grid>
    </Grid>
  );
};

export default OverviewTab;

================
File: src/components/jobs/utils/searchUtils.js
================
// src/components/jobs/utils/searchUtils.js
import React from 'react';
import { useTheme } from '@mui/material/styles';
import {
  PlayArrow as PlayIcon,
  Pause as PauseIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Delete as DeleteIcon,
  Psychology as PsychologyIcon,
  Business as BusinessIcon,
  Search as SearchIcon,
  CloudDownload as CloudDownloadIcon,
  Save as SaveIcon,
  Info as InfoIcon,
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

export const getStatusColor = (status) => {
  switch (status) {
    case 'running': return 'success';
    case 'paused': return 'warning';
    case 'completed': return 'info';
    case 'failed': return 'error';
    case 'cancelled': return 'default';
    default: return 'default';
  }
};

export const getStatusIcon = (status) => {
  switch (status) {
    case 'running': return <PlayIcon fontSize="small" />;
    case 'paused': return <PauseIcon fontSize="small" />;
    case 'completed': return <CheckCircleIcon fontSize="small" />;
    case 'failed': return <ErrorIcon fontSize="small" />;
    case 'cancelled': return <DeleteIcon fontSize="small" />;
    default: return null;
  }
};

export const getReasoningIcon = (phase) => {
  switch (phase) {
    case 'initialization': 
      return <AutoJobLogo variant="icon-only" size="small" sx={{ width: 18, height: 18 }} />;
    case 'career_analysis': 
      return <PsychologyIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'company_discovery': 
      return <BusinessIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'job_search': 
      return <SearchIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'content_extraction': 
      return <CloudDownloadIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'job_saving': 
      return <SaveIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'completion': 
      return <CheckCircleIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'error': 
      return <ErrorIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    default: 
      return <InfoIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
  }
};

export const getReasoningColor = (phase, success, theme) => {
  // Success/failure states take priority
  if (success === false) return theme.palette.error.main;
  if (success === true && phase === 'completion') return theme.palette.success.main;
  
  // Phase-specific colors using your theme
  switch (phase) {
    case 'initialization': 
      return theme.palette.primary.main; // #1a73e8
    case 'career_analysis': 
      return theme.palette.secondary.main; // #00c4b4
    case 'company_discovery': 
      return theme.palette.info.main; // #4285f4
    case 'job_search': 
      return theme.palette.warning.main; // #fbbc04
    case 'content_extraction': 
      return theme.palette.success.main; // #34a853
    case 'job_saving': 
      return theme.palette.primary.dark; // #0d47a1
    case 'completion': 
      return theme.palette.success.main; // #34a853
    case 'error': 
      return theme.palette.error.main; // #ea4335
    default: 
      return theme.palette.text.secondary; // #5f6368
  }
};

export const formatDate = (date) => {
  return new Date(date).toLocaleString('en-US', {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });
};

export const formatDuration = (duration) => {
  if (!duration) return 'N/A';
  if (duration < 1000) return `${duration}ms`;
  if (duration < 60000) return `${Math.round(duration / 1000)}s`;
  return `${Math.round(duration / 60000)}m`;
};

export const getProgressPercentage = (search) => {
  if (search.dailyLimit === 0) return 0;
  return Math.round((search.jobsFoundToday / search.dailyLimit) * 100);
};

================
File: src/components/layout/Header.js
================
// src/components/layout/Header.js - UPDATED WITHOUT NOTIFICATIONS
import React, { useState } from 'react';
import {
  AppBar,
  Toolbar,
  IconButton,
  Typography,
  Menu,
  MenuItem,
  Box,
  Tooltip,
  useTheme,
  alpha,
  ListItemIcon,
  ListItemText,
} from '@mui/material';
import {
  Menu as MenuIcon,
  HelpOutline as HelpOutlineIcon,
  Quiz as QuizIcon,
  Support as SupportIcon,
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import { useNavigate } from 'react-router-dom';
import AutoJobLogo from '../common/AutoJobLogo';
import GlobalSearch from '../common/GlobalSearch';

const Header = ({ onToggleSidebar }) => {
  const theme = useTheme();
  const { logout, currentUser } = useAuth();
  const navigate = useNavigate();
  const [helpAnchorEl, setHelpAnchorEl] = useState(null);
  
  const isHelpMenuOpen = Boolean(helpAnchorEl);

  const handleHelpMenuOpen = (event) => {
    setHelpAnchorEl(event.currentTarget);
  };

  const handleMenuClose = (setState) => () => {
    setState(null);
  };

  return (
    <AppBar 
      position="static"
      color="default"
      elevation={1}
      sx={{ 
        backgroundColor: 'background.paper',
        borderBottom: '1px solid',
        borderColor: 'divider',
        width: '100%',
        boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.08)',
      }}
    >
      <Toolbar sx={{ px: { xs: 2, sm: 3 }, minHeight: '64px !important' }}>
        {/* Mobile Menu Button */}
        <IconButton
          edge="start"
          color="inherit"
          aria-label="open drawer"
          onClick={onToggleSidebar}
          sx={{ 
            mr: 2, 
            display: { sm: 'block', md: 'none' },
            color: 'text.primary'
          }}
        >
          <MenuIcon />
        </IconButton>

        {/* Global Search Component */}
        <GlobalSearch 
          sx={{
            marginRight: 2,
            marginLeft: 0,
            width: '100%',
            maxWidth: { xs: '100%', sm: 400, md: 500 },
          }}
        />

        <Box sx={{ flexGrow: 1 }} />

        {/* Action Buttons */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
          {/* Help */}
          <Tooltip title="Help & Support" arrow>
            <IconButton
              color="inherit"
              onClick={handleHelpMenuOpen}
              sx={{ 
                color: 'text.secondary',
                '&:hover': {
                  color: 'primary.main',
                  backgroundColor: alpha(theme.palette.primary.main, 0.04)
                }
              }}
            >
              <HelpOutlineIcon />
            </IconButton>
          </Tooltip>
        </Box>
      </Toolbar>

      {/* Help Menu */}
      <Menu
        anchorEl={helpAnchorEl}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        open={isHelpMenuOpen}
        onClose={handleMenuClose(setHelpAnchorEl)}
        PaperProps={{
          sx: {
            mt: 1,
            minWidth: 240,
            boxShadow: '0 4px 20px rgba(0,0,0,0.1)',
          }
        }}
      >
        <MenuItem onClick={handleMenuClose(setHelpAnchorEl)} sx={{ py: 1.5 }}>
          <ListItemIcon>
            <QuizIcon color="primary" />
          </ListItemIcon>
          <ListItemText
            primary="Getting Started Guide"
            secondary="Learn how to use auto-job.ai"
            primaryTypographyProps={{ variant: 'body2', fontWeight: 500 }}
            secondaryTypographyProps={{ variant: 'caption' }}
          />
        </MenuItem>
        <MenuItem onClick={handleMenuClose(setHelpAnchorEl)} sx={{ py: 1.5 }}>
          <ListItemIcon>
            <HelpOutlineIcon color="primary" />
          </ListItemIcon>
          <ListItemText
            primary="FAQ"
            secondary="Find answers to common questions"
            primaryTypographyProps={{ variant: 'body2', fontWeight: 500 }}
            secondaryTypographyProps={{ variant: 'caption' }}
          />
        </MenuItem>
        <MenuItem onClick={handleMenuClose(setHelpAnchorEl)} sx={{ py: 1.5 }}>
          <ListItemIcon>
            <SupportIcon color="primary" />
          </ListItemIcon>
          <ListItemText
            primary="Contact Support"
            secondary="Get help from our team"
            primaryTypographyProps={{ variant: 'body2', fontWeight: 500 }}
            secondaryTypographyProps={{ variant: 'caption' }}
          />
        </MenuItem>
      </Menu>
    </AppBar>
  );
};

export default Header;

================
File: src/components/layout/MainLayout.js
================
// src/components/layout/MainLayout.js
import React, { useState } from 'react';
import { Box, useMediaQuery, useTheme } from '@mui/material';
import Sidebar from './Sidebar';
import Header from './Header';

const MainLayout = ({ children }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [sidebarOpen, setSidebarOpen] = useState(!isMobile);

  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen);
  };

  return (
    <Box sx={{ 
      display: 'flex', 
      height: '100vh', // Fixed viewport height
      overflow: 'hidden' // Prevent any overflow on the main container
    }}>
      <Sidebar open={sidebarOpen} onClose={() => setSidebarOpen(false)} />
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          display: 'flex',
          flexDirection: 'column',
          height: '100vh', // Full viewport height
          overflow: 'hidden', // Prevent overflow on main wrapper
        }}
      >
        {/* Sticky Header */}
        <Box sx={{ 
          position: 'sticky',
          top: 0,
          zIndex: (theme) => theme.zIndex.appBar,
          flexShrink: 0 // Prevent header from shrinking
        }}>
          <Header onToggleSidebar={toggleSidebar} />
        </Box>
        
        {/* Scrollable Content Area */}
        <Box
          sx={{
            flexGrow: 1,
            overflow: 'auto', // Enable scrolling for content
            backgroundColor: 'background.default',
            p: 3,
            // Ensure proper scrollbar styling
            '&::-webkit-scrollbar': {
              width: '6px',
            },
            '&::-webkit-scrollbar-track': {
              backgroundColor: 'rgba(0, 0, 0, 0.04)',
              borderRadius: '3px',
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0, 0, 0, 0.2)',
              borderRadius: '3px',
              '&:hover': {
                backgroundColor: 'rgba(0, 0, 0, 0.3)',
              },
            },
          }}
        >
          {children}
        </Box>
      </Box>
    </Box>
  );
};

export default MainLayout;

================
File: src/components/layout/Sidebar.js
================
// src/components/layout/Sidebar.js
import React, { useContext } from 'react';
import { 
  Box, 
  Drawer, 
  List, 
  ListItem, 
  ListItemButton, 
  ListItemIcon, 
  ListItemText,
  Divider,
  Typography,
  useTheme,
  useMediaQuery,
  Avatar,
  Collapse,
} from '@mui/material';
import { Link, useLocation } from 'react-router-dom';
import {
  Dashboard as DashboardIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  People as PeopleIcon,
  Assignment as AssignmentIcon,
  Settings as SettingsIcon,
  Logout as LogoutIcon,
  SmartToy as SmartToyIcon,
  ExpandLess,
  ExpandMore,
  UploadFile as UploadFileIcon,
  FormatListBulleted as FormatListBulletedIcon,
  Add as AddIcon,
  ContentPasteSearch as ContentPasteSearchIcon,
  ManageSearch as ManageSearchIcon,
  Search as SearchIcon,
  Message as MessageIcon,
  Person as PersonIcon
} from '@mui/icons-material';
import { AuthContext } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const drawerWidth = 260;

const navItems = [
  { 
    title: 'Dashboard',
    path: '/dashboard',
    icon: <DashboardIcon />,
    color: '#1a73e8' // Primary blue
  },
  { 
    title: 'My Resumes',
    path: '/resumes',
    icon: <DescriptionIcon />,
    color: '#34a853', // Success green
  },
  { 
    title: 'Jobs Portal',
    path: '/jobs',
    icon: <WorkIcon />,
    color: '#4285f4', // Info blue
    subItems: [
      {
        title: 'All Jobs',
        path: '/jobs',
        icon: <FormatListBulletedIcon fontSize="small" />,
        color: '#4285f4'
      },
      {
        title: 'Agent Job Discovery',
        path: '/jobs/ai-searches',
        icon: <SmartToyIcon fontSize="small" />,
        color: '#4285f4'
      }
    ]
  },

  { 
    title: 'Recruiter Outreach',
    path: '/recruiters',
    icon: <PeopleIcon />,
    color: '#00c4b4', // Secondary teal

  },

];

const Sidebar = ({ open, onClose }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const location = useLocation();
  const { currentUser, logout } = useContext(AuthContext);
  const [openSubMenu, setOpenSubMenu] = React.useState('');

  // Auto-expand the submenu for the current path
  React.useEffect(() => {
    navItems.forEach(item => {
      if (item.subItems && (
        location.pathname === item.path || 
        item.subItems.some(subItem => location.pathname.startsWith(subItem.path)) ||
        // Special handling for recruiter routes
        (item.path === '/recruiters' && location.pathname.startsWith('/recruiters'))
      )) {
        setOpenSubMenu(item.title);
      }
    });
  }, [location.pathname]);

  const handleSubMenuClick = (title) => {
    setOpenSubMenu(openSubMenu === title ? '' : title);
  };

  const isPathActive = (path) => {
    // Special handling for exact path matching on main routes
    if (path === '/recruiters' && location.pathname === '/recruiters') {
      return true;
    }
    // For sub-items, check exact path
    if (path.includes('/recruiters/')) {
      return location.pathname === path;
    }
    // Default behavior for other routes
    return location.pathname === path || location.pathname.startsWith(`${path}/`);
  };

  const isSubItemActive = (subItemPath) => {
    return location.pathname === subItemPath;
  };

  const drawerContent = (
    <Box sx={{ 
      height: '100%', 
      display: 'flex', 
      flexDirection: 'column',
      overflow: 'hidden' // Prevent overflow on sidebar container
    }}>
      {/* Logo Section */}
      <Box sx={{ 
        px: 2.5, 
        py: 2, 
        display: 'flex', 
        alignItems: 'center',
        cursor: 'pointer',
        flexShrink: 0 // Prevent logo from shrinking
      }}>
        <AutoJobLogo 
          variant="horizontal"
          size="small"
          color="primary"
          showTagline={false}
        />
      </Box>
      
      <Box sx={{ px: 2, pt: 2, pb: 1, flexShrink: 0 }}>
        <Typography variant="overline" color="text.secondary" sx={{ fontWeight: 600 }}>
          Main Menu
        </Typography>
      </Box>
      
      {/* Scrollable Navigation Area */}
      <Box sx={{ 
        flex: 1, 
        overflow: 'auto',
        // Custom scrollbar for sidebar
        '&::-webkit-scrollbar': {
          width: '4px',
        },
        '&::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        '&::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.15)',
          borderRadius: '2px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.25)',
          },
        },
      }}>
        <List sx={{ px: 1 }}>
          {navItems.map((item) => (
            <React.Fragment key={item.path}>
              <ListItem disablePadding>
                {item.subItems ? (
                  <ListItemButton
                    onClick={() => handleSubMenuClick(item.title)}
                    selected={location.pathname.startsWith(item.path)}
                    sx={{
                      borderRadius: 1.5,
                      mb: 0.5,
                      '&.Mui-selected': {
                        backgroundColor: `${item.color}15`, // Use item color with 15% opacity
                        color: item.color,
                        '&:hover': {
                          backgroundColor: `${item.color}20`, // Slightly darker on hover
                        },
                        '& .MuiListItemIcon-root': {
                          color: item.color,
                        },
                      },
                      '&:hover': {
                        backgroundColor: `${item.color}08`, // Light hover state with item color
                      }
                    }}
                  >
                    <ListItemIcon 
                      sx={{ 
                        minWidth: 40,
                        color: item.color,
                        '& .MuiSvgIcon-root': {
                          fontSize: '1.3rem'
                        }
                      }}
                    >
                      {React.cloneElement(item.icon, { 
                        style: { color: item.color }
                      })}
                    </ListItemIcon>
                    <ListItemText 
                      primary={item.title}
                      primaryTypographyProps={{
                        fontWeight: location.pathname.startsWith(item.path) ? 600 : 500,
                        fontSize: '0.9rem',
                        color: location.pathname.startsWith(item.path) ? item.color : 'text.primary'
                      }}
                    />
                    {openSubMenu === item.title ? 
                      <ExpandLess sx={{ color: 'text.secondary' }} /> : 
                      <ExpandMore sx={{ color: 'text.secondary' }} />
                    }
                  </ListItemButton>
                ) : (
                  <ListItemButton
                    component={Link}
                    to={item.path}
                    selected={isPathActive(item.path)}
                    sx={{
                      borderRadius: 1.5,
                      mb: 0.5,
                      '&.Mui-selected': {
                        backgroundColor: `${item.color}15`, // Use item color with 15% opacity
                        color: item.color,
                        '&:hover': {
                          backgroundColor: `${item.color}20`, // Slightly darker on hover
                        },
                        '& .MuiListItemIcon-root': {
                          color: item.color,
                        },
                      },
                      '&:hover': {
                        backgroundColor: `${item.color}08`, // Light hover state with item color
                      }
                    }}
                  >
                    <ListItemIcon 
                      sx={{ 
                        minWidth: 40,
                        color: item.color,
                        '& .MuiSvgIcon-root': {
                          fontSize: '1.3rem'
                        }
                      }}
                    >
                      {React.cloneElement(item.icon, { 
                        style: { color: item.color }
                      })}
                    </ListItemIcon>
                    <ListItemText 
                      primary={item.title}
                      primaryTypographyProps={{
                        fontWeight: isPathActive(item.path) ? 600 : 500,
                        fontSize: '0.9rem',
                        color: isPathActive(item.path) ? item.color : 'text.primary'
                      }}
                    />
                  </ListItemButton>
                )}
              </ListItem>
              {item.subItems && (
                <Collapse in={openSubMenu === item.title} timeout="auto" unmountOnExit>
                  <List component="div" disablePadding>
                    {item.subItems.map((subItem) => (
                      <ListItemButton
                        key={subItem.path}
                        component={Link}
                        to={subItem.path}
                        selected={isSubItemActive(subItem.path)}
                        sx={{
                          pl: 4,
                          py: 0.75,
                          borderRadius: 1.5,
                          mb: 0.5,
                          '&.Mui-selected': {
                            backgroundColor: `${subItem.color}15`, // Use subItem color with 15% opacity
                            color: subItem.color,
                            '&:hover': {
                              backgroundColor: `${subItem.color}20`, // Slightly darker on hover
                            },
                            '& .MuiListItemIcon-root': {
                              color: subItem.color,
                            },
                          },
                          '&:hover': {
                            backgroundColor: `${subItem.color}08`, // Light hover state with subItem color
                          }
                        }}
                      >
                        <ListItemIcon 
                          sx={{ 
                            minWidth: 32,
                            color: subItem.color,
                            '& .MuiSvgIcon-root': {
                              fontSize: '1.1rem'
                            }
                          }}
                        >
                          {React.cloneElement(subItem.icon, { 
                            style: { color: subItem.color }
                          })}
                        </ListItemIcon>
                        <ListItemText 
                          primary={subItem.title}
                          primaryTypographyProps={{
                            variant: 'body2',
                            fontWeight: isSubItemActive(subItem.path) ? 600 : 500,
                            fontSize: '0.85rem',
                            color: isSubItemActive(subItem.path) ? subItem.color : 'text.primary'
                          }}
                        />
                      </ListItemButton>
                    ))}
                  </List>
                </Collapse>
              )}
            </React.Fragment>
          ))}
        </List>
      </Box>
      
      <Divider sx={{ mt: 2, flexShrink: 0 }} />
      
      {/* User Section - Fixed at bottom */}
      <Box sx={{ p: 2, flexShrink: 0 }}>
        <Box sx={{ 
          display: 'flex', 
          alignItems: 'center', 
          mb: 2,
          p: 1.5,
          borderRadius: 2,
          backgroundColor: 'rgba(26, 115, 232, 0.04)',
          border: '1px solid rgba(26, 115, 232, 0.1)'
        }}>
          <Avatar 
            sx={{ 
              width: 40, 
              height: 40,
              mr: 2,
              bgcolor: 'primary.main',
              fontSize: '1rem',
              fontWeight: 600
            }}
          >
            {currentUser?.firstName?.[0] || 'U'}
          </Avatar>
          <Box sx={{ flex: 1, minWidth: 0 }}>
            <Typography variant="subtitle2" sx={{ fontWeight: 600 }} noWrap>
              {currentUser?.firstName ? `${currentUser.firstName} ${currentUser.lastName}` : 'User'}
            </Typography>
            <Typography variant="caption" color="text.secondary" noWrap>
              {currentUser?.email || 'user@example.com'}
            </Typography>
          </Box>
        </Box>
        
        <List sx={{ p: 0 }}>
          <ListItem disablePadding>
            <ListItemButton
              component={Link}
              to="/settings"
              sx={{
                borderRadius: 1.5,
                py: 1,
                '&:hover': {
                  backgroundColor: 'rgba(0, 0, 0, 0.04)'
                }
              }}
            >
              <ListItemIcon sx={{ minWidth: 36 }}>
                <SettingsIcon 
                  fontSize="small" 
                  sx={{ color: '#666' }}
                />
              </ListItemIcon>
              <ListItemText 
                primary="Settings" 
                primaryTypographyProps={{
                  fontSize: '0.9rem',
                  fontWeight: 500
                }}
              />
            </ListItemButton>
          </ListItem>
          <ListItem disablePadding>
            <ListItemButton
              onClick={logout}
              sx={{
                borderRadius: 1.5,
                py: 1,
                '&:hover': {
                  backgroundColor: 'rgba(234, 67, 53, 0.04)',
                  '& .MuiListItemIcon-root': {
                    color: 'error.main'
                  },
                  '& .MuiListItemText-primary': {
                    color: 'error.main'
                  }
                }
              }}
            >
              <ListItemIcon sx={{ minWidth: 36 }}>
                <LogoutIcon 
                  fontSize="small" 
                  sx={{ color: '#666' }}
                />
              </ListItemIcon>
              <ListItemText 
                primary="Logout" 
                primaryTypographyProps={{
                  fontSize: '0.9rem',
                  fontWeight: 500
                }}
              />
            </ListItemButton>
          </ListItem>
        </List>
      </Box>
    </Box>
  );

  return (
    <Drawer
      variant={isMobile ? 'temporary' : 'permanent'}
      open={open}
      onClose={onClose}
      sx={{
        width: drawerWidth,
        flexShrink: 0,
        '& .MuiDrawer-paper': {
          width: drawerWidth,
          boxSizing: 'border-box',
          borderRight: '1px solid',
          borderColor: 'divider',
          backgroundColor: 'background.paper',
          height: '100vh', // Full viewport height
          overflow: 'hidden' // Prevent overflow on drawer paper
        },
      }}
    >
      {drawerContent}
    </Drawer>
  );
};

export default Sidebar;

================
File: src/components/recruiters/OutreachComposer.js
================
// src/components/recruiters/OutreachComposer.js - ENHANCED WITH IMPROVED UI
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  Typography,
  Box,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  Avatar,
  Divider,
  Alert,
  LinearProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  RadioGroup,
  FormControlLabel,
  Radio,
  Autocomplete,
  Collapse,
  Paper
} from '@mui/material';
import {
  Close as CloseIcon,
  AutoFixHigh as AutoFixHighIcon,
  Send as SendIcon,
  Save as SaveIcon,
  Refresh as RefreshIcon,
  Psychology as PsychologyIcon,
  Business as BusinessIcon,
  Person as PersonIcon,
  Work as WorkIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Description as DescriptionIcon,
  Lightbulb as LightbulbIcon,
  Star as StarIcon,
  TrendingUp as TrendingUpIcon,
  School as SchoolIcon,
  Assignment as AssignmentIcon,
  Preview as PreviewIcon,
  CheckCircle as CheckCircleIcon,
  Drafts as DraftsIcon,
  Cancel as CancelIcon,
  Edit as EditIcon,
  ContentCopy as ContentCopyIcon,
  Warning as WarningIcon,
  Info as InfoIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import { useAuth } from '../../context/AuthContext';
import recruiterService from '../../utils/recruiterService';
import resumeService from '../../utils/resumeService';
import jobService from '../../utils/jobService';
import AutoJobLogo from '../common/AutoJobLogo';

const OutreachComposer = ({ 
  open, 
  onClose, 
  recruiter, 
  onSend, 
  onSave,
  defaultMessage = '',
  mode = 'create' // 'create' or 'edit'
}) => {
  const theme = useTheme();
  const { currentUser } = useAuth();
  
  // Form state
  const [messageContent, setMessageContent] = useState(defaultMessage);
  const [messageType, setMessageType] = useState('introduction');
  const [tone, setTone] = useState('professional');
  const [sentVia, setSentVia] = useState('email'); // Default to email
  const [selectedResume, setSelectedResume] = useState(null);
  const [selectedJob, setSelectedJob] = useState(null);
  const [customRequirements, setCustomRequirements] = useState('');
  
  // UI state
  const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [characterCount, setCharacterCount] = useState(0);
  const [error, setError] = useState('');
  const [generationHistory, setGenerationHistory] = useState([]);
  
  // Email-specific state
  const [showEmailPreview, setShowEmailPreview] = useState(false);
  const [showStatusDialog, setShowStatusDialog] = useState(false);
  const [emailSubject, setEmailSubject] = useState('');
  const [formattedEmailBody, setFormattedEmailBody] = useState('');
  const [manualStatus, setManualStatus] = useState('sent');
  const [showClipboardFallback, setShowClipboardFallback] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);
  
  // Data state
  const [resumes, setResumes] = useState([]);
  const [jobs, setJobs] = useState([]);
  const [loadingData, setLoadingData] = useState(true);

  // Load user data on mount
  useEffect(() => {
    if (open) {
      loadUserData();
      setMessageContent(defaultMessage);
      setCharacterCount(defaultMessage.length);
    }
  }, [open, defaultMessage]);

  // Update character count when message changes
  useEffect(() => {
    setCharacterCount(messageContent.length);
  }, [messageContent]);

  const loadUserData = async () => {
    try {
      setLoadingData(true);
      const [resumesResponse, jobsResponse] = await Promise.all([
        resumeService.getUserResumes(),
        jobService.getUserJobs()
      ]);
      
      setResumes(resumesResponse || []);
      setJobs(jobsResponse || []);
    } catch (error) {
      console.error('Failed to load user data:', error);
      setError('Failed to load your resumes and jobs');
    } finally {
      setLoadingData(false);
    }
  };

  // Email utility functions
  const generateSubjectLine = (recruiter, messageType, jobTitle = null) => {
    const companyName = recruiter?.company?.name || 'your company';
    
    const templates = {
      introduction: `Exploring opportunities at ${companyName}`,
      application: `Application for ${jobTitle || 'Software Developer'} position`,
      follow_up: `Following up - ${companyName} opportunities`,
      thank_you: `Thank you for your time - ${recruiter?.firstName || 'Recruiter'}`
    };
    
    return templates[messageType] || `Professional inquiry - ${companyName}`;
  };

  const formatEmailMessage = (content, recruiterData, userData) => {
    const recruiterFirstName = recruiterData?.firstName || 'there';
    
    // Remove any subject lines from the AI content
    let cleanedContent = content.replace(/^Subject:.*$/gim, '').trim();
    
    // Check if the content already has a greeting
    const hasGreeting = cleanedContent.toLowerCase().includes('dear ') || 
                       cleanedContent.toLowerCase().includes('hello ') ||
                       cleanedContent.toLowerCase().includes('hi ');
    
    // Check if the content already has a signature/closing
    const hasSignature = cleanedContent.toLowerCase().includes('best regards') || 
                        cleanedContent.toLowerCase().includes('warm regards') ||
                        cleanedContent.toLowerCase().includes('sincerely') ||
                        cleanedContent.toLowerCase().includes('regards,');
    
    let formattedContent = cleanedContent;
    
    // Add greeting only if none exists
    if (!hasGreeting) {
      formattedContent = `Dear ${recruiterFirstName},

${cleanedContent}`;
    }
    
    // Add signature only if none exists
    if (!hasSignature && !hasGreeting) {
      const userFirstName = userData?.firstName || 'Best regards';
      formattedContent = `${formattedContent}

Best regards,
${userFirstName}`;
    }
    
    return formattedContent;
  };

  const handleGenerateMessage = async () => {
    if (!recruiter) return;
    
    try {
      setIsGenerating(true);
      setError('');
      
      const messageParams = {
        recruiterId: recruiter.id,
        resumeId: selectedResume?._id,
        jobId: selectedJob?._id,
        messageType,
        tone,
        customRequirements
      };

      console.log('🤖 Generating message with params:', messageParams);
      
      const response = await recruiterService.generatePersonalizedMessage(messageParams);
      
      // Save to generation history
      setGenerationHistory(prev => [{
        message: response.message,
        params: messageParams,
        timestamp: new Date()
      }, ...prev.slice(0, 4)]); // Keep last 5 generations
      
      setMessageContent(response.message);
      
    } catch (error) {
      console.error('Message generation failed:', error);
      setError('Failed to generate message. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSendViaEmail = () => {
    try {
      // Generate subject line
      const subject = generateSubjectLine(recruiter, messageType, selectedJob?.title);
      
      // Format message with signature
      const formattedMessage = formatEmailMessage(messageContent, recruiter, currentUser);
      
      setEmailSubject(subject);
      setFormattedEmailBody(formattedMessage);
      setShowEmailPreview(true);
      
    } catch (error) {
      console.error('Email preparation failed:', error);
      setError('Failed to prepare email. Please try again.');
    }
  };

  const copyToClipboard = async () => {
    try {
      const fullEmailContent = `To: ${recruiter.email}
Subject: ${emailSubject}

${formattedEmailBody}`;
      
      await navigator.clipboard.writeText(fullEmailContent);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 3000);
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      // Fallback for older browsers
      const fullEmailContent = `To: ${recruiter.email}
Subject: ${emailSubject}

${formattedEmailBody}`;
      
      const textArea = document.createElement('textarea');
      textArea.value = fullEmailContent;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 3000);
    }
  };

  const handleStatusUpdate = async () => {
    try {
      const outreachData = {
        recruiterId: recruiter.id,
        messageContent,
        messageTemplate: messageType,
        sentVia: 'email',
        jobId: selectedJob?._id,
        customizations: [],
        status: manualStatus === 'sent' ? 'sent' : 'drafted'
      };

      if (manualStatus === 'sent') {
        await onSend(outreachData);
      } else {
        await onSave(outreachData);
      }
      
      setShowStatusDialog(false);
      handleClose();
      
    } catch (error) {
      console.error('Status update failed:', error);
      setError('Failed to update status. Please try again.');
    }
  };

  const handleSend = async () => {
    if (sentVia === 'email') {
      handleSendViaEmail();
      return;
    }

    // Original send logic for other methods
    try {
      setIsSending(true);
      setError('');
      
      const outreachData = {
        recruiterId: recruiter.id,
        messageContent,
        messageTemplate: messageType,
        sentVia,
        jobId: selectedJob?._id,
        customizations: []
      };

      // Validate the outreach data
      const validation = recruiterService.validateOutreachData(outreachData);
      if (!validation.isValid) {
        setError(validation.errors.join(', '));
        return;
      }

      await onSend(outreachData);
      handleClose();
      
    } catch (error) {
      console.error('Send failed:', error);
      setError('Failed to send message. Please try again.');
    } finally {
      setIsSending(false);
    }
  };

  const handleSave = async () => {
    try {
      const outreachData = {
        recruiterId: recruiter.id,
        messageContent,
        messageTemplate: messageType,
        sentVia,
        jobId: selectedJob?._id,
        customizations: []
      };

      await onSave(outreachData);
      handleClose();
      
    } catch (error) {
      console.error('Save failed:', error);
      setError('Failed to save draft. Please try again.');
    }
  };

  const handleClose = () => {
    setMessageContent('');
    setError('');
    setGenerationHistory([]);
    setShowAdvancedOptions(false);
    setShowEmailPreview(false);
    setShowStatusDialog(false);
    setEmailSubject('');
    setFormattedEmailBody('');
    setManualStatus('sent');
    setShowClipboardFallback(false);
    setCopySuccess(false);
    onClose();
  };

  const messageTemplates = recruiterService.getMessageTemplates();
  const toneOptions = recruiterService.getToneOptions();

  const getCharacterCountColor = () => {
    if (characterCount > 2000) return 'error';
    if (characterCount > 1500) return 'warning';
    return 'primary';
  };

  const getSentViaIcon = (method) => {
    switch (method) {
      case 'email': return <EmailIcon />;
      case 'phone': return <PhoneIcon />;
      default: return <BusinessIcon />;
    }
  };

  const getTemplateIcon = (template) => {
    switch (template) {
      case 'introduction': return <PersonIcon sx={{ color: theme.palette.primary.main }} />;
      case 'follow_up': return <TrendingUpIcon sx={{ color: theme.palette.secondary.main }} />;
      case 'application': return <AssignmentIcon sx={{ color: theme.palette.success.main }} />;
      case 'thank_you': return <StarIcon sx={{ color: theme.palette.warning.main }} />;
      default: return <DescriptionIcon sx={{ color: theme.palette.info.main }} />;
    }
  };

  const getToneIcon = (toneValue) => {
    switch (toneValue) {
      case 'professional': return <BusinessIcon sx={{ color: theme.palette.primary.main }} />;
      case 'friendly': return <PersonIcon sx={{ color: theme.palette.success.main }} />;
      case 'casual': return <LightbulbIcon sx={{ color: theme.palette.warning.main }} />;
      case 'formal': return <SchoolIcon sx={{ color: theme.palette.info.main }} />;
      default: return <DescriptionIcon />;
    }
  };

  if (!recruiter) return null;

  return (
    <>
      <Dialog
        open={open && !showStatusDialog}
        onClose={handleClose}
        maxWidth="lg"
        fullWidth
        PaperProps={{
          sx: { borderRadius: 3, minHeight: '700px' }
        }}
      >
        {/* Enhanced Header */}
        <DialogTitle sx={{ 
          p: 0,
          background: `linear-gradient(135deg, ${theme.palette.primary.main}15, ${theme.palette.secondary.main}15)`,
          borderBottom: `1px solid ${theme.palette.divider}`
        }}>
          <Box sx={{ p: 3 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                <Avatar
                  sx={{
                    bgcolor: theme.palette.primary.main,
                    width: 48,
                    height: 48,
                    fontSize: '1.2rem',
                    fontWeight: 'bold'
                  }}
                >
                  {recruiter.firstName?.[0]}{recruiter.lastName?.[0]}
                </Avatar>
                <Box>
                  <Typography variant="h5" sx={{ fontWeight: 600, color: theme.palette.primary.main }}>
                    Compose Message
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    To {recruiter.firstName} {recruiter.lastName} at {recruiter.company?.name}
                  </Typography>
                </Box>
              </Box>
              <IconButton 
                onClick={handleClose}
                sx={{ 
                  bgcolor: 'background.paper',
                  '&:hover': { bgcolor: 'grey.100' }
                }}
              >
                <CloseIcon />
              </IconButton>
            </Box>

            {/* Status Chips */}
            <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
              <Chip
                icon={<WorkIcon />}
                label={recruiter.title}
                size="small"
                variant="outlined"
                color="primary"
                sx={{ borderRadius: 1 }}
              />
              <Chip
                icon={<BusinessIcon />}
                label={recruiter.company?.name}
                size="small"
                variant="outlined"
                color="secondary"
                sx={{ borderRadius: 1 }}
              />
              {recruiter.industry && (
                <Chip
                  label={recruiter.industry}
                  size="small"
                  variant="filled"
                  color="info"
                  sx={{ borderRadius: 1 }}
                />
              )}
            </Box>
          </Box>
        </DialogTitle>

        <DialogContent sx={{ p: 0 }}>
          {loadingData && (
            <Box sx={{ p: 2 }}>
              <LinearProgress sx={{ borderRadius: 1 }} />
              <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                Loading your resumes and jobs...
              </Typography>
            </Box>
          )}

          {error && (
            <Box sx={{ p: 3 }}>
              <Alert severity="error" sx={{ borderRadius: 2 }} onClose={() => setError('')}>
                {error}
              </Alert>
            </Box>
          )}

          <Box sx={{ p: 3 }}>
            <Grid container spacing={3}>
              {/* Left Column - AI Generation */}
              <Grid item xs={12} lg={8}>
                {/* Enhanced AI Generation Controls */}
                <Card 
                  elevation={0} 
                  sx={{ 
                    mb: 3, 
                    border: `1px solid ${theme.palette.primary.light}`,
                    borderRadius: 2,
                    background: `linear-gradient(135deg, ${theme.palette.primary.main}08, ${theme.palette.secondary.main}05)`
                  }}
                >
                  <CardContent sx={{ p: 3 }}>
                    <Typography 
                      variant="h6" 
                      gutterBottom 
                      sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1, 
                        color: theme.palette.primary.main,
                        fontWeight: 600,
                        mb: 3
                      }}
                    >
                      <PsychologyIcon />
                      AI Message Generator
                    </Typography>

                    <Grid container spacing={3}>
                      {/* IMPROVED: Adjusted grid sizes for better width distribution */}
                      <Grid item xs={12} md={7}>
                        <FormControl fullWidth>
                          <InputLabel sx={{ color: theme.palette.primary.main }}>Message Type</InputLabel>
                          <Select
                            value={messageType}
                            label="Message Type"
                            onChange={(e) => setMessageType(e.target.value)}
                            sx={{ borderRadius: 2 }}
                          >
                            {Object.entries(messageTemplates).map(([key, template]) => (
                              <MenuItem key={key} value={key} sx={{ py: 1.5 }}>
                                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                  {getTemplateIcon(key)}
                                  <Box>
                                    <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                      {template.name}
                                    </Typography>
                                    <Typography variant="caption" color="text.secondary">
                                      {template.description}
                                    </Typography>
                                  </Box>
                                </Box>
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>

                      {/* IMPROVED: Adjusted grid size for better width distribution */}
                      <Grid item xs={12} md={5}>
                        <FormControl fullWidth>
                          <InputLabel sx={{ color: theme.palette.secondary.main }}>Tone</InputLabel>
                          <Select
                            value={tone}
                            label="Tone"
                            onChange={(e) => setTone(e.target.value)}
                            sx={{ borderRadius: 2 }}
                          >
                            {toneOptions.map((option) => (
                              <MenuItem key={option.value} value={option.value} sx={{ py: 1.5 }}>
                                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                  {getToneIcon(option.value)}
                                  <Box>
                                    <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                      {option.label}
                                    </Typography>
                                    <Typography variant="caption" color="text.secondary">
                                      {option.description}
                                    </Typography>
                                  </Box>
                                </Box>
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>

                      <Grid item xs={12}>
                        <Button
                          variant="contained"
                          startIcon={isGenerating ? <LinearProgress sx={{ width: 20 }} /> : 
                            <AutoJobLogo 
                              variant="icon-only" 
                              size="small" 
                              sx={{ width: 24, height: 24 }} 
                            />
                          }
                          onClick={handleGenerateMessage}
                          disabled={isGenerating}
                          fullWidth
                          size="large"
                          sx={{ 
                            borderRadius: 2,
                            py: 1.5,
                            background: `linear-gradient(45deg, ${theme.palette.secondary.main}, ${theme.palette.secondary.light})`,
                            '&:hover': {
                              background: `linear-gradient(45deg, ${theme.palette.secondary.dark}, ${theme.palette.secondary.main})`
                            },
                            '&:disabled': {
                              background: theme.palette.grey[300]
                            }
                          }}
                        >
                          {isGenerating ? 'Generating Magic...' : '✨ Generate AI Message'}
                        </Button>
                      </Grid>
                    </Grid>

                    {/* Advanced Options */}
                    <Box sx={{ mt: 3 }}>
                      <Button
                        variant="text"
                        onClick={() => setShowAdvancedOptions(!showAdvancedOptions)}
                        endIcon={showAdvancedOptions ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                        sx={{ color: theme.palette.primary.main }}
                      >
                        Advanced Options
                      </Button>
                      
                      <Collapse in={showAdvancedOptions}>
                        <Box sx={{ mt: 2 }}>
                          <Grid container spacing={2}>
                            <Grid item xs={12} sm={6}>
                              <Autocomplete
                                options={resumes}
                                getOptionLabel={(option) => option?.name || ''}
                                value={selectedResume}
                                onChange={(e, value) => setSelectedResume(value)}
                                isOptionEqualToValue={(option, value) => option?._id === value?._id}
                                renderInput={(params) => (
                                  <TextField
                                    {...params}
                                    label="Use Resume"
                                    placeholder="Select resume for context..."
                                    size="small"
                                    InputProps={{
                                      ...params.InputProps,
                                      startAdornment: <DescriptionIcon sx={{ mr: 1, color: theme.palette.success.main }} />
                                    }}
                                  />
                                )}
                              />
                            </Grid>

                            <Grid item xs={12} sm={6}>
                              <Autocomplete
                                options={jobs}
                                getOptionLabel={(option) => option ? `${option.title} at ${option.company}` : ''}
                                value={selectedJob}
                                onChange={(e, value) => setSelectedJob(value)}
                                isOptionEqualToValue={(option, value) => option?._id === value?._id}
                                renderInput={(params) => (
                                  <TextField
                                    {...params}
                                    label="Target Job"
                                    placeholder="Select job if applying..."
                                    size="small"
                                    InputProps={{
                                      ...params.InputProps,
                                      startAdornment: <WorkIcon sx={{ mr: 1, color: theme.palette.warning.main }} />
                                    }}
                                  />
                                )}
                              />
                            </Grid>

                            <Grid item xs={12}>
                              <TextField
                                fullWidth
                                multiline
                                rows={2}
                                label="Custom Requirements"
                                placeholder="Any specific points you want to mention..."
                                value={customRequirements}
                                onChange={(e) => setCustomRequirements(e.target.value)}
                                size="small"
                                InputProps={{
                                  startAdornment: <LightbulbIcon sx={{ mr: 1, color: theme.palette.info.main, alignSelf: 'flex-start', mt: 1 }} />
                                }}
                              />
                            </Grid>
                          </Grid>
                        </Box>
                      </Collapse>
                    </Box>
                  </CardContent>
                </Card>

                {/* Enhanced Message Content */}
                <Paper elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                    <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <DescriptionIcon sx={{ color: theme.palette.primary.main }} />
                      Message Content
                    </Typography>
                  </Box>
                  <Box sx={{ p: 3 }}>
                    <TextField
                      fullWidth
                      multiline
                      rows={12}
                      placeholder="Write your message here or use the AI generator above..."
                      value={messageContent}
                      onChange={(e) => setMessageContent(e.target.value)}
                      error={characterCount > 2000}
                      helperText={
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <span>
                            {characterCount > 2000 && 'Message too long. '}
                            {messageTemplates[messageType]?.suggestedLength && 
                              `Suggested: ${messageTemplates[messageType].suggestedLength}`}
                          </span>
                          <span style={{ color: theme.palette[getCharacterCountColor()].main, fontWeight: 600 }}>
                            {characterCount}/2000
                          </span>
                        </Box>
                      }
                      sx={{
                        '& .MuiOutlinedInput-root': {
                          borderRadius: 2,
                          fontSize: '0.95rem',
                          lineHeight: 1.6
                        }
                      }}
                    />
                  </Box>
                </Paper>

                {/* Generation History */}
                {generationHistory.length > 0 && (
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="subtitle2" gutterBottom sx={{ color: theme.palette.primary.main }}>
                      Recent Generations
                    </Typography>
                    <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                      {generationHistory.map((generation, index) => (
                        <Chip
                          key={index}
                          label={`${generation.params.messageType} (${generation.params.tone})`}
                          size="small"
                          variant="outlined"
                          onClick={() => setMessageContent(generation.message)}
                          sx={{ 
                            cursor: 'pointer',
                            borderRadius: 1,
                            '&:hover': {
                              backgroundColor: theme.palette.primary.main + '10'
                            }
                          }}
                        />
                      ))}
                    </Box>
                  </Box>
                )}
              </Grid>

              {/* Right Column - Settings and Preview */}
              <Grid item xs={12} lg={4}>
                {/* Enhanced Communication Method */}
                <Card elevation={0} sx={{ mb: 3, border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                    <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <SendIcon sx={{ color: theme.palette.success.main }} />
                      Send Via
                    </Typography>
                  </Box>
                  <CardContent>
                    <RadioGroup
                      value={sentVia}
                      onChange={(e) => setSentVia(e.target.value)}
                    >
                      <FormControlLabel
                        value="email"
                        control={<Radio />}
                        label={
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                            <EmailIcon sx={{ color: theme.palette.primary.main }} />
                            <Box>
                              <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                Email (Recommended)
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                Shows email preview with copy functionality
                              </Typography>
                            </Box>
                          </Box>
                        }
                        disabled={!recruiter.email}
                      />
                      <FormControlLabel
                        value="phone"
                        control={<Radio />}
                        label={
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                            <PhoneIcon sx={{ color: theme.palette.success.main }} />
                            <Box>
                              <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                Phone Call
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                Script for phone conversation
                              </Typography>
                            </Box>
                          </Box>
                        }
                        disabled={!recruiter.phone}
                      />
                    </RadioGroup>
                  </CardContent>
                </Card>

                {/* Enhanced Recruiter Info */}
                <Card elevation={0} sx={{ mb: 3, border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                    <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <PersonIcon sx={{ color: theme.palette.secondary.main }} />
                      Recruiter Details
                    </Typography>
                  </Box>
                  <CardContent>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          TITLE
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>
                          {recruiter.title}
                        </Typography>
                      </Box>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          COMPANY
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>
                          {recruiter.company?.name}
                        </Typography>
                      </Box>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          EMAIL
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>
                          {recruiter.email || 'Not available'}
                        </Typography>
                      </Box>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          INDUSTRY
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>
                          {recruiter.industry}
                        </Typography>
                      </Box>
                      {recruiter.experienceYears && (
                        <Box>
                          <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                            EXPERIENCE
                          </Typography>
                          <Typography variant="body2" sx={{ fontWeight: 500 }}>
                            {recruiter.experienceYears} years
                          </Typography>
                        </Box>
                      )}
                      {recruiter.specializations && (
                        <Box>
                          <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600, mb: 1, display: 'block' }}>
                            SPECIALIZATIONS
                          </Typography>
                          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                            {recruiter.specializations.slice(0, 3).map((spec, index) => (
                              <Chip 
                                key={index} 
                                label={spec} 
                                size="small" 
                                variant="outlined"
                                sx={{ borderRadius: 1, fontSize: '0.75rem' }}
                              />
                            ))}
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </CardContent>
                </Card>

                {/* Enhanced Template Guide */}
                {messageTemplates[messageType] && (
                  <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                    <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                      <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <LightbulbIcon sx={{ color: theme.palette.warning.main }} />
                        Template Guide
                      </Typography>
                    </Box>
                    <CardContent>
                      <Typography variant="body2" color="text.secondary" paragraph>
                        {messageTemplates[messageType].description}
                      </Typography>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          SUGGESTED LENGTH:
                        </Typography>
                        <Chip 
                          label={messageTemplates[messageType].suggestedLength} 
                          size="small" 
                          color="info"
                          variant="outlined"
                          sx={{ borderRadius: 1 }}
                        />
                      </Box>
                    </CardContent>
                  </Card>
                )}
              </Grid>
            </Grid>
          </Box>
        </DialogContent>

        {/* Enhanced Footer Actions */}
        <DialogActions sx={{ 
          p: 3, 
          borderTop: `1px solid ${theme.palette.divider}`,
          background: `linear-gradient(135deg, ${theme.palette.grey[50]}, ${theme.palette.grey[25]})`
        }}>
          <Button 
            onClick={handleClose} 
            variant="outlined"
            sx={{ borderRadius: 2 }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleSave}
            variant="outlined"
            startIcon={<SaveIcon />}
            disabled={!messageContent.trim()}
            sx={{ borderRadius: 2 }}
          >
            Save Draft
          </Button>
          {/* IMPROVED: Fixed Prepare Email button with proper text color */}
          <Button
            onClick={handleSend}
            variant="contained"
            startIcon={isSending ? <LinearProgress sx={{ width: 20 }} /> : getSentViaIcon(sentVia)}
            disabled={!messageContent.trim() || isSending || characterCount > 2000}
            sx={{ 
              borderRadius: 2,
              background: `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`,
              color: '#ffffff !important', // Ensure white text
              fontWeight: 600,
              '&:hover': {
                background: `linear-gradient(45deg, ${theme.palette.success.dark}, ${theme.palette.success.main})`
              },
              '&:disabled': {
                background: theme.palette.grey[300],
                color: theme.palette.grey[500] + ' !important'
              }
            }}
          >
            {isSending ? 'Processing...' : 
             sentVia === 'email' ? 'Prepare Email' : `Send via ${sentVia}`}
          </Button>
        </DialogActions>
      </Dialog>

      {/* IMPROVED: Enhanced Email Preview Dialog with Better Theme Integration */}
      <Dialog
        open={showEmailPreview}
        onClose={() => setShowEmailPreview(false)}
        maxWidth="md"
        fullWidth
        PaperProps={{
          sx: { 
            borderRadius: 3, 
            overflow: 'hidden',
            boxShadow: theme.shadows[8]
          }
        }}
      >
        <DialogTitle sx={{ 
          p: 0,
          background: `linear-gradient(135deg, ${theme.palette.primary.main}, ${theme.palette.primary.dark})`,
          color: 'white',
          position: 'relative'
        }}>
          <Box sx={{ p: 3 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
              <Avatar sx={{ 
                bgcolor: 'rgba(255,255,255,0.2)', 
                color: 'white', 
                width: 56, 
                height: 56,
                border: '2px solid rgba(255,255,255,0.3)'
              }}>
                <EmailIcon sx={{ fontSize: '1.8rem' }} />
              </Avatar>
              <Box>
                <Typography variant="h5" sx={{ fontWeight: 700, color: 'white', mb: 0.5 }}>
                  📧 Email Preview
                </Typography>
                <Typography variant="body2" sx={{ 
                  color: 'rgba(255,255,255,0.9)',
                  display: 'flex',
                  alignItems: 'center',
                  gap: 1
                }}>
                  <PreviewIcon sx={{ fontSize: '1rem' }} />
                  Review your email before copying to your email client
                </Typography>
              </Box>
            </Box>
            
            {/* IMPROVED: Email client mockup header with better styling */}
            <Paper sx={{ 
              bgcolor: 'rgba(255,255,255,0.15)', 
              borderRadius: 2, 
              p: 2.5,
              border: '1px solid rgba(255,255,255,0.3)',
              backdropFilter: 'blur(10px)'
            }}>
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                    <PersonIcon sx={{ color: 'rgba(255,255,255,0.9)', fontSize: '1.1rem' }} />
                    <Typography variant="caption" sx={{ 
                      color: 'rgba(255,255,255,0.9)', 
                      fontWeight: 700,
                      letterSpacing: '0.5px'
                    }}>
                      TO
                    </Typography>
                  </Box>
                  <Typography variant="body2" sx={{ 
                    color: 'white', 
                    fontWeight: 600,
                    fontSize: '0.95rem'
                  }}>
                    {recruiter.email}
                  </Typography>
                </Grid>
                <Grid item xs={12} sm={6}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                    <DescriptionIcon sx={{ color: 'rgba(255,255,255,0.9)', fontSize: '1.1rem' }} />
                    <Typography variant="caption" sx={{ 
                      color: 'rgba(255,255,255,0.9)', 
                      fontWeight: 700,
                      letterSpacing: '0.5px'
                    }}>
                      SUBJECT
                    </Typography>
                  </Box>
                  <Typography variant="body2" sx={{ 
                    color: 'white', 
                    fontWeight: 600,
                    fontSize: '0.95rem',
                    lineHeight: 1.3
                  }}>
                    {emailSubject}
                  </Typography>
                </Grid>
              </Grid>
            </Paper>

            {/* Close button */}
            <IconButton
              onClick={() => setShowEmailPreview(false)}
              sx={{
                position: 'absolute',
                top: 16,
                right: 16,
                color: 'white',
                bgcolor: 'rgba(255,255,255,0.1)',
                '&:hover': {
                  bgcolor: 'rgba(255,255,255,0.2)'
                }
              }}
            >
              <CloseIcon />
            </IconButton>
          </Box>
        </DialogTitle>

        <DialogContent sx={{ p: 0 }}>
          {/* IMPROVED: Email body mockup with better styling */}
          <Box sx={{ 
            p: 4, 
            bgcolor: `linear-gradient(135deg, ${theme.palette.grey[50]}, ${theme.palette.grey[25]})`,
            minHeight: 300
          }}>
            <Paper 
              elevation={4}
              sx={{ 
                p: 4, 
                borderRadius: 3,
                background: 'linear-gradient(135deg, #ffffff, #fafafa)',
                border: `2px solid ${theme.palette.primary.light}`,
                position: 'relative',
                boxShadow: theme.shadows[6],
                '&::before': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: 6,
                  background: `linear-gradient(90deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`,
                  borderTopLeftRadius: 3,
                  borderTopRightRadius: 3
                }
              }}
            >
              {/* Email content with better typography */}
              <Typography 
                variant="body1" 
                sx={{ 
                  whiteSpace: 'pre-wrap',
                  lineHeight: 1.8,
                  fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
                  color: theme.palette.text.primary,
                  fontSize: '1.05rem',
                  letterSpacing: '0.02em'
                }}
              >
                {formattedEmailBody}
              </Typography>
            </Paper>
          </Box>

          {/* IMPROVED: Enhanced info section with theme colors */}
          <Box sx={{ 
            p: 3, 
            bgcolor: `linear-gradient(135deg, ${theme.palette.primary.main}08, ${theme.palette.secondary.main}05)`,
            borderTop: `1px solid ${theme.palette.divider}`
          }}>
            <Alert 
              severity="info" 
              icon={<LightbulbIcon sx={{ color: theme.palette.primary.main }} />}
              sx={{ 
                borderRadius: 2,
                border: `1px solid ${theme.palette.primary.light}`,
                bgcolor: 'rgba(255,255,255,0.9)',
                '& .MuiAlert-icon': {
                  color: theme.palette.primary.main
                }
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 2 }}>
                <Box sx={{ flex: 1 }}>
                  <Typography variant="body2" sx={{ 
                    fontWeight: 700, 
                    color: theme.palette.primary.main, 
                    mb: 1,
                    display: 'flex',
                    alignItems: 'center',
                    gap: 1
                  }}>
                    <CheckCircleIcon sx={{ fontSize: '1.1rem' }} />
                    What happens next:
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ lineHeight: 1.6 }}>
                    Copy the email content using the button below, then paste it into your preferred email client. 
                    This approach maintains your professional reputation while leveraging AI-generated content.
                  </Typography>
                </Box>
              </Box>
            </Alert>
          </Box>
        </DialogContent>

        {/* IMPROVED: Enhanced dialog actions with better button styling */}
        <DialogActions sx={{ 
          p: 3, 
          background: `linear-gradient(135deg, ${theme.palette.grey[50]}, white)`,
          borderTop: `1px solid ${theme.palette.divider}`,
          gap: 2
        }}>
          <Button 
            onClick={() => setShowEmailPreview(false)}
            variant="outlined"
            startIcon={<EditIcon />}
            sx={{ 
              borderRadius: 2,
              borderColor: theme.palette.primary.main,
              color: theme.palette.primary.main,
              fontWeight: 600,
              px: 3,
              '&:hover': {
                bgcolor: theme.palette.primary.main + '10',
                borderColor: theme.palette.primary.dark
              }
            }}
          >
            Edit Message
          </Button>
          <Button
            onClick={copyToClipboard}
            variant="contained"
            startIcon={copySuccess ? <CheckCircleIcon /> : <ContentCopyIcon />}
            size="large"
            sx={{ 
              borderRadius: 2,
              px: 4,
              fontWeight: 700,
              background: copySuccess 
                ? `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`
                : `linear-gradient(45deg, ${theme.palette.secondary.main}, ${theme.palette.secondary.dark})`,
              color: '#ffffff !important',
              boxShadow: theme.shadows[4],
              '&:hover': {
                background: copySuccess
                  ? `linear-gradient(45deg, ${theme.palette.success.dark}, ${theme.palette.success.main})`
                  : `linear-gradient(45deg, ${theme.palette.secondary.dark}, ${theme.palette.secondary.main})`,
                boxShadow: theme.shadows[6],
                transform: 'translateY(-1px)'
              }
            }}
          >
            {copySuccess ? 'Email Copied!' : 'Copy Email'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* IMPROVED: Enhanced Status Update Dialog */}
      <Dialog
        open={showStatusDialog}
        onClose={() => setShowStatusDialog(false)}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: { 
            borderRadius: 3,
            boxShadow: theme.shadows[8]
          }
        }}
      >
        <DialogTitle sx={{ 
          p: 3,
          borderBottom: `1px solid ${theme.palette.divider}`,
          background: `linear-gradient(135deg, ${theme.palette.success.main}15, ${theme.palette.primary.main}15)`
        }}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <Avatar sx={{ 
              bgcolor: theme.palette.success.main,
              width: 56,
              height: 56
            }}>
              <CheckCircleIcon sx={{ fontSize: '1.5rem' }} />
            </Avatar>
            <Box>
              <Typography variant="h6" sx={{ 
                fontWeight: 700, 
                color: theme.palette.success.main,
                mb: 0.5
              }}>
                Update Email Status
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Let us know what happened with your email
              </Typography>
            </Box>
          </Box>
        </DialogTitle>

        <DialogContent sx={{ p: 3 }}>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 3, lineHeight: 1.6 }}>
            After copying the email content for <strong>{recruiter.firstName} {recruiter.lastName}</strong>, 
            please update the status below to help us track your outreach effectiveness:
          </Typography>

          <RadioGroup
            value={manualStatus}
            onChange={(e) => setManualStatus(e.target.value)}
          >
            <FormControlLabel
              value="sent"
              control={<Radio sx={{ color: theme.palette.success.main }} />}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, py: 1 }}>
                  <CheckCircleIcon sx={{ color: theme.palette.success.main }} />
                  <Box>
                    <Typography variant="body2" sx={{ fontWeight: 600 }}>
                      Email sent successfully
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      I copied the content and sent the email
                    </Typography>
                  </Box>
                </Box>
              }
            />
            <FormControlLabel
              value="drafted"
              control={<Radio sx={{ color: theme.palette.warning.main }} />}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, py: 1 }}>
                  <DraftsIcon sx={{ color: theme.palette.warning.main }} />
                  <Box>
                    <Typography variant="body2" sx={{ fontWeight: 600 }}>
                      Saved as draft for later
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      I saved the email content to send later
                    </Typography>
                  </Box>
                </Box>
              }
            />
            <FormControlLabel
              value="cancelled"
              control={<Radio sx={{ color: theme.palette.error.main }} />}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, py: 1 }}>
                  <CancelIcon sx={{ color: theme.palette.error.main }} />
                  <Box>
                    <Typography variant="body2" sx={{ fontWeight: 600 }}>
                      Decided not to send
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      I chose not to send this email
                    </Typography>
                  </Box>
                </Box>
              }
            />
          </RadioGroup>
        </DialogContent>

        <DialogActions sx={{ 
          p: 3, 
          borderTop: `1px solid ${theme.palette.divider}`,
          background: `linear-gradient(135deg, ${theme.palette.grey[50]}, white)`
        }}>
          <Button 
            onClick={() => setShowStatusDialog(false)}
            variant="outlined"
            sx={{ 
              borderRadius: 2,
              fontWeight: 600
            }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleStatusUpdate}
            variant="contained"
            sx={{ 
              borderRadius: 2,
              fontWeight: 700,
              px: 3,
              background: `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`,
              color: '#ffffff !important',
              '&:hover': {
                background: `linear-gradient(45deg, ${theme.palette.success.dark}, ${theme.palette.success.main})`
              }
            }}
          >
            Update Status
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
};

export default OutreachComposer;

================
File: src/components/recruiters/OutreachTracker.js
================
// src/components/recruiters/OutreachTracker.js - UPDATED WITH BETTER ERROR HANDLING
import React, { useState } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  Chip,
  Avatar,
  Grid,
  IconButton,
  Tooltip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  ListItemSecondaryAction,
  Divider,
  Alert,
  CircularProgress,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  TextField,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Snackbar
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  Email as EmailIcon,
  LinkedIn as LinkedInIcon,
  Phone as PhoneIcon,
  Schedule as ScheduleIcon,
  Reply as ReplyIcon,
  Edit as EditIcon,
  Visibility as VisibilityIcon,
  ExpandMore as ExpandMoreIcon,
  Send as SendIcon,
  Drafts as DraftIcon,
  CheckCircle as CheckCircleIcon,
  Business as BusinessIcon,
  Delete as DeleteIcon,
  FilterList as FilterListIcon,
  Sort as SortIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';

const OutreachCard = ({ campaign, onViewRecruiter, onEditCampaign, onDeleteCampaign }) => {
  const theme = useTheme();
  const formatted = recruiterService.formatOutreachForDisplay(campaign);

  const getStatusIcon = (status) => {
    switch (status) {
      case 'drafted':
        return <DraftIcon color="action" />;
      case 'sent':
        return <SendIcon color="warning" />;
      case 'replied':
        return <ReplyIcon color="success" />;
      case 'delivered':
        return <CheckCircleIcon color="info" />;
      default:
        return <EmailIcon color="action" />;
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'drafted':
        return 'default';
      case 'sent':
        return 'warning';
      case 'replied':
        return 'success';
      case 'delivered':
        return 'info';
      default:
        return 'default';
    }
  };

  const getSentViaIcon = (sentVia) => {
    switch (sentVia) {
      case 'linkedin':
        return <LinkedInIcon fontSize="small" />;
      case 'email':
        return <EmailIcon fontSize="small" />;
      case 'phone':
        return <PhoneIcon fontSize="small" />;
      default:
        return <BusinessIcon fontSize="small" />;
    }
  };

  const handleViewRecruiter = () => {
    console.log('🔍 OutreachCard: handleViewRecruiter called');
    console.log('📋 Campaign data:', campaign);
    
    if (!onViewRecruiter) {
      console.error('❌ onViewRecruiter function not provided');
      return;
    }

    // Try different ways to get the recruiterId
    let recruiterId = campaign.recruiterId || campaign.recruiter_id || campaign.recruiter?.id;
    
    if (!recruiterId) {
      console.error('❌ No recruiterId found in campaign data:', {
        recruiterId: campaign.recruiterId,
        recruiter_id: campaign.recruiter_id,
        recruiterObject: campaign.recruiter
      });
      return;
    }

    console.log('✅ Found recruiterId:', recruiterId);
    
    // Create a recruiter object with the ID and any available recruiter data
    const recruiterData = {
      id: recruiterId,
      ...campaign.recruiter // Spread any additional recruiter data if available
    };
    
    console.log('📤 Calling onViewRecruiter with:', recruiterData);
    onViewRecruiter(recruiterData);
  };

  const handleEditCampaign = () => {
    console.log('✏️ OutreachCard: handleEditCampaign called for campaign:', campaign.id);
    if (onEditCampaign) {
      onEditCampaign(campaign);
    }
  };

  const handleDeleteCampaign = () => {
    console.log('🗑️ OutreachCard: handleDeleteCampaign called for campaign:', campaign.id);
    if (onDeleteCampaign) {
      onDeleteCampaign(campaign.id);
    } else {
      console.error('❌ onDeleteCampaign function not provided');
    }
  };

  return (
    <Card elevation={2} sx={{ mb: 2, borderLeft: `4px solid ${theme.palette[getStatusColor(campaign.status)]?.main || theme.palette.grey[400]}` }}>
      <CardContent>
        <Grid container spacing={2} alignItems="center">
          {/* Recruiter Info */}
          <Grid item xs={12} sm={6} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              <Avatar
                sx={{
                  bgcolor: theme.palette.primary.main,
                  width: 40,
                  height: 40
                }}
              >
                {formatted?.recruiterDisplay ? 
                  formatted.recruiterDisplay.split(' ').map(n => n[0]).join('').substring(0, 2) :
                  'UK'
                }
              </Avatar>
              <Box>
                <Typography variant="subtitle2" fontWeight={600}>
                  {formatted?.recruiterDisplay || campaign.recruiter?.name || 'Unknown Recruiter'}
                </Typography>
                <Typography variant="caption" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                  <BusinessIcon fontSize="small" />
                  {formatted?.companyDisplay || campaign.recruiter?.company?.name || 'Unknown Company'}
                </Typography>
              </Box>
            </Box>
          </Grid>

          {/* Status and Message Info */}
          <Grid item xs={12} sm={6} md={4}>
            <Box>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                <Chip
                  icon={getStatusIcon(campaign.status)}
                  label={formatted?.statusDisplay || campaign.status}
                  size="small"
                  color={getStatusColor(campaign.status)}
                  variant="filled"
                />
                <Chip
                  icon={getSentViaIcon(campaign.sentVia)}
                  label={campaign.sentVia || 'unknown'}
                  size="small"
                  variant="outlined"
                />
              </Box>
              <Typography variant="body2" color="text.secondary" noWrap>
                {formatted?.messagePreview || campaign.messageContent?.substring(0, 100) + '...' || 'No message preview'}
              </Typography>
            </Box>
          </Grid>

          {/* Dates and Actions */}
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <Box>
                <Typography variant="caption" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                  <ScheduleIcon fontSize="small" />
                  Created: {formatted?.createdDisplay || new Date(campaign.createdAt).toLocaleDateString()}
                </Typography>
                {(formatted?.sentDisplay || campaign.sentAt) && (
                  <Typography variant="caption" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mt: 0.5 }}>
                    <SendIcon fontSize="small" />
                    Sent: {formatted?.sentDisplay || new Date(campaign.sentAt).toLocaleDateString()}
                  </Typography>
                )}
                {(formatted?.hasReplies || campaign.repliesCount > 0) && (
                  <Typography variant="caption" color="success.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mt: 0.5 }}>
                    <ReplyIcon fontSize="small" />
                    {campaign.repliesCount || 0} replies
                  </Typography>
                )}
              </Box>

              {/* Action Buttons */}
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <Tooltip title="View Recruiter">
                  <IconButton size="small" onClick={handleViewRecruiter}>
                    <VisibilityIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                
                {(formatted?.canEdit || campaign.status === 'drafted') && (
                  <Tooltip title="Edit Campaign">
                    <IconButton size="small" onClick={handleEditCampaign}>
                      <EditIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                )}
                
                <Tooltip title="Delete Campaign">
                  <IconButton 
                    size="small" 
                    onClick={handleDeleteCampaign} 
                    color="error"
                    sx={{ '&:hover': { backgroundColor: 'error.main', color: 'white' } }}
                  >
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
            </Box>
          </Grid>
        </Grid>

        {/* Expandable Message Content */}
        <Accordion elevation={0} sx={{ mt: 2, '&:before': { display: 'none' } }}>
          <AccordionSummary expandIcon={<ExpandMoreIcon />}>
            <Typography variant="body2">View Full Message</Typography>
          </AccordionSummary>
          <AccordionDetails>
            <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>
              {campaign.messageContent || 'No message content available'}
            </Typography>
          </AccordionDetails>
        </Accordion>
      </CardContent>
    </Card>
  );
};

const OutreachTracker = ({ 
  campaigns = [], 
  loading = false, 
  onRefresh, 
  onViewRecruiter, 
  onEditCampaign 
}) => {
  const theme = useTheme();
  const [statusFilter, setStatusFilter] = useState('all');
  const [sortBy, setSortBy] = useState('createdAt');
  const [sortOrder, setSortOrder] = useState('desc');
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [campaignToDelete, setCampaignToDelete] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  // Filter and sort campaigns
  const filteredAndSortedCampaigns = React.useMemo(() => {
    let filtered = campaigns;

    // Apply status filter
    if (statusFilter !== 'all') {
      filtered = filtered.filter(campaign => campaign.status === statusFilter);
    }

    // Apply sorting
    filtered.sort((a, b) => {
      let aValue, bValue;
      
      switch (sortBy) {
        case 'createdAt':
          aValue = new Date(a.createdAt);
          bValue = new Date(b.createdAt);
          break;
        case 'sentAt':
          aValue = a.sentAt ? new Date(a.sentAt) : new Date(0);
          bValue = b.sentAt ? new Date(b.sentAt) : new Date(0);
          break;
        case 'recruiterName':
          aValue = (a.recruiter?.name || '').toLowerCase();
          bValue = (b.recruiter?.name || '').toLowerCase();
          break;
        case 'company':
          aValue = (a.recruiter?.company?.name || '').toLowerCase();
          bValue = (b.recruiter?.company?.name || '').toLowerCase();
          break;
        default:
          aValue = a[sortBy];
          bValue = b[sortBy];
      }

      if (sortOrder === 'asc') {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    return filtered;
  }, [campaigns, statusFilter, sortBy, sortOrder]);

  const handleDeleteCampaign = async (campaignId) => {
    console.log('🗑️ OutreachTracker: Delete requested for campaign:', campaignId);
    
    if (!campaignId) {
      console.error('❌ No campaign ID provided for deletion');
      showNotification('Error: No campaign ID provided', 'error');
      return;
    }

    setCampaignToDelete(campaignId);
    setDeleteDialogOpen(true);
  };

  const confirmDelete = async () => {
    if (!campaignToDelete) {
      console.error('❌ No campaign selected for deletion');
      return;
    }

    try {
      setIsDeleting(true);
      console.log(`🗑️ Attempting to delete campaign: ${campaignToDelete}`);
      
      const result = await recruiterService.deleteOutreach(campaignToDelete);
      console.log('✅ Delete successful:', result);
      
      showNotification('Campaign deleted successfully!', 'success');
      
      // Close dialog
      setDeleteDialogOpen(false);
      setCampaignToDelete(null);
      
      // Refresh the list
      if (onRefresh) {
        console.log('🔄 Calling onRefresh to update the list');
        onRefresh();
      } else {
        console.warn('⚠️ onRefresh function not provided - list may not update');
      }
      
    } catch (error) {
      console.error('❌ Delete failed:', error);
      
      let errorMessage = 'Failed to delete campaign';
      if (error.response?.data?.error) {
        errorMessage = error.response.data.error;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      showNotification(errorMessage, 'error');
    } finally {
      setIsDeleting(false);
    }
  };

  const cancelDelete = () => {
    console.log('❌ Delete cancelled by user');
    setDeleteDialogOpen(false);
    setCampaignToDelete(null);
  };

  const showNotification = (message, severity = 'success') => {
    setNotification({
      open: true,
      message,
      severity
    });
  };

  const getStatusCounts = () => {
    const counts = {
      all: campaigns.length,
      drafted: 0,
      sent: 0,
      replied: 0,
      delivered: 0
    };

    campaigns.forEach(campaign => {
      if (counts.hasOwnProperty(campaign.status)) {
        counts[campaign.status]++;
      }
    });

    return counts;
  };

  const statusCounts = getStatusCounts();

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>
        <Box sx={{ textAlign: 'center' }}>
          <CircularProgress size={60} />
          <Typography variant="h6" sx={{ mt: 2, color: 'text.secondary' }}>
            Loading outreach campaigns...
          </Typography>
        </Box>
      </Box>
    );
  }

  if (campaigns.length === 0) {
    return (
      <Card elevation={1} sx={{ textAlign: 'center', py: 8 }}>
        <CardContent>
          <EmailIcon sx={{ fontSize: 64, color: 'text.disabled', mb: 2 }} />
          <Typography variant="h6" gutterBottom>
            No outreach campaigns yet
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
            Start by searching for recruiters and sending your first outreach message.
          </Typography>
          <Button variant="outlined" onClick={onRefresh}>
            Refresh
          </Button>
        </CardContent>
      </Card>
    );
  }

  return (
    <Box>
      {/* Header with Filters */}
      <Card elevation={1} sx={{ mb: 3 }}>
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <EmailIcon color="primary" />
              Outreach Campaigns ({campaigns.length})
            </Typography>
            
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={onRefresh}
              disabled={loading}
            >
              Refresh
            </Button>
          </Box>

          {/* Filters and Sorting */}
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} sm={6} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel>Status Filter</InputLabel>
                <Select
                  value={statusFilter}
                  label="Status Filter"
                  onChange={(e) => setStatusFilter(e.target.value)}
                >
                  <MenuItem value="all">All ({statusCounts.all})</MenuItem>
                  <MenuItem value="drafted">Drafted ({statusCounts.drafted})</MenuItem>
                  <MenuItem value="sent">Sent ({statusCounts.sent})</MenuItem>
                  <MenuItem value="delivered">Delivered ({statusCounts.delivered})</MenuItem>
                  <MenuItem value="replied">Replied ({statusCounts.replied})</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel>Sort By</InputLabel>
                <Select
                  value={sortBy}
                  label="Sort By"
                  onChange={(e) => setSortBy(e.target.value)}
                >
                  <MenuItem value="createdAt">Date Created</MenuItem>
                  <MenuItem value="sentAt">Date Sent</MenuItem>
                  <MenuItem value="recruiterName">Recruiter Name</MenuItem>
                  <MenuItem value="company">Company</MenuItem>
                  <MenuItem value="status">Status</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel>Order</InputLabel>
                <Select
                  value={sortOrder}
                  label="Order"
                  onChange={(e) => setSortOrder(e.target.value)}
                >
                  <MenuItem value="desc">Newest First</MenuItem>
                  <MenuItem value="asc">Oldest First</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <Typography variant="body2" color="text.secondary" textAlign="center">
                Showing {filteredAndSortedCampaigns.length} of {campaigns.length} campaigns
              </Typography>
            </Grid>
          </Grid>

          {/* Status Summary */}
          <Box sx={{ display: 'flex', gap: 1, mt: 2, flexWrap: 'wrap' }}>
            <Chip 
              label={`${statusCounts.drafted} Drafts`} 
              size="small" 
              color="default" 
              variant={statusFilter === 'drafted' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('drafted')}
              sx={{ cursor: 'pointer' }}
            />
            <Chip 
              label={`${statusCounts.sent} Sent`} 
              size="small" 
              color="warning" 
              variant={statusFilter === 'sent' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('sent')}
              sx={{ cursor: 'pointer' }}
            />
            <Chip 
              label={`${statusCounts.delivered} Delivered`} 
              size="small" 
              color="info" 
              variant={statusFilter === 'delivered' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('delivered')}
              sx={{ cursor: 'pointer' }}
            />
            <Chip 
              label={`${statusCounts.replied} Replied`} 
              size="small" 
              color="success" 
              variant={statusFilter === 'replied' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('replied')}
              sx={{ cursor: 'pointer' }}
            />
          </Box>
        </CardContent>
      </Card>

      {/* Campaigns List */}
      {filteredAndSortedCampaigns.length === 0 ? (
        <Alert severity="info" sx={{ mb: 2 }}>
          No campaigns match the current filter criteria.
        </Alert>
      ) : (
        <Box>
          {filteredAndSortedCampaigns.map((campaign, index) => (
            <OutreachCard
              key={campaign.id || index}
              campaign={campaign}
              onViewRecruiter={onViewRecruiter}
              onEditCampaign={onEditCampaign}
              onDeleteCampaign={handleDeleteCampaign}
            />
          ))}
        </Box>
      )}

      {/* Delete Confirmation Dialog */}
      <Dialog
        open={deleteDialogOpen}
        onClose={cancelDelete}
        PaperProps={{
          sx: { borderRadius: 2 }
        }}
      >
        <DialogTitle>Confirm Delete</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete this outreach campaign? This action cannot be undone.
          </Typography>
          {campaignToDelete && (
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              Campaign ID: {campaignToDelete}
            </Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={cancelDelete} disabled={isDeleting}>
            Cancel
          </Button>
          <Button 
            onClick={confirmDelete} 
            color="error" 
            variant="contained"
            disabled={isDeleting}
            startIcon={isDeleting ? <CircularProgress size={16} color="inherit" /> : null}
          >
            {isDeleting ? 'Deleting...' : 'Delete'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Notification Snackbar */}
      <Snackbar
        open={notification.open}
        autoHideDuration={6000}
        onClose={() => setNotification({ ...notification, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setNotification({ ...notification, open: false })}
          severity={notification.severity}
          variant="filled"
          sx={{ borderRadius: 2 }}
        >
          {notification.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default OutreachTracker;

================
File: src/components/recruiters/RecruiterDetails.js
================
// src/components/recruiters/RecruiterDetails.js
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Avatar,
  Divider,
  IconButton,
  Card,
  CardContent,
  Grid,
  Chip,
  Link,
  CircularProgress,
  Alert,
  Paper
} from '@mui/material';
import {
  Close as CloseIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  LinkedIn as LinkedInIcon,
  Business as BusinessIcon,
  Work as WorkIcon,
  Language as LanguageIcon,
  CalendarToday as CalendarTodayIcon,
  Send as SendIcon,
  Star as StarIcon,
  Groups as GroupsIcon,
  Domain as DomainIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';

const RecruiterDetails = ({ open, onClose, recruiterId, onStartOutreach }) => {
  const theme = useTheme();
  const [recruiter, setRecruiter] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  // Reset state when dialog opens/closes or recruiterId changes
  useEffect(() => {
    if (open && recruiterId) {
      loadRecruiterDetails();
    } else {
      // Reset state when dialog closes or no recruiterId
      setRecruiter(null);
      setError('');
      setLoading(false);
    }
  }, [open, recruiterId]);

  const loadRecruiterDetails = async () => {
    // Don't load if no recruiterId provided
    if (!recruiterId) {
      setError('No recruiter selected');
      return;
    }

    try {
      setLoading(true);
      setError('');
      console.log('🔍 Loading recruiter details for ID:', recruiterId);
      
      const response = await recruiterService.getRecruiterDetails(recruiterId);
      
      if (response && response.recruiter) {
        setRecruiter(response.recruiter);
        console.log('✅ Recruiter details loaded:', response.recruiter.fullName);
      } else {
        setError('Recruiter data not found');
      }
    } catch (error) {
      console.error('Failed to load recruiter details:', error);
      setError('Failed to load recruiter details. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    // Reset all state when closing
    setRecruiter(null);
    setError('');
    setLoading(false);
    onClose();
  };

  const handleStartOutreach = () => {
    if (recruiter) {
      onStartOutreach(recruiter);
      handleClose();
    }
  };

  const formatCompanySize = (sizeString) => {
    if (!sizeString) return 'Not specified';
    
    // Handle formats like "10000plus" or "1000plus"
    const plusMatch = sizeString.match(/(\d+)plus/i);
    if (plusMatch) {
      const [, number] = plusMatch;
      return `${parseInt(number).toLocaleString()}+ employees`;
    }
    
    // Handle formats like "Employees.1000to4999" or "1000to4999"
    const rangeMatch = sizeString.match(/(\d+)to(\d+)/);
    if (rangeMatch) {
      const [, min, max] = rangeMatch;
      return `${parseInt(min).toLocaleString()} - ${parseInt(max).toLocaleString()} employees`;
    }
    
    // Handle other formats like "Employees.1000plus"
    if (sizeString.includes('Employees.')) {
      const cleanedSize = sizeString.replace('Employees.', '');
      
      // Check for plus format after removing "Employees."
      const plusMatch2 = cleanedSize.match(/(\d+)plus/i);
      if (plusMatch2) {
        const [, number] = plusMatch2;
        return `${parseInt(number).toLocaleString()}+ employees`;
      }
      
      // Check for range format after removing "Employees."
      const rangeMatch2 = cleanedSize.match(/(\d+)to(\d+)/);
      if (rangeMatch2) {
        const [, min, max] = rangeMatch2;
        return `${parseInt(min).toLocaleString()} - ${parseInt(max).toLocaleString()} employees`;
      }
      
      return cleanedSize.replace('to', ' - ') + ' employees';
    }
    
    return sizeString;
  };

  const getInitials = (firstName, lastName) => {
    return `${firstName?.[0] || ''}${lastName?.[0] || ''}`.toUpperCase();
  };

  const getAvatarColor = () => {
    const colors = [
      theme.palette.primary.main,
      theme.palette.secondary.main,
      theme.palette.success.main,
      theme.palette.warning.main,
      theme.palette.info.main
    ];
    // Use recruiter ID to consistently assign colors
    const colorIndex = (recruiterId || 0) % colors.length;
    return colors[colorIndex];
  };

  // Safe text rendering function
  const safeText = (value) => {
    if (value === null || value === undefined) return 'Not specified';
    if (typeof value === 'object') {
      // Handle industry object specifically
      if (value.name) return value.name;
      if (value.description) return value.description;
      return 'Not specified';
    }
    return String(value);
  };

  // Extract industry name safely
  const getIndustryName = (industry) => {
    if (!industry) return 'Not specified';
    if (typeof industry === 'string') return industry;
    if (typeof industry === 'object' && industry.name) return industry.name;
    return 'Not specified';
  };

  // Don't render dialog if not open
  if (!open) return null;

  // Show error state if no recruiterId provided
  if (!recruiterId) {
    return (
      <Dialog
        open={open}
        onClose={handleClose}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: { borderRadius: 3 }
        }}
      >
        <DialogTitle sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center',
          borderBottom: `1px solid ${theme.palette.divider}`
        }}>
          <Typography variant="h6" sx={{ color: theme.palette.error.main }}>
            Error
          </Typography>
          <IconButton onClick={handleClose}>
            <CloseIcon />
          </IconButton>
        </DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <Alert severity="error" sx={{ borderRadius: 2 }}>
            No recruiter selected. Please select a recruiter to view details.
          </Alert>
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button onClick={handleClose} variant="contained">
            Close
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: { 
          borderRadius: 3,
          minHeight: '500px'
        }
      }}
    >
      {/* Header */}
      <DialogTitle sx={{ 
        p: 0,
        background: `linear-gradient(135deg, ${theme.palette.primary.main}15, ${theme.palette.secondary.main}15)`,
        borderBottom: `1px solid ${theme.palette.divider}`
      }}>
        <Box sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center',
          p: 3
        }}>
          <Typography variant="h5" sx={{ fontWeight: 600, color: theme.palette.primary.main }}>
            Recruiter Details
          </Typography>
          <IconButton 
            onClick={handleClose}
            sx={{ 
              bgcolor: 'background.paper',
              '&:hover': { bgcolor: 'grey.100' }
            }}
          >
            <CloseIcon />
          </IconButton>
        </Box>
      </DialogTitle>

      <DialogContent sx={{ p: 0 }}>
        {loading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 400 }}>
            <Box sx={{ textAlign: 'center' }}>
              <CircularProgress size={60} sx={{ color: theme.palette.primary.main, mb: 2 }} />
              <Typography variant="h6" color="text.secondary">
                Loading recruiter details...
              </Typography>
            </Box>
          </Box>
        )}

        {error && (
          <Box sx={{ p: 3 }}>
            <Alert 
              severity="error" 
              sx={{ borderRadius: 2 }}
              action={
                <Button 
                  color="inherit" 
                  size="small" 
                  onClick={loadRecruiterDetails}
                  disabled={loading}
                >
                  Retry
                </Button>
              }
            >
              {error}
            </Alert>
          </Box>
        )}

        {recruiter && !loading && !error && (
          <Box sx={{ p: 3 }}>
            {/* Profile Header */}
            <Paper 
              elevation={0} 
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                background: `linear-gradient(135deg, ${theme.palette.primary.main}08, ${theme.palette.secondary.main}08)`,
                border: `1px solid ${theme.palette.divider}`
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 3 }}>
                <Avatar
                  sx={{
                    width: 80,
                    height: 80,
                    bgcolor: getAvatarColor(),
                    fontSize: '2rem',
                    fontWeight: 'bold',
                    border: `3px solid ${theme.palette.background.paper}`,
                    boxShadow: theme.shadows[4]
                  }}
                >
                  {getInitials(recruiter.firstName, recruiter.lastName)}
                </Avatar>
                
                <Box sx={{ flex: 1 }}>
                  <Typography variant="h4" sx={{ fontWeight: 600, mb: 1, color: theme.palette.text.primary }}>
                    {safeText(recruiter.fullName || `${recruiter.firstName || ''} ${recruiter.lastName || ''}`)}
                  </Typography>
                  
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                    <WorkIcon sx={{ color: theme.palette.primary.main, fontSize: '1.2rem' }} />
                    <Typography variant="h6" sx={{ color: theme.palette.primary.main, fontWeight: 500 }}>
                      {safeText(recruiter.title)}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <BusinessIcon sx={{ color: theme.palette.text.secondary, fontSize: '1.1rem' }} />
                    <Typography variant="body1" color="text.secondary" sx={{ fontWeight: 500 }}>
                      {safeText(recruiter.company?.name)}
                    </Typography>
                    {recruiter.rating && (
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, ml: 2 }}>
                        <StarIcon sx={{ color: theme.palette.warning.main, fontSize: '1.1rem' }} />
                        <Typography variant="body2" sx={{ fontWeight: 600 }}>
                          {Number(recruiter.rating).toFixed(1)}
                        </Typography>
                      </Box>
                    )}
                  </Box>
                </Box>
                
                {recruiter.outreach?.hasContacted && (
                  <Chip
                    label="Previously Contacted"
                    color="success"
                    variant="outlined"
                    sx={{ 
                      borderRadius: 2,
                      fontWeight: 500
                    }}
                  />
                )}
              </Box>
            </Paper>

            <Grid container spacing={3}>
              {/* Contact Information */}
              <Grid item xs={12} md={6}>
                <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <CardContent sx={{ p: 3 }}>
                    <Typography 
                      variant="h6" 
                      gutterBottom 
                      sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1, 
                        mb: 2,
                        color: theme.palette.primary.main,
                        fontWeight: 600
                      }}
                    >
                      <EmailIcon />
                      Contact Information
                    </Typography>

                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {recruiter.email && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <EmailIcon sx={{ color: theme.palette.primary.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Email
                            </Typography>
                            <Link
                              href={`mailto:${recruiter.email}`}
                              sx={{ 
                                color: theme.palette.primary.main,
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              {safeText(recruiter.email)}
                            </Link>
                          </Box>
                        </Box>
                      )}

                      {recruiter.phone && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <PhoneIcon sx={{ color: theme.palette.success.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Phone
                            </Typography>
                            <Link
                              href={`tel:${recruiter.phone}`}
                              sx={{ 
                                color: theme.palette.text.primary,
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              {safeText(recruiter.phone)}
                            </Link>
                          </Box>
                        </Box>
                      )}

                      {recruiter.linkedinUrl && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <LinkedInIcon sx={{ color: '#0077b5', fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              LinkedIn
                            </Typography>
                            <Link
                              href={recruiter.linkedinUrl}
                              target="_blank"
                              rel="noopener noreferrer"
                              sx={{ 
                                color: '#0077b5',
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              LinkedIn Profile
                            </Link>
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </CardContent>
                </Card>
              </Grid>

              {/* Company Details */}
              <Grid item xs={12} md={6}>
                <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <CardContent sx={{ p: 3 }}>
                    <Typography 
                      variant="h6" 
                      gutterBottom 
                      sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1, 
                        mb: 2,
                        color: theme.palette.primary.main,
                        fontWeight: 600
                      }}
                    >
                      <DomainIcon />
                      Company Details
                    </Typography>

                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {recruiter.company?.size && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <GroupsIcon sx={{ color: theme.palette.secondary.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Company Size
                            </Typography>
                            <Typography variant="body2" sx={{ fontWeight: 500 }}>
                              {formatCompanySize(recruiter.company.size)}
                            </Typography>
                          </Box>
                        </Box>
                      )}

                      {recruiter.industry && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <WorkIcon sx={{ color: theme.palette.info.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Industry
                            </Typography>
                            <Chip
                              label={getIndustryName(recruiter.industry)}
                              size="small"
                              variant="outlined"
                              color="primary"
                              sx={{ borderRadius: 1, fontWeight: 500 }}
                            />
                          </Box>
                        </Box>
                      )}

                      {recruiter.company?.foundedYear && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <CalendarTodayIcon sx={{ color: theme.palette.warning.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Founded
                            </Typography>
                            <Typography variant="body2" sx={{ fontWeight: 500 }}>
                              {safeText(recruiter.company.foundedYear)}
                            </Typography>
                          </Box>
                        </Box>
                      )}

                      {recruiter.company?.website && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <LanguageIcon sx={{ color: theme.palette.success.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Website
                            </Typography>
                            <Link
                              href={String(recruiter.company.website).startsWith('http') ? 
                                recruiter.company.website : 
                                `https://${recruiter.company.website}`
                              }
                              target="_blank"
                              rel="noopener noreferrer"
                              sx={{ 
                                color: theme.palette.primary.main,
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              {safeText(recruiter.company.website)}
                            </Link>
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </CardContent>
                </Card>
              </Grid>

              {/* Specializations */}
              {recruiter.specializations && Array.isArray(recruiter.specializations) && recruiter.specializations.length > 0 && (
                <Grid item xs={12}>
                  <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                    <CardContent sx={{ p: 3 }}>
                      <Typography 
                        variant="h6" 
                        gutterBottom 
                        sx={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          gap: 1, 
                          mb: 2,
                          color: theme.palette.primary.main,
                          fontWeight: 600
                        }}
                      >
                        <StarIcon />
                        Specializations
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {recruiter.specializations.map((spec, index) => (
                          <Chip
                            key={index}
                            label={safeText(spec)}
                            variant="outlined"
                            sx={{ 
                              borderRadius: 1,
                              fontWeight: 500,
                              '&:hover': {
                                backgroundColor: theme.palette.primary.main + '08'
                              }
                            }}
                          />
                        ))}
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>
              )}
            </Grid>
          </Box>
        )}
      </DialogContent>

      {/* Footer Actions - Only Close Button */}
      <DialogActions sx={{ 
        p: 3, 
        borderTop: `1px solid ${theme.palette.divider}`,
        background: theme.palette.grey[50]
      }}>
        <Button 
          onClick={handleClose} 
          variant="contained"
          sx={{ 
            borderRadius: 2,
            minWidth: 100
          }}
        >
          Close
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default RecruiterDetails;

================
File: src/components/recruiters/RecruiterList.js
================
// src/components/recruiters/RecruiterList.js - FIXED PAGINATION
import React, { useState } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Avatar,
  Button,
  Chip,
  Grid,
  IconButton,
  Tooltip,
  Rating,
  Divider,
  Link,
  Badge,
  CircularProgress,
  Alert,
  Pagination,
  Paper
} from '@mui/material';
import {
  Email as EmailIcon,
  Phone as PhoneIcon,
  LinkedIn as LinkedInIcon,
  Business as BusinessIcon,
  Visibility as VisibilityIcon,
  CheckCircle as CheckCircleIcon,
  Person as PersonIcon,
  Work as WorkIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';
import AutoJobLogo from '../common/AutoJobLogo';

const RecruiterCard = ({ recruiter, onViewDetails, onStartOutreach, onLoadMore }) => {
  const theme = useTheme();
  const [isLoading, setIsLoading] = useState(false);

  // Format recruiter data for display
  const formattedRecruiter = recruiterService.formatRecruiterForDisplay ? 
    recruiterService.formatRecruiterForDisplay(recruiter) : {
      displayName: `${recruiter.firstName} ${recruiter.lastName}`,
      companyDisplay: recruiter.company?.name || 'Company Not Available'
    };

  const handleStartOutreach = async () => {
    setIsLoading(true);
    try {
      await onStartOutreach(recruiter);
    } catch (error) {
      console.error('Failed to start outreach:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const getContactStatusColor = (status) => {
    switch (status) {
      case 'replied':
        return 'success';
      case 'sent':
        return 'warning';
      case 'drafted':
        return 'info';
      default:
        return 'default';
    }
  };

  const getContactStatusText = (recruiter) => {
    if (recruiter.outreach?.hasContacted) {
      switch (recruiter.outreach.status) {
        case 'replied':
          return 'Replied';
        case 'sent':
          return 'Contacted';
        case 'drafted':
          return 'Draft Saved';
        default:
          return 'Contacted';
      }
    }
    return 'Not Contacted';
  };

  // Use different theme colors for avatar
  const getAvatarColor = (index) => {
    const colors = [
      theme.palette.secondary.main, // Teal
      theme.palette.warning.main,   // Orange
      theme.palette.success.main,   // Green
      theme.palette.info.main,      // Blue
      theme.palette.error.main      // Red
    ];
    // Use recruiter ID or name to consistently assign colors
    const colorIndex = (recruiter.id || recruiter.firstName?.charCodeAt(0) || 0) % colors.length;
    return colors[colorIndex];
  };

  return (
    <Card 
      elevation={0}
      sx={{ 
        height: '100%',
        transition: 'all 0.2s ease-in-out',
        border: `1px solid ${theme.palette.divider}`,
        borderRadius: 2,
        '&:hover': {
          elevation: 2,
          transform: 'translateY(-2px)',
          boxShadow: theme.shadows[4],
          borderColor: theme.palette.primary.light
        },
        ...(recruiter.outreach?.hasContacted && {
          borderColor: theme.palette.success.light,
          backgroundColor: `${theme.palette.success.main}08`
        })
      }}
    >
      <CardContent sx={{ p: 3, height: '100%', display: 'flex', flexDirection: 'column' }}>
        {/* Header with Avatar and Basic Info */}
        <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
          <Avatar
            sx={{
              width: 48,
              height: 48,
              mr: 2,
              bgcolor: getAvatarColor(),
              fontSize: '1.1rem',
              fontWeight: 'bold'
            }}
          >
            {recruiter.firstName?.[0]}{recruiter.lastName?.[0]}
          </Avatar>
          
          <Box sx={{ flex: 1, minWidth: 0 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
              <Typography 
                variant="h6" 
                sx={{ 
                  fontWeight: 600,
                  fontSize: '1.1rem',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  color: theme.palette.text.primary
                }}
              >
                {formattedRecruiter.displayName}
              </Typography>
              
              {recruiter.outreach?.hasContacted && (
                <Tooltip title={`Status: ${getContactStatusText(recruiter)}`}>
                  <CheckCircleIcon 
                    sx={{ 
                      fontSize: 16, 
                      color: theme.palette.success.main
                    }} 
                  />
                </Tooltip>
              )}
            </Box>
            
            <Typography variant="body2" sx={{ color: theme.palette.primary.main, fontWeight: 500, mb: 0.5 }}>
              {recruiter.title}
            </Typography>
            
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
              <BusinessIcon sx={{ fontSize: 16, color: theme.palette.text.secondary }} />
              <Typography variant="body2" color="text.secondary" noWrap>
                {formattedRecruiter.companyDisplay}
              </Typography>
            </Box>
          </Box>

          {/* Rating */}
          {recruiter.rating && (
            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              <Rating
                value={recruiter.rating}
                readOnly
                size="small"
                precision={0.1}
              />
              <Typography variant="caption" color="text.secondary">
                {recruiter.rating.toFixed(1)}
              </Typography>
            </Box>
          )}
        </Box>

        {/* Company Logo and Info */}
        {recruiter.company?.logo && (
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <Avatar
              src={recruiter.company.logo}
              variant="square"
              sx={{ width: 20, height: 20, mr: 1 }}
            />
            <Typography variant="body2" color="text.secondary">
              {recruiter.company.size && `${recruiter.company.size} company`}
            </Typography>
          </Box>
        )}

        {/* Industry and Specializations */}
        {recruiter.industry && (
          <Box sx={{ mb: 2 }}>
            <Chip
              label={recruiter.industry}
              size="small"
              variant="outlined"
              color="primary"
              sx={{ mr: 1, mb: 1, borderRadius: 1 }}
            />
            {recruiter.specializations && recruiter.specializations.slice(0, 2).map((spec, index) => (
              <Chip
                key={index}
                label={spec}
                size="small"
                variant="outlined"
                sx={{ mr: 1, mb: 1, borderRadius: 1 }}
              />
            ))}
          </Box>
        )}

        {/* Contact Status */}
        <Box sx={{ mb: 2 }}>
          <Chip
            label={getContactStatusText(recruiter)}
            size="small"
            color={getContactStatusColor(recruiter.outreach?.status)}
            variant={recruiter.outreach?.hasContacted ? 'filled' : 'outlined'}
            sx={{ fontWeight: 500, borderRadius: 1 }}
          />
          
          {recruiter.outreach?.lastContactDate && (
            <Typography variant="caption" color="text.secondary" sx={{ ml: 1 }}>
              Last contact: {new Date(recruiter.outreach.lastContactDate).toLocaleDateString()}
            </Typography>
          )}
        </Box>

        {/* Contact Information */}
        <Box sx={{ mb: 2, flex: 1 }}>
          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            {recruiter.email && (
              <Tooltip title={`Email: ${recruiter.email}`}>
                <IconButton size="small" sx={{ color: theme.palette.primary.main }}>
                  <EmailIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
            
            {recruiter.phone && (
              <Tooltip title={`Phone: ${recruiter.phone}`}>
                <IconButton size="small" sx={{ color: theme.palette.primary.main }}>
                  <PhoneIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
            
            {recruiter.linkedinUrl && (
              <Tooltip title="LinkedIn Profile">
                <IconButton 
                  size="small" 
                  sx={{ color: theme.palette.primary.main }}
                  component={Link}
                  href={recruiter.linkedinUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  <LinkedInIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
          </Box>
        </Box>

        <Divider sx={{ mb: 2 }} />

        {/* Action Buttons */}
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button
            variant="outlined"
            startIcon={<VisibilityIcon />}
            onClick={() => onViewDetails(recruiter)}
            size="small"
            sx={{ flex: 1, borderRadius: 2 }}
          >
            View Details
          </Button>
          
          <Button
            variant="contained"
            startIcon={isLoading ? <CircularProgress size={16} color="inherit" /> : 
              <AutoJobLogo variant="icon-only" size="small" sx={{ width: 24, height: 24 }} />
            }
            onClick={handleStartOutreach}
            disabled={isLoading}
            size="small"
            color={recruiter.outreach?.hasContacted ? 'secondary' : 'primary'}
            sx={{ flex: 1, borderRadius: 2 }}
          >
            {isLoading ? 'Loading...' : 'Contact Recruiter'}
          </Button>
        </Box>
      </CardContent>
    </Card>
  );
};

const RecruiterList = ({ 
  searchResults, 
  loading, 
  error, 
  hasSearched,
  onViewDetails, 
  onStartOutreach,
  onLoadMore,
  onPageChange
}) => {
  const theme = useTheme();
  const [currentPage, setCurrentPage] = useState(1);

  const handlePageChange = (event, newPage) => {
    console.log(`📄 Page change requested: ${newPage}`);
    setCurrentPage(newPage);
    
    // Calculate offset for new page
    const limit = searchResults?.pagination?.limit || 20;
    const offset = (newPage - 1) * limit;
    
    // Call the page change handler with proper parameters
    if (onPageChange) {
      onPageChange(newPage, offset);
    } else if (onLoadMore) {
      // Fallback to onLoadMore if onPageChange not provided
      onLoadMore(newPage, offset);
    }
  };

  const handleLoadMore = () => {
    console.log('📄 Load more requested');
    if (onLoadMore) {
      const nextPage = currentPage + 1;
      const limit = searchResults?.pagination?.limit || 20;
      const offset = currentPage * limit; // Current page * limit for next batch
      
      setCurrentPage(nextPage);
      onLoadMore(nextPage, offset);
    }
  };

  // Show loading state
  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>
        <Box sx={{ textAlign: 'center' }}>
          <CircularProgress size={60} sx={{ color: theme.palette.primary.main }} />
          <Typography variant="h6" sx={{ mt: 2, color: 'text.secondary' }}>
            Searching recruiters...
          </Typography>
        </Box>
      </Box>
    );
  }

  // Show error state
  if (error) {
    return (
      <Alert 
        severity="error" 
        sx={{ 
          mb: 3, 
          borderRadius: 2,
          '& .MuiAlert-icon': {
            color: theme.palette.error.main
          }
        }}
      >
        {error}
      </Alert>
    );
  }

  // Show empty state only if user has searched
  if (hasSearched && (!searchResults || !searchResults.recruiters || searchResults.recruiters.length === 0)) {
    return (
      <Paper elevation={0} sx={{ textAlign: 'center', py: 8, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
        <PersonIcon sx={{ fontSize: 64, color: 'text.disabled', mb: 2 }} />
        <Typography variant="h6" gutterBottom>
          No recruiters found
        </Typography>
        <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
          Try adjusting your search criteria or filters to find more results.
        </Typography>
        <Button 
          variant="outlined" 
          onClick={() => window.location.reload()}
          sx={{ borderRadius: 2 }}
        >
          Reset Search
        </Button>
      </Paper>
    );
  }

  // Don't show anything if no search has been performed
  if (!hasSearched) {
    return null;
  }

  const { recruiters, pagination } = searchResults;
  const totalPages = Math.ceil(pagination.total / pagination.limit);

  console.log('🔍 RecruiterList render:', {
    recruitersCount: recruiters?.length,
    currentPage,
    totalPages,
    pagination
  });

  return (
    <Box>
      {/* Results Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <WorkIcon sx={{ color: theme.palette.primary.main }} />
          {pagination.total.toLocaleString()} Recruiters Found
        </Typography>
      </Box>

      {/* Recruiter Grid */}
      <Grid container spacing={3}>
        {recruiters.map((recruiter) => (
          <Grid item xs={12} sm={6} lg={4} key={recruiter.id}>
            <RecruiterCard
              recruiter={recruiter}
              onViewDetails={onViewDetails}
              onStartOutreach={onStartOutreach}
              onLoadMore={onLoadMore}
            />
          </Grid>
        ))}
      </Grid>

      {/* Pagination - Only show if more than one page */}
      {totalPages > 1 && (
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
          <Pagination
            count={totalPages}
            page={currentPage}
            onChange={handlePageChange}
            color="primary"
            size="large"
            showFirstButton
            showLastButton
            sx={{
              '& .MuiPaginationItem-root': {
                borderRadius: 2
              }
            }}
          />
        </Box>
      )}

      {/* Load More Button (Alternative to pagination) - REMOVED */}
      {/* This section has been removed as requested */}

      {/* Results Summary - SIMPLIFIED */}
      <Paper 
        elevation={0}
        sx={{ 
          mt: 3, 
          p: 2, 
          borderRadius: 2, 
          textAlign: 'center',
          border: `1px solid ${theme.palette.divider}`,
          bgcolor: theme.palette.grey[50]
        }}
      >
        <Typography variant="body2" color="text.secondary">
          Showing {recruiters.length} of {pagination.total.toLocaleString()} recruiters
        </Typography>
      </Paper>
    </Box>
  );
};

export default RecruiterList;

================
File: src/components/recruiters/RecruiterPage.js
================
// src/components/recruiters/RecruiterPage.js - UPDATED WITH PAGINATION AND BADGE COUNT
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Container,
  Typography,
  Tabs,
  Tab,
  Alert,
  Snackbar,
  Tooltip,
  Badge
} from '@mui/material';
import {
  Search as SearchIcon,
  Message as MessageIcon,
  Analytics as AnalyticsIcon,
  TrendingUp as TrendingUpIcon,
  People as PeopleIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import MainLayout from '../layout/MainLayout';
import PageHeader from '../common/PageHeader';
import RecruiterSearch from './RecruiterSearch';
import RecruiterList from './RecruiterList';
import RecruiterDetails from './RecruiterDetails';
import OutreachComposer from './OutreachComposer';
import OutreachTracker from './OutreachTracker';
import recruiterService from '../../utils/recruiterService';

const TabPanel = ({ children, value, index, ...other }) => (
  <div
    role="tabpanel"
    hidden={value !== index}
    id={`recruiter-tabpanel-${index}`}
    aria-labelledby={`recruiter-tab-${index}`}
    {...other}
  >
    {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
  </div>
);

const RecruiterPage = () => {
  const theme = useTheme();
  
  // Tab state
  const [activeTab, setActiveTab] = useState(0);
  
  // Search state
  const [searchResults, setSearchResults] = useState(null);
  const [searchLoading, setSearchLoading] = useState(false);
  const [searchError, setSearchError] = useState('');
  const [hasSearched, setHasSearched] = useState(false);
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [currentSearchParams, setCurrentSearchParams] = useState(null);
  
  // Dialog state
  const [selectedRecruiter, setSelectedRecruiter] = useState(null);
  const [showRecruiterDetails, setShowRecruiterDetails] = useState(false);
  const [showOutreachComposer, setShowOutreachComposer] = useState(false);
  
  // Outreach state - Load immediately for badge count
  const [outreachCampaigns, setOutreachCampaigns] = useState([]);
  const [outreachLoading, setOutreachLoading] = useState(false);
  const [analytics, setAnalytics] = useState(null);
  
  // Notification state
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  // Refs for component communication
  const searchRef = useRef(null);

  // Load initial data immediately when component mounts
  useEffect(() => {
    // Always load outreach campaigns for badge count
    loadOutreachCampaigns();
  }, []);

  // Load additional data when tab changes
  useEffect(() => {
    if (activeTab === 2) {
      loadAnalytics();
    }
  }, [activeTab]);

  // Search handlers
  const handleSearchResults = (results, searchParams = null) => {
    console.log('🔍 RecruiterPage: Search results received:', results);
    console.log('🔍 RecruiterPage: Search params received:', searchParams);
    
    setSearchResults(results);
    setSearchError('');
    setHasSearched(true);
    setCurrentPage(1); // Reset to page 1 for new search
    
    // Store search params for pagination (FIXED)
    if (searchParams) {
      setCurrentSearchParams(searchParams);
      console.log('✅ RecruiterPage: Stored search params:', searchParams);
    }
  };

  const handleSearchLoading = (loading) => {
    setSearchLoading(loading);
  };

  const handleSearchError = (error) => {
    setSearchError(error);
    setHasSearched(true);
    showNotification(error, 'error');
  };

  // Pagination handler - this is the key fix
  const handlePageChange = async (page, offset) => {
    console.log(`📄 RecruiterPage: Page change - Page: ${page}, Offset: ${offset}`);
    console.log(`🔍 RecruiterPage: Using stored search params:`, currentSearchParams);
    
    try {
      setSearchLoading(true);
      setCurrentPage(page);
      
      // Use the stored search parameters with pagination (FIXED)
      const searchFilters = {
        ...currentSearchParams, // This now contains the proper search filters
        limit: 20,
        offset: offset
      };
      
      console.log('🔍 RecruiterPage: Performing paginated search:', searchFilters);
      
      const response = await recruiterService.searchRecruiters(searchFilters);
      
      console.log('✅ RecruiterPage: Paginated results received:', response);
      setSearchResults(response);
      
    } catch (error) {
      console.error('❌ RecruiterPage: Pagination failed:', error);
      showNotification('Failed to load more recruiters', 'error');
    } finally {
      setSearchLoading(false);
    }
  };

  // Enhanced search results handler that stores search params
  const handleSearchResultsWithParams = (results, searchParams = null) => {
    console.log('🔍 RecruiterPage: Search results with params:', { results, searchParams });
    
    setSearchResults(results);
    setSearchError('');
    setHasSearched(true);
    setCurrentPage(1);
    
    // Store search parameters for pagination
    if (searchParams) {
      setCurrentSearchParams(searchParams);
    }
  };

  // Load more handler (alternative to pagination)
  const handleLoadMore = async (page, offset) => {
    console.log(`📄 RecruiterPage: Load more - Page: ${page}, Offset: ${offset}`);
    await handlePageChange(page, offset);
  };

  // Recruiter handlers
  const handleViewRecruiterDetails = (recruiter) => {
    setSelectedRecruiter(recruiter);
    setShowRecruiterDetails(true);
  };

  const handleStartOutreach = (recruiter) => {
    setSelectedRecruiter(recruiter);
    setShowOutreachComposer(true);
  };

  // Outreach handlers
  const handleSendOutreach = async (outreachData) => {
    try {
      const response = await recruiterService.createOutreach(outreachData);
      
      // Immediately send the outreach
      await recruiterService.sendOutreach(response.outreach.id);
      
      showNotification('Message sent successfully!', 'success');
      
      // Reload outreach campaigns to update count
      loadOutreachCampaigns();
      
    } catch (error) {
      console.error('Failed to send outreach:', error);
      showNotification('Failed to send message. Please try again.', 'error');
      throw error;
    }
  };

  const handleSaveOutreach = async (outreachData) => {
    try {
      await recruiterService.createOutreach(outreachData);
      showNotification('Draft saved successfully!', 'success');
      
      // Reload outreach campaigns to update count
      loadOutreachCampaigns();
      
    } catch (error) {
      console.error('Failed to save outreach:', error);
      showNotification('Failed to save draft. Please try again.', 'error');
      throw error;
    }
  };

  // Load outreach campaigns
  const loadOutreachCampaigns = async () => {
    try {
      setOutreachLoading(true);
      console.log('📋 Loading outreach campaigns for badge count...');
      
      const response = await recruiterService.getUserOutreach({ limit: 50 });
      const campaigns = response.outreaches || [];
      
      setOutreachCampaigns(campaigns);
      console.log(`✅ Loaded ${campaigns.length} outreach campaigns`);
      
    } catch (error) {
      console.error('Failed to load outreach campaigns:', error);
      // Don't show error notification for initial load, just log it
      if (activeTab === 1) {
        showNotification('Failed to load outreach campaigns', 'error');
      }
    } finally {
      setOutreachLoading(false);
    }
  };

  // Load analytics
  const loadAnalytics = async () => {
    try {
      const response = await recruiterService.getAnalytics('30d');
      setAnalytics(response.analytics);
    } catch (error) {
      console.error('Failed to load analytics:', error);
      showNotification('Failed to load analytics', 'error');
    }
  };

  // Notification helper
  const showNotification = (message, severity = 'success') => {
    setNotification({
      open: true,
      message,
      severity
    });
  };

  // Calculate notification badges
  const getDraftCount = () => {
    return outreachCampaigns.filter(campaign => campaign.status === 'drafted').length;
  };

  const getTotalOutreachCount = () => {
    return outreachCampaigns.length;
  };

  const getUnrepliedCount = () => {
    return outreachCampaigns.filter(campaign => 
      campaign.status === 'sent' && 
      campaign.repliesCount === 0 &&
      Date.now() - new Date(campaign.sentAt).getTime() > 7 * 24 * 60 * 60 * 1000 // 7 days old
    ).length;
  };

  return (
    <MainLayout>
      <Container maxWidth="lg" sx={{ py: 3 }}>
        {/* Page Header */}
        <PageHeader
          title="Recruiter Outreach"
          subtitle="Find and connect with recruiters to accelerate your job search"
          icon={<PeopleIcon />}
        />

        {/* Main Tabs - Match ResumeDetail style */}
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
          <Tabs
            value={activeTab}
            onChange={(e, newValue) => setActiveTab(newValue)}
            variant="scrollable"
            scrollButtons="auto"
            sx={{
              '& .MuiTab-root': {
                minHeight: 48,
                fontSize: '0.875rem',
                fontWeight: 500,
                textTransform: 'none',
                color: theme.palette.text.secondary,
                '&.Mui-selected': {
                  color: theme.palette.primary.main,
                  fontWeight: 600
                }
              },
              '& .MuiTabs-indicator': {
                height: 2,
                backgroundColor: theme.palette.primary.main
              }
            }}
          >
            <Tab
              label="Find Recruiters"
              icon={<SearchIcon />}
              iconPosition="start"
              sx={{ 
                display: 'flex',
                flexDirection: 'row',
                gap: 1
              }}
            />
            <Tab
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <MessageIcon />
                  Outreach Campaigns
                  {getTotalOutreachCount() > 0 && (
                    <Badge 
                      badgeContent={getTotalOutreachCount()} 
                      color="warning" 
                      max={99}
                      sx={{ 
                        ml: 0.5,
                        '& .MuiBadge-badge': {
                          fontSize: '0.75rem',
                          height: 18,
                          minWidth: 18,
                          borderRadius: '9px'
                        }
                      }}
                    />
                  )}
                </Box>
              }
            />
            <Tab
              label="Analytics"
              icon={<AnalyticsIcon />}
              iconPosition="start"
              sx={{ 
                display: 'flex',
                flexDirection: 'row',
                gap: 1
              }}
            />
          </Tabs>
        </Box>

        {/* Tab Content */}
        <TabPanel value={activeTab} index={0}>
          {/* Search Tab */}
          <Box>
            <RecruiterSearch
              ref={searchRef}
              onSearchResults={handleSearchResults}
              onLoading={handleSearchLoading}
              onError={handleSearchError}
              onSearchStateChange={setHasSearched}
            />
            
            <RecruiterList
              searchResults={searchResults}
              loading={searchLoading}
              error={searchError}
              hasSearched={hasSearched}
              onViewDetails={handleViewRecruiterDetails}
              onStartOutreach={handleStartOutreach}
              onLoadMore={handleLoadMore}
              onPageChange={handlePageChange}
            />
          </Box>
        </TabPanel>

        <TabPanel value={activeTab} index={1}>
          {/* Outreach Tab */}
          <OutreachTracker
            campaigns={outreachCampaigns}
            loading={outreachLoading}
            onRefresh={loadOutreachCampaigns}
            onViewRecruiter={handleViewRecruiterDetails}
            onEditCampaign={(campaign) => {
              // Handle editing existing campaign
              setSelectedRecruiter(campaign.recruiter);
              setShowOutreachComposer(true);
            }}
          />
        </TabPanel>

        <TabPanel value={activeTab} index={2}>
          {/* Analytics Tab */}
          <Box>
            {analytics ? (
              <Box>
                {/* Analytics Dashboard */}
                <Typography variant="h5" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 3 }}>
                  <TrendingUpIcon color="primary" />
                  Outreach Performance (Last 30 Days)
                </Typography>
                
                <Box sx={{ 
                  display: 'grid', 
                  gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', 
                  gap: 3, 
                  mb: 4 
                }}>
                  <Box sx={{ 
                    p: 3, 
                    borderRadius: 2, 
                    bgcolor: 'background.paper',
                    border: `1px solid ${theme.palette.divider}`,
                    textAlign: 'center'
                  }}>
                    <Typography variant="h3" color="primary.main" fontWeight="bold">
                      {analytics.totalOutreach || 0}
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Total Outreach
                    </Typography>
                  </Box>
                  
                  <Box sx={{ 
                    p: 3, 
                    borderRadius: 2, 
                    bgcolor: 'background.paper',
                    border: `1px solid ${theme.palette.divider}`,
                    textAlign: 'center'
                  }}>
                    <Typography variant="h3" color="success.main" fontWeight="bold">
                      {analytics.sent || 0}
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Messages Sent
                    </Typography>
                  </Box>
                  
                  <Box sx={{ 
                    p: 3, 
                    borderRadius: 2, 
                    bgcolor: 'background.paper',
                    border: `1px solid ${theme.palette.divider}`,
                    textAlign: 'center'
                  }}>
                    <Typography variant="h3" color="warning.main" fontWeight="bold">
                      {analytics.replied || 0}
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Replies Received
                    </Typography>
                  </Box>
                  
                  <Box sx={{ 
                    p: 3, 
                    borderRadius: 2, 
                    bgcolor: 'background.paper',
                    border: `1px solid ${theme.palette.divider}`,
                    textAlign: 'center'
                  }}>
                    <Typography variant="h3" color="info.main" fontWeight="bold">
                      {analytics.responseRate || 0}%
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Response Rate
                    </Typography>
                  </Box>
                </Box>

                <Alert severity="info" sx={{ borderRadius: 2 }}>
                  <Typography variant="body2">
                    💡 <strong>Pro Tip:</strong> Response rates typically improve with personalized messages. 
                    Try using our AI message generator with your resume and target job information for better results.
                  </Typography>
                </Alert>
              </Box>
            ) : (
              <Box sx={{ textAlign: 'center', py: 8 }}>
                <AnalyticsIcon sx={{ fontSize: 64, color: 'text.disabled', mb: 2 }} />
                <Typography variant="h6" gutterBottom>
                  No analytics data yet
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Start reaching out to recruiters to see your performance metrics here.
                </Typography>
              </Box>
            )}
          </Box>
        </TabPanel>

        {/* Dialogs */}
        <RecruiterDetails
          open={showRecruiterDetails}
          onClose={() => {
            setShowRecruiterDetails(false);
            setSelectedRecruiter(null);
          }}
          recruiterId={selectedRecruiter?.id}
          onStartOutreach={handleStartOutreach}
        />

        <OutreachComposer
          open={showOutreachComposer}
          onClose={() => {
            setShowOutreachComposer(false);
            setSelectedRecruiter(null);
          }}
          recruiter={selectedRecruiter}
          onSend={handleSendOutreach}
          onSave={handleSaveOutreach}
        />

        {/* Notifications */}
        <Snackbar
          open={notification.open}
          autoHideDuration={6000}
          onClose={() => setNotification({ ...notification, open: false })}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert
            onClose={() => setNotification({ ...notification, open: false })}
            severity={notification.severity}
            variant="filled"
            sx={{ borderRadius: 2 }}
          >
            {notification.message}
          </Alert>
        </Snackbar>

        {/* Removed Floating Action Button - conflicts with AI Assistant widget */}
      </Container>
    </MainLayout>
  );
};

export default RecruiterPage;

================
File: src/components/recruiters/RecruiterSearch.js
================
// src/components/recruiters/RecruiterSearch.js - FIXED WITH PAGINATION SUPPORT
import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Grid,
  Typography,
  Autocomplete,
  Chip,
  Paper,
  Collapse,
  IconButton,
  Divider,
  Alert,
  CircularProgress,
  Badge
} from '@mui/material';
import {
  Search as SearchIcon,
  FilterList as FilterIcon,
  Clear as ClearIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Work as WorkIcon,
  Business as BusinessIcon,
  Person as PersonIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';

const RecruiterSearch = ({ onSearchResults, onLoading, onError, onSearchStateChange }) => {
  const theme = useTheme();
  
  // Search state - NO LOCATION FILTER
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState({
    company: null,
    industry: null,
    title: ''
  });
  
  // UI state
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const [isSearching, setIsSearching] = useState(false);
  const [searchCount, setSearchCount] = useState(0);
  
  // Store current search parameters for pagination
  const [currentSearchParams, setCurrentSearchParams] = useState(null);
  
  // Filter options - NO LOCATIONS
  const [filterOptions, setFilterOptions] = useState({
    companies: [],
    industries: []
  });
  const [filterOptionsLoading, setFilterOptionsLoading] = useState(true);

  // Load filter options on component mount
  useEffect(() => {
    loadFilterOptions();
  }, []);

  const loadFilterOptions = async () => {
    try {
      setFilterOptionsLoading(true);
      const response = await recruiterService.getFilterOptions();
      setFilterOptions(response.filterOptions);
    } catch (error) {
      console.error('Failed to load filter options:', error);
      onError?.('Failed to load search filters');
    } finally {
      setFilterOptionsLoading(false);
    }
  };

  // Debounced search function with pagination support
  const performSearch = useCallback(async (searchParams = {}, page = 1, offset = 0) => {
    try {
      setIsSearching(true);
      onLoading?.(true);
      onSearchStateChange?.(true);
      
      const searchFilters = {
        query: searchQuery,
        company: filters.company?.name || '',
        industry: filters.industry?.name || '',
        title: filters.title || '',
        ...searchParams, // This should override the above if provided
        limit: 20,
        offset: offset
      };

      console.log('🔍 Performing search with filters:', searchFilters);
      console.log(`📄 Page: ${page}, Offset: ${offset}`);
      
      // Store current search params for pagination (FIXED)
      const paramsToStore = {
        query: searchFilters.query,
        company: searchFilters.company,
        industry: searchFilters.industry,
        title: searchFilters.title
      };
      setCurrentSearchParams(paramsToStore);
      
      const response = await recruiterService.searchRecruiters(searchFilters);
      
      setSearchCount(response.pagination.total);
      
      // Pass search parameters along with results (FIXED)
      if (onSearchResults) {
        // Add the search parameters to the callback
        onSearchResults(response, paramsToStore);
      }
      
    } catch (error) {
      console.error('Search failed:', error);
      onError?.('Search failed. Please try again.');
    } finally {
      setIsSearching(false);
      onLoading?.(false);
    }
  }, [searchQuery, filters, onSearchResults, onLoading, onError, onSearchStateChange]);

  // Handle search button click
  const handleSearch = () => {
    performSearch({}, 1, 0); // Reset to page 1
  };

  // Handle pagination from RecruiterList
  const handlePageChange = useCallback((page, offset) => {
    console.log(`🔄 RecruiterSearch: Page change requested - Page: ${page}, Offset: ${offset}`);
    
    if (currentSearchParams) {
      // Use stored search parameters for pagination
      performSearch(currentSearchParams, page, offset);
    } else {
      // Fallback: perform new search with current filters
      performSearch({}, page, offset);
    }
  }, [currentSearchParams, performSearch]);

  // Expose pagination handler to parent component
  React.useImperativeHandle(React.forwardRef(() => null), () => ({
    handlePageChange
  }));

  // Make pagination handler available to parent
  React.useEffect(() => {
    if (onSearchResults && typeof onSearchResults === 'function') {
      // Add pagination handler as a property to the callback
      onSearchResults.handlePageChange = handlePageChange;
    }
  }, [handlePageChange, onSearchResults]);

  // Handle filter changes with proper null handling
  const handleFilterChange = (filterName, value) => {
    setFilters(prev => ({
      ...prev,
      [filterName]: value
    }));
  };

  // Reset entire search state
  const resetSearchState = () => {
    setSearchQuery('');
    setFilters({
      company: null,
      industry: null,
      title: ''
    });
    setSearchCount(0);
    setShowAdvancedFilters(false);
    setCurrentSearchParams(null);
    onSearchStateChange?.(false);
    onSearchResults?.(null);
  };

  // Clear search query (X button)
  const clearSearchQuery = () => {
    setSearchQuery('');
    // If there are no other filters, reset everything
    if (!hasActiveFiltersExceptQuery()) {
      resetSearchState();
    }
  };

  // Refresh search with current parameters
  const refreshSearch = () => {
    performSearch({}, 1, 0); // Reset to page 1
  };

  // Check if any filters are applied (excluding search query)
  const hasActiveFiltersExceptQuery = () => {
    return filters.company || 
           filters.industry || 
           filters.title;
  };

  // Check if any filters are applied (including search query)
  const hasActiveFilters = () => {
    return searchQuery || hasActiveFiltersExceptQuery();
  };

  // Expose the pagination handler to parent components
  React.useEffect(() => {
    // Create a custom property on the component to expose pagination
    if (typeof window !== 'undefined') {
      window.recruiterSearchPagination = handlePageChange;
    }
    
    return () => {
      if (typeof window !== 'undefined') {
        delete window.recruiterSearchPagination;
      }
    };
  }, [handlePageChange]);

  return (
    <Paper elevation={0} sx={{ mb: 3, border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
      <CardContent sx={{ p: 3 }}>
        {/* Main Search Bar */}
        <Box sx={{ mb: 3 }}>
          <Typography variant="h5" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
            <SearchIcon sx={{ color: theme.palette.primary.main }} />
            Find Recruiters
            {searchCount > 0 && (
              <Chip 
                label={`${searchCount.toLocaleString()} found`} 
                size="small" 
                color="primary" 
                variant="outlined"
                sx={{ borderRadius: 1 }}
              />
            )}
          </Typography>
          
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} md={8}>
              <TextField
                fullWidth
                variant="outlined"
                placeholder="Search by name, company, title, or keywords..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
                InputProps={{
                  startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                  endAdornment: searchQuery && (
                    <IconButton size="small" onClick={clearSearchQuery}>
                      <ClearIcon />
                    </IconButton>
                  )
                }}
                sx={{ 
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2
                  }
                }}
              />
            </Grid>
            
            <Grid item xs={12} md={4}>
              <Box sx={{ display: 'flex', gap: 1 }}>
                <Button
                  variant="contained"
                  onClick={handleSearch}
                  disabled={isSearching}
                  startIcon={isSearching ? <CircularProgress size={16} color="inherit" /> : <SearchIcon />}
                  sx={{ borderRadius: 2, minWidth: 120 }}
                >
                  {isSearching ? 'Searching...' : 'Search'}
                </Button>
                
                <Badge 
                  badgeContent={hasActiveFilters() ? '●' : 0} 
                  color="secondary"
                  variant="dot"
                >
                  <Button
                    variant="outlined"
                    onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
                    startIcon={<FilterIcon />}
                    endIcon={showAdvancedFilters ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                    sx={{ borderRadius: 2 }}
                  >
                    Filters
                  </Button>
                </Badge>
              </Box>
            </Grid>
          </Grid>
        </Box>

        {/* Advanced Filters */}
        <Collapse in={showAdvancedFilters}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              bgcolor: theme.palette.grey[50],
              border: `1px solid ${theme.palette.divider}`
            }}
          >
            <Typography variant="subtitle1" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <FilterIcon sx={{ color: theme.palette.primary.main }} />
              Advanced Filters
            </Typography>
            
            <Grid container spacing={3}>
              {/* Company Filter */}
              <Grid item xs={12} md={6} lg={4}>
                <Autocomplete
                  options={filterOptions.companies}
                  getOptionLabel={(option) => option?.name || ''}
                  value={filters.company}
                  onChange={(e, value) => handleFilterChange('company', value)}
                  loading={filterOptionsLoading}
                  isOptionEqualToValue={(option, value) => option?.name === value?.name}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="Company"
                      placeholder="Select company..."
                      size="small"
                      InputProps={{
                        ...params.InputProps,
                        startAdornment: <BusinessIcon sx={{ mr: 1, color: 'text.secondary', fontSize: '1.2rem' }} />
                      }}
                    />
                  )}
                  renderOption={(props, option) => (
                    <Box component="li" {...props} key={option.name}>
                      <Box>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>{option.name}</Typography>
                        <Typography variant="caption" color="text.secondary">
                          {option.count} recruiters
                        </Typography>
                      </Box>
                    </Box>
                  )}
                />
              </Grid>

              {/* Industry Filter */}
              <Grid item xs={12} md={6} lg={4}>
                <Autocomplete
                  options={filterOptions.industries}
                  getOptionLabel={(option) => option?.name || ''}
                  value={filters.industry}
                  onChange={(e, value) => handleFilterChange('industry', value)}
                  loading={filterOptionsLoading}
                  isOptionEqualToValue={(option, value) => option?.name === value?.name}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="Industry"
                      placeholder="Select industry..."
                      size="small"
                      InputProps={{
                        ...params.InputProps,
                        startAdornment: <WorkIcon sx={{ mr: 1, color: 'text.secondary', fontSize: '1.2rem' }} />
                      }}
                    />
                  )}
                  renderOption={(props, option) => (
                    <Box component="li" {...props} key={option.name}>
                      <Box>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>{option.name}</Typography>
                        <Typography variant="caption" color="text.secondary">
                          {option.count} recruiters
                        </Typography>
                      </Box>
                    </Box>
                  )}
                />
              </Grid>

              {/* Title Filter */}
              <Grid item xs={12} md={6} lg={4}>
                <TextField
                  fullWidth
                  size="small"
                  label="Job Title"
                  placeholder="e.g., Technical Recruiter"
                  value={filters.title}
                  onChange={(e) => handleFilterChange('title', e.target.value)}
                  InputProps={{
                    startAdornment: <PersonIcon sx={{ mr: 1, color: 'text.secondary', fontSize: '1.2rem' }} />
                  }}
                />
              </Grid>
            </Grid>

            <Divider sx={{ my: 2 }} />

            {/* Filter Actions */}
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <Box sx={{ display: 'flex', gap: 1 }}>
                {hasActiveFilters() && (
                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={resetSearchState}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Reset All
                  </Button>
                )}
              </Box>
              
              <Button
                variant="contained"
                onClick={handleSearch}
                disabled={isSearching}
                startIcon={isSearching ? <CircularProgress size={16} color="inherit" /> : <SearchIcon />}
                sx={{ borderRadius: 2 }}
              >
                Apply Filters
              </Button>
            </Box>

            {/* Active Filters Display */}
            {hasActiveFilters() && (
              <Box sx={{ mt: 2 }}>
                <Typography variant="caption" color="text.secondary" gutterBottom display="block" sx={{ mb: 1 }}>
                  Active Filters:
                </Typography>
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {searchQuery && (
                    <Chip
                      label={`Search: "${searchQuery}"`}
                      size="small"
                      onDelete={() => setSearchQuery('')}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                  {filters.company && (
                    <Chip
                      label={`Company: ${filters.company.name}`}
                      size="small"
                      onDelete={() => handleFilterChange('company', null)}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                  {filters.industry && (
                    <Chip
                      label={`Industry: ${filters.industry.name}`}
                      size="small"
                      onDelete={() => handleFilterChange('industry', null)}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                  {filters.title && (
                    <Chip
                      label={`Title: ${filters.title}`}
                      size="small"
                      onDelete={() => handleFilterChange('title', '')}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                </Box>
              </Box>
            )}
          </Paper>
        </Collapse>

        {/* Search Tips */}
        {!hasActiveFilters() && (
          <Alert 
            severity="info" 
            sx={{ 
              mt: 2,
              borderRadius: 2,
              '& .MuiAlert-icon': {
                color: theme.palette.info.main
              }
            }}
          >
            <Typography variant="body2">
              💡 <strong>Search Tips:</strong> Use specific keywords like "Technical Recruiter", company names, or job titles. 
              Try filtering by industry for better results.
            </Typography>
          </Alert>
        )}
      </CardContent>
      
      {/* Export pagination handler for parent component */}
      <div style={{ display: 'none' }} data-pagination-handler={handlePageChange} />
    </Paper>
  );
};

// Add pagination handler as a static method
RecruiterSearch.handlePageChange = null;

export default RecruiterSearch;

================
File: src/components/resumes/components/AiEditingToolbar.js
================
// src/components/resumes/components/AiEditingToolbar.js - FIXED PROGRESS DISPLAY
import React from 'react';
import {
  Box,
  Typography,
  Paper,
  Button,
  ButtonGroup,
  Chip,
  Grid,
  LinearProgress,
  useTheme
} from '@mui/material';
import {
  Chat as ChatIcon,
  AutoFixHigh as AutoFixHighIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

/**
 * AI editing toolbar component with enhanced progress tracking
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {function} props.onQuickAction - Quick action handler
 * @param {function} props.onOpenChat - Open chat handler
 * @param {boolean} props.aiProcessing - AI processing state
 * @param {string} props.progressStage - Current progress stage message
 * @param {number} props.progressPercentage - Progress percentage (0-100)
 * @returns {JSX.Element} AI editing toolbar component
 */
const AiEditingToolbar = ({ 
  resume, 
  onQuickAction, 
  onOpenChat, 
  aiProcessing, 
  progressStage, 
  progressPercentage 
}) => {
  const theme = useTheme();
  
  // Ensure progress percentage is valid for MUI LinearProgress
  const validProgressPercentage = Math.max(0, Math.min(100, progressPercentage || 0));

  return (
    <Paper 
      elevation={3} 
      sx={{ 
        p: 2, 
        mb: 3, 
        borderRadius: 3,
        background: `linear-gradient(135deg, ${theme.palette.primary.main}10 0%, ${theme.palette.secondary.main}10 100%)`,
        border: `1px solid ${theme.palette.primary.main}30`
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <AutoJobLogo variant="icon-only" size="small" />
        <Typography variant="h6" sx={{ ml: 1, fontWeight: 600 }}>
          AI Job Assistant
        </Typography>
        <Chip 
          label="Powered by AJ" 
          size="small" 
          color="primary" 
          sx={{ ml: 2 }}
        />
      </Box>

      {aiProcessing && (
        <Box sx={{ mb: 2 }}>
          <LinearProgress 
            variant="determinate" 
            value={validProgressPercentage} 
            sx={{ 
              borderRadius: 1,
              height: 8,
              '& .MuiLinearProgress-bar': {
                borderRadius: 1,
                background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.secondary.main} 100%)`
              }
            }} 
          />
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mt: 1 }}>
            <Typography 
              variant="caption" 
              color="text.secondary"
              sx={{ 
                fontWeight: 500,
                maxWidth: '75%',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
              }}
            >
              {progressStage || 'AJ is improving your resume...'}
            </Typography>
            <Typography variant="caption" color="primary" fontWeight="medium">
              {Math.round(validProgressPercentage)}%
            </Typography>
          </Box>
        </Box>
      )}

      <Grid container spacing={2} alignItems="center">
        <Grid item xs={12} md={8}>
          <Typography variant="body2" color="text.secondary">
            Let AJ analyze and optimize your resume for better ATS compatibility and job matching.
          </Typography>
        </Grid>
        
        <Grid item xs={12} md={4}>
          <ButtonGroup variant="contained" fullWidth>
            <Button
              startIcon={<ChatIcon />}
              onClick={onOpenChat}
              disabled={aiProcessing}
              sx={{ flexGrow: 1 }}
            >
              Edit with AJ
            </Button>
            <Button
              startIcon={<AutoFixHighIcon />}
              onClick={() => onQuickAction('Auto-Fix for ATS')}
              disabled={aiProcessing}
              color="secondary"
            >
              Auto-Fix for ATS
            </Button>
          </ButtonGroup>
        </Grid>
      </Grid>
    </Paper>
  );
};

export default AiEditingToolbar;

================
File: src/components/resumes/components/BeforeAfterComparison.js
================
// src/components/resumes/components/BeforeAfterComparison.js - FIXED READABILITY
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Card,
  CardContent,
  Grid,
  Chip,
  IconButton,
  Tabs,
  Tab,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Alert
} from '@mui/material';
import {
  Close as CloseIcon,
  TrendingUp as TrendingUpIcon,
  CheckCircle as CheckCircleIcon,
  ArrowForward as ArrowForwardIcon,
  Timeline as TimelineIcon,
  Work as WorkIcon,
  Code as CodeIcon
} from '@mui/icons-material';

/**
 * Before/After Comparison Dialog Component - FIXED UI READABILITY
 * @param {object} props - Component props
 * @param {boolean} props.open - Dialog open state
 * @param {function} props.onClose - Close dialog handler
 * @param {object} props.comparisonData - Comparison data from backend
 * @returns {JSX.Element} Before/After comparison dialog
 */
const BeforeAfterComparison = ({ open, onClose, comparisonData }) => {
  const [tabValue, setTabValue] = useState(0);

  if (!comparisonData) return null;

  const { scores, changes, summary, summaryText } = comparisonData;

  const TabPanel = ({ children, value, index }) => (
    <div hidden={value !== index}>
      {value === index && <Box sx={{ pt: 2 }}>{children}</Box>}
    </div>
  );

  const renderScoreComparison = () => (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Alert severity="success" sx={{ mb: 3 }}>
          <Typography variant="h6" gutterBottom>
            🎉 Optimization Results
          </Typography>
          <Typography variant="body1">
            {summaryText}
          </Typography>
        </Alert>
      </Grid>
      
      <Grid item xs={12} md={6}>
        <Card variant="outlined" sx={{ textAlign: 'center', p: 2 }}>
          <Typography variant="h6" color="text.secondary" gutterBottom>
            Before Optimization
          </Typography>
          <Box sx={{ display: 'flex', justifyContent: 'space-around', mt: 2 }}>
            <Box>
              <Typography variant="h4" color="warning.main" fontWeight="bold">
                {scores.before.overallScore}
              </Typography>
              <Typography variant="caption" color="text.secondary">
                Overall Score
              </Typography>
            </Box>
            <Box>
              <Typography variant="h4" color="warning.main" fontWeight="bold">
                {scores.before.atsCompatibility}%
              </Typography>
              <Typography variant="caption" color="text.secondary">
                ATS Score
              </Typography>
            </Box>
          </Box>
        </Card>
      </Grid>

      <Grid item xs={12} md={6}>
        <Card variant="outlined" sx={{ 
          textAlign: 'center', 
          p: 2, 
          bgcolor: 'success.light', 
          border: '2px solid',
          borderColor: 'success.main'
        }}>
          <Typography variant="h6" gutterBottom sx={{ color: 'success.dark', fontWeight: 600 }}>
            After Optimization
          </Typography>
          <Box sx={{ display: 'flex', justifyContent: 'space-around', mt: 2 }}>
            <Box>
              <Typography variant="h4" sx={{ color: 'success.dark', fontWeight: 'bold' }}>
                {scores.after.overallScore}
              </Typography>
              <Typography variant="caption" sx={{ color: 'success.dark', fontWeight: 500 }}>
                Overall Score
              </Typography>
            </Box>
            <Box>
              <Typography variant="h4" sx={{ color: 'success.dark', fontWeight: 'bold' }}>
                {scores.after.atsCompatibility}%
              </Typography>
              <Typography variant="caption" sx={{ color: 'success.dark', fontWeight: 500 }}>
                ATS Score
              </Typography>
            </Box>
          </Box>
          {(scores.after.atsCompatibility - scores.before.atsCompatibility) > 0 && (
            <Chip 
              icon={<TrendingUpIcon />}
              label={`+${scores.after.atsCompatibility - scores.before.atsCompatibility}% improvement`}
              color="success"
              variant="outlined"
              sx={{ 
                mt: 2,
                bgcolor: 'white',
                color: 'success.dark',
                fontWeight: 600,
                '& .MuiChip-icon': {
                  color: 'success.main'
                }
              }}
            />
          )}
        </Card>
      </Grid>

      <Grid item xs={12}>
        <Card variant="outlined" sx={{ p: 2 }}>
          <Typography variant="h6" gutterBottom>
            📊 Summary Statistics
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h5" color="primary" fontWeight="bold">
                  {summary.sectionsModified}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Sections Enhanced
                </Typography>
              </Box>
            </Grid>
            <Grid item xs={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h5" color="primary" fontWeight="bold">
                  {summary.improvementsCount}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Improvements Made
                </Typography>
              </Box>
            </Grid>
            <Grid item xs={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h5" color="primary" fontWeight="bold">
                  {summary.keywordsAdded}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Keywords Added
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </Card>
      </Grid>
    </Grid>
  );

  const renderDetailedChanges = () => (
    <Box>
      {changes.map((change, index) => (
        <Card key={index} variant="outlined" sx={{ mb: 3 }}>
          <CardContent>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
              {change.section === 'experience' ? <WorkIcon color="primary" /> : <CodeIcon color="primary" />}
              <Box sx={{ ml: 1 }}>
                <Typography variant="h6" color="primary">
                  {change.section === 'experience' ? 'Work Experience' : 'Skills'} Enhancement
                </Typography>
                {change.jobTitle && (
                  <Typography variant="body2" color="text.secondary">
                    {change.jobTitle} at {change.company}
                  </Typography>
                )}
              </Box>
              <Box sx={{ ml: 'auto' }}>
                <Chip 
                  label={change.changeType} 
                  color="primary" 
                  size="small"
                  sx={{ textTransform: 'capitalize' }}
                />
              </Box>
            </Box>

            <Typography variant="body2" color="text.secondary" gutterBottom>
              {change.impact}
            </Typography>

            <Divider sx={{ my: 2 }} />

            {change.field === 'highlights' ? (
              <Box>
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" color="error.main" gutterBottom>
                      Before:
                    </Typography>
                    <List dense>
                      {change.before.map((item, idx) => (
                        <ListItem key={idx} sx={{ pl: 0, py: 0.5 }}>
                          <ListItemText 
                            primary={item}
                            sx={{ 
                              '& .MuiListItemText-primary': { 
                                fontSize: '0.875rem',
                                bgcolor: 'rgba(255, 0, 0, 0.05)',
                                p: 1,
                                borderRadius: 1,
                                border: '1px solid rgba(255, 0, 0, 0.2)'
                              }
                            }}
                          />
                        </ListItem>
                      ))}
                    </List>
                  </Grid>
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" color="success.main" gutterBottom>
                      After:
                    </Typography>
                    <List dense>
                      {change.after.map((item, idx) => (
                        <ListItem key={idx} sx={{ pl: 0, py: 0.5 }}>
                          <ListItemIcon sx={{ minWidth: 32 }}>
                            <CheckCircleIcon fontSize="small" color="success" />
                          </ListItemIcon>
                          <ListItemText 
                            primary={item}
                            sx={{ 
                              '& .MuiListItemText-primary': { 
                                fontSize: '0.875rem',
                                bgcolor: 'rgba(0, 255, 0, 0.05)',
                                p: 1,
                                borderRadius: 1,
                                border: '1px solid rgba(0, 255, 0, 0.2)'
                              }
                            }}
                          />
                        </ListItem>
                      ))}
                    </List>
                  </Grid>
                </Grid>
              </Box>
            ) : (
              <Box>
                <Typography variant="subtitle2" color="error.main" gutterBottom>
                  Before:
                </Typography>
                <Typography variant="body2" sx={{ 
                  bgcolor: 'rgba(255, 0, 0, 0.05)', 
                  p: 2, 
                  borderRadius: 1,
                  border: '1px solid rgba(255, 0, 0, 0.2)',
                  mb: 2
                }}>
                  {change.before}
                </Typography>
                
                <Typography variant="subtitle2" color="success.main" gutterBottom>
                  After:
                </Typography>
                <Typography variant="body2" sx={{ 
                  bgcolor: 'rgba(0, 255, 0, 0.05)', 
                  p: 2, 
                  borderRadius: 1,
                  border: '1px solid rgba(0, 255, 0, 0.2)'
                }}>
                  {change.after}
                </Typography>
              </Box>
            )}
          </CardContent>
        </Card>
      ))}

      {changes.length === 0 && (
        <Alert severity="info">
          <Typography variant="body1">
            No detailed changes to display. The optimization focused on overall improvements and keyword enhancements.
          </Typography>
        </Alert>
      )}
    </Box>
  );

  return (
    <Dialog 
      open={open} 
      onClose={onClose} 
      maxWidth="lg" 
      fullWidth
      PaperProps={{
        sx: { borderRadius: 3, maxHeight: '90vh' }
      }}
    >
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <TimelineIcon color="primary" sx={{ mr: 1 }} />
          <Typography variant="h5" fontWeight="bold">
            ATS Optimization Results
          </Typography>
        </Box>
        <IconButton onClick={onClose} size="small">
          <CloseIcon />
        </IconButton>
      </DialogTitle>

      <DialogContent>
        <Tabs 
          value={tabValue} 
          onChange={(e, newValue) => setTabValue(newValue)}
          sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}
        >
          <Tab 
            label="Score Comparison" 
            icon={<TrendingUpIcon />} 
            iconPosition="start"
          />
          <Tab 
            label="Detailed Changes" 
            icon={<CheckCircleIcon />} 
            iconPosition="start"
          />
        </Tabs>

        <TabPanel value={tabValue} index={0}>
          {renderScoreComparison()}
        </TabPanel>

        <TabPanel value={tabValue} index={1}>
          {renderDetailedChanges()}
        </TabPanel>
      </DialogContent>

      <DialogActions sx={{ p: 3 }}>
        <Button 
          onClick={onClose} 
          variant="contained" 
          startIcon={<CheckCircleIcon />}
          size="large"
        >
          Got it!
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default BeforeAfterComparison;

================
File: src/components/resumes/components/ProcessingView.js
================
// src/components/resumes/components/ProcessingView.js
import React from 'react';
import {
  Box,
  Typography,
  Button,
  Card,
  CardContent,
  CircularProgress,
  Divider
} from '@mui/material';
import { ArrowBack as ArrowBackIcon } from '@mui/icons-material';
import MainLayout from '../../layout/MainLayout';

/**
 * Processing view component shown while resume is being analyzed
 * @param {object} props - Component props
 * @param {function} props.navigate - Navigation function
 * @returns {JSX.Element} Processing view component
 */
const ProcessingView = ({ navigate }) => {
  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/resumes')}
          sx={{ mb: 3 }}
        >
          Back to Resumes
        </Button>
        
        <Card sx={{ maxWidth: 700, mx: 'auto', borderRadius: 3 }}>
          <CardContent sx={{ textAlign: 'center', py: 5 }}>
            <CircularProgress size={80} thickness={4} sx={{ mb: 3 }} />
            <Typography variant="h5" gutterBottom fontWeight={500}>
              Processing Your Resume
            </Typography>
            <Typography variant="body1" sx={{ mb: 4, color: 'text.secondary' }}>
              Our AI is currently analyzing your resume. This process may take a few minutes.
            </Typography>
            <Divider sx={{ my: 2 }} />
            <Typography variant="body2" color="primary">
              This page will automatically update when processing is complete.
            </Typography>
          </CardContent>
        </Card>
      </Box>
    </MainLayout>
  );
};

export default ProcessingView;

================
File: src/components/resumes/components/ScoreDisplay.js
================
// src/components/resumes/components/ScoreDisplay.js
import React from 'react';
import {
  Box,
  Typography,
  CircularProgress,
  useTheme
} from '@mui/material';
import { getScoreColor } from '../utils/resumeHelpers';

/**
 * Circular progress score display component
 * @param {object} props - Component props
 * @param {number} props.value - Score value (0-100)
 * @param {string} props.label - Score label
 * @param {number} props.size - Circle size in pixels
 * @returns {JSX.Element} Score display component
 */
const ScoreDisplay = ({ value, label, size = 100 }) => {
  const theme = useTheme();
  const color = getScoreColor(value, theme);

  return (
    <Box sx={{ position: 'relative', display: 'inline-flex' }}>
      <CircularProgress
        variant="determinate"
        size={size}
        thickness={5}
        value={100}
        sx={{ color: color, opacity: 0.2, position: 'absolute' }}
      />
      <CircularProgress
        variant="determinate"
        size={size}
        thickness={5}
        value={value}
        sx={{ color: color }}
      />
      <Box
        sx={{
          position: 'absolute',
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column'
        }}
      >
        <Typography variant="h4" fontWeight="bold" color={color}>
          {Math.round(value)}
        </Typography>
        <Typography variant="caption" color="text.secondary">
          {label}
        </Typography>
      </Box>
    </Box>
  );
};

export default ScoreDisplay;

================
File: src/components/resumes/components/TabPanel.js
================
// src/components/resumes/components/TabPanel.js
import React from 'react';
import { Box } from '@mui/material';

/**
 * Generic tab panel wrapper component
 * @param {object} props - Component props
 * @param {React.ReactNode} props.children - Tab content
 * @param {number} props.value - Current tab value
 * @param {number} props.index - Tab index
 * @returns {JSX.Element} Tab panel component
 */
const TabPanel = ({ children, value, index, ...other }) => (
  <div
    role="tabpanel"
    hidden={value !== index}
    id={`resume-tabpanel-${index}`}
    aria-labelledby={`resume-tab-${index}`}
    {...other}
  >
    {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
  </div>
);

export default TabPanel;

================
File: src/components/resumes/hooks/useAiIntegration.js
================
// src/components/resumes/hooks/useAiIntegration.js - COMPLETE FIXED VERSION WITH ANALYSIS REFRESH
import { useState, useEffect, useCallback, useRef } from 'react';
import { useAiAssistant } from '../../../context/AiAssistantContext';
import axios from '../../../utils/axios';

/**
 * Custom hook for AI integration functionality with REAL SSE progress tracking and ANALYSIS REFRESH
 * @param {object} resume - Resume data object
 * @param {function} fetchResumeDetails - Function to refresh resume data
 * @returns {object} AI processing states and functions
 */
export const useAiIntegration = (resume, fetchResumeDetails) => {
  const [aiProcessing, setAiProcessing] = useState(false);
  const [aiSuccess, setAiSuccess] = useState('');
  const [progressPercentage, setProgressPercentage] = useState(0);
  const [progressStage, setProgressStage] = useState('');
  const [comparisonData, setComparisonData] = useState(null);
  
  // SSE connection ref
  const eventSourceRef = useRef(null);
  
  // Safely get AI assistant functions
  let setAiOpen = () => {};
  let updateContextFromLocation = () => {};
  
  try {
    const aiAssistant = useAiAssistant();
    setAiOpen = aiAssistant?.setIsOpen || (() => {});
    updateContextFromLocation = aiAssistant?.updateContextFromLocation || (() => {});
    
    // Log available functions for debugging
    console.log('Available AI functions:', Object.keys(aiAssistant));
  } catch (error) {
    console.warn('AI Assistant not available:', error);
  }

  // Cleanup SSE connection on unmount
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        console.log('🧹 Cleaning up SSE connection on unmount');
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
    };
  }, []);

  // Trigger context update when resume changes
  useEffect(() => {
    if (resume && updateContextFromLocation) {
      // Use the existing context update function
      updateContextFromLocation();
      console.log('Updated AI context for resume:', resume.name);
    }
  }, [resume, updateContextFromLocation]);

  // 🔥 CRITICAL FIX: Listen for AI resume updates AND refresh analysis
  useEffect(() => {
    const handleResumeUpdate = async (event) => {
      if (event.detail?.resumeId === resume?.id) {
        console.log('🔄 Resume update event received, refreshing analysis data...');
        
        // Force a complete refresh of resume data including analysis
        await fetchResumeDetails();
        
        // Show success message
        setAiSuccess(event.detail.message || '✅ AJ updated your resume!');
        
        // 🔥 ENHANCED: If the event includes new analysis data, use it
        if (event.detail.newAnalysis) {
          console.log('📊 New analysis data received:', event.detail.newAnalysis);
          setAiSuccess(prev => prev + `\n📊 New Scores: Overall ${event.detail.newAnalysis.overallScore}%, ATS ${event.detail.newAnalysis.atsCompatibility}%`);
        }
        
        setTimeout(() => setAiSuccess(''), 8000); // Longer timeout for detailed messages
      }
    };

    window.addEventListener('resumeUpdated', handleResumeUpdate);
    return () => window.removeEventListener('resumeUpdated', handleResumeUpdate);
  }, [resume?.id, fetchResumeDetails]);

  /**
   * Start real-time progress tracking via SSE - FIXED VERSION
   */
  const startProgressTracking = useCallback((resumeId) => {
    console.log('🚀 Starting real-time progress tracking via SSE for resume:', resumeId);
    
    // Close existing connection if any
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }

    try {
      // Get auth token for SSE request
      const token = localStorage.getItem('token');
      if (!token) {
        console.error('❌ No auth token available for SSE connection');
        setProgressStage('Authentication required');
        return;
      }

      // 🔧 FIX: Construct the URL properly with backend port
      const baseUrl = process.env.NODE_ENV === 'development' 
        ? 'http://localhost:5000' 
        : window.location.origin;
      
      const sseUrl = `${baseUrl}/api/resumes/${resumeId}/optimization-progress?token=${encodeURIComponent(token)}`;
      console.log('📡 Connecting to SSE URL:', sseUrl);
      
      // 🔧 FIX: Add a small delay to ensure backend is ready
      setTimeout(() => {
        try {
          // Create EventSource connection
          eventSourceRef.current = new EventSource(sseUrl);
          
          eventSourceRef.current.onopen = (event) => {
            console.log('📡 SSE connection opened successfully', event);
            setProgressStage('Connected to progress stream');
          };
          
          eventSourceRef.current.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              console.log('📡 Parsed SSE update:', data);
              
              if (data.type === 'progress') {
                console.log(`📊 Real Progress Update: ${data.percentage}% - ${data.message}`);
                setProgressPercentage(data.percentage);
                setProgressStage(data.message);
                
                // If optimization is complete, we'll handle it in the main API response
                if (data.percentage >= 100) {
                  console.log('✅ SSE Progress Complete - awaiting final API response');
                  setProgressStage('Optimization complete - finalizing...');
                }
              } else if (data.type === 'connected') {
                console.log('📡 SSE Connection confirmed:', data.message);
                setProgressStage('Progress tracking connected');
              } else if (data.type === 'complete') {
                console.log('🎉 SSE Optimization complete signal received');
                setProgressPercentage(100);
                setProgressStage(data.message);
              } else if (data.type === 'error') {
                console.error('❌ SSE Error received:', data.message);
                setProgressStage(`Error: ${data.message}`);
              } else if (data.type === 'heartbeat') {
                // Ignore heartbeat messages, just log them
                console.log('💓 SSE Heartbeat received');
              }
            } catch (parseError) {
              console.error('❌ Error parsing SSE data:', parseError, 'Raw data:', event.data);
            }
          };
          
          eventSourceRef.current.onerror = (error) => {
            console.error('❌ SSE Connection Error:', error);
            console.error('❌ SSE ReadyState:', eventSourceRef.current?.readyState);
            console.error('❌ SSE URL was:', sseUrl);
            
            // 🔧 FIX: Better error handling with specific messages
            const readyState = eventSourceRef.current?.readyState;
            let errorMessage = 'Connection error';
            
            if (readyState === 0) {
              errorMessage = 'Connecting to progress stream...';
            } else if (readyState === 2) {
              errorMessage = 'Connection closed - continuing without live updates';
            } else {
              errorMessage = 'Connection failed - continuing without live updates';
            }
            
            setProgressStage(errorMessage);
            
            // Close and cleanup on error
            if (eventSourceRef.current) {
              eventSourceRef.current.close();
              eventSourceRef.current = null;
            }
          };

          console.log('📡 SSE Connection setup complete');
          
        } catch (connectionError) {
          console.error('❌ Failed to create SSE connection:', connectionError);
          setProgressStage('Failed to connect - continuing without live updates');
        }
      }, 100); // Small delay to ensure everything is ready
      
    } catch (error) {
      console.error('❌ Failed to establish SSE connection:', error);
      setProgressStage('Failed to connect - continuing without live updates');
    }
  }, []);

  /**
   * Stop progress tracking and cleanup SSE connection
   */
  const stopProgressTracking = useCallback(() => {
    console.log('🛑 Stopping progress tracking and closing SSE connection');
    
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
      console.log('📡 SSE connection closed');
    }
  }, []);

  const openAiChat = useCallback(() => {
    try {
      setAiOpen(true);
    } catch (error) {
      console.warn('Cannot open AI chat:', error);
      setAiSuccess('AI Assistant not available. Please check your setup.');
      setTimeout(() => setAiSuccess(''), 3000);
    }
  }, [setAiOpen]);

  const handleQuickAction = useCallback(async (action) => {
    if (!resume) return;
    
    console.log(`🤖 AJ: Starting ${action} with real progress tracking...`);
    
    setAiProcessing(true);
    setProgressPercentage(0);
    setProgressStage('Initializing...');
    setComparisonData(null);
    
    try {
      if (action === 'Auto-Fix for ATS') {
        console.log('🤖 AJ: Starting ATS optimization with real progress...');
        
        // 🔧 FIX: Start SSE connection FIRST, then add delay before API call
        startProgressTracking(resume.id);
        
        // 🔧 FIX: Wait longer to ensure SSE connection is established
        setProgressStage('Connecting to progress stream...');
        await new Promise(resolve => setTimeout(resolve, 1500)); // Increased delay
        
        setProgressStage('Starting ATS optimization...');
        
        // Call the real backend API for ATS optimization
        const response = await axios.post(`/resumes/${resume.id}/optimize-ats`, {
          targetJob: null // Could be enhanced to include specific job targeting
        });
        
console.log('✅ AJ: ATS optimization response:', response.data);
       
       if (response.data.success) {
         const { data } = response.data;
         
         // Store comparison data for before/after dialog
         if (data.comparison) {
           console.log('📊 Setting comparison data for before/after view');
           setComparisonData(data.comparison);
         }
         
         // Show detailed success message with improvement metrics
         const improvementMessage = `✅ ATS Optimization Complete! 
📈 ATS Score: ${data.previousATSScore}% → ${data.newATSScore}% 
🚀 Improvement: +${data.improvementGain}%`;
         
         setAiSuccess(improvementMessage);
         setProgressPercentage(100);
         setProgressStage('Optimization completed successfully!');
         
         // 🔥 CRITICAL FIX: Force complete resume refresh with analysis
         console.log('🔄 Forcing complete resume data refresh with new analysis...');
         await fetchResumeDetails();
         
         // 🔥 ENHANCED: Wait a moment then force another refresh to ensure analysis is updated
         setTimeout(async () => {
           console.log('🔄 Secondary refresh to ensure analysis scores are updated...');
           await fetchResumeDetails();
         }, 2000);
         
         // Dispatch update event with detailed info
         window.dispatchEvent(new CustomEvent('resumeUpdated', {
           detail: { 
             resumeId: resume.id, 
             message: `ATS optimization complete: ${data.newATSScore}% compatibility`,
             atsScore: data.newATSScore,
             improvement: data.improvementGain,
             // 🔥 CRITICAL: Include new analysis data for UI refresh
             newAnalysis: {
               overallScore: data.newATSScore,
               atsCompatibility: data.newATSScore
             }
           }
         }));
         
       } else {
         throw new Error(response.data.message || 'ATS optimization failed');
       }
       
     } else {
       // Handle other actions (if any in the future)
       console.log(`🤖 AJ: Processing action: ${action}`);
       
       // Simulate other actions for now
       setProgressStage('Processing...');
       setProgressPercentage(50);
       await new Promise(resolve => setTimeout(resolve, 2000));
       setProgressPercentage(100);
       setProgressStage('Complete!');
       
       setAiSuccess(`✅ ${action} completed successfully!`);
       
       // 🔥 CRITICAL FIX: Force complete resume refresh for all actions
       await fetchResumeDetails();
       
       window.dispatchEvent(new CustomEvent('resumeUpdated', {
         detail: { resumeId: resume.id, message: `AI completed: ${action}` }
       }));
     }
     
   } catch (error) {
     console.error('❌ AI action failed:', error);
     
     // Enhanced error handling with specific messages
     let errorMessage = '❌ AI action failed. Please try again.';
     
     if (error.response?.status === 401) {
       errorMessage = '❌ Authentication error. Please log in again.';
     } else if (error.response?.status === 404) {
       errorMessage = '❌ Resume not found. Please refresh and try again.';
     } else if (error.response?.status === 500) {
       errorMessage = '❌ Server error. Our AI is temporarily unavailable.';
     } else if (error.response?.data?.message) {
       errorMessage = `❌ ${error.response.data.message}`;
     }
     
     setAiSuccess(errorMessage);
     setProgressStage(errorMessage);
     
   } finally {
     // Always cleanup SSE connection when done
     stopProgressTracking();
     
     setAiProcessing(false);
     setTimeout(() => {
       setAiSuccess('');
       setProgressStage('');
       setProgressPercentage(0);
     }, 8000); // Longer timeout for detailed messages
   }
 }, [resume, fetchResumeDetails, startProgressTracking, stopProgressTracking]);

 return { 
   aiProcessing, 
   aiSuccess, 
   openAiChat, 
   handleQuickAction,
   progressPercentage,
   progressStage,
   comparisonData
 };
};

================
File: src/components/resumes/hooks/useResumeData.js
================
// src/components/resumes/hooks/useResumeData.js - ENHANCED WITH FORCE REFRESH
import { useState, useCallback } from 'react';
import axios from '../../../utils/axios';

/**
 * Custom hook for managing resume data, loading states, and API calls
 * @param {string} id - Resume ID
 * @returns {object} Resume data, loading states, and fetch function
 */
export const useResumeData = (id) => {
  const [resume, setResume] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [processingStatus, setProcessingStatus] = useState('complete');

  const fetchResumeDetails = useCallback(async (isPolling = false, forceRefresh = false) => {
    try {
      if (!isPolling && !forceRefresh) setLoading(true);
      
      console.log(`🔄 Fetching resume details: ${id} (polling: ${isPolling}, force: ${forceRefresh})`);
      
      // 🔥 CRITICAL FIX: Add cache-busting parameter for force refresh
      const url = forceRefresh 
        ? `/resumes/${id}?_t=${Date.now()}` 
        : `/resumes/${id}`;
      
      const response = await axios.get(url);
      const resumeData = response.data.resume || response.data;
      
      console.log('📊 Resume data received:', {
        id: resumeData.id,
        name: resumeData.name,
        hasAnalysis: !!resumeData.analysis,
        overallScore: resumeData.analysis?.overallScore,
        atsCompatibility: resumeData.analysis?.atsCompatibility,
        analysisKeys: resumeData.analysis ? Object.keys(resumeData.analysis) : []
      });
      
      setResume(resumeData);
      
      // Check processing status
      if (resumeData.parsedData?.contactInfo?.name === 'Parsing Error') {
        setProcessingStatus('in-progress');
      } else {
        setProcessingStatus('complete');
      }
      
      setError('');
      
      console.log('✅ Resume data updated in state');
      
    } catch (error) {
      console.error('Error fetching resume details:', error);
      setError('Failed to load resume details. Please try again.');
    } finally {
      if (!isPolling && !forceRefresh) setLoading(false);
    }
  }, [id]);

  // 🔥 NEW: Force refresh function that bypasses cache
  const forceRefreshResume = useCallback(async () => {
    console.log('🔄 Force refreshing resume data...');
    setLoading(true);
    await fetchResumeDetails(false, true);
    setLoading(false);
  }, [fetchResumeDetails]);

  return { 
    resume, 
    loading, 
    error, 
    processingStatus, 
    fetchResumeDetails, 
    forceRefreshResume, // 🔥 NEW: Expose force refresh function
    setResume 
  };
};

================
File: src/components/resumes/ResumeDetail.js
================
// src/components/resumes/ResumeDetail.js - ENHANCED WITH ANALYSIS REFRESH
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  Tabs,
  Tab,
  CircularProgress,
  Alert,
  Snackbar,
  useTheme,
  ButtonGroup,
  Fade,
  Chip
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  Description as DescriptionIcon,
  Lightbulb as LightbulbIcon,
  Person as PersonIcon,
  CloudDownload as CloudDownloadIcon,
  Refresh as RefreshIcon,
  Visibility as VisibilityIcon
} from '@mui/icons-material';
import MainLayout from '../layout/MainLayout';

// Import custom hooks
import { useResumeData } from './hooks/useResumeData';
import { useAiIntegration } from './hooks/useAiIntegration';

// Import components
import TabPanel from './components/TabPanel';
import ProcessingView from './components/ProcessingView';
import AiEditingToolbar from './components/AiEditingToolbar';
import BeforeAfterComparison from './components/BeforeAfterComparison';

// Import tab content components
import OverviewTab from './tabs/OverviewTab';
import AnalysisTab from './tabs/AnalysisTab';
import ContentTab from './tabs/ContentTab';

/**
 * Main ResumeDetail component - now modular and streamlined with progress tracking and ANALYSIS REFRESH
 * Orchestrates all the individual components and manages state
 */
const ResumeDetail = () => {
  const theme = useTheme();
  const { id } = useParams();
  const navigate = useNavigate();
  const [tabValue, setTabValue] = useState(0);
  const [alert, setAlert] = useState({ open: false, message: '', severity: 'success' });
  const [showComparison, setShowComparison] = useState(false);

  // Custom hooks for data and AI integration
  const { 
    resume, 
    loading, 
    error, 
    processingStatus, 
    fetchResumeDetails, 
    forceRefreshResume // 🔥 NEW: Use force refresh function
  } = useResumeData(id);
  
  const { 
    aiProcessing, 
    aiSuccess, 
    openAiChat, 
    handleQuickAction,
    progressStage,
    progressPercentage,
    comparisonData
  } = useAiIntegration(resume, forceRefreshResume); // 🔥 FIXED: Use force refresh

  // Show comparison dialog when optimization completes
  useEffect(() => {
    if (comparisonData && !aiProcessing) {
      setShowComparison(true);
    }
  }, [comparisonData, aiProcessing]);

  // Polling for processing status
  useEffect(() => {
    if (processingStatus === 'in-progress') {
      const pollInterval = setInterval(() => fetchResumeDetails(true), 10000);
      return () => clearInterval(pollInterval);
    }
  }, [processingStatus, fetchResumeDetails]);

  // Initial load
  useEffect(() => {
    fetchResumeDetails();
  }, [fetchResumeDetails]);

  // 🔥 CRITICAL FIX: Enhanced resume update event listener with analysis refresh
  useEffect(() => {
    const handleResumeUpdate = async (event) => {
      if (event.detail?.resumeId === id) {
        console.log('🔄 ResumeDetail: Resume update event received, force refreshing...');
        
        // Force refresh the resume data to get new analysis scores
        await forceRefreshResume();
        
        // Show success alert with new scores if available
        let message = event.detail.message || '✅ Resume updated successfully!';
        
        if (event.detail.newAnalysis) {
          message += `\n📊 New Scores: Overall ${event.detail.newAnalysis.overallScore}%, ATS ${event.detail.newAnalysis.atsCompatibility}%`;
        }
        
        setAlert({
          open: true,
          message: message,
          severity: 'success'
        });
        
        // Auto-hide alert after longer duration for detailed messages
        setTimeout(() => {
          setAlert({ open: false, message: '', severity: 'success' });
        }, 8000);
      }
    };

    window.addEventListener('resumeUpdated', handleResumeUpdate);
    return () => window.removeEventListener('resumeUpdated', handleResumeUpdate);
  }, [id, forceRefreshResume]);

  const handleDownload = async () => {
    try {
      // Get the latest version or fall back to original
      let downloadUrl;
      
      if (resume.versions && resume.versions.length > 0) {
        // Get the most recent version
        const latestVersion = resume.versions[resume.versions.length - 1];
        downloadUrl = latestVersion.downloadUrl;
        console.log('📥 Downloading latest version:', latestVersion.versionNumber, latestVersion.createdAt);
      } else {
        // Fall back to original file
        downloadUrl = resume.downloadUrl;
        console.log('📥 Downloading original file');
      }
      
      if (downloadUrl) {
        // Open in new tab to trigger download
        window.open(downloadUrl, '_blank');
      } else {
        throw new Error('No download URL available');
      }
      
    } catch (error) {
      console.error('Download error:', error);
      setAlert({
        open: true,
        message: 'Failed to download the resume. Please try again.',
        severity: 'error'
      });
    }
  };

  // 🔥 ENHANCED: Force refresh function for manual refresh button
  const handleManualRefresh = async () => {
    console.log('🔄 Manual refresh triggered');
    setAlert({
      open: true,
      message: 'Refreshing resume data...',
      severity: 'info'
    });
    
    try {
      await forceRefreshResume();
      setAlert({
        open: true,
        message: '✅ Resume data refreshed successfully!',
        severity: 'success'
      });
    } catch (error) {
      setAlert({
        open: true,
        message: '❌ Failed to refresh resume data.',
        severity: 'error'
      });
    }
  };

  // Loading state
  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
          <CircularProgress size={60} thickness={4} />
          <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
            Loading your resume details...
          </Typography>
        </Box>
      </MainLayout>
    );
  }

  // Error state
  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="error">{error}</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/resumes')}
            sx={{ mt: 2 }}
          >
            Back to Resumes
          </Button>
        </Box>
      </MainLayout>
    );
  }

  // Processing state
  if (processingStatus === 'in-progress') {
    return <ProcessingView navigate={navigate} />;
  }

  if (!resume) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="info">Resume not found.</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/resumes')}
            sx={{ mt: 2 }}
          >
            Back to Resumes
          </Button>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1200px', mx: 'auto' }}>
        {/* Navigation */}
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/resumes')}
          variant="outlined"
          sx={{ mb: 3 }}
        >
          Back to Resumes
        </Button>

        {/* AI Success Message */}
        {aiSuccess && (
          <Fade in={!!aiSuccess}>
            <Alert 
              severity="success" 
              sx={{ 
                mb: 3,
                '& .MuiAlert-message': {
                  whiteSpace: 'pre-line' // Allow line breaks in success messages
                }
              }}
              action={
                comparisonData && (
                  <Button 
                    color="inherit" 
                    size="small"
                    startIcon={<VisibilityIcon />}
                    onClick={() => setShowComparison(true)}
                  >
                    View Changes
                  </Button>
                )
              }
            >
              {aiSuccess}
            </Alert>
          </Fade>
        )}

        {/* Header */}
        <Paper 
          elevation={2} 
          sx={{ 
            p: 3, 
            mb: 3, 
            borderRadius: 3,
            backgroundImage: `linear-gradient(135deg, ${theme.palette.background.paper} 0%, ${theme.palette.primary.light}15 100%)` 
          }}
        >
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap' }}>
            <Box sx={{ maxWidth: { xs: '80%', sm: '70%', md: '75%' } }}>
              <Typography 
                variant="h4" 
                component="h1" 
                fontWeight={700} 
                color="primary"
                sx={{ 
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  mb: 0.5
                }}
              >
                {resume.name}
              </Typography>
              <Box sx={{ display: 'flex', alignItems: 'center', mt: 1, flexWrap: 'wrap' }}>
                <Chip 
                  icon={<DescriptionIcon />} 
                  label={resume.fileType} 
                  size="small" 
                  sx={{ mr: 1, mb: 0.5 }} 
                />
                <Typography variant="body2" color="text.secondary">
                  Last updated: {new Date(resume.updatedAt).toLocaleDateString()}
                </Typography>
                {/* 🔥 ENHANCED: Show analysis scores in header */}
                {resume.analysis && (
                  <Box sx={{ ml: 2, display: 'flex', gap: 1 }}>
                    <Chip 
                      label={`Score: ${resume.analysis.overallScore || 0}%`}
                      size="small"
                      color={resume.analysis.overallScore >= 80 ? 'success' : resume.analysis.overallScore >= 60 ? 'warning' : 'error'}
                    />
                    <Chip 
                      label={`ATS: ${resume.analysis.atsCompatibility || 0}%`}
                      size="small"
                      color={resume.analysis.atsCompatibility >= 80 ? 'success' : resume.analysis.atsCompatibility >= 60 ? 'warning' : 'error'}
                    />
                  </Box>
                )}
              </Box>
            </Box>
            
            <ButtonGroup>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={handleManualRefresh} // 🔥 FIXED: Use force refresh
                size="small"
              >
                Refresh
              </Button>
              <Button
                variant="contained"
                startIcon={<CloudDownloadIcon />}
                onClick={handleDownload}
              >
                Download
              </Button>
            </ButtonGroup>
          </Box>
        </Paper>

        {/* AI Editing Toolbar */}
        <AiEditingToolbar
          resume={resume}
          onQuickAction={handleQuickAction}
          onOpenChat={openAiChat}
          aiProcessing={aiProcessing}
          progressStage={progressStage}
          progressPercentage={progressPercentage}
        />

        {/* Main Content Tabs */}
        <Box>
          <Paper sx={{ borderRadius: 3, overflow: 'hidden', mb: 3 }}>
            <Tabs
              value={tabValue}
              onChange={(e, newValue) => setTabValue(newValue)}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ 
                borderBottom: 1, 
                borderColor: 'divider',
                bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.02)',
              }}
            >
              <Tab label="Overview" icon={<DescriptionIcon />} iconPosition="start" />
              <Tab label="Analysis" icon={<LightbulbIcon />} iconPosition="start" />
              <Tab label="Content" icon={<PersonIcon />} iconPosition="start" />
            </Tabs>
          </Paper>

          <TabPanel value={tabValue} index={0}>
            <OverviewTab resume={resume} theme={theme} />
          </TabPanel>

          <TabPanel value={tabValue} index={1}>
            <AnalysisTab resume={resume} theme={theme} />
          </TabPanel>

          <TabPanel value={tabValue} index={2}>
            <ContentTab resume={resume} theme={theme} />
          </TabPanel>
        </Box>

        {/* Alert Snackbar */}
        <Snackbar 
          open={alert.open} 
          autoHideDuration={6000} 
          onClose={() => setAlert({ ...alert, open: false })}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert onClose={() => setAlert({ ...alert, open: false })} severity={alert.severity}>
            {alert.message}
          </Alert>
        </Snackbar>

        {/* Before/After Comparison Dialog */}
        <BeforeAfterComparison
          open={showComparison}
          onClose={() => setShowComparison(false)}
          comparisonData={comparisonData}
        />
      </Box>
    </MainLayout>
  );
};

export default ResumeDetail;

================
File: src/components/resumes/ResumesPage.js
================
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Grid, 
  Card, 
  CardContent, 
  CardActions, 
  Divider, 
  Chip, 
  CircularProgress, 
  LinearProgress,
  IconButton,
  Menu,
  MenuItem,
  Tooltip
} from '@mui/material';
import { 
  Add as AddIcon, 
  Description as DescriptionIcon,
  Refresh as RefreshIcon,
  ErrorOutline as ErrorOutlineIcon,
  MoreVert as MoreVertIcon,
  TrendingUp as TrendingUpIcon,
  LightbulbOutlined as LightbulbIcon,
  Download as DownloadIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  SmartToy as SmartToyIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import axios from '../../utils/axios';
import MainLayout from '../layout/MainLayout';
import ResumeUploadDialog from './ResumeUploadDialog';

const ResumesPage = () => {
  const navigate = useNavigate();
  const [resumes, setResumes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [openUploadDialog, setOpenUploadDialog] = useState(false);
  const [anchorEl, setAnchorEl] = useState(null);
  const [selectedResumeId, setSelectedResumeId] = useState(null);

  useEffect(() => {
    fetchResumes();
  }, []);

  const fetchResumes = async () => {
    try {
      setLoading(true);
      setError('');
      console.log('Fetching resumes...');
      const response = await axios.get('/resumes');
      console.log('Resume response:', response);
      setResumes(response.data.resumes || []);
    } catch (err) {
      console.error('Error fetching resumes:', err);
      setError(err.response?.data?.message || 'Failed to load resumes. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleOpenUploadDialog = () => {
    setOpenUploadDialog(true);
  };

  const handleCloseUploadDialog = () => {
    setOpenUploadDialog(false);
  };

  const handleResumeUploaded = (resumeId) => {
    fetchResumes();
    handleCloseUploadDialog();
    
    // If a resumeId is provided, navigate to the resume detail page
    if (resumeId) {
      navigate(`/resumes/${resumeId}`);
    }
  };

  const handleMenuOpen = (event, resumeId) => {
    setAnchorEl(event.currentTarget);
    setSelectedResumeId(resumeId);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
    setSelectedResumeId(null);
  };

  const handleDeleteResume = async () => {
    if (!selectedResumeId) return;
    
    try {
      await axios.delete(`/resumes/${selectedResumeId}`);
      setResumes(prevResumes => prevResumes.filter(resume => resume._id !== selectedResumeId));
      handleMenuClose();
    } catch (err) {
      console.error('Error deleting resume:', err);
    }
  };

  const getScoreColor = (score) => {
    if (score >= 80) return 'success.main';
    if (score >= 60) return 'warning.main';
    return 'error.main';
  };

  const renderEmptyState = () => (
    <Box sx={{ mt: 2 }}>
      <Paper 
        elevation={1} 
        sx={{ 
          p: 3, 
          textAlign: 'center', 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center',
          backgroundColor: theme => theme.palette.background.paper,
          border: `1px solid`,
          borderColor: 'divider',
          borderRadius: 3,
          mb: 3
        }}
      >
        <DescriptionIcon sx={{ fontSize: 48, color: 'primary.main', mb: 2, opacity: 0.8 }} />
        <Typography variant="h5" gutterBottom fontWeight={600}>
          Let's Supercharge Your Job Search
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 3, maxWidth: 560, lineHeight: 1.5 }}>
          Upload your resume to unlock AI-powered analysis, optimization, and job matching. 
          Our platform will help you create the perfect resume, match with relevant job opportunities, 
          and significantly increase your chances of landing interviews.
        </Typography>
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<AddIcon />} 
          onClick={handleOpenUploadDialog}
          sx={{ 
            py: 1, 
            px: 3, 
            fontSize: '0.9rem', 
            fontWeight: 500,
            borderRadius: 2
          }}
        >
          Upload Your First Resume
        </Button>
      </Paper>

      <Typography variant="h6" sx={{ mb: 2.5, fontWeight: 600 }}>
        How Our Resume Manager Works
      </Typography>

      <Grid container spacing={2.5} sx={{ mb: 3 }}>
        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #4caf50',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              1. AI Resume Analysis
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <DescriptionIcon sx={{ fontSize: 56, color: '#4caf50', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Our AI scans your resume and provides detailed insights about strengths, weaknesses, 
              and specific improvement suggestions.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #2196f3',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              2. ATS Optimization
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <TrendingUpIcon sx={{ fontSize: 56, color: '#2196f3', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Beat the automated screening systems with compatibility scoring and keyword 
              optimization suggestions.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #ff9800',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              3. Job-Resume Matching
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <LightbulbIcon sx={{ fontSize: 56, color: '#ff9800', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Find the perfect match between your resume and job opportunities with skills gap 
              analysis and tailored recommendations.
            </Typography>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );

  const renderErrorState = () => (
    <Paper 
      elevation={1} 
      sx={{ 
        p: 3, 
        mt: 2,
        borderRadius: 2,
        border: `1px solid`,
        borderColor: 'error.light',
        bgcolor: theme => `${theme.palette.error.main}08`
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
        <ErrorOutlineIcon color="error" sx={{ mr: 1.5, mt: 0.5 }} />
        <Box>
          <Typography variant="subtitle1" color="error" gutterBottom fontWeight={600}>
            Error Loading Resumes
          </Typography>
          <Typography variant="body2" sx={{ mb: 2.5 }}>
            Failed to load resumes. Please try again.
          </Typography>
        </Box>
      </Box>
      <Box sx={{ display: 'flex', gap: 1.5 }}>
        <Button 
          variant="outlined" 
          color="primary" 
          startIcon={<RefreshIcon />} 
          onClick={fetchResumes}
          size="small"
          sx={{ borderRadius: 2 }}
        >
          Try Again
        </Button>
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<AddIcon />} 
          onClick={handleOpenUploadDialog}
          size="small"
          sx={{ borderRadius: 2 }}
        >
          Upload New Resume
        </Button>
      </Box>
    </Paper>
  );

  const renderResumeGrid = () => (
    <Grid container spacing={3} sx={{ mt: 1 }}>
      {resumes.map((resume) => (
        <Grid item xs={12} sm={6} md={4} key={resume._id}>
          <Card sx={{ 
            height: '100%', 
            display: 'flex', 
            flexDirection: 'column',
            position: 'relative',
            transition: 'transform 0.2s, box-shadow 0.2s',
            '&:hover': {
              transform: 'translateY(-4px)',
              boxShadow: '0 8px 24px rgba(0,0,0,0.12)'
            }
          }}>
            <CardContent sx={{ flexGrow: 1, pt: 3 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                {resume.isTailored && (
                  <SmartToyIcon color="secondary" sx={{ mr: 1 }} />
                )}
                <Typography variant="h6" gutterBottom noWrap fontWeight={500}>
                  {resume.name}
                </Typography>
              </Box>
              <Typography variant="body2" color="text.secondary" gutterBottom>
                Updated {new Date(resume.updatedAt || resume.createdAt).toLocaleDateString()}
              </Typography>
              {resume.isTailored && resume.tailoredForJob && (
                <Typography variant="body2" color="secondary.main" sx={{ fontStyle: 'italic', mb: 1 }}>
                  Tailored for {resume.tailoredForJob.jobTitle} at {resume.tailoredForJob.company}
                </Typography>
              )}
              <Divider sx={{ my: 2 }} />
              
              {resume.analysis && resume.analysis.overallScore && (
                <Box sx={{ mt: 2, mb: 3 }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                    <Typography variant="subtitle2" fontWeight={500}>
                      Resume Score
                    </Typography>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Typography variant="h6" fontWeight={600} color={getScoreColor(resume.analysis.overallScore)}>
                        {resume.analysis.overallScore}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ ml: 0.5 }}>
                        /100
                      </Typography>
                    </Box>
                  </Box>
                  <LinearProgress 
                    variant="determinate" 
                    value={resume.analysis.overallScore} 
                    sx={{ 
                      height: 8, 
                      borderRadius: 2,
                      backgroundColor: 'rgba(0,0,0,0.05)',
                      '& .MuiLinearProgress-bar': {
                        backgroundColor: getScoreColor(resume.analysis.overallScore)
                      }
                    }}
                  />
                </Box>
              )}
              
              {resume.analysis && resume.analysis.atsCompatibility && (
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                  <Typography variant="body2" color="text.secondary">
                    ATS Compatibility
                  </Typography>
                  <Typography variant="body2" fontWeight={500}>
                    {resume.analysis.atsCompatibility}%
                  </Typography>
                </Box>
              )}
              
              {resume.matchAnalysis && resume.matchAnalysis.overallScore && (
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <TrendingUpIcon fontSize="small" color="success" sx={{ mr: 0.5 }} />
                    <Typography variant="body2" color="text.secondary">
                      Match Rate
                    </Typography>
                  </Box>
                  <Typography variant="body2" fontWeight={500}>
                    {resume.matchAnalysis.overallScore}%
                  </Typography>
                </Box>
              )}
              
              <Box sx={{ mt: 2, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                <Chip 
                  label={resume.fileType ? resume.fileType.toUpperCase() : 'PDF'} 
                  size="small" 
                  variant="outlined" 
                />
                {resume.versions && resume.versions.length > 0 && (
                  <Chip 
                    label={`${resume.versions.length + 1} Versions`} 
                    size="small" 
                    variant="outlined" 
                  />
                )}
                {resume.isTailored && (
                  <Chip 
                    icon={<SmartToyIcon />}
                    label="AI Tailored" 
                    size="small" 
                    variant="outlined"
                    color="secondary"
                  />
                )}
              </Box>
              
              {resume.analysis && resume.analysis.improvementAreas && resume.analysis.improvementAreas.length > 0 && (
                <Box sx={{ mt: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mb: 1 }}>
                    <LightbulbIcon fontSize="small" sx={{ color: 'warning.main' }} />
                    <Typography variant="body2" fontWeight={500}>
                      Improvement Areas
                    </Typography>
                  </Box>
                  {resume.analysis.improvementAreas.slice(0, 2).map((area, index) => (
                    <Typography key={index} variant="body2" color="text.secondary" sx={{ 
                      display: 'flex', 
                      alignItems: 'center',
                      fontSize: '0.75rem',
                      '&:before': {
                        content: '""',
                        display: 'inline-block',
                        width: '4px',
                        height: '4px',
                        borderRadius: '50%',
                        backgroundColor: 'text.secondary',
                        mr: 1
                      }
                    }}>
                      {area.section}: {area.suggestions[0]}
                    </Typography>
                  ))}
                </Box>
              )}
            </CardContent>
            <CardActions sx={{ justifyContent: 'space-between', p: 2 }}>
              <Button 
                size="small" 
                color="primary" 
                onClick={() => navigate(`/resumes/${resume._id}`)}
                variant="contained"
              >
                View Details
              </Button>
              <Box>
                <Tooltip title="Download">
                  <IconButton 
                    size="small" 
                    onClick={() => window.open(resume.downloadUrl || resume.fileUrl, '_blank')}
                    sx={{ mr: 1 }}
                  >
                    <DownloadIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <IconButton 
                  size="small"
                  aria-controls={`resume-menu-${resume._id}`}
                  aria-haspopup="true"
                  onClick={(e) => handleMenuOpen(e, resume._id)}
                >
                  <MoreVertIcon fontSize="small" />
                </IconButton>
              </Box>
            </CardActions>
          </Card>
        </Grid>
      ))}
      <Grid item xs={12} sm={6} md={4}>
        <Card 
          sx={{ 
            height: '100%', 
            minHeight: 200,
            display: 'flex', 
            flexDirection: 'column', 
            justifyContent: 'center', 
            alignItems: 'center',
            p: 3,
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            border: '2px dashed',
            borderColor: 'divider',
            cursor: 'pointer',
            transition: 'all 0.2s ease-in-out',
            '&:hover': {
              borderColor: 'primary.main',
              backgroundColor: 'rgba(63, 81, 181, 0.04)'
            }
          }}
          onClick={handleOpenUploadDialog}
        >
          <AddIcon sx={{ fontSize: 40, color: 'primary.main', mb: 2 }} />
          <Typography variant="h6" align="center" fontWeight={500}>
            Upload New Resume
          </Typography>
          <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 1 }}>
            Add another resume to your collection
          </Typography>
        </Card>
      </Grid>
    </Grid>
  );

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h4" component="h1" fontWeight={500}>
            Resume Manager
          </Typography>
          {!loading && !error && resumes.length > 0 && (
            <Button 
              variant="contained" 
              color="primary" 
              startIcon={<AddIcon />} 
              onClick={handleOpenUploadDialog}
              sx={{ textTransform: 'none' }}
            >
              Upload New Resume
            </Button>
          )}
        </Box>

        {loading ? (
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '300px' }}>
            <CircularProgress size={60} thickness={4} color="primary" />
            <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
              Loading your resumes...
            </Typography>
          </Box>
        ) : error ? (
          renderErrorState()
        ) : resumes.length === 0 ? (
          renderEmptyState()
        ) : (
          renderResumeGrid()
        )}
      </Box>

      <ResumeUploadDialog 
        open={openUploadDialog}
        onClose={handleCloseUploadDialog}
        onResumeUploaded={handleResumeUploaded}
      />
      
      <Menu
        id="resume-menu"
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >

        <MenuItem onClick={handleDeleteResume} sx={{ color: 'error.main' }}>
          <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
          Delete Resume
        </MenuItem>
      </Menu>
    </MainLayout>
  );
};

export default ResumesPage;

================
File: src/components/resumes/ResumeUploadDialog.js
================
import React, { useState, useEffect } from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Button, 
  TextField, 
  Box, 
  Typography,
  Alert,
  Stepper,
  Step,
  StepLabel,
  IconButton,
  LinearProgress,
  StepContent
} from '@mui/material';
import { 
  CloudUpload as CloudUploadIcon,
  Close as CloseIcon,
  PictureAsPdf as PdfIcon,
  Description as DescriptionIcon,
  CheckCircle as CheckCircleIcon,
  Info as InfoIcon,
  Psychology as PsychologyIcon,
  DataObject as DataObjectIcon,
  Memory as MemoryIcon,
  Error as ErrorIcon
} from '@mui/icons-material';
import resumeService from '../../utils/resumeService';

const ResumeUploadDialog = ({ open, onClose, onResumeUploaded }) => {
  const [activeStep, setActiveStep] = useState(0);
  const [file, setFile] = useState(null);
  const [name, setName] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [dragActive, setDragActive] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [processingStage, setProcessingStage] = useState('uploading'); // 'uploading', 'parsing', 'analyzing', 'completed', 'error'
  const [uploadComplete, setUploadComplete] = useState(false);
  const [resumeId, setResumeId] = useState(null);
  const [processingTimeout, setProcessingTimeout] = useState(false);
  const [canClose, setCanClose] = useState(true);

  // Clear any intervals when the component unmounts
  useEffect(() => {
    return () => {
      // Cleanup function
    };
  }, []);

  const steps = [
    { label: 'Select Resume', icon: <DescriptionIcon /> },
    { label: 'Add Details', icon: <DataObjectIcon /> },
    { label: 'Processing', icon: <MemoryIcon /> }
  ];

  const processingSteps = [
    { label: 'Uploading', value: 10, icon: <CloudUploadIcon color="primary" /> },
    { label: 'Parsing', value: 30, icon: <DataObjectIcon color="info" /> },
    { label: 'AI Analyzing', value: 75, icon: <PsychologyIcon color="secondary" /> },
    { label: 'Complete', value: 100, icon: <CheckCircleIcon color="success" /> }
  ];

  const getProcessingStepIndex = () => {
    switch (processingStage) {
      case 'uploading': return 0;
      case 'parsing': return 1;
      case 'analyzing': return 2;
      case 'completed': return 3;
      default: return 0;
    }
  };

  const resetForm = () => {
    setFile(null);
    setName('');
    setError('');
    setActiveStep(0);
    setUploadProgress(0);
    setProcessingStage('uploading');
    setUploadComplete(false);
    setResumeId(null);
    setProcessingTimeout(false);
    setCanClose(true);
  };

  const handleClose = () => {
    if (canClose) {
      resetForm();
      onClose();
    }
  };

  const handleFileDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const droppedFile = e.dataTransfer.files[0];
      validateAndSetFile(droppedFile);
    }
  };

  const handleFileChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      const selectedFile = e.target.files[0];
      validateAndSetFile(selectedFile);
    }
  };

  const validateAndSetFile = (file) => {
    const validTypes = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
    const maxSize = 10 * 1024 * 1024; // 10MB
    
    setError('');
    
    if (!validTypes.includes(file.type)) {
      setError('Please upload a PDF or DOCX file');
      return;
    }
    
    if (file.size > maxSize) {
      setError('File size must be less than 10MB');
      return;
    }
    
    setFile(file);
    if (!name) {
      // Set the name field to file name without extension
      const fileName = file.name.replace(/\.[^/.]+$/, "");
      setName(fileName);
    }
    
    setActiveStep(1);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(true);
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
  };

  const handleProgressUpdate = (status) => {
    if (!status) return;
    
    console.log('Status update:', status); // Log the status for debugging
    
    // Update processing stage based on status
    const stage = status.stage || status.status || 'uploading';
    setProcessingStage(stage);
    
    // Update progress percentage
    if (status.percentage) {
      setUploadProgress(status.percentage);
    } else {
      // If no percentage is provided, use default values based on stage
      switch (stage) {
        case 'uploading':
          setUploadProgress(10);
          break;
        case 'parsing':
          setUploadProgress(30);
          break;
        case 'analyzing':
          setUploadProgress(75);
          break;
        case 'completed':
          setUploadProgress(100);
          setUploadComplete(true);
          setCanClose(true);
          break;
        case 'error':
          setError(status.error || status.message || 'An error occurred during processing');
          setCanClose(true);
          break;
        default:
          break;
      }
    }
  };

  const handleSubmit = async () => {
    if (!file) {
      setError('Please select a file to upload');
      return;
    }
    
    if (!name.trim()) {
      setError('Please enter a name for your resume');
      return;
    }

    try {
      setLoading(true);
      setActiveStep(2);
      setProcessingStage('uploading');
      setUploadProgress(10);
      setCanClose(false); // Prevent closing during upload
      setError('');
      
      const formData = new FormData();
      formData.append('file', file);
      formData.append('name', name);
      
      // Upload the resume
      const response = await resumeService.uploadResume(formData);
      
      console.log('Upload response:', response); // Log the response structure
      
      // Extract resume ID from the response (handle different response structures)
      let resumeId = null;
      
      if (response && response.resume && response.resume._id) {
        // Standard structure
        resumeId = response.resume._id;
      } else if (response && response._id) {
        // Alternative structure where resume is the root object
        resumeId = response._id;
      } else if (response && response.id) {
        // Alternative structure with 'id' instead of '_id'
        resumeId = response.id;
      } else if (response && response.resume && response.resume.id) {
        // Alternative structure with 'id' instead of '_id'
        resumeId = response.resume.id;
      } else if (response && response.data && response.data.resume && response.data.resume._id) {
        // Structure with data wrapper
        resumeId = response.data.resume._id;
      } else if (response && response.data && response.data._id) {
        // Structure with data wrapper
        resumeId = response.data._id;
      }
      
      if (resumeId) {
        setResumeId(resumeId);
        
        try {
          // Start polling for status updates
          await resumeService.pollResumeStatus(resumeId, handleProgressUpdate, 300000);
        } catch (pollError) {
          console.error('Error polling resume status:', pollError);
          
          if (pollError.message && pollError.message.includes('timed out')) {
            setProcessingTimeout(true);
            setError('Processing is taking longer than expected. You can close this dialog and check back later.');
          } else {
            setError(pollError.message || 'An error occurred while processing your resume');
          }
          
          setCanClose(true);
        }
      } else {
        console.error('Could not extract resume ID from response:', response);
        throw new Error('Invalid response from server - could not find resume ID');
      }
    } catch (err) {
      console.error('Error uploading resume:', err);
      setError(err.response?.data?.message || 'Failed to upload resume. Please try again.');
      setCanClose(true);
    } finally {
      setLoading(false);
    }
  };

  const getFileIcon = () => {
    if (!file) return null;
    
    return file.type === 'application/pdf' 
      ? <PdfIcon color="error" fontSize="large" />
      : <DescriptionIcon color="primary" fontSize="large" />;
  };

  const getProcessingStageIcon = () => {
    switch (processingStage) {
      case 'uploading':
        return <CloudUploadIcon sx={{ fontSize: 64, color: 'primary.main' }} />;
      case 'parsing':
        return <DataObjectIcon sx={{ fontSize: 64, color: 'info.main' }} />;
      case 'analyzing':
        return <PsychologyIcon sx={{ fontSize: 64, color: 'secondary.main' }} />;
      case 'completed':
        return <CheckCircleIcon sx={{ fontSize: 64, color: 'success.main' }} />;
      case 'error':
        return <ErrorIcon sx={{ fontSize: 64, color: 'error.main' }} />;
      default:
        return <MemoryIcon sx={{ fontSize: 64, color: 'primary.main' }} />;
    }
  };

  const getProcessingStageText = () => {
    switch (processingStage) {
      case 'uploading':
        return {
          title: 'Uploading your resume...',
          description: 'Your file is being securely uploaded to our servers.'
        };
      case 'parsing':
        return {
          title: 'Parsing your resume...',
          description: 'Our AI is extracting information from your resume, identifying your experience, skills, and qualifications.'
        };
      case 'analyzing':
        return {
          title: 'Analyzing your resume...',
          description: 'We\'re now analyzing your resume to provide personalized recommendations, identify strengths and weaknesses, and prepare improvement suggestions.'
        };
      case 'completed':
        return {
          title: 'Processing complete!',
          description: 'Your resume has been successfully processed and analyzed.'
        };
      case 'error':
        return {
          title: 'Processing error',
          description: 'There was an error processing your resume. Please try again.'
        };
      default:
        return {
          title: 'Processing your resume...',
          description: 'This may take a moment.'
        };
    }
  };

  const renderStepContent = () => {
    switch (activeStep) {
      case 0:
        return (
          <Box 
            sx={{ 
              mt: 2, 
              border: '2px dashed',
              borderColor: dragActive ? 'primary.main' : 'divider',
              borderRadius: 2,
              p: 4,
              textAlign: 'center',
              cursor: 'pointer',
              backgroundColor: dragActive ? 'action.hover' : 'background.paper',
              transition: 'all 0.2s ease'
            }}
            onDrop={handleFileDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onClick={() => document.getElementById('resume-file-upload').click()}
          >
            <input
              id="resume-file-upload"
              type="file"
              accept=".pdf,.docx"
              onChange={handleFileChange}
              style={{ display: 'none' }}
            />
            
            <CloudUploadIcon sx={{ fontSize: 64, color: 'primary.main', mb: 2 }} />
            
            <Typography variant="h6" gutterBottom fontWeight={500}>
              Drag & drop your resume here
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              or click to browse your files
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Supported formats: PDF, DOCX (Max size: 10MB)
            </Typography>
          </Box>
        );
      case 1:
        return (
          <Box sx={{ mt: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
              {getFileIcon()}
              <Box sx={{ ml: 2, flexGrow: 1 }}>
                <Typography variant="body1" fontWeight="medium">
                  {file?.name}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {(file?.size / 1024 / 1024).toFixed(2)} MB
                </Typography>
              </Box>
            </Box>
            
            <TextField
              label="Resume Name"
              fullWidth
              value={name}
              onChange={(e) => setName(e.target.value)}
              margin="normal"
              required
              placeholder="e.g., Software Developer Resume"
              helperText="Give your resume a descriptive name to easily identify it later"
            />
            
            <Box sx={{ display: 'flex', alignItems: 'center', mt: 3, p: 2, bgcolor: 'info.light', borderRadius: 2 }}>
              <InfoIcon color="info" sx={{ mr: 1.5, alignSelf: 'flex-start' }} />
              <Typography variant="body2">
                Your resume will be analyzed with AI to provide personalized insights, skills assessment, and improvement suggestions. This process may take a few minutes to complete.
              </Typography>
            </Box>
          </Box>
        );
      case 2:
        const stageText = getProcessingStageText();
        const processingStepIndex = getProcessingStepIndex();
        
        return (
          <Box sx={{ mt: 2 }}>
            {/* Processing steps stepper */}
            <Stepper activeStep={processingStepIndex} orientation="vertical" sx={{ mb: 3 }}>
              {processingSteps.map((step, index) => (
                <Step key={step.label} completed={index < processingStepIndex}>
                  <StepLabel 
                    StepIconComponent={() => step.icon}
                    sx={{ 
                      '& .MuiStepLabel-label': { 
                        fontWeight: index === processingStepIndex ? 600 : 400 
                      }
                    }}
                  >
                    {step.label}
                  </StepLabel>
                  <StepContent>
                    <Typography variant="body2" color="text.secondary">
                      {index === 0 && 'Uploading your file to our secure servers'}
                      {index === 1 && 'Extracting information from your resume'}
                      {index === 2 && 'Our AI is analyzing your resume for insights and recommendations'}
                      {index === 3 && 'All done! Your resume has been processed successfully'}
                    </Typography>
                  </StepContent>
                </Step>
              ))}
            </Stepper>
            
            {/* Progress visualization */}
            <Box sx={{ textAlign: 'center', px: 2, mb: 3 }}>
              {getProcessingStageIcon()}
              <Typography variant="h6" gutterBottom sx={{ mt: 2 }}>
                {stageText.title}
              </Typography>
              <Typography variant="body2" color="text.secondary" gutterBottom sx={{ mb: 3, mx: 'auto', maxWidth: 400 }}>
                {stageText.description}
              </Typography>
              <LinearProgress 
                variant="determinate" 
                value={uploadProgress} 
                sx={{ height: 8, borderRadius: 4, mb: 1 }} 
              />
              <Typography variant="body2" color="text.secondary">
                {Math.round(uploadProgress)}% Complete
              </Typography>
            </Box>
            
            {/* Warning message */}
            {!uploadComplete && !processingTimeout && (
              <Alert severity="warning" sx={{ mt: 2 }}>
                <Typography variant="body2" fontWeight={500}>
                  Please don't close this window
                </Typography>
                <Typography variant="body2">
                  Closing this dialog before processing is complete may result in incomplete analysis.
                </Typography>
              </Alert>
            )}
            
            {/* Timeout message */}
            {processingTimeout && (
              <Alert severity="info" sx={{ mt: 2 }}>
                <Typography variant="body2" fontWeight={500}>
                  Processing is taking longer than expected
                </Typography>
                <Typography variant="body2">
                  You can close this dialog and check back later. Your resume will continue processing in the background.
                </Typography>
              </Alert>
            )}
            
            {/* Success message */}
            {uploadComplete && (
              <Alert severity="success" sx={{ mt: 2 }}>
                <Typography variant="body2" fontWeight={500}>
                  Resume processing complete!
                </Typography>
                <Typography variant="body2">
                  Your resume has been successfully processed and analyzed. You can now view your analysis and improvement suggestions.
                </Typography>
              </Alert>
            )}
          </Box>
        );
      default:
        return null;
    }
  };

  return (
    <Dialog 
      open={open} 
      onClose={canClose ? handleClose : undefined} 
      maxWidth="sm" 
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2
        }
      }}
    >
      <DialogTitle>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Typography variant="h6" fontWeight={600}>Upload Resume</Typography>
          {canClose && (
            <IconButton onClick={handleClose} size="small">
              <CloseIcon />
            </IconButton>
          )}
        </Box>
      </DialogTitle>
      
      <DialogContent>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        
        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
          {steps.map((step) => (
            <Step key={step.label}>
              <StepLabel StepIconComponent={() => step.icon}>{step.label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {renderStepContent()}
      </DialogContent>
      
      <DialogActions sx={{ px: 3, pb: 3 }}>
        {activeStep === 0 && (
          <Button onClick={handleClose} disabled={!canClose}>
            Cancel
          </Button>
        )}
        
        {activeStep === 1 && (
          <>
            <Button onClick={() => setActiveStep(0)} disabled={loading}>
              Back
            </Button>
            <Button 
              onClick={handleSubmit} 
              variant="contained" 
              color="primary"
              disabled={!file || !name.trim() || loading}
            >
              Upload
            </Button>
          </>
        )}
        
        {activeStep === 2 && (
          <>
            {(processingTimeout || uploadComplete || processingStage === 'error') && (
              <Button 
                onClick={() => {
                  handleClose();
                  if (uploadComplete) {
                    onResumeUploaded(resumeId);
                  }
                }} 
                variant="contained" 
                color="primary"
              >
                {uploadComplete ? 'View Resume' : 'Close'}
              </Button>
            )}
            
            {!uploadComplete && !processingTimeout && processingStage !== 'error' && (
              <Button 
                disabled={!canClose}
                variant="outlined"
                color="primary"
              >
                Processing...
              </Button>
            )}
          </>
        )}
      </DialogActions>
    </Dialog>
  );
};

export default ResumeUploadDialog;

================
File: src/components/resumes/ResumeWithAssistant.js
================
// src/components/resumes/ResumeWithAssistant.js
import React, { useState, useEffect } from 'react';
import {
  Box,
  Grid,
  Paper,
  Typography,
  Button,
  Fab,
  Tooltip,
  Chip,
  Alert,
  Zoom,
  useTheme,
  alpha
} from '@mui/material';
import {
  SmartToy as RobotIcon,
  AutoFixHigh as SuggestionIcon,
  Visibility as PreviewIcon,
  Edit as EditIcon,
  Chat as ChatIcon
} from '@mui/icons-material';
import { useParams } from 'react-router-dom';
import AiAssistantWidget from '../assistant/AiAssistantWidget';
import resumeService from '../../utils/resumeService';
import assistantService from '../../utils/assistantService';
import MainLayout from '../layout/MainLayout';

const ResumeWithAssistant = () => {
  const theme = useTheme();
  const { id: resumeId } = useParams();
  const [resume, setResume] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [assistantActive, setAssistantActive] = useState(false);
  const [pendingSuggestions, setPendingSuggestions] = useState([]);
  const [showAssistant, setShowAssistant] = useState(false);

  useEffect(() => {
    if (resumeId) {
      fetchResume();
    }
  }, [resumeId]);

  const fetchResume = async () => {
    try {
      setLoading(true);
      const resumeData = await resumeService.getResumeById(resumeId);
      setResume(resumeData);
    } catch (err) {
      console.error('Error fetching resume:', err);
      setError('Failed to load resume');
    } finally {
      setLoading(false);
    }
  };

  const handleResumeUpdate = async (changes) => {
    try {
      // Apply changes to resume
      const updatedResume = await assistantService.applyResumeChanges(resumeId, changes);
      setResume(updatedResume.resume);
      
      // Show success feedback
      setPendingSuggestions(prev => prev.filter(s => s.id !== changes.id));
      
    } catch (error) {
      console.error('Error applying resume changes:', error);
    }
  };

  const handleAssistantToggle = () => {
    setShowAssistant(!showAssistant);
  };

  const ResumePreview = () => (
    <Paper 
      elevation={2} 
      sx={{ 
        p: 3, 
        height: 'fit-content',
        borderRadius: 2,
        border: `1px solid ${alpha(theme.palette.primary.main, 0.1)}`
      }}
    >
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h5" fontWeight={600}>
          {resume?.name || 'Resume Preview'}
        </Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Tooltip title="Edit Resume">
            <Button
              variant="outlined"
              size="small"
              startIcon={<EditIcon />}
              onClick={() => {/* Navigate to edit */}}
            >
              Edit
            </Button>
          </Tooltip>
          <Tooltip title="Preview Resume">
            <Button
              variant="outlined"
              size="small"
              startIcon={<PreviewIcon />}
              onClick={() => {/* Open preview */}}
            >
              Preview
            </Button>
          </Tooltip>
        </Box>
      </Box>

      {/* Resume Sections */}
      {resume?.parsedData && (
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
          {/* Contact Info */}
          {resume.parsedData.contactInfo && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 1, color: theme.palette.primary.main }}>
                Contact Information
              </Typography>
              <Typography variant="body1" fontWeight={500}>
                {resume.parsedData.contactInfo.name}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {resume.parsedData.contactInfo.email} | {resume.parsedData.contactInfo.phone}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {resume.parsedData.contactInfo.location}
              </Typography>
            </Box>
          )}

          {/* Summary */}
          {resume.parsedData.summary && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 1, color: theme.palette.primary.main }}>
                Professional Summary
              </Typography>
              <Typography variant="body2" sx={{ lineHeight: 1.6 }}>
                {resume.parsedData.summary}
              </Typography>
            </Box>
          )}

          {/* Experience */}
          {resume.parsedData.experience?.length > 0 && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 2, color: theme.palette.primary.main }}>
                Experience
              </Typography>
              {resume.parsedData.experience.slice(0, 3).map((exp, index) => (
                <Box key={index} sx={{ mb: 2, pb: 2, borderBottom: index < 2 ? `1px solid ${theme.palette.divider}` : 'none' }}>
                  <Typography variant="subtitle1" fontWeight={500}>
                    {exp.title} at {exp.company}
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                    {exp.startDate} - {exp.endDate || 'Present'} | {exp.location}
                  </Typography>
                  <Typography variant="body2" sx={{ mb: 1 }}>
                    {exp.description}
                  </Typography>
                  {exp.highlights?.length > 0 && (
                    <Box component="ul" sx={{ mt: 1, pl: 2 }}>
                      {exp.highlights.slice(0, 3).map((highlight, i) => (
                        <Typography component="li" variant="body2" key={i} sx={{ mb: 0.5 }}>
                          {highlight}
                        </Typography>
                      ))}
                    </Box>
                  )}
                </Box>
              ))}
            </Box>
          )}

          {/* Skills */}
          {resume.parsedData.skills?.length > 0 && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 2, color: theme.palette.primary.main }}>
                Skills
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {resume.parsedData.skills.slice(0, 12).map((skill, index) => (
                  <Chip
                    key={index}
                    label={typeof skill === 'string' ? skill : skill.name}
                    size="small"
                    variant="outlined"
                    sx={{ borderColor: alpha(theme.palette.primary.main, 0.3) }}
                  />
                ))}
                {resume.parsedData.skills.length > 12 && (
                  <Chip
                    label={`+${resume.parsedData.skills.length - 12} more`}
                    size="small"
                    color="primary"
                    variant="outlined"
                  />
                )}
              </Box>
            </Box>
          )}

          {/* Education */}
          {resume.parsedData.education?.length > 0 && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 2, color: theme.palette.primary.main }}>
                Education
              </Typography>
              {resume.parsedData.education.map((edu, index) => (
                <Box key={index} sx={{ mb: 1 }}>
                  <Typography variant="subtitle1" fontWeight={500}>
                    {edu.degree} in {edu.field}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {edu.institution} | {edu.endDate}
                  </Typography>
                </Box>
              ))}
            </Box>
          )}
        </Box>
      )}
    </Paper>
  );

  const AssistantPanel = () => (
    <Box sx={{ position: 'sticky', top: 24 }}>
      {/* AI Suggestions Banner */}
      {pendingSuggestions.length > 0 && (
        <Alert 
          severity="info" 
          icon={<SuggestionIcon />}
          sx={{ 
            mb: 2,
            border: `1px solid ${alpha(theme.palette.info.main, 0.3)}`,
            borderRadius: 2
          }}
          action={
            <Button 
              size="small" 
              onClick={handleAssistantToggle}
              sx={{ color: theme.palette.info.main }}
            >
              Review
            </Button>
          }
        >
          AJ has {pendingSuggestions.length} suggestion{pendingSuggestions.length > 1 ? 's' : ''} for your resume
        </Alert>
      )}

      {/* Assistant Status */}
      <Paper 
        elevation={1} 
        sx={{ 
          p: 2, 
          borderRadius: 2,
          background: `linear-gradient(45deg, ${alpha(theme.palette.secondary.main, 0.05)} 30%, ${alpha(theme.palette.secondary.light, 0.05)} 90%)`,
          border: `1px solid ${alpha(theme.palette.secondary.main, 0.2)}`
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <RobotIcon sx={{ color: theme.palette.secondary.main, mr: 1 }} />
          <Typography variant="h6" fontWeight={500}>
            AJ Assistant
          </Typography>
          {assistantActive && (
            <Chip 
              label="Active" 
              size="small" 
              color="success" 
              sx={{ ml: 'auto' }}
            />
          )}
        </Box>
        
        <Typography variant="body2" color="text.secondary" paragraph>
          Your AI career assistant is ready to help optimize your resume and provide career guidance.
        </Typography>

        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button
            variant="contained"
            color="secondary"
            startIcon={<ChatIcon />}
            onClick={handleAssistantToggle}
            size="small"
            fullWidth
          >
            Chat with AJ
          </Button>
        </Box>

        <Box sx={{ mt: 2, pt: 2, borderTop: `1px solid ${theme.palette.divider}` }}>
          <Typography variant="caption" color="text.secondary">
            Quick Actions:
          </Typography>
          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 1 }}>
            <Chip 
              label="Analyze Resume" 
              size="small" 
              variant="outlined" 
              clickable
              onClick={() => {/* Handle quick action */}}
            />
            <Chip 
              label="Improve Summary" 
              size="small" 
              variant="outlined" 
              clickable
            />
            <Chip 
              label="Enhance Skills" 
              size="small" 
              variant="outlined" 
              clickable
            />
          </Box>
        </Box>
      </Paper>
    </Box>
  );

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '60vh' }}>
          <Typography>Loading resume...</Typography>
        </Box>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="error">{error}</Alert>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1400px', mx: 'auto' }}>
        <Grid container spacing={3}>
          {/* Main Resume Content */}
          <Grid item xs={12} md={8}>
            <ResumePreview />
          </Grid>

          {/* AI Assistant Panel */}
          <Grid item xs={12} md={4}>
            <AssistantPanel />
          </Grid>
        </Grid>

        {/* AI Assistant Widget */}
        {showAssistant && (
          <Zoom in={showAssistant}>
            <Box>
              <AiAssistantWidget
                resumeId={resumeId}
                resumeData={resume?.parsedData}
                onResumeUpdate={handleResumeUpdate}
                position={{ bottom: 100, right: 24 }}
              />
            </Box>
          </Zoom>
        )}

        {/* Floating Assistant Button (when not shown in panel) */}
        {!showAssistant && (
          <Zoom in={!showAssistant}>
            <Fab
              color="secondary"
              onClick={handleAssistantToggle}
              sx={{
                position: 'fixed',
                bottom: 24,
                right: 24,
                zIndex: 1000,
                background: `linear-gradient(45deg, ${theme.palette.secondary.main} 30%, ${theme.palette.secondary.light} 90%)`,
                boxShadow: '0 8px 24px rgba(0, 196, 180, 0.3)',
                '&:hover': {
// Continuation of ResumeWithAssistant.js

                  background: `linear-gradient(45deg, ${theme.palette.secondary.dark} 30%, ${theme.palette.secondary.main} 90%)`,
                  transform: 'scale(1.05)',
                },
                transition: 'all 0.2s ease-in-out'
              }}
            >
              <RobotIcon sx={{ fontSize: 28 }} />
            </Fab>
          </Zoom>
        )}
      </Box>
    </MainLayout>
  );
};

export default ResumeWithAssistant;

================
File: src/components/resumes/tabs/AnalysisTab.js
================
// src/components/resumes/tabs/AnalysisTab.js
import React from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Divider
} from '@mui/material';
import {
  ArrowUpward as ArrowUpwardIcon,
  Lightbulb as LightbulbIcon,
  Timeline as TimelineIcon,
  CheckCircle as CheckCircleIcon,
  ExpandMore as ExpandMoreIcon
} from '@mui/icons-material';
import { renderImprovedSnippet } from '../utils/resumeHelpers';

/**
 * Analysis tab component showing detailed improvement areas and recommendations
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {object} props.theme - MUI theme object
 * @returns {JSX.Element} Analysis tab content
 */
const AnalysisTab = ({ resume, theme }) => {
  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  return (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Card elevation={2} sx={{ borderRadius: 3, mb: 3 }}>
          <CardHeader 
            title="Detailed Improvement Areas" 
            avatar={<ArrowUpwardIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent sx={{ pb: 1 }}>
            {(resume.analysis?.improvementAreas || []).map((area, index) => (
              <Accordion 
                key={index} 
                defaultExpanded={index === 0}
                sx={{ 
                  mb: 2, 
                  borderRadius: '8px !important', 
                  overflow: 'hidden',
                  '&:before': { display: 'none' },
                  boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
                }}
              >
                <AccordionSummary
                  expandIcon={<ExpandMoreIcon />}
                  sx={{ 
                    bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.02)' 
                  }}
                >
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <Box sx={{ 
                      width: 32, 
                      height: 32, 
                      borderRadius: '50%', 
                      bgcolor: theme.palette.primary.main,
                      color: 'white',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      mr: 2,
                      flexShrink: 0
                    }}>
                      {index + 1}
                    </Box>
                    <Typography variant="subtitle1" fontWeight="bold" sx={{ textTransform: 'capitalize' }}>
                      {area.section}
                    </Typography>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {(area.suggestions || []).map((suggestion, idx) => (
                      <ListItem key={idx} sx={{ px: 0 }}>
                        <ListItemIcon>
                          <LightbulbIcon fontSize="small" color="warning" />
                        </ListItemIcon>
                        <ListItemText primary={suggestion} />
                      </ListItem>
                    ))}
                  </List>
                  
                  {area.improvedSnippets && area.improvedSnippets.length > 0 ? (
                    <Box sx={{ mt: 2 }}>
                      <Typography variant="subtitle2" gutterBottom sx={{ 
                        color: theme.palette.primary.main,
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center'
                      }}>
                        AI-Enhanced Examples
                      </Typography>
                      {area.improvedSnippets.map((snippet) => (
                        renderImprovedSnippet(snippet, theme)
                      ))}
                    </Box>
                  ) : (
                    <Box sx={{ mt: 2 }}>
                      <Typography variant="subtitle2" gutterBottom sx={{ 
                        color: theme.palette.primary.main,
                        fontWeight: 600
                      }}>
                        No examples available for this section
                      </Typography>
                    </Box>
                  )}
                </AccordionDetails>
              </Accordion>
            ))}
          </CardContent>
        </Card>
      </Grid>

      <Grid item xs={12}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Keyword Recommendations" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>
            <Typography variant="body2" color="text.secondary" paragraph>
              Including these keywords will boost your resume's ATS compatibility and relevance for your target roles:
            </Typography>
            
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 3 }}>
              {(resume.analysis?.keywordsSuggestions || []).map((keyword, index) => (
                <Chip 
                  key={index} 
                  label={keyword} 
                  sx={{ 
                    bgcolor: COLORS[index % COLORS.length] + '20',
                    color: COLORS[index % COLORS.length],
                    fontWeight: 500,
                    borderRadius: 2
                  }} 
                />
              ))}
            </Box>
            
            <Box sx={{ 
              p: 2, 
              bgcolor: 'rgba(33, 150, 243, 0.1)', 
              borderRadius: 2,
              border: '1px solid rgba(33, 150, 243, 0.2)',
              display: 'flex',
              alignItems: 'flex-start'
            }}>
              <CheckCircleIcon color="info" sx={{ mr: 1.5, mt: 0.5 }} />
              <Typography variant="body2">
                Using these keywords strategically throughout your resume helps you pass through Applicant Tracking Systems (ATS) and catch the attention of recruiters looking for these specific skills and qualifications.
              </Typography>
            </Box>
          </CardContent>
        </Card>
      </Grid>

      {resume.analysis?.profileSummary && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Career Path Analysis" 
              avatar={<TimelineIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <Box sx={{ mb: 3 }}>
                    <Typography variant="subtitle1" gutterBottom fontWeight={600} color="primary">
                      Current Profile
                    </Typography>
                    <Box sx={{ p: 2, bgcolor: 'rgba(0,0,0,0.02)', borderRadius: 2 }}>
                      <Typography variant="body1" fontWeight={500} paragraph>
                        {resume.analysis.profileSummary.currentRole || 'Product Manager'}
                      </Typography>
                      <Typography variant="body2" paragraph>
                        Career Level: {resume.analysis.profileSummary.careerLevel || 'Mid-Senior'}
                      </Typography>
                      <Typography variant="body2" sx={{ mb: 1 }}>
                        Industry Experience:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                        {(resume.analysis.profileSummary.industries || ['Software', 'SaaS', 'Enterprise']).map((industry, index) => (
                          <Chip 
                            key={index} 
                            label={industry} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.primary.main}20`,
                              color: theme.palette.primary.main 
                            }} 
                          />
                        ))}
                      </Box>
                    </Box>
                  </Box>
                </Grid>
                
                <Grid item xs={12} md={6}>
                  <Box sx={{ mb: 3 }}>
                    <Typography variant="subtitle1" gutterBottom fontWeight={600} color="primary">
                      Career Progression Opportunities
                    </Typography>
                    <Box sx={{ p: 2, bgcolor: 'rgba(0,0,0,0.02)', borderRadius: 2 }}>
                      <Typography variant="body2" sx={{ mb: 1 }}>
                        Suggested Job Titles:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mb: 2 }}>
                        {(resume.analysis.profileSummary.suggestedJobTitles || ['Senior Product Manager', 'Product Lead', 'Director of Product']).map((title, index) => (
                          <Chip 
                            key={index} 
                            label={title} 
                            size="small" 
                            variant="outlined" 
                            color="primary" 
                          />
                        ))}
                      </Box>
                      
                      <Typography variant="body2" sx={{ mb: 1 }}>
                        Recommended Industries:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                        {(resume.analysis.profileSummary.suggestedIndustries || ['AI/ML', 'FinTech', 'Enterprise SaaS']).map((industry, index) => (
                          <Chip 
                            key={index} 
                            label={industry} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.secondary.main}20`,
                              color: theme.palette.secondary.main
                            }} 
                          />
                        ))}
                      </Box>
                    </Box>
                  </Box>
                </Grid>
                
                <Grid item xs={12}>
                  <Divider sx={{ my: 1 }} />
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="subtitle1" gutterBottom fontWeight={600} color="primary">
                      Career Growth Recommendations
                    </Typography>
                    <List dense>
                      <ListItem sx={{ px: 0 }}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" />
                        </ListItemIcon>
                        <ListItemText 
                          primary="Highlight quantifiable achievements in product launches and user metrics" 
                          secondary="Add specific numbers to demonstrate your impact on business outcomes"
                        />
                      </ListItem>
                      <ListItem sx={{ px: 0 }}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" />
                        </ListItemIcon>
                        <ListItemText 
                          primary="Showcase strategic thinking and leadership experience" 
                          secondary="Emphasize instances where you've led cross-functional teams or influenced product strategy"
                        />
                      </ListItem>
                      <ListItem sx={{ px: 0 }}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" />
                        </ListItemIcon>
                        <ListItemText 
                          primary="Emphasize technical skills alongside product management expertise" 
                          secondary="Highlight your understanding of technical concepts, data analysis capabilities, and technical tools"
                        />
                      </ListItem>
                    </List>
                  </Box>
                </Grid>
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}
    </Grid>
  );
};

export default AnalysisTab;

================
File: src/components/resumes/tabs/ContentTab.js
================
// src/components/resumes/tabs/ContentTab.js
import React from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip
} from '@mui/material';
import {
  Person as PersonIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  LocationOn as LocationOnIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  School as SchoolIcon,
  Code as CodeIcon,
  CheckCircle as CheckCircleIcon,
  BusinessCenter as BusinessCenterIcon,
  Timeline as TimelineIcon
} from '@mui/icons-material';
import { formatDateRange } from '../utils/resumeHelpers';

/**
 * Content tab component showing full resume content in structured format
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {object} props.theme - MUI theme object
 * @returns {JSX.Element} Content tab content
 */
const ContentTab = ({ resume, theme }) => {
  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  return (
    <Grid container spacing={3}>
      {/* Contact Information */}
      <Grid item xs={12}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Contact Information" 
            avatar={<PersonIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <PersonIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Name</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.name || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <EmailIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Email</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.email || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <PhoneIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Phone</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.phone || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <LocationOnIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Location</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.location || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
      </Grid>

      {/* Summary */}
      {resume.parsedData?.summary && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Professional Summary" 
              avatar={<DescriptionIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Typography variant="body1" sx={{ lineHeight: 1.7 }}>
                {resume.parsedData.summary}
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Experience */}
      {resume.parsedData?.experience && resume.parsedData.experience.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Work Experience" 
              avatar={<WorkIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              {resume.parsedData.experience.map((exp, index) => (
                <Box key={index} sx={{ 
                  mb: 3, 
                  pb: 3, 
                  borderBottom: index < resume.parsedData.experience.length - 1 ? '1px solid' : 'none', 
                  borderColor: 'divider' 
                }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap' }}>
                    <Box>
                      <Typography variant="h6" fontWeight={600} color="primary">
                        {exp.title}
                      </Typography>
                      <Typography variant="subtitle1" sx={{ display: 'flex', alignItems: 'center' }}>
                        <BusinessCenterIcon fontSize="small" sx={{ mr: 1, color: theme.palette.secondary.main }} />
                        {exp.company}
                      </Typography>
                    </Box>
                    
                    <Box sx={{ 
                      bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)', 
                      px: 1.5, 
                      py: 0.5, 
                      borderRadius: 2,
                      display: 'flex',
                      alignItems: 'center',
                      alignSelf: 'flex-start'
                    }}>
                      <TimelineIcon fontSize="small" sx={{ mr: 0.5, color: theme.palette.primary.main }} />
                      <Typography variant="body2" color="text.secondary">
                        {formatDateRange(exp.startDate, exp.endDate)}
                      </Typography>
                    </Box>
                  </Box>
                  
                  {exp.location && (
                    <Typography variant="body2" color="text.secondary" sx={{ 
                      display: 'flex', 
                      alignItems: 'center', 
                      mt: 0.5 
                    }}>
                      <LocationOnIcon fontSize="small" sx={{ mr: 0.5 }} /> {exp.location}
                    </Typography>
                  )}
                  
                  {exp.description && (
                    <Typography variant="body2" sx={{ whiteSpace: 'pre-line', my: 1.5 }}>
                      {exp.description}
                    </Typography>
                  )}
                  
                  {exp.highlights && exp.highlights.length > 0 && (
                    <Box sx={{ mt: 1.5 }}>
                      <Typography variant="body2" fontWeight="bold" color="primary">
                        Key Achievements:
                      </Typography>
                      <List dense sx={{ pl: 2 }}>
                        {exp.highlights.map((highlight, idx) => (
                          <ListItem key={idx} sx={{ px: 0, py: 0.5 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}>
                              <CheckCircleIcon fontSize="small" color="success" />
                            </ListItemIcon>
                            <ListItemText primary={highlight} />
                          </ListItem>
                        ))}
                      </List>
                    </Box>
                  )}
                  
                  {exp.skills && exp.skills.length > 0 && (
                    <Box sx={{ mt: 1.5 }}>
                      <Typography variant="body2" fontWeight="bold" color="primary">
                        Skills Used:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 0.5 }}>
                        {exp.skills.map((skill, idx) => (
                          <Chip 
                            key={idx} 
                            label={skill} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.primary.main}15`,
                              color: theme.palette.primary.main 
                            }} 
                          />
                        ))}
                      </Box>
                    </Box>
                  )}
                </Box>
              ))}
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Education */}
      {resume.parsedData?.education && resume.parsedData.education.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Education" 
              avatar={<SchoolIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              {resume.parsedData.education.map((edu, index) => (
                <Box key={index} sx={{ 
                  mb: 3, 
                  pb: 3, 
                  borderBottom: index < resume.parsedData.education.length - 1 ? '1px solid' : 'none', 
                  borderColor: 'divider' 
                }}>
                  <Typography variant="h6" fontWeight={600} color="primary">
                    {edu.degree} {edu.field ? `in ${edu.field}` : ''}
                  </Typography>
                  <Typography variant="subtitle1" sx={{ display: 'flex', alignItems: 'center' }}>
                    <SchoolIcon fontSize="small" sx={{ mr: 1, color: theme.palette.secondary.main }} />
                    {edu.institution}
                  </Typography>
                  <Box sx={{ 
                    bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)', 
                    px: 1.5, 
                    py: 0.5, 
                    borderRadius: 2,
                    display: 'inline-flex',
                    alignItems: 'center',
                    mt: 1
                  }}>
                    <TimelineIcon fontSize="small" sx={{ mr: 0.5, color: theme.palette.primary.main }} />
                    <Typography variant="body2" color="text.secondary">
                      {formatDateRange(edu.startDate, edu.endDate)}
                    </Typography>
                  </Box>
                  
                  {edu.gpa && (
                    <Typography variant="body2" sx={{ mt: 1.5 }}>
                      <b>GPA:</b> {edu.gpa}
                    </Typography>
                  )}
                  
                  {edu.highlights && edu.highlights.length > 0 && (
                    <Box sx={{ mt: 1.5 }}>
                      <Typography variant="body2" fontWeight="bold" color="primary">
                        Highlights:
                      </Typography>
                      <List dense sx={{ pl: 2 }}>
                        {edu.highlights.map((highlight, idx) => (
                          <ListItem key={idx} sx={{ px: 0, py: 0.5 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}>
                              <CheckCircleIcon fontSize="small" color="success" />
                            </ListItemIcon>
                            <ListItemText primary={highlight} />
                          </ListItem>
                        ))}
                      </List>
                    </Box>
                  )}
                </Box>
              ))}
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Certifications */}
      {resume.parsedData?.certifications && resume.parsedData.certifications.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Certifications" 
              avatar={<CheckCircleIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={2}>
                {resume.parsedData.certifications.map((cert, index) => (
                  <Grid item xs={12} sm={6} lg={4} key={index}>
                    <Box sx={{ 
                      p: 2, 
                      borderRadius: 2, 
                      border: '1px solid',
                      borderColor: theme.palette.divider,
                      height: '100%',
                      display: 'flex',
                      flexDirection: 'column',
                      transition: 'all 0.2s ease',
                      '&:hover': {
                        boxShadow: '0 4px 12px rgba(0,0,0,0.08)',
                        borderColor: theme.palette.primary.light
                      }
                    }}>
                      <Typography variant="h6" fontWeight={600} color="primary" gutterBottom>
                        {cert.name}
                      </Typography>
                      <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        <BusinessCenterIcon fontSize="small" sx={{ mr: 0.5, color: theme.palette.secondary.main }} />
                        {cert.issuer}
                      </Typography>
                      {cert.dateObtained && (
                        <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', color: 'text.secondary' }}>
                          <TimelineIcon fontSize="small" sx={{ mr: 0.5 }} />
                          {new Date(cert.dateObtained).toLocaleDateString()}
                          {cert.validUntil && ` - ${new Date(cert.validUntil).toLocaleDateString()}`}
                        </Typography>
                      )}
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Skills */}
      {resume.parsedData?.skills && resume.parsedData.skills.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Skills" 
              avatar={<CodeIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {resume.parsedData.skills.map((skill, index) => {
                  let color;
                  if (typeof skill === 'object' && skill.level) {
                    color = skill.level === 'Expert' ? theme.palette.success.main : 
                            skill.level === 'Advanced' ? theme.palette.info.main : 
                            skill.level === 'Intermediate' ? theme.palette.warning.main : 
                            theme.palette.grey[600];
                  } else {
                    color = COLORS[index % COLORS.length];
                  }
                  
                  return (
                    <Chip 
                      key={index} 
                      label={
                        typeof skill === 'object' ? 
                          skill.level ? 
                            `${skill.name} (${skill.level})` : 
                            skill.name : 
                          skill
                      } 
                      sx={{ 
                        bgcolor: `${color}15`, 
                        color: color,
                        fontWeight: 500,
                        borderRadius: 2,
                        py: 2
                      }} 
                    />
                  );
                })}
              </Box>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Languages */}
      {resume.parsedData?.languages && resume.parsedData.languages.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Languages" 
              avatar={<PersonIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={2}>
                {resume.parsedData.languages.map((lang, index) => (
                  <Grid item xs={12} sm={6} md={4} lg={3} key={index}>
                    <Box sx={{ 
                      p: 2,
                      borderRadius: 2,
                      border: '1px solid',
                      borderColor: theme.palette.divider,
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center'
                    }}>
                      <Box>
                        <Typography variant="body1" fontWeight="medium">{lang.language}</Typography>
                        {lang.proficiency && (
                          <Typography variant="body2" color="text.secondary">{lang.proficiency}</Typography>
                        )}
                      </Box>
                      {lang.proficiency && (
                        <Chip 
                          label={lang.proficiency} 
                          size="small" 
                          sx={{ 
                            bgcolor: theme.palette.primary.main + '20',
                            color: theme.palette.primary.main,
                            fontWeight: 500 
                          }} 
                        />
                      )}
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Projects */}
      {resume.parsedData?.projects && resume.parsedData.projects.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Projects" 
              avatar={<WorkIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={3}>
                {resume.parsedData.projects.map((project, index) => (
                  <Grid item xs={12} md={6} key={index}>
                    <Box sx={{ 
                      p: 2,
                      borderRadius: 3,
                      border: '1px solid',
                      borderColor: theme.palette.divider,
                      height: '100%',
                      transition: 'all 0.2s ease',
                      '&:hover': {
                        boxShadow: '0 4px 20px rgba(0,0,0,0.08)',
                        borderColor: theme.palette.primary.light
                      }
                    }}>
                      <Typography variant="h6" fontWeight={600} color="primary">
                        {project.name}
                      </Typography>
                      
                      {project.url && (
                        <Typography variant="body2" color="primary" component="a" href={project.url} target="_blank" sx={{ 
                          display: 'block', 
                          mb: 1,
                          textDecoration: 'none',
                          '&:hover': { textDecoration: 'underline' }
                        }}>
                          {project.url}
                        </Typography>
                      )}
                      
                      {(project.startDate || project.endDate) && (
                        <Typography variant="body2" color="text.secondary" sx={{ 
                          mb: 1.5,
                          display: 'flex',
                          alignItems: 'center' 
                        }}>
                          <TimelineIcon fontSize="small" sx={{ mr: 0.5 }} />
                          {formatDateRange(project.startDate, project.endDate)}
                        </Typography>
                      )}
                      
                      {project.description && (
                        <Typography variant="body2" sx={{ mb: 1.5 }}>
                          {project.description}
                        </Typography>
                      )}
                      
                      {project.skills && project.skills.length > 0 && (
                        <Box sx={{ mt: 1.5 }}>
                          <Typography variant="body2" fontWeight="bold" color="text.secondary">
                            Technologies Used:
                          </Typography>
                          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 1 }}>
                            {project.skills.map((skill, idx) => (
                              <Chip 
                                key={idx} 
                                label={skill} 
                                size="small" 
                                sx={{ 
                                  bgcolor: `${theme.palette.secondary.main}15`,
                                  color: theme.palette.secondary.main 
                                }} 
                              />
                            ))}
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}
    </Grid>
  );
};

export default ContentTab;

================
File: src/components/resumes/tabs/OverviewTab.js
================
// src/components/resumes/tabs/OverviewTab.js
import React from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  LinearProgress
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  Person as PersonIcon,
  BusinessCenter as BusinessCenterIcon,
  Timeline as TimelineIcon,
  Lightbulb as LightbulbIcon
} from '@mui/icons-material';
import ScoreDisplay from '../components/ScoreDisplay';

/**
 * Overview tab component showing resume scores, strengths, and profile summary
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {object} props.theme - MUI theme object
 * @returns {JSX.Element} Overview tab content
 */
const OverviewTab = ({ resume, theme }) => {
  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  return (
    <Grid container spacing={3}>
      <Grid item xs={12} md={4}>
        {/* Resume Scores Card */}
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Resume Scores" 
            avatar={<CheckCircleIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent sx={{ display: 'flex', justifyContent: 'center', flexDirection: 'column', alignItems: 'center' }}>
            <ScoreDisplay 
              value={resume.analysis?.overallScore || 0} 
              label="Overall Score"
            />
            
            <Box sx={{ width: '100%', mt: 3 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body1">ATS Compatibility</Typography>
                <Typography variant="h6" fontWeight="medium">
                  {resume.analysis?.atsCompatibility || 0}%
                </Typography>
              </Box>
              <LinearProgress 
                variant="determinate" 
                value={resume.analysis?.atsCompatibility || 0}
                sx={{ height: 8, borderRadius: 4 }}
              />
            </Box>
          </CardContent>
        </Card>

        {/* Profile Summary Card */}
        {resume.analysis?.profileSummary && (
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Professional Profile" 
              avatar={<PersonIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <List disablePadding>
                <ListItem disableGutters sx={{ px: 0, py: 1 }}>
                  <ListItemIcon sx={{ minWidth: 40 }}>
                    <BusinessCenterIcon fontSize="small" color="primary" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Current Role" 
                    secondary={resume.analysis.profileSummary.currentRole || 'Not specified'}
                  />
                </ListItem>
                
                <ListItem disableGutters sx={{ px: 0, py: 1 }}>
                  <ListItemIcon sx={{ minWidth: 40 }}>
                    <TimelineIcon fontSize="small" color="primary" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Career Level" 
                    secondary={resume.analysis.profileSummary.careerLevel || 'Mid-level'}
                  />
                </ListItem>
              </List>
              
              {resume.analysis.profileSummary.suggestedJobTitles?.length > 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography variant="subtitle2" gutterBottom color="text.secondary">
                    Suggested Job Titles
                  </Typography>
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                    {resume.analysis.profileSummary.suggestedJobTitles.map((title, index) => (
                      <Chip 
                        key={index} 
                        label={title} 
                        size="small" 
                        variant="outlined" 
                        color="primary" 
                      />
                    ))}
                  </Box>
                </Box>
              )}
            </CardContent>
          </Card>
        )}
      </Grid>

      <Grid item xs={12} md={8}>
        {/* Strengths & Weaknesses */}
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Strengths & Improvement Areas" 
            avatar={<CheckCircleIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle1" gutterBottom color="success.main" fontWeight={600}>
                  <CheckCircleIcon sx={{ mr: 1, verticalAlign: 'middle' }} /> Strengths
                </Typography>
                <List dense>
                  {(resume.analysis?.strengths || []).map((strength, index) => (
                    <ListItem key={index} sx={{ 
                      backgroundColor: `${theme.palette.success.main}10`, 
                      borderRadius: 2, 
                      mb: 1,
                      px: 2
                    }}>
                      <ListItemText primary={strength} />
                    </ListItem>
                  ))}
                </List>
              </Grid>

              <Grid item xs={12} md={6}>
                <Typography variant="subtitle1" gutterBottom color="warning.main" fontWeight={600}>
                  <WarningIcon sx={{ mr: 1, verticalAlign: 'middle' }} /> Improvement Areas
                </Typography>
                <List dense>
                  {(resume.analysis?.weaknesses || []).map((weakness, index) => (
                    <ListItem key={index} sx={{ 
                      backgroundColor: `${theme.palette.warning.main}10`, 
                      borderRadius: 2, 
                      mb: 1,
                      px: 2 
                    }}>
                      <ListItemText primary={weakness} />
                    </ListItem>
                  ))}
                </List>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
        
        {/* Keywords */}
        <Card elevation={2} sx={{ borderRadius: 3 }}>
          <CardHeader 
            title="Keyword Recommendations" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>                    
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
              {(resume.analysis?.keywordsSuggestions || []).map((keyword, index) => (
                <Chip 
                  key={index} 
                  label={keyword} 
                  sx={{ 
                    bgcolor: COLORS[index % COLORS.length] + '20',
                    color: COLORS[index % COLORS.length],
                    fontWeight: 500,
                    borderRadius: 2
                  }} 
                />
              ))}
            </Box>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
};

export default OverviewTab;

================
File: src/components/resumes/utils/resumeHelpers.js
================
// src/components/resumes/utils/resumeHelpers.js
import React from 'react';
import {
  Box,
  Typography,
  Card,
  CardContent,
  Avatar,
} from '@mui/material';
import { ArrowUpward as ArrowUpwardIcon } from '@mui/icons-material';

/**
 * Renders an improved snippet component showing before/after text
 * @param {object} snippet - Snippet object with original and improved text
 * @param {object} theme - MUI theme object
 * @returns {JSX.Element} Rendered snippet card
 */
export const renderImprovedSnippet = (snippet, theme) => {
  return (
    <Card variant="outlined" sx={{ mb: 2, overflow: 'visible', borderRadius: 2 }} key={snippet.original}>
      <CardContent sx={{ p: 2 }}>
        <Box sx={{ position: 'relative', mb: 2 }}>
          <Box sx={{ 
            backgroundColor: 'rgba(239, 83, 80, 0.1)', 
            color: 'text.primary', 
            p: 2, 
            borderRadius: 2,
            position: 'relative',
            border: '1px solid rgba(239, 83, 80, 0.3)'
          }}>
            <Typography variant="body2" sx={{ fontFamily: 'monospace' }}>
              {snippet.original}
            </Typography>
          </Box>
          <Box sx={{ 
            display: 'flex', 
            justifyContent: 'center', 
            py: 1 
          }}>
            <Avatar sx={{ bgcolor: theme.palette.primary.main }}>
              <ArrowUpwardIcon />
            </Avatar>
          </Box>
          <Box sx={{ 
            backgroundColor: 'rgba(76, 175, 80, 0.1)', 
            color: 'text.primary', 
            p: 2, 
            borderRadius: 2,
            border: '1px solid rgba(76, 175, 80, 0.3)'
          }}>
            <Typography variant="body2" sx={{ fontFamily: 'monospace' }}>
              {snippet.improved}
            </Typography>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};

/**
 * Gets color based on score value
 * @param {number} value - Score value (0-100)
 * @param {object} theme - MUI theme object
 * @returns {string} Color value
 */
export const getScoreColor = (value, theme) => {
  if (value >= 80) return theme.palette.success.main;
  if (value >= 60) return theme.palette.warning.main;
  return theme.palette.error.main;
};

/**
 * Formats date range for display
 * @param {string|Date} startDate - Start date
 * @param {string|Date} endDate - End date
 * @returns {string} Formatted date range
 */
export const formatDateRange = (startDate, endDate) => {
  if (startDate && endDate) {
    return `${new Date(startDate).toLocaleDateString()} - ${endDate ? new Date(endDate).toLocaleDateString() : 'Present'}`;
  } else if (startDate) {
    return `From ${new Date(startDate).toLocaleDateString()}`;
  } else if (endDate) {
    return `Until ${new Date(endDate).toLocaleDateString()}`;
  }
  return 'Date not specified';
};

================
File: src/components/search/SearchPage.js
================
// src/components/search/SearchPage.js
import React, { useState, useEffect } from 'react';
import {
  Box,
  Container,
  Typography,
  Paper,
  Grid,
  Card,
  CardContent,
  TextField,
  InputAdornment,
  IconButton,
  Chip,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Tabs,
  Tab,
  CircularProgress,
  Alert,
  useTheme,
  alpha,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Checkbox,
  FormControlLabel,
  Slider,
  Badge
} from '@mui/material';
import {
  Search as SearchIcon,
  Clear as ClearIcon,
  FilterList as FilterListIcon,
  Sort as SortIcon,
  Work as WorkIcon,
  Description as DescriptionIcon,
  Person as PersonIcon,
  ExpandMore as ExpandMoreIcon,
  History as HistoryIcon,
  TrendingUp as TrendingUpIcon,
  Bookmark as BookmarkIcon,
  Share as ShareIcon,
  Download as DownloadIcon
} from '@mui/icons-material';
import { useLocation, useNavigate } from 'react-router-dom';
import MainLayout from '../layout/MainLayout';
import useSearch from '../../hooks/useSearch';
import searchService from '../../utils/searchService';

const SearchPage = () => {
  const theme = useTheme();
  const location = useLocation();
  const navigate = useNavigate();
  
  // Initialize search with URL params
  const searchParams = new URLSearchParams(location.search);
  const initialQuery = searchParams.get('q') || '';
  const initialCategory = searchParams.get('category') || 'all';

  const {
    query,
    category,
    results,
    suggestions,
    isLoading,
    error,
    recentSearches,
    setQuery,
    setCategory,
    search,
    clearAll,
    getResultsForCategory,
    getTotalResults,
    hasResults,
    categories
  } = useSearch({
    initialQuery,
    initialCategory,
    autoSearch: true,
    onSearchComplete: (results, searchQuery) => {
      // Update URL with search params
      const newSearchParams = new URLSearchParams();
      newSearchParams.set('q', searchQuery);
      if (category !== 'all') {
        newSearchParams.set('category', category);
      }
      navigate(`/search?${newSearchParams}`, { replace: true });
    }
  });

  // Advanced filters state
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const [filters, setFilters] = useState({
    dateRange: 'all',
    matchScore: [0, 100],
    location: '',
    company: '',
    experienceLevel: '',
    skills: [],
    sortBy: 'relevance',
    sortOrder: 'desc'
  });

  // Popular searches and categories
  const [popularSearches, setPopularSearches] = useState([]);

  useEffect(() => {
    loadPopularSearches();
  }, []);

  const loadPopularSearches = async () => {
    try {
      const popular = await searchService.getPopularSearches();
      setPopularSearches(popular.searches || []);
    } catch (error) {
      console.error('Error loading popular searches:', error);
    }
  };

  const handleSearchSubmit = (event) => {
    event.preventDefault();
    if (query.trim()) {
      search(query, category);
    }
  };

  const handleCategoryChange = (event, newCategory) => {
    setCategory(newCategory);
  };

  const handleFilterChange = (filterName, value) => {
    setFilters(prev => ({
      ...prev,
      [filterName]: value
    }));
  };

  const handleClearFilters = () => {
    setFilters({
      dateRange: 'all',
      matchScore: [0, 100],
      location: '',
      company: '',
      experienceLevel: '',
      skills: [],
      sortBy: 'relevance',
      sortOrder: 'desc'
    });
  };

  const handleResultClick = (result) => {
    navigate(result.url);
  };

  const renderSearchInput = () => (
    <Paper elevation={2} sx={{ p: 3, mb: 3 }}>
      <Box component="form" onSubmit={handleSearchSubmit}>
        <TextField
          fullWidth
          variant="outlined"
          placeholder="Search jobs, resumes, recruiters, companies, skills..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon color="action" />
              </InputAdornment>
            ),
            endAdornment: (
              <InputAdornment position="end">
                {query && (
                  <IconButton onClick={() => setQuery('')} edge="end">
                    <ClearIcon />
                  </IconButton>
                )}
                <Button
                  type="submit"
                  variant="contained"
                  sx={{ ml: 1 }}
                  disabled={!query.trim()}
                >
                  Search
                </Button>
              </InputAdornment>
            )
          }}
          sx={{
            '& .MuiOutlinedInput-root': {
              fontSize: '1.1rem',
              '& fieldset': {
                borderColor: alpha(theme.palette.primary.main, 0.3),
              },
              '&:hover fieldset': {
                borderColor: theme.palette.primary.main,
              },
              '&.Mui-focused fieldset': {
                borderColor: theme.palette.primary.main,
              },
            }
          }}
        />
      </Box>

      {/* Recent and Popular Searches */}
      {!query && (
        <Box sx={{ mt: 2 }}>
          {recentSearches.length > 0 && (
            <Box sx={{ mb: 2 }}>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <HistoryIcon fontSize="small" sx={{ mr: 1 }} />
                Recent Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {recentSearches.slice(0, 5).map((search, index) => (
                  <Chip
                    key={index}
                    label={search.query}
                    onClick={() => setQuery(search.query)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}

          {popularSearches.length > 0 && (
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <TrendingUpIcon fontSize="small" sx={{ mr: 1 }} />
                Popular Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {popularSearches.slice(0, 8).map((search, index) => (
                  <Chip
                    key={index}
                    label={search}
                    variant="outlined"
                    onClick={() => setQuery(search)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
        </Box>
      )}
    </Paper>
  );

  const renderFilters = () => (
    <Card sx={{ mb: 3 }}>
      <CardContent>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
          <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center' }}>
            <FilterListIcon sx={{ mr: 1 }} />
            Filters
          </Typography>
          <Box>
            <Button
              variant="outlined"
              size="small"
              onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
              sx={{ mr: 1 }}
            >
              Advanced
            </Button>
            <Button
              variant="text"
              size="small"
              onClick={handleClearFilters}
            >
              Clear All
            </Button>
          </Box>
        </Box>

        <Grid container spacing={2}>
          <Grid item xs={12} sm={6} md={3}>
            <FormControl fullWidth size="small">
              <InputLabel>Date Range</InputLabel>
              <Select
                value={filters.dateRange}
                onChange={(e) => handleFilterChange('dateRange', e.target.value)}
                label="Date Range"
              >
                <MenuItem value="all">All Time</MenuItem>
                <MenuItem value="today">Today</MenuItem>
                <MenuItem value="week">This Week</MenuItem>
                <MenuItem value="month">This Month</MenuItem>
                <MenuItem value="quarter">This Quarter</MenuItem>
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <FormControl fullWidth size="small">
              <InputLabel>Sort By</InputLabel>
              <Select
                value={filters.sortBy}
                onChange={(e) => handleFilterChange('sortBy', e.target.value)}
                label="Sort By"
              >
                <MenuItem value="relevance">Relevance</MenuItem>
                <MenuItem value="date">Date</MenuItem>
                <MenuItem value="match_score">Match Score</MenuItem>
                <MenuItem value="alphabetical">Alphabetical</MenuItem>
              </Select>
            </FormControl>
          </Grid>

          {category === 'jobs' && (
            <>
              <Grid item xs={12} sm={6} md={3}>
                <TextField
                  fullWidth
                  size="small"
                  label="Location"
                  value={filters.location}
                  onChange={(e) => handleFilterChange('location', e.target.value)}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <TextField
                  fullWidth
                  size="small"
                  label="Company"
                  value={filters.company}
                  onChange={(e) => handleFilterChange('company', e.target.value)}
                />
              </Grid>
            </>
          )}
        </Grid>

        {/* Advanced Filters */}
        {showAdvancedFilters && (
          <Accordion sx={{ mt: 2 }}>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography>Advanced Filters</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" gutterBottom>
                    Match Score Range
                  </Typography>
                  <Slider
                    value={filters.matchScore}
                    onChange={(e, value) => handleFilterChange('matchScore', value)}
                    valueLabelDisplay="auto"
                    marks={[
                      { value: 0, label: '0%' },
                      { value: 50, label: '50%' },
                      { value: 100, label: '100%' }
                    ]}
                  />
                </Grid>
                
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" gutterBottom>
                    Experience Level
                  </Typography>
                  <Box sx={{ display: 'flex', flexDirection: 'column' }}>
                    {['Entry Level', 'Mid Level', 'Senior Level', 'Executive'].map((level) => (
                      <FormControlLabel
                        key={level}
                        control={<Checkbox size="small" />}
                        label={level}
                      />
                    ))}
                  </Box>
                </Grid>
              </Grid>
            </AccordionDetails>
          </Accordion>
        )}
      </CardContent>
    </Card>
  );

  const renderCategoryTabs = () => (
    <Paper sx={{ mb: 3 }}>
      <Tabs
        value={category}
        onChange={handleCategoryChange}
        variant="scrollable"
        scrollButtons="auto"
        sx={{ borderBottom: 1, borderColor: 'divider' }}
      >
        {categories.map((cat) => (
          <Tab
            key={cat.value}
            value={cat.value}
            label={
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                {cat.label}
                {results && getResultsForCategory(cat.value).length > 0 && (
                  <Badge
                    badgeContent={getResultsForCategory(cat.value).length}
                    color="primary"
                    sx={{
                      '& .MuiBadge-badge': {
                        fontSize: '0.7rem',
                        height: 16,
                        minWidth: 16
                      }
                    }}
                  />
                )}
              </Box>
            }
          />
        ))}
      </Tabs>
    </Paper>
  );

  const renderResults = () => {
    if (isLoading) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
          <CircularProgress />
        </Box>
      );
    }

    if (error) {
      return (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      );
    }

    if (!hasResults() && query) {
      return (
        <Paper sx={{ p: 4, textAlign: 'center' }}>
          <SearchIcon sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
          <Typography variant="h6" gutterBottom>
            No results found for "{query}"
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
            Try adjusting your search terms or filters
          </Typography>
          <Button onClick={clearAll}>Clear Search</Button>
        </Paper>
      );
    }

    if (!hasResults()) {
      return null;
    }

    const currentResults = getResultsForCategory(category);

    return (
      <Paper>
        <Box sx={{ p: 2, borderBottom: '1px solid', borderColor: 'divider' }}>
          <Typography variant="h6">
            {getTotalResults()} results found
            {query && ` for "${query}"`}
          </Typography>
        </Box>

        <List>
          {currentResults.map((result, index) => {
            const typeDisplay = searchService.getResultTypeDisplay(result.type);
            
            return (
              <React.Fragment key={`${result.type}-${result.id}`}>
                {index > 0 && <Divider />}
                <ListItem
                  button
                  onClick={() => handleResultClick(result)}
                  sx={{ py: 2 }}
                >
                  <ListItemIcon>
                    <Box
                      sx={{
                        width: 40,
                        height: 40,
                        borderRadius: 1,
                        backgroundColor: alpha(typeDisplay.color, 0.1),
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        color: typeDisplay.color
                      }}
                    >
                      {result.type === 'job' && <WorkIcon />}
                      {result.type === 'resume' && <DescriptionIcon />}
                      {result.type === 'recruiter' && <PersonIcon />}
                    </Box>
                  </ListItemIcon>
                  
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                        <Typography variant="subtitle1" sx={{ fontWeight: 500 }}>
                          {result.title}
                        </Typography>
                        <Chip
                          label={typeDisplay.label}
                          size="small"
                          sx={{ 
                            backgroundColor: alpha(typeDisplay.color, 0.1),
                            color: typeDisplay.color,
                            fontSize: '0.7rem'
                          }}
                        />
                        {result.matchScore && (
                          <Chip
                            label={`${result.matchScore}% match`}
                            size="small"
                            color={result.matchScore >= 80 ? 'success' : result.matchScore >= 60 ? 'info' : 'warning'}
                            sx={{ fontSize: '0.7rem' }}
                          />
                        )}
                      </Box>
                    }
                    secondary={
                      <Box>
                        <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                          {result.subtitle}
                        </Typography>
                        {result.description && (
                          <Typography variant="caption" display="block" color="text.secondary" sx={{ mb: 0.5 }}>
                            {result.description}
                          </Typography>
                        )}
                        {result.skills && result.skills.length > 0 && (
                          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                            {result.skills.slice(0, 5).map((skill, skillIndex) => (
                              <Chip
                                key={skillIndex}
                                label={typeof skill === 'string' ? skill : skill.name}
                                size="small"
                                variant="outlined"
                                sx={{ height: 20, fontSize: '0.65rem' }}
                              />
                            ))}
                            {result.skills.length > 5 && (
                              <Typography variant="caption" color="text.secondary">
                                +{result.skills.length - 5} more
                              </Typography>
                            )}
                          </Box>
                        )}
                      </Box>
                    }
                  />

                  <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                    <IconButton size="small">
                      <BookmarkIcon fontSize="small" />
                    </IconButton>
                    <IconButton size="small">
                      <ShareIcon fontSize="small" />
                    </IconButton>
                  </Box>
                </ListItem>
              </React.Fragment>
            );
          })}
        </List>
      </Paper>
    );
  };

  return (
    <MainLayout>
      <Container maxWidth="xl">
        <Box sx={{ py: 3 }}>
          <Typography variant="h4" gutterBottom>
            Search
          </Typography>
          
          {renderSearchInput()}
          
          {query && (
            <>
              {renderFilters()}
              {renderCategoryTabs()}
            </>
          )}
          
          {renderResults()}
        </Box>
      </Container>
    </MainLayout>
  );
};

export default SearchPage;

================
File: src/components/SettingsPage.js
================
// src/components/SettingsPage.js
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Card,
  CardContent,
  TextField,
  Button,
  Grid,
  Divider,
  Alert,
  Avatar,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Chip,
  LinearProgress,
  Paper,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  ListItemSecondaryAction
} from '@mui/material';
import {
  Person as PersonIcon,
  Security as SecurityIcon,
  Edit as EditIcon,
  Save as SaveIcon,
  Cancel as CancelIcon,
  Lock as LockIcon,
  Delete as DeleteIcon,
  Verified as VerifiedIcon,
  Warning as WarningIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import { useAuth } from '../context/AuthContext';
import MainLayout from './layout/MainLayout';
import settingsService from '../utils/settingsService';

console.log('🔧 SettingsPage component is being loaded...');

const SettingsPage = () => {
  console.log('🔧 SettingsPage component is rendering...');
  const theme = useTheme();
  const { currentUser, refreshUser } = useAuth();
  
  // Form state
  const [profileData, setProfileData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phoneNumber: ''
  });
  
  const [passwordData, setPasswordData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  // UI state
  const [isEditingProfile, setIsEditingProfile] = useState(false);
  const [isChangingPassword, setIsChangingPassword] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [deleteConfirmText, setDeleteConfirmText] = useState('');
  const [showPasswords, setShowPasswords] = useState({
    current: false,
    new: false,
    confirm: false
  });
  
  // Loading and error states
  const [loading, setLoading] = useState({
    profile: false,
    password: false,
    delete: false
  });
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // Initialize form data when user data loads
  useEffect(() => {
    if (currentUser) {
      setProfileData({
        firstName: currentUser.firstName || '',
        lastName: currentUser.lastName || '',
        email: currentUser.email || '',
        phoneNumber: currentUser.phoneNumber || ''
      });
    }
  }, [currentUser]);

  // Clear messages after 5 seconds
  useEffect(() => {
    if (error || success) {
      const timer = setTimeout(() => {
        setError('');
        setSuccess('');
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [error, success]);

  const handleProfileSave = async () => {
    try {
      setLoading(prev => ({ ...prev, profile: true }));
      setError('');
      
      // Validate form data
      const validation = settingsService.validateProfileData(profileData);
      if (!validation.isValid) {
        setError(validation.errors.join(', '));
        return;
      }
      
      // Call API to update profile
      const response = await settingsService.updateProfile(profileData);
      
      setSuccess(response.message || 'Profile updated successfully!');
      setIsEditingProfile(false);
      
      // Refresh user data
      if (refreshUser) {
        await refreshUser();
      }
      
    } catch (error) {
      console.error('Profile update failed:', error);
      setError(settingsService.getErrorMessage(error));
    } finally {
      setLoading(prev => ({ ...prev, profile: false }));
    }
  };

  const handlePasswordChange = async () => {
    try {
      setLoading(prev => ({ ...prev, password: true }));
      setError('');
      
      // Validate form data
      const validation = settingsService.validatePasswordData(passwordData);
      if (!validation.isValid) {
        setError(validation.errors.join(', '));
        return;
      }
      
      // Call API to change password
      const response = await settingsService.changePassword(passwordData);
      
      setSuccess(response.message || 'Password changed successfully!');
      setPasswordData({
        currentPassword: '',
        newPassword: '',
        confirmPassword: ''
      });
      setIsChangingPassword(false);
      
    } catch (error) {
      console.error('Password change failed:', error);
      setError(settingsService.getErrorMessage(error));
    } finally {
      setLoading(prev => ({ ...prev, password: false }));
    }
  };

  const handleDeleteAccount = async () => {
    try {
      setLoading(prev => ({ ...prev, delete: true }));
      setError('');
      
      // Call API to delete account
      const response = await settingsService.deleteAccount({ confirmationText: 'DELETE' });
      
      setSuccess(response.message || 'Account deletion initiated. You will be logged out shortly.');
      
      // Logout user after a delay
      setTimeout(() => {
        window.location.href = '/login';
      }, 3000);
      
    } catch (error) {
      console.error('Account deletion failed:', error);
      setError(settingsService.getErrorMessage(error));
    } finally {
      setLoading(prev => ({ ...prev, delete: false }));
      setShowDeleteDialog(false);
    }
  };

  const handleCancelEdit = () => {
    // Reset form data to original values
    setProfileData({
      firstName: currentUser?.firstName || '',
      lastName: currentUser?.lastName || '',
      email: currentUser?.email || '',
      phoneNumber: currentUser?.phoneNumber || ''
    });
    setIsEditingProfile(false);
  };

  const togglePasswordVisibility = (field) => {
    setShowPasswords(prev => ({
      ...prev,
      [field]: !prev[field]
    }));
  };

  const getPasswordStrength = (password) => {
    return settingsService.calculatePasswordStrength(password);
  };

  const passwordStrength = getPasswordStrength(passwordData.newPassword);

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        {/* Page Header - following ResumesPage pattern */}
        <Box sx={{ mb: 4 }}>
          <Typography variant="h4" component="h1" fontWeight={500}>
            Settings
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Manage your account preferences and security settings
          </Typography>
        </Box>

      {/* Status Messages */}
      {error && (
        <Alert 
          severity="error" 
          sx={{ mb: 3, borderRadius: 2 }}
          onClose={() => setError('')}
        >
          {error}
        </Alert>
      )}
      
      {success && (
        <Alert 
          severity="success" 
          sx={{ mb: 3, borderRadius: 2 }}
          onClose={() => setSuccess('')}
        >
          {success}
        </Alert>
      )}

      <Grid container spacing={3}>
        {/* User Profile Settings */}
        <Grid item xs={12} lg={8}>
          <Card sx={{ borderRadius: 3, mb: 3 }}>
            <CardContent sx={{ p: 4 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <Avatar
                  sx={{
                    width: 64,
                    height: 64,
                    bgcolor: theme.palette.primary.main,
                    fontSize: '1.5rem',
                    fontWeight: 600,
                    mr: 3
                  }}
                >
                  {profileData.firstName?.[0]}{profileData.lastName?.[0]}
                </Avatar>
                <Box sx={{ flex: 1 }}>
                  <Typography variant="h5" sx={{ fontWeight: 600, color: theme.palette.primary.main, mb: 1 }}>
                    <PersonIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Profile Information
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Update your personal information and contact details
                  </Typography>
                </Box>
                {!isEditingProfile && (
                  <Button
                    variant="outlined"
                    startIcon={<EditIcon />}
                    onClick={() => setIsEditingProfile(true)}
                    sx={{ borderRadius: 2 }}
                  >
                    Edit Profile
                  </Button>
                )}
              </Box>

              <Grid container spacing={3}>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="First Name"
                    value={profileData.firstName}
                    onChange={(e) => setProfileData(prev => ({ ...prev, firstName: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="Last Name"
                    value={profileData.lastName}
                    onChange={(e) => setProfileData(prev => ({ ...prev, lastName: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Email Address"
                    type="email"
                    value={profileData.email}
                    onChange={(e) => setProfileData(prev => ({ ...prev, email: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    InputProps={{
                      startAdornment: <EmailIcon sx={{ mr: 1, color: theme.palette.primary.main }} />,
                      endAdornment: currentUser?.isEmailVerified ? (
                        <Chip
                          label="Verified"
                          size="small"
                          icon={<VerifiedIcon />}
                          color="success"
                          variant="outlined"
                          sx={{ borderRadius: 1 }}
                        />
                      ) : (
                        <Chip
                          label="Unverified"
                          size="small"
                          icon={<WarningIcon />}
                          color="warning"
                          variant="outlined"
                          sx={{ borderRadius: 1 }}
                        />
                      )
                    }}
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Phone Number"
                    type="tel"
                    value={profileData.phoneNumber}
                    onChange={(e) => setProfileData(prev => ({ ...prev, phoneNumber: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    placeholder="+1 (555) 123-4567"
                    InputProps={{
                      startAdornment: <PhoneIcon sx={{ mr: 1, color: theme.palette.secondary.main }} />
                    }}
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                {isEditingProfile && (
                  <Grid item xs={12}>
                    <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
                      <Button
                        variant="outlined"
                        startIcon={<CancelIcon />}
                        onClick={handleCancelEdit}
                        sx={{ borderRadius: 2 }}
                      >
                        Cancel
                      </Button>
                      <Button
                        variant="contained"
                        startIcon={loading.profile ? <LinearProgress sx={{ width: 20 }} /> : <SaveIcon />}
                        onClick={handleProfileSave}
                        disabled={loading.profile}
                        sx={{ 
                          borderRadius: 2,
                          background: `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`
                        }}
                      >
                        {loading.profile ? 'Saving...' : 'Save Changes'}
                      </Button>
                    </Box>
                  </Grid>
                )}
              </Grid>
            </CardContent>
          </Card>

          {/* Security Settings */}
          <Card sx={{ borderRadius: 3 }}>
            <CardContent sx={{ p: 4 }}>
              <Typography variant="h5" sx={{ fontWeight: 600, color: theme.palette.error.main, mb: 1 }}>
                <SecurityIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
                Privacy & Security
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 4 }}>
                Manage your account security and privacy preferences
              </Typography>

              {/* Change Password Section */}
              <Box sx={{ mb: 4 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                  <Box>
                    <Typography variant="h6" sx={{ fontWeight: 600 }}>
                      Change Password
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Update your password to keep your account secure
                    </Typography>
                  </Box>
                  {!isChangingPassword && (
                    <Button
                      variant="outlined"
                      startIcon={<LockIcon />}
                      onClick={() => setIsChangingPassword(true)}
                      sx={{ borderRadius: 2 }}
                    >
                      Change Password
                    </Button>
                  )}
                </Box>

                {isChangingPassword && (
                  <Paper 
                    elevation={0} 
                    sx={{ 
                      p: 3, 
                      border: `1px solid ${theme.palette.divider}`, 
                      borderRadius: 2,
                      bgcolor: theme.palette.grey[50]
                    }}
                  >
                    <Grid container spacing={3}>
                      <Grid item xs={12}>
                        <TextField
                          fullWidth
                          label="Current Password"
                          type={showPasswords.current ? 'text' : 'password'}
                          value={passwordData.currentPassword}
                          onChange={(e) => setPasswordData(prev => ({ ...prev, currentPassword: e.target.value }))}
                          InputProps={{
                            endAdornment: (
                              <IconButton
                                onClick={() => togglePasswordVisibility('current')}
                                edge="end"
                              >
                                {showPasswords.current ? <VisibilityOffIcon /> : <VisibilityIcon />}
                              </IconButton>
                            )
                          }}
                          sx={{
                            '& .MuiOutlinedInput-root': {
                              borderRadius: 2
                            }
                          }}
                        />
                      </Grid>

                      <Grid item xs={12}>
                        <TextField
                          fullWidth
                          label="New Password"
                          type={showPasswords.new ? 'text' : 'password'}
                          value={passwordData.newPassword}
                          onChange={(e) => setPasswordData(prev => ({ ...prev, newPassword: e.target.value }))}
                          InputProps={{
                            endAdornment: (
                              <IconButton
                                onClick={() => togglePasswordVisibility('new')}
                                edge="end"
                              >
                                {showPasswords.new ? <VisibilityOffIcon /> : <VisibilityIcon />}
                              </IconButton>
                            )
                          }}
                          sx={{
                            '& .MuiOutlinedInput-root': {
                              borderRadius: 2
                            }
                          }}
                        />
                        {passwordData.newPassword && (
                          <Box sx={{ mt: 1 }}>
                            <LinearProgress
                              variant="determinate"
                              value={passwordStrength.strength}
                              color={passwordStrength.color}
                              sx={{ height: 6, borderRadius: 3 }}
                            />
                            <Typography variant="caption" color={`${passwordStrength.color}.main`} sx={{ mt: 0.5, display: 'block' }}>
                              Password strength: {passwordStrength.label}
                            </Typography>
                          </Box>
                        )}
                      </Grid>

                      <Grid item xs={12}>
                        <TextField
                          fullWidth
                          label="Confirm New Password"
                          type={showPasswords.confirm ? 'text' : 'password'}
                          value={passwordData.confirmPassword}
                          onChange={(e) => setPasswordData(prev => ({ ...prev, confirmPassword: e.target.value }))}
                          error={passwordData.confirmPassword && passwordData.newPassword !== passwordData.confirmPassword}
                          helperText={
                            passwordData.confirmPassword && passwordData.newPassword !== passwordData.confirmPassword
                              ? 'Passwords do not match'
                              : ''
                          }
                          InputProps={{
                            endAdornment: (
                              <IconButton
                                onClick={() => togglePasswordVisibility('confirm')}
                                edge="end"
                              >
                                {showPasswords.confirm ? <VisibilityOffIcon /> : <VisibilityIcon />}
                              </IconButton>
                            )
                          }}
                          sx={{
                            '& .MuiOutlinedInput-root': {
                              borderRadius: 2
                            }
                          }}
                        />
                      </Grid>

                      <Grid item xs={12}>
                        <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
                          <Button
                            variant="outlined"
                            onClick={() => {
                              setIsChangingPassword(false);
                              setPasswordData({
                                currentPassword: '',
                                newPassword: '',
                                confirmPassword: ''
                              });
                            }}
                            sx={{ borderRadius: 2 }}
                          >
                            Cancel
                          </Button>
                          <Button
                            variant="contained"
                            startIcon={loading.password ? <LinearProgress sx={{ width: 20 }} /> : <LockIcon />}
                            onClick={handlePasswordChange}
                            disabled={
                              loading.password ||
                              !passwordData.currentPassword ||
                              !passwordData.newPassword ||
                              passwordData.newPassword !== passwordData.confirmPassword
                            }
                            sx={{ 
                              borderRadius: 2,
                              background: `linear-gradient(45deg, ${theme.palette.warning.main}, ${theme.palette.warning.dark})`
                            }}
                          >
                            {loading.password ? 'Changing...' : 'Change Password'}
                          </Button>
                        </Box>
                      </Grid>
                    </Grid>
                  </Paper>
                )}
              </Box>

              <Divider sx={{ my: 4 }} />

              {/* Delete Account Section */}
              <Box>
                <Typography variant="h6" sx={{ fontWeight: 600, color: theme.palette.error.main, mb: 1 }}>
                  Delete Account
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
                  Permanently delete your account and all associated data. This action cannot be undone.
                </Typography>
                
                <Alert severity="warning" sx={{ mb: 3, borderRadius: 2 }}>
                  <Typography variant="body2" sx={{ fontWeight: 500 }}>
                    Before deleting your account, please note:
                  </Typography>
                  <List dense sx={{ mt: 1 }}>
                    <ListItem sx={{ py: 0.5 }}>
                      <ListItemText 
                        primary="• All your resumes and job applications will be permanently deleted"
                        primaryTypographyProps={{ variant: 'body2' }}
                      />
                    </ListItem>
                    <ListItem sx={{ py: 0.5 }}>
                      <ListItemText 
                        primary="• Your AI search history and preferences will be lost"
                        primaryTypographyProps={{ variant: 'body2' }}
                      />
                    </ListItem>
                    <ListItem sx={{ py: 0.5 }}>
                      <ListItemText 
                        primary="• Any active outreach campaigns will be terminated"
                        primaryTypographyProps={{ variant: 'body2' }}
                      />
                    </ListItem>
                  </List>
                </Alert>

                <Button
                  variant="outlined"
                  color="error"
                  startIcon={<DeleteIcon />}
                  onClick={() => setShowDeleteDialog(true)}
                  sx={{ borderRadius: 2 }}
                >
                  Delete My Account
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Sidebar - Account Summary */}
        <Grid item xs={12} lg={4}>
          <Card sx={{ borderRadius: 3, position: 'sticky', top: 24 }}>
            <CardContent sx={{ p: 3 }}>
              <Typography variant="h6" sx={{ fontWeight: 600, mb: 3 }}>
                Account Summary
              </Typography>
              
              <List>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <PersonIcon color="primary" />
                  </ListItemIcon>
                  <ListItemText
                    primary="Profile Completion"
                    secondary={`${settingsService.calculateProfileCompletion(currentUser)}% complete`}
                  />
                </ListItem>

                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <EmailIcon color={currentUser?.isEmailVerified ? 'success' : 'warning'} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Email Status"
                    secondary={currentUser?.isEmailVerified ? 'Verified' : 'Pending verification'}
                  />
                  <ListItemSecondaryAction>
                    <Chip
                      label={currentUser?.isEmailVerified ? 'Verified' : 'Unverified'}
                      size="small"
                      color={currentUser?.isEmailVerified ? 'success' : 'warning'}
                      variant="outlined"
                      sx={{ borderRadius: 1 }}
                    />
                  </ListItemSecondaryAction>
                </ListItem>

                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <SecurityIcon color="info" />
                  </ListItemIcon>
                  <ListItemText
                    primary="Account Security"
                    secondary="Password protected"
                  />
                  <ListItemSecondaryAction>
                    <Chip
                      label="Secure"
                      size="small"
                      color="success"
                      variant="outlined"
                      sx={{ borderRadius: 1 }}
                    />
                  </ListItemSecondaryAction>
                </ListItem>
              </List>

              <Divider sx={{ my: 2 }} />

              <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
                Member since {new Date(currentUser?.createdAt || Date.now()).toLocaleDateString('en-US', {
                  month: 'long',
                  year: 'numeric'
                })}
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Delete Account Confirmation Dialog */}
      <Dialog
        open={showDeleteDialog}
        onClose={() => setShowDeleteDialog(false)}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: { borderRadius: 3 }
        }}
      >
        <DialogTitle sx={{ 
          color: theme.palette.error.main,
          display: 'flex',
          alignItems: 'center',
          gap: 1
        }}>
          <DeleteIcon />
          Confirm Account Deletion
        </DialogTitle>
        <DialogContent>
          <Typography variant="body1" sx={{ mb: 2 }}>
            Are you absolutely sure you want to delete your account? This action is permanent and cannot be undone.
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Type <strong>DELETE</strong> below to confirm:
          </Typography>
          <TextField
            fullWidth
            placeholder="Type DELETE to confirm"
            value={deleteConfirmText}
            onChange={(e) => setDeleteConfirmText(e.target.value)}
            sx={{ mt: 2 }}
          />
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button 
            onClick={() => setShowDeleteDialog(false)}
            variant="outlined"
            sx={{ borderRadius: 2 }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleDeleteAccount}
            variant="contained"
            color="error"
            startIcon={loading.delete ? <LinearProgress sx={{ width: 20 }} /> : <DeleteIcon />}
            disabled={loading.delete || deleteConfirmText !== 'DELETE'}
            sx={{ borderRadius: 2 }}
          >
            {loading.delete ? 'Deleting...' : 'Delete Account'}
          </Button>
        </DialogActions>
      </Dialog>
      </Box>
    </MainLayout>
  );
};

export default SettingsPage;

================
File: src/context/AiAssistantContext.js
================
// src/context/AiAssistantContext.js - COMPLETE FILE WITH NEW CONVERSATION FIX
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { useLocation } from 'react-router-dom';
import { useAuth } from './AuthContext';
import resumeService from '../utils/resumeService';
import jobService from '../utils/jobService';
import assistantService from '../utils/assistantService';

// Create the context
const AiAssistantContext = createContext();

// Custom hook to use the context
export const useAiAssistant = () => {
  const context = useContext(AiAssistantContext);
  if (!context) {
    throw new Error('useAiAssistant must be used within an AiAssistantProvider');
  }
  return context;
};

// Provider component
export const AiAssistantProvider = ({ children }) => {
  const location = useLocation();
  const { currentUser, isAuthenticated } = useAuth();
  
  // AI Assistant state
  const [isOpen, setIsOpen] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);
  
  // Enhanced conversation state
  const [conversations, setConversations] = useState([]);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [currentConversation, setCurrentConversation] = useState(null);
  const [conversationsLoading, setConversationsLoading] = useState(false);
  const [conversationError, setConversationError] = useState(null);
  
  // Memory state
  const [userMemories, setUserMemories] = useState([]);
  const [memoryInsights, setMemoryInsights] = useState([]);
  const [memoriesLoading, setMemoriesLoading] = useState(false);
  
  // Context awareness
  const [currentContext, setCurrentContext] = useState({
    page: 'dashboard',
    resumeCount: 0,
    jobCount: 0,
    currentResume: null,
    currentJob: null,
    userProfile: null
  });
  
  // Suggestions and analytics
  const [contextualSuggestions, setContextualSuggestions] = useState([]);
  const [suggestionsCount, setSuggestionsCount] = useState(0);
  const [analytics, setAnalytics] = useState(null);
  
  // Chat state
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Initialize on authentication
  useEffect(() => {
    if (isAuthenticated && currentUser) {
      initializeAiAssistant();
    } else {
      resetState();
    }
  }, [isAuthenticated, currentUser]);

  // Update context when location changes
  useEffect(() => {
    if (isAuthenticated && currentUser) {
      updateContextFromLocation();
    }
  }, [location.pathname, isAuthenticated, currentUser]);

  // Load conversation when current conversation changes
  useEffect(() => {
    if (currentConversationId && !currentConversationId.startsWith('new-conversation-')) {
      loadConversation(currentConversationId);
    }
  }, [currentConversationId]);

  /**
   * Initialize AI Assistant system
   */
  const initializeAiAssistant = useCallback(async () => {
    try {
      await Promise.all([
        loadConversations(),
        loadMemoryInsights(),
        updateContextFromLocation()
      ]);
    } catch (error) {
      console.error('Failed to initialize AI Assistant:', error);
      setError('Failed to initialize AI Assistant');
    }
  }, []);

  /**
   * Reset all state
   */
  const resetState = useCallback(() => {
    setConversations([]);
    setCurrentConversationId(null);
    setCurrentConversation(null);
    setUserMemories([]);
    setMemoryInsights([]);
    setMessages([]);
    setContextualSuggestions([]);
    setAnalytics(null);
    setError(null);
    setCurrentContext({
      page: 'auth',
      resumeCount: 0,
      jobCount: 0,
      currentResume: null,
      currentJob: null,
      userProfile: null
    });
  }, []);

  /**
   * Load user's conversations
   */
  const loadConversations = useCallback(async (options = {}) => {
    try {
      setConversationsLoading(true);
      setConversationError(null);

      const response = await assistantService.getConversations({
        limit: 20,
        sortBy: 'lastActiveAt',
        ...options
      });

      // Filter out placeholder conversations
      const realConversations = response.conversations?.filter(conv => !conv.isPlaceholder) || [];
      setConversations(realConversations);
      
      // Set current conversation to most recent if none selected
      if (!currentConversationId && realConversations.length > 0) {
        setCurrentConversationId(realConversations[0]._id);
      }

    } catch (error) {
      console.error('Failed to load conversations:', error);
      setConversationError('Failed to load conversations');
    } finally {
      setConversationsLoading(false);
    }
  }, [currentConversationId]);

  /**
   * Load specific conversation
   */
  const loadConversation = useCallback(async (conversationId) => {
    try {
      const conversation = await assistantService.getConversation(conversationId);
      setCurrentConversation(conversation);
      setMessages(conversation.messages || []);
    } catch (error) {
      console.error('Failed to load conversation:', error);
      setError('Failed to load conversation');
    }
  }, []);

  /**
   * Create new conversation - PROPERLY FIXED
   */
  const createNewConversation = useCallback(async (title, category = 'general') => {
    try {
      console.log('Creating new conversation...');
      
      // Create a temporary conversation placeholder
      const tempConversationId = `new-conversation-${Date.now()}`;
      const placeholderConversation = {
        _id: tempConversationId,
        title: title || 'New Conversation',
        category,
        messages: [],
        messageCount: 0,
        createdAt: new Date(),
        lastActiveAt: new Date(),
        isPlaceholder: true,
        status: 'active'
      };
      
      // Add to conversations list and set as current
      setConversations(prev => [placeholderConversation, ...prev]);
      setCurrentConversationId(tempConversationId);
      setCurrentConversation(placeholderConversation);
      setMessages([]);
      setError(null);
      
      console.log('New conversation placeholder created:', tempConversationId);
      return placeholderConversation;

    } catch (error) {
      console.error('Failed to create conversation:', error);
      setError('Failed to create new conversation');
      return null;
    }
  }, []);

  /**
   * Send message - ENHANCED to handle new conversations
   */
  const sendMessage = useCallback(async (message, options = {}) => {
  try {
    setIsLoading(true);
    setError(null);

    // Add user message immediately to UI with proper timestamp
    const userMessage = {
      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'user',
      content: message,
      timestamp: new Date(), // FIXED: Use Date object instead of timestamp
      createdAt: new Date() // FIXED: Add createdAt for consistency
    };
    setMessages(prev => [...prev, userMessage]);

    // Check if this is a new conversation (placeholder)
    const isNewConversation = !currentConversationId || 
                             currentConversationId.startsWith('new-conversation-') ||
                             options.newConversation;

    // Prepare request data
    const requestData = {
      message,
      context: currentContext,
      conversationId: isNewConversation ? null : currentConversationId,
      newConversation: isNewConversation,
      conversationHistory: isNewConversation ? [] : messages.slice(-5)
    };

    console.log('Sending message:', { 
      isNewConversation, 
      currentConversationId, 
      messageLength: message.length 
    });

    // Send to AI
    const response = await assistantService.sendMessage(requestData);

    // Add AI response to UI with proper timestamp
    const aiMessage = {
      id: `msg_${Date.now() + 1}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'ai',
      content: response.message,
      timestamp: new Date(), // FIXED: Use Date object
      createdAt: new Date(), // FIXED: Add createdAt
      suggestions: response.suggestions || [],
      actions: response.actions || [],
      memoryInsights: response.memoryInsights || []
    };

    setMessages(prev => [...prev, aiMessage]);

    // Handle new conversation ID from backend
    if (response.conversationId) {
      // If this was a new conversation, update the ID and remove placeholder
      if (isNewConversation) {
        console.log('New conversation created with ID:', response.conversationId);
        
        // Remove the placeholder conversation
        setConversations(prev => prev.filter(conv => !conv.isPlaceholder));
        
        // Set the real conversation ID
        setCurrentConversationId(response.conversationId);
        
        // Refresh conversations to get the real conversation data
        setTimeout(() => {
          loadConversations();
        }, 500);
      }
      
      // Update conversation title if provided
      if (response.conversationTitle) {
        setCurrentConversation(prev => ({
          ...prev,
          title: response.conversationTitle
        }));
      }
    }

    // Update suggestions
    if (response.suggestions && response.suggestions.length > 0) {
      setContextualSuggestions(response.suggestions);
      setSuggestionsCount(response.suggestions.length);
    }

    return response;

  } catch (error) {
    console.error('Failed to send message:', error);
    setError('Failed to send message. Please try again.');
    
    // Add error message to UI with proper timestamp
    const errorMessage = {
      id: `msg_${Date.now() + 2}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'ai',
      content: "I'm having trouble connecting right now. Please try again in a moment.",
      timestamp: new Date(), // FIXED: Use Date object
      createdAt: new Date(), // FIXED: Add createdAt
      isError: true
    };
    setMessages(prev => [...prev, errorMessage]);

  } finally {
    setIsLoading(false);
  }
}, [currentContext, currentConversationId, messages, loadConversations]);

  /**
   * Switch to different conversation
   */
  const switchConversation = useCallback(async (conversationId) => {
    if (conversationId === currentConversationId) return;
    
    console.log('Switching to conversation:', conversationId);
    setCurrentConversationId(conversationId);
    setMessages([]);
    setError(null);
    
    // Don't load placeholder conversations
    if (!conversationId.startsWith('new-conversation-')) {
      // The useEffect will handle loading the conversation
    }
  }, [currentConversationId]);

  /**
   * Update conversation metadata
   */
  const updateConversation = useCallback(async (conversationId, updates) => {
    try {
      // Don't update placeholder conversations
      if (conversationId.startsWith('new-conversation-')) {
        return null;
      }

      const updatedConversation = await assistantService.updateConversation(conversationId, updates);
      
      // Update in conversations list
      setConversations(prev => 
        prev.map(conv => 
          conv._id === conversationId ? { ...conv, ...updatedConversation } : conv
        )
      );

      // Update current conversation if it's the one being updated
      if (conversationId === currentConversationId) {
        setCurrentConversation(prev => ({ ...prev, ...updatedConversation }));
      }

      return updatedConversation;

    } catch (error) {
      console.error('Failed to update conversation:', error);
      setError('Failed to update conversation');
      return null;
    }
  }, [currentConversationId]);

  /**
   * Delete conversation
   */
  const deleteConversation = useCallback(async (conversationId, permanent = false) => {
    try {
      // Handle placeholder conversations
      if (conversationId.startsWith('new-conversation-')) {
        setConversations(prev => prev.filter(conv => conv._id !== conversationId));
        if (conversationId === currentConversationId) {
          const remaining = conversations.filter(conv => conv._id !== conversationId);
          if (remaining.length > 0) {
            setCurrentConversationId(remaining[0]._id);
          } else {
            setCurrentConversationId(null);
            setCurrentConversation(null);
            setMessages([]);
          }
        }
        return;
      }

      await assistantService.deleteConversation(conversationId, permanent);
      
      // Remove from conversations list
      setConversations(prev => prev.filter(conv => conv._id !== conversationId));
      
      // If it was the current conversation, switch to another one
      if (conversationId === currentConversationId) {
        const remainingConversations = conversations.filter(conv => conv._id !== conversationId);
        if (remainingConversations.length > 0) {
          setCurrentConversationId(remainingConversations[0]._id);
        } else {
          setCurrentConversationId(null);
          setCurrentConversation(null);
          setMessages([]);
        }
      }

    } catch (error) {
      console.error('Failed to delete conversation:', error);
      setError('Failed to delete conversation');
    }
  }, [currentConversationId, conversations]);

  /**
   * Load memory insights
   */
  const loadMemoryInsights = useCallback(async () => {
    try {
      setMemoriesLoading(true);
      const response = await assistantService.getMemoryInsights();
      setMemoryInsights(response.insights || []);
      setUserMemories(response.analytics || {});
    } catch (error) {
      console.error('Failed to load memory insights:', error);
    } finally {
      setMemoriesLoading(false);
    }
  }, []);

  /**
   * Search across conversations and memories
   */
  const searchEverything = useCallback(async (query) => {
    try {
      const results = await assistantService.search(query);
      return results;
    } catch (error) {
      console.error('Search failed:', error);
      return { conversations: [], memories: [] };
    }
  }, []);

  /**
   * Get analytics
   */
  const loadAnalytics = useCallback(async (timeframe = '30d') => {
    try {
      const analyticsData = await assistantService.getAnalytics(timeframe);
      setAnalytics(analyticsData);
      return analyticsData;
    } catch (error) {
      console.error('Failed to load analytics:', error);
      return null;
    }
  }, []);

  /**
   * Update context from current location
   */
  const updateContextFromLocation = useCallback(async () => {
    if (!isAuthenticated || !currentUser) {
      setCurrentContext({
        page: 'auth',
        resumeCount: 0,
        jobCount: 0,
        currentResume: null,
        currentJob: null,
        userProfile: null
      });
      return;
    }

    try {
      console.log('🤖 AJ: Updating context for:', location.pathname);
      
      const pathSegments = location.pathname.split('/').filter(Boolean);
      const page = pathSegments[0] || 'dashboard';
      
      let newContext = {
        page,
        resumeCount: 0,
        jobCount: 0,
        currentResume: null,
        currentJob: null,
        userProfile: {
          name: `${currentUser.firstName} ${currentUser.lastName}`,
          email: currentUser.email
        }
      };

      // Get user's resumes and jobs count
      try {
        const [resumes, jobs] = await Promise.all([
          resumeService.getUserResumes(),
          jobService.getUserJobs()
        ]);

        newContext.resumeCount = resumes?.length || 0;
        newContext.jobCount = jobs?.length || 0;

        // Page-specific context
        switch (page) {
          case 'resumes':
            if (pathSegments[1] && resumes) {
              const currentResume = resumes.find(r => r._id === pathSegments[1]);
              if (currentResume) {
                newContext.currentResume = {
                  id: currentResume._id,
                  name: currentResume.name,
                  analysis: currentResume.analysis,
                  score: currentResume.analysis?.overallScore
                };
              }
            }
            break;

          case 'jobs':
            if (pathSegments[1] && pathSegments[1] !== 'ai-searches' && jobs) {
              const currentJob = jobs.find(j => j._id === pathSegments[1]);
              if (currentJob) {
                newContext.currentJob = {
                  id: currentJob._id,
                  title: currentJob.title,
                  company: currentJob.company,
                  matchAnalysis: currentJob.matchAnalysis
                };
              }
            }
            
            if (pathSegments[1] === 'ai-searches') {
              newContext.page = 'ai-searches';
            }
            break;

          default:
            break;
        }

      } catch (error) {
        console.warn('🤖 AJ: Error fetching user data for context:', error);
      }

      // Generate contextual suggestions
      const suggestions = generateContextualSuggestions(newContext);
      
      setCurrentContext(newContext);
      setContextualSuggestions(suggestions);
      setSuggestionsCount(suggestions.length);

      console.log('🤖 AJ: Context updated:', newContext);

    } catch (error) {
      console.error('🤖 AJ: Error updating context:', error);
    }
  }, [location.pathname, isAuthenticated, currentUser]);

  /**
   * Generate contextual suggestions
   */
  const generateContextualSuggestions = useCallback((context) => {
    const suggestions = [];

    switch (context.page) {
      case 'dashboard':
        if (context.resumeCount === 0) {
          suggestions.push('Upload your first resume');
        } else {
          suggestions.push('Which resume needs the most work?');
        }
        
        if (context.jobCount === 0) {
          suggestions.push('Find job opportunities');
        } else {
          suggestions.push('Review my job matches');
        }
        
        suggestions.push('Show my career progress');
        suggestions.push('What should I focus on today?');
        break;

      case 'resumes':
        if (context.currentResume) {
          suggestions.push('Improve this resume');
          suggestions.push('Check ATS compatibility');
          if (context.currentResume.score && context.currentResume.score < 80) {
            suggestions.push('What can I improve?');
          }
        } else {
          suggestions.push('Which resume is best?');
          suggestions.push('Compare my resumes');
        }
        suggestions.push('Create new resume');
        break;

      case 'jobs':
        if (context.currentJob) {
          suggestions.push('Match my resume to this job');
          suggestions.push('How can I improve my match?');
          suggestions.push('Write a cover letter');
        } else {
          suggestions.push('Find new job opportunities');
          suggestions.push('Review my job matches');
        }
        suggestions.push('Help with applications');
        break;

      case 'ai-searches':
        suggestions.push('Optimize search criteria');
        suggestions.push('Review found opportunities');
        suggestions.push('Adjust search parameters');
        break;

      default:
        suggestions.push('Help with resume');
        suggestions.push('Find job opportunities');
        suggestions.push('Career guidance');
        suggestions.push('Review my progress');
        break;
    }

    return suggestions.slice(0, 4);
  }, []);

  /**
   * Handle suggestion clicks
   */
  const handleSuggestionClick = useCallback((suggestion) => {
    return sendMessage(suggestion);
  }, [sendMessage]);

  /**
   * Refresh all data
   */
  const refreshContext = useCallback(async () => {
    await Promise.all([
      updateContextFromLocation(),
      loadConversations(),
      loadMemoryInsights()
    ]);
  }, [updateContextFromLocation, loadConversations, loadMemoryInsights]);

// Context value
const contextValue = {
  // State
  isOpen,
  setIsOpen,
  isMinimized,
  setIsMinimized,
  
  // Conversations
  conversations,
  currentConversationId,
  setCurrentConversationId,     // ADD THIS LINE
  currentConversation,
  setCurrentConversation,       // ADD THIS LINE
  conversationsLoading,
  conversationError,
  
  // Memory
  userMemories,
  memoryInsights,
  memoriesLoading,
  
  // Context
  currentContext,
  setCurrentContext,  // ADD THIS LINE
  contextualSuggestions,
  suggestionsCount,
  analytics,
  
  // Chat
  messages,
  isLoading,
  error,
  
  // Actions
  sendMessage,
  createNewConversation,
  switchConversation,
  updateConversation,
  deleteConversation,
  handleSuggestionClick,
  
  // Data management
  loadConversations,
  loadMemoryInsights,
  loadAnalytics,
  searchEverything,
  refreshContext,
  updateContextFromLocation,  // ADD THIS LINE TOO
  
  // Utilities
  setError,
  setMessages
};

  return (
    <AiAssistantContext.Provider value={contextValue}>
      {children}
    </AiAssistantContext.Provider>
  );
};

================
File: src/context/AuthContext.js
================
// frontend/src/context/AuthContext.js - FIXED INFINITE LOOP ISSUE
import React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';
import api, { isRateLimitError, getErrorMessage } from '../utils/axios';

// Create and export the context
export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null);
  const [token, setToken] = useState(localStorage.getItem('token'));
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Use refs to track loading state and prevent infinite loops
  const isLoadingUser = useRef(false);
  const lastUserLoadAttempt = useRef(0);

  // Load user function - memoized properly to prevent infinite loops
  const loadUser = useCallback(async (force = false) => {
    const now = Date.now();
    const timeSinceLastAttempt = now - lastUserLoadAttempt.current;
    
    // Prevent rapid successive calls unless forced
    if (!force && (timeSinceLastAttempt < 3000 || isLoadingUser.current)) {
      console.log('🔄 Skipping user load - too recent or already loading');
      setLoading(false);
      return;
    }

    if (!token) {
      console.log('🔍 No token found, skipping user load');
      setLoading(false);
      return;
    }

    try {
      isLoadingUser.current = true;
      lastUserLoadAttempt.current = now;
      console.log('🔍 Loading user with token...');
      
      // Set the token in the Authorization header
      api.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      
      const response = await api.get('/auth/me');
      console.log('✅ User loaded successfully:', response.data);
      
      if (response.data.success && response.data.data?.user) {
        setCurrentUser(response.data.data.user);
        setIsAuthenticated(true);
        setError(null);
        console.log('✅ User authenticated successfully');
      } else {
        throw new Error('Invalid response format from /auth/me');
      }
    } catch (err) {
      console.error('❌ Error loading user:', err);
      
      // Handle different error types
      if (isRateLimitError(err)) {
        console.log('⏱️ Rate limited during user load - keeping current auth state');
        setError('Too many requests. Please wait a moment.');
        // Don't clear auth state for rate limiting
      } else if (err.response?.status === 401 || err.response?.status === 403) {
        console.log('🔒 Token expired or invalid - clearing auth state');
        // Clear invalid token
        localStorage.removeItem('token');
        delete api.defaults.headers.common['Authorization'];
        setToken(null);
        setCurrentUser(null);
        setIsAuthenticated(false);
        setError(null);
      } else {
        console.log('🔥 Other error during user load');
        setError('Failed to load user session');
      }
    } finally {
      isLoadingUser.current = false;
      setLoading(false);
    }
  }, [token]); // Only depend on token

  // Load user if token exists - but only run when token actually changes
  useEffect(() => {
    const currentToken = localStorage.getItem('token');
    if (currentToken && currentToken === token) {
      loadUser(true);
    } else if (!currentToken) {
      setLoading(false);
    }
  }, [token]); // Remove loadUser from dependencies to prevent infinite loop

  // Register new user
  const register = async (userData) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Attempting registration...');
      const response = await api.post('/auth/register', userData);
      console.log('✅ Registration response:', response.data);
      
      if (response.data.success && response.data.token) {
        const { token: newToken, data } = response.data;
        
        // Store token and set auth header
        localStorage.setItem('token', newToken);
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
        
        setToken(newToken);
        setCurrentUser(data.user);
        setIsAuthenticated(true);
        
        console.log('✅ Registration successful');
        return { success: true, user: data.user };
      } else {
        throw new Error(response.data.error || 'Invalid registration response');
      }
    } catch (err) {
      console.error('❌ Registration error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Login user
  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Attempting login for:', email);
      
      const response = await api.post('/auth/login', { 
        email: email.trim(), 
        password 
      });
      
      console.log('✅ Login response:', response.data);
      
      if (response.data.success && response.data.token) {
        const { token: newToken, data } = response.data;
        
        // Store token and set auth header
        localStorage.setItem('token', newToken);
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
        
        setToken(newToken);
        setCurrentUser(data.user);
        setIsAuthenticated(true);
        setError(null);
        
        console.log('✅ Login successful for user:', data.user.email);
        return { success: true, user: data.user };
      } else {
        throw new Error(response.data.error || 'Invalid login response');
      }
    } catch (err) {
      console.error('❌ Login error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Logout user
  const logout = async () => {
    try {
      console.log('🔍 Attempting logout...');
      
      // Try to call logout endpoint with timeout
      const logoutPromise = api.post('/auth/logout');
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Logout timeout')), 5000)
      );
      
      await Promise.race([logoutPromise, timeoutPromise]);
      console.log('✅ Logout successful');
    } catch (err) {
      console.error('❌ Logout error:', err);
      console.log('⚠️ Logout API call failed, but continuing with local cleanup');
      // Continue with local cleanup even if server request fails
    } finally {
      // Always clean up local state
      localStorage.removeItem('token');
      delete api.defaults.headers.common['Authorization'];
      setToken(null);
      setCurrentUser(null);
      setIsAuthenticated(false);
      setError(null);
      console.log('✅ Local session cleared');
    }
  };

  // Forgot password
  const forgotPassword = async (email) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Requesting password reset for:', email);
      const response = await api.post('/auth/forgot-password', { email });
      console.log('✅ Password reset response:', response.data);
      
      return { 
        success: true, 
        message: response.data.data?.message || 'Reset email sent' 
      };
    } catch (err) {
      console.error('❌ Forgot password error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Reset password
  const resetPassword = async (resetToken, password) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Attempting password reset...');
      const response = await api.put(`/auth/reset-password/${resetToken}`, { password });
      console.log('✅ Password reset response:', response.data);
      
      if (response.data.success && response.data.token) {
        const { token: newToken } = response.data;
        
        // Store new token
        localStorage.setItem('token', newToken);
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
        setToken(newToken);
        
        return { success: true };
      } else {
        throw new Error(response.data.error || 'Invalid reset response');
      }
    } catch (err) {
      console.error('❌ Password reset error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Force refresh user data
  const refreshUser = useCallback(() => {
    if (token) {
      return loadUser(true);
    }
  }, [token, loadUser]);

  const value = {
    currentUser,
    isAuthenticated,
    loading,
    error,
    register,
    login,
    logout,
    forgotPassword,
    resetPassword,
    clearError,
    refreshUser
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

// Custom hook for easier context usage
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

// Default export (some files might expect this)
export default AuthContext;

================
File: src/hooks/useSearch.js
================
// src/hooks/useSearch.js
import { useState, useEffect, useCallback, useRef } from 'react';
import searchService from '../utils/searchService';

/**
 * Custom hook for managing search functionality
 */
const useSearch = (options = {}) => {
  const {
    initialQuery = '',
    initialCategory = 'all',
    autoSearch = true,
    debounceDelay = 300,
    enableSuggestions = true,
    onSearchComplete = null,
    onError = null
  } = options;

  // State
  const [query, setQuery] = useState(initialQuery);
  const [category, setCategory] = useState(initialCategory);
  const [results, setResults] = useState(null);
  const [suggestions, setSuggestions] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [recentSearches, setRecentSearches] = useState([]);

  // Refs
  const debouncedSearchRef = useRef(null);
  const abortControllerRef = useRef(null);

  // Initialize debounced search
  useEffect(() => {
    debouncedSearchRef.current = searchService.createDebouncedSearch(
      performSearch,
      debounceDelay
    );
  }, [category, debounceDelay]);

  // Load recent searches on mount
  useEffect(() => {
    const recent = searchService.getRecentSearches();
    setRecentSearches(recent);
  }, []);

  // Auto-search when query changes
  useEffect(() => {
    if (autoSearch && query.trim().length >= 2) {
      if (debouncedSearchRef.current) {
        debouncedSearchRef.current(query);
      }
    } else if (query.trim().length === 0) {
      clearResults();
    }
  }, [query, autoSearch]);

  // Load suggestions when query changes
  useEffect(() => {
    if (enableSuggestions && query.length >= 1 && query.length < 2) {
      loadSuggestions(query);
    }
  }, [query, enableSuggestions]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  const performSearch = useCallback(async (searchQuery) => {
    if (!searchQuery || searchQuery.trim().length < 2) {
      return;
    }

    try {
      // Cancel previous request
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }

      setIsLoading(true);
      setError(null);

      // Create new abort controller
      abortControllerRef.current = new AbortController();

      const searchResults = await searchService.globalSearch(searchQuery, {
        category,
        limit: 20
      });

      if (searchResults.success) {
        const formattedResults = searchService.formatSearchResults(searchResults.data.results);
        setResults(formattedResults);
        
        // Save to recent searches
        searchService.saveRecentSearch(searchQuery, searchResults.data.results);
        
        // Update recent searches state
        const updatedRecent = searchService.getRecentSearches();
        setRecentSearches(updatedRecent);

        // Call completion callback
        if (onSearchComplete) {
          onSearchComplete(formattedResults, searchQuery);
        }
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        const errorMessage = err.response?.data?.error || err.message || 'Search failed';
        setError(errorMessage);
        
        if (onError) {
          onError(err);
        }
      }
    } finally {
      setIsLoading(false);
    }
  }, [category, onSearchComplete, onError]);

  const loadSuggestions = useCallback(async (searchQuery) => {
    try {
      const suggestionsData = await searchService.getSuggestions(searchQuery);
      setSuggestions(suggestionsData.suggestions || []);
    } catch (err) {
      console.error('Error loading suggestions:', err);
      setSuggestions([]);
    }
  }, []);

  const clearResults = useCallback(() => {
    setResults(null);
    setSuggestions([]);
    setError(null);
  }, []);

  const clearAll = useCallback(() => {
    setQuery('');
    clearResults();
  }, [clearResults]);

  const search = useCallback((searchQuery, searchCategory = category) => {
    setQuery(searchQuery);
    setCategory(searchCategory);
    performSearch(searchQuery);
  }, [category, performSearch]);

  const searchInCategory = useCallback((searchCategory) => {
    setCategory(searchCategory);
    if (query.trim().length >= 2) {
      performSearch(query);
    }
  }, [query, performSearch]);

  const retrySearch = useCallback(() => {
    if (query.trim().length >= 2) {
      performSearch(query);
    }
  }, [query, performSearch]);

  const getResultsForCategory = useCallback((categoryName) => {
    return results?.[categoryName] || [];
  }, [results]);

  const getTotalResults = useCallback(() => {
    return results?.totalCount || 0;
  }, [results]);

  const hasResults = useCallback(() => {
    return getTotalResults() > 0;
  }, [getTotalResults]);

  const hasResultsForCategory = useCallback((categoryName) => {
    return getResultsForCategory(categoryName).length > 0;
  }, [getResultsForCategory]);

  const searchSpecificCategory = useCallback(async (searchQuery, categoryName) => {
    try {
      setIsLoading(true);
      setError(null);

      let categoryResults = [];
      
      switch (categoryName) {
        case 'jobs':
          categoryResults = await searchService.searchJobs(searchQuery);
          break;
        case 'resumes':
          categoryResults = await searchService.searchResumes(searchQuery);
          break;
        case 'recruiters':
          categoryResults = await searchService.searchRecruiters(searchQuery);
          break;
        default:
          throw new Error('Invalid category');
      }

      return categoryResults;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const validateQuery = useCallback((searchQuery) => {
    return searchService.validateSearchQuery(searchQuery);
  }, []);

  const highlightText = useCallback((text, highlightQuery = query) => {
    return searchService.highlightSearchTerms(text, highlightQuery);
  }, [query]);

  const addToRecentSearches = useCallback((searchQuery) => {
    searchService.saveRecentSearch(searchQuery, results || { totalCount: 0 });
    const updatedRecent = searchService.getRecentSearches();
    setRecentSearches(updatedRecent);
  }, [results]);

  const clearRecentSearches = useCallback(() => {
    searchService.clearRecentSearches();
    setRecentSearches([]);
  }, []);

  // Return search state and methods
  return {
    // State
    query,
    category,
    results,
    suggestions,
    isLoading,
    error,
    recentSearches,

    // Actions
    setQuery,
    setCategory,
    search,
    searchInCategory,
    searchSpecificCategory,
    clearResults,
    clearAll,
    retrySearch,
    addToRecentSearches,
    clearRecentSearches,

    // Utilities
    getResultsForCategory,
    getTotalResults,
    hasResults,
    hasResultsForCategory,
    validateQuery,
    highlightText,

    // Categories
    categories: searchService.getSearchCategories(),

    // Keyboard shortcuts
    shortcuts: searchService.getKeyboardShortcuts()
  };
};

export default useSearch;

================
File: src/index.css
================
/* src/index.css */
html {
  font-size: 90%;
  -webkit-text-size-adjust: 90%;
  -ms-text-size-adjust: 90%;
  height: 100%;
  overflow: hidden; /* Prevent body scroll */
}

body {
  margin: 0;
  padding: 0;
  font-family: 'Inter', 'Roboto', 'Segoe UI', -apple-system, BlinkMacSystemFont, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  box-sizing: border-box;
  height: 100vh;
  overflow: hidden; /* Prevent body scroll */
}

*, *:before, *:after {
  box-sizing: inherit;
}

/* Apply to the root app container for consistent scaling */
#root {
  width: 100%;
  height: 100vh;
  overflow: hidden; /* Ensure root container doesn't scroll */
}

/* Adjust any fixed pixel sizes that might need manual adjustment */
.MuiDialog-paper {
  max-width: calc(600px * 1.11) !important;
}

/* For any components with fixed dimensions that need adjustment */
.fixed-width-element {
  width: calc(300px * 1.11) !important;
}

.fixed-height-element {
  height: calc(200px * 1.11) !important;
}

/* Ensure proper scrollbar styling globally */
* {
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
}

*::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

*::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.04);
  border-radius: 3px;
}

*::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

*::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.3);
}

*::-webkit-scrollbar-corner {
  background: transparent;
}

/* Ensure Material-UI components respect the layout */
.MuiAppBar-root {
  position: static !important;
}

/* Prevent any unwanted scrolling in layout components */
.layout-container {
  height: 100vh;
  overflow: hidden;
}

.content-container {
  height: 100%;
  overflow-y: auto;
}

================
File: src/index.js
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import ThemeProvider from './ThemeProvider'
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(
  <ThemeProvider>
    <App />
  </ThemeProvider>
)

================
File: src/ThemeProvider.js
================
// src/ThemeProvider.js
import { createTheme, ThemeProvider as MuiThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';

// Define the auto-job.ai theme with 90% scaling
const theme = createTheme({
  palette: {
    primary: {
      main: '#1a73e8', // Deep blue
      light: '#4285f4',
      dark: '#0d47a1',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#00c4b4', // Teal accent
      light: '#33d1c1',
      dark: '#00897b',
      contrastText: '#ffffff',
    },
    success: {
      main: '#34a853',
      light: '#5cb85c',
      dark: '#2e7d32',
    },
    warning: {
      main: '#fbbc04',
      light: '#ffcd38',
      dark: '#f57c00',
    },
    error: {
      main: '#ea4335',
      light: '#ef5350',
      dark: '#c62828',
    },
    info: {
      main: '#4285f4',
      light: '#64b5f6',
      dark: '#1976d2',
    },
    background: {
      default: '#f5f7fa', // Light gray background
      paper: '#ffffff',
    },
    text: {
      primary: '#202124',
      secondary: '#5f6368',
      disabled: '#9aa0a6',
    },
    divider: 'rgba(0, 0, 0, 0.12)',
  },
  typography: {
    // Apply 90% scaling to the base font size
    fontSize: 14 * 0.9,
    fontFamily: [
      'Inter',
      'Roboto',
      '"Segoe UI"',
      '-apple-system',
      'BlinkMacSystemFont',
      'Arial',
      'sans-serif',
    ].join(','),
    h1: {
      fontSize: '2.5rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 600,
      lineHeight: 1.3,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 600,
      lineHeight: 1.3,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h6: {
      fontSize: '1.125rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    subtitle1: {
      fontSize: '1rem',
      fontWeight: 500,
      lineHeight: 1.5,
    },
    subtitle2: {
      fontSize: '0.875rem',
      fontWeight: 500,
      lineHeight: 1.5,
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.5,
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.5,
    },
    button: {
      fontSize: '0.875rem',
      fontWeight: 600,
      textTransform: 'none',
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        html: {
          fontSize: '90%', // Set root font size to 90%
          WebkitTextSizeAdjust: '90%',
          MsTextSizeAdjust: '90%',
        },
        '*, *::before, *::after': {
          boxSizing: 'border-box',
        },
        body: {
          margin: 0,
          padding: 0,
          WebkitFontSmoothing: 'antialiased',
          MozOsxFontSmoothing: 'grayscale',
        },
        // Custom Scrollbar Styles - Minimal Design
        '*::-webkit-scrollbar': {
          width: '4px',
          height: '4px',
        },
        '*::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        '*::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.2)',
          borderRadius: '2px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.3)',
          },
          '&:active': {
            backgroundColor: 'rgba(0, 0, 0, 0.4)',
          },
        },
        '*::-webkit-scrollbar-corner': {
          backgroundColor: 'transparent',
        },
        // Firefox scrollbar styling
        '*': {
          scrollbarWidth: 'thin',
          scrollbarColor: 'rgba(0, 0, 0, 0.2) transparent',
        },
        // Dialog scrollbars - even thinner
        '.MuiDialog-paper::-webkit-scrollbar': {
          width: '3px',
        },
        '.MuiDialog-paper::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.15)',
          borderRadius: '1.5px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.25)',
          },
        },
        '.MuiDialog-paper::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        // Menu and dropdown scrollbars - ultra thin
        '.MuiMenu-paper::-webkit-scrollbar, .MuiSelect-paper::-webkit-scrollbar': {
          width: '2px',
        },
        '.MuiMenu-paper::-webkit-scrollbar-thumb, .MuiSelect-paper::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.15)',
          borderRadius: '1px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.25)',
          },
        },
        '.MuiMenu-paper::-webkit-scrollbar-track, .MuiSelect-paper::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        // Textarea scrollbars
        'textarea::-webkit-scrollbar': {
          width: '4px',
        },
        'textarea::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.2)',
          borderRadius: '2px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.3)',
          },
        },
        'textarea::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
      },
    },
    MuiButton: {
      defaultProps: {
        disableElevation: true,
      },
      styleOverrides: {
        root: {
          padding: '8px 16px',
          borderRadius: 8,
        },
        contained: {
          boxShadow: '0px 3px 5px -1px rgba(0,0,0,0.08), 0px 6px 10px 0px rgba(0,0,0,0.05), 0px 1px 18px 0px rgba(0,0,0,0.04)',
          '&:hover': {
            boxShadow: '0px 6px 10px -1px rgba(0,0,0,0.1), 0px 10px 14px 0px rgba(0,0,0,0.07), 0px 1px 18px 0px rgba(0,0,0,0.06)',
          },
        },
      },
    },
    MuiTextField: {
      defaultProps: {
        variant: 'outlined',
      },
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0px 4px 8px rgba(0, 0, 0, 0.05)',
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        elevation1: {
          boxShadow: '0px 4px 8px rgba(0, 0, 0, 0.05)',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.08)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiListItemButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          '&.Mui-selected': {
            backgroundColor: 'rgba(26, 115, 232, 0.1)',
            color: '#1a73e8',
            '&:hover': {
              backgroundColor: 'rgba(26, 115, 232, 0.15)',
            },
            '& .MuiListItemIcon-root': {
              color: '#1a73e8',
            },
          },
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          borderRight: '1px solid rgba(0, 0, 0, 0.12)',
        },
      },
    },
    MuiLinearProgress: {
      styleOverrides: {
        root: {
          borderRadius: 4,
          height: 8,
          backgroundColor: 'rgba(0, 0, 0, 0.06)',
        },
      },
    },
    MuiAvatar: {
      styleOverrides: {
        root: {
          backgroundColor: '#1a73e8',
        },
      },
    },
    // Adjust container widths to compensate for 90% scaling
    MuiContainer: {
      styleOverrides: {
        root: {
          // Counter the 90% scaling by making containers slightly larger
          '@media (min-width:600px)': {
            maxWidth: 'calc(600px * 1.11)',
          },
          '@media (min-width:900px)': {
            maxWidth: 'calc(900px * 1.11)',
          },
          '@media (min-width:1200px)': {
            maxWidth: 'calc(1200px * 1.11)',
          },
          '@media (min-width:1536px)': {
            maxWidth: 'calc(1536px * 1.11)',
          },
        },
      },
    },
  },
});

export default function ThemeProvider({ children }) {
  return (
    <MuiThemeProvider theme={theme}>
      <CssBaseline />
      {children}
    </MuiThemeProvider>
  );
}

================
File: src/utils/assistantService.js
================
// src/utils/assistantService.js - ENHANCED WITH RESUME EDITING CAPABILITIES AND TIMEOUT FIXES
import api from './axios';

const assistantService = {
  // ===================================================================
  // ENHANCED CHAT WITH CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Send message to AI Assistant with enhanced context and conversation management
   */
  sendMessage: async (requestData) => {
    try {
      const {
        message,
        context = {},
        conversationId,
        newConversation = false,
        conversationHistory = []
      } = requestData;

      console.log('🚀 Sending message to AI:', { message: message.substring(0, 50) + '...', conversationId, newConversation });

      // 🔥 CRITICAL FIX: Detect resume editing requests and increase timeout
      const isResumeEditRequest = detectResumeEditRequest(message, context);
      const timeoutDuration = isResumeEditRequest ? 60000 : 30000; // 60s for resume edits, 30s for regular chat

      console.log(`⏱️ Using ${timeoutDuration/1000}s timeout for ${isResumeEditRequest ? 'resume editing' : 'regular chat'} request`);

      const response = await api.post('/assistant/chat', {
        message,
        context: {
          page: context.page || 'unknown',
          currentResume: context.currentResume || null,
          currentJob: context.currentJob || null,
          resumeCount: context.resumeCount || 0,
          jobCount: context.jobCount || 0,
          userProfile: context.userProfile || null
        },
        conversationId,
        newConversation,
        conversationHistory: conversationHistory.slice(-10) // Last 10 messages
      }, {
        timeout: timeoutDuration // 🔥 DYNAMIC TIMEOUT based on request type
      });

      console.log('✅ AI Response received:', response.data);

      return {
        message: response.data.message,
        suggestions: response.data.suggestions || [],
        actions: response.data.actions || [],
        confidence: response.data.confidence || 0.8,
        conversationId: response.data.conversationId,
        conversationTitle: response.data.conversationTitle,
        memoryInsights: response.data.memoryInsights || [],
        usage: response.data.usage || {},
        // 🔥 CRITICAL: Pass through resume update data
        resumeUpdated: response.data.resumeUpdated || false,
        newAnalysis: response.data.newAnalysis || null,
        resumeChanges: response.data.resumeChanges || null
      };

    } catch (error) {
      console.error('Enhanced AI Assistant Service Error:', error);
      
      // 🔥 ENHANCED: Better error handling for resume editing timeouts
      if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
        const isResumeEdit = detectResumeEditRequest(requestData.message, requestData.context);
        if (isResumeEdit) {
          throw new Error('Resume update is taking longer than usual. The changes may still be processing. Please refresh the page in a moment to see the updated scores.');
        } else {
          throw new Error('Request timed out. The AI is taking longer than usual to respond. Please try again.');
        }
      } else if (error.response?.status === 503) {
        throw new Error('AI service temporarily unavailable. Please try again in a moment.');
      } else if (error.response?.status === 429) {
        throw new Error('Rate limit exceeded. Please wait before sending another message.');
      } else {
        // Fallback response
        const fallbackResponse = assistantService.getContextualFallback(requestData.message, requestData.context);
        throw new Error(fallbackResponse.error || 'AI service temporarily unavailable');
      }
    }
  },

  // ===================================================================
  // CONVERSATION MANAGEMENT
  // ===================================================================

  /**
   * Get user's conversations
   */
  getConversations: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.category) params.append('category', options.category);
      if (options.tags && options.tags.length > 0) params.append('tags', options.tags.join(','));
      if (options.search) params.append('search', options.search);
      if (options.pinned !== undefined) params.append('pinned', options.pinned);
      if (options.starred !== undefined) params.append('starred', options.starred);
      if (options.limit) params.append('limit', options.limit);
      if (options.offset) params.append('offset', options.offset);
      if (options.sortBy) params.append('sortBy', options.sortBy);

      const response = await api.get(`/assistant/conversations?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching conversations:', error);
      throw error;
    }
  },

  /**
   * Get specific conversation
   */
  getConversation: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}`);
      return response.data.conversation;
    } catch (error) {
      console.error('Error fetching conversation:', error);
      throw error;
    }
  },

  /**
   * Create new conversation
   */
  createConversation: async (conversationData) => {
    try {
      const response = await api.post('/assistant/conversations', conversationData);
      return response.data.conversation;
    } catch (error) {
      console.error('Error creating conversation:', error);
      throw error;
    }
  },

  /**
   * Update conversation
   */
  updateConversation: async (conversationId, updates) => {
    try {
      const response = await api.put(`/assistant/conversations/${conversationId}`, updates);
      return response.data.conversation;
    } catch (error) {
      console.error('Error updating conversation:', error);
      throw error;
    }
  },

  /**
   * Delete conversation
   */
  deleteConversation: async (conversationId, permanent = false) => {
    try {
      const params = permanent ? '?permanent=true' : '';
      const response = await api.delete(`/assistant/conversations/${conversationId}${params}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting conversation:', error);
      throw error;
    }
  },

  /**
   * Generate conversation summary
   */
  generateSummary: async (conversationId) => {
    try {
      const response = await api.post(`/assistant/conversations/${conversationId}/summary`);
      return response.data.summary;
    } catch (error) {
      console.error('Error generating summary:', error);
      throw error;
    }
  },

  /**
   * Get conversation insights
   */
  getConversationInsights: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/insights`);
      return response.data.insights;
    } catch (error) {
      console.error('Error getting insights:', error);
      throw error;
    }
  },

  /**
   * Export conversation
   */
  exportConversation: async (conversationId, format = 'json') => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}/export?format=${format}`);
      return response.data.export;
    } catch (error) {
      console.error('Error exporting conversation:', error);
      throw error;
    }
  },

  /**
   * Bulk update conversations
   */
  bulkUpdateConversations: async (conversationIds, updates) => {
    try {
      const response = await api.post('/assistant/conversations/bulk-update', {
        conversationIds,
        updates
      });
      return response.data.result;
    } catch (error) {
      console.error('Error bulk updating conversations:', error);
      throw error;
    }
  },

  // ===================================================================
  // MEMORY MANAGEMENT
  // ===================================================================

  /**
   * Get user memories
   */
  getMemories: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.type) params.append('type', options.type);
      if (options.category) params.append('category', options.category);
      if (options.search) params.append('search', options.search);
      if (options.minConfidence) params.append('minConfidence', options.minConfidence);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/memories?${params}`);
      return response.data;

    } catch (error) {
      console.error('Error fetching memories:', error);
      throw error;
    }
  },

  /**
   * Add or update memory
   */
  updateMemory: async (memoryData) => {
    try {
      const response = await api.post('/assistant/memories', { memoryData });
      return response.data;
    } catch (error) {
      console.error('Error updating memory:', error);
      throw error;
    }
  },

  /**
   * Delete memory
   */
  deleteMemory: async (memoryId) => {
    try {
      const response = await api.delete(`/assistant/memories/${memoryId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting memory:', error);
      throw error;
    }
  },

  /**
   * Get memory insights
   */
  getMemoryInsights: async () => {
    try {
      const response = await api.get('/assistant/memory-insights');
      return response.data;
    } catch (error) {
      console.error('Error getting memory insights:', error);
      return {
        insights: [],
        analytics: {
          totalMemories: 0,
          averageConfidence: 0,
          memoriesByType: [],
          memoriesByCategory: []
        }
      };
    }
  },

  /**
   * Perform memory maintenance
   */
  performMemoryMaintenance: async () => {
    try {
      const response = await api.post('/assistant/memory-maintenance');
      return response.data.maintenance;
    } catch (error) {
      console.error('Error performing memory maintenance:', error);
      throw error;
    }
  },

  // ===================================================================
  // SEARCH & ANALYTICS
  // ===================================================================

  /**
   * Search across conversations and memories
   */
  search: async (query, options = {}) => {
    try {
      const params = new URLSearchParams();
      params.append('query', query);
      
      if (options.searchType) params.append('searchType', options.searchType);
      if (options.limit) params.append('limit', options.limit);

      const response = await api.get(`/assistant/search?${params}`);
      return response.data.results;

    } catch (error) {
      console.error('Error searching:', error);
      return { conversations: [], memories: [] };
    }
  },

  /**
   * Get analytics
   */
  getAnalytics: async (timeframe = '30d') => {
    try {
      const response = await api.get(`/assistant/analytics?timeframe=${timeframe}`);
      return response.data.analytics;
    } catch (error) {
      console.error('Error getting analytics:', error);
      throw error;
    }
  },

  // ===================================================================
  // ENHANCED RESUME OPERATIONS - FULL IMPLEMENTATION
  // ===================================================================

  /**
   * Analyze resume with memory context
   */
  analyzeResume: async (resumeId, analysisType = 'comprehensive') => {
    try {
      const response = await api.post('/assistant/analyze-resume', {
        resumeId,
        analysisType,
        includeImprovements: true,
        includeKeywords: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing resume:', error);
      throw error;
    }
  },

  /**
   * Apply resume changes suggested by AI
   */
  applyResumeChanges: async (resumeId, changes, changeType = 'ai_enhancement') => {
    try {
      const response = await api.post('/assistant/apply-resume-changes', {
        resumeId,
        changes,
        changeType
      }, {
        timeout: 60000 // Extended timeout for resume processing
      });

      return response.data;

    } catch (error) {
      console.error('Error applying resume changes:', error);
      throw error;
    }
  },

  /**
   * Optimize resume for ATS
   */
  optimizeForATS: async (resumeId, jobId = null) => {
    try {
      const response = await api.post('/assistant/optimize-ats', {
        resumeId,
        targetJobId: jobId,
        optimizationLevel: 'aggressive',
        useMemoryContext: true
      }, {
        timeout: 60000 // Extended timeout for ATS optimization
      });

      return response.data;

    } catch (error) {
      console.error('Error optimizing for ATS:', error);
      throw error;
    }
  },

  /**
   * Quick resume edit
   */
  quickEditResume: async (resumeId, editRequest) => {
    try {
      const response = await api.post('/assistant/resume/quick-edit', {
        resumeId,
        editRequest
      }, {
        timeout: 45000
      });

      return response.data;

    } catch (error) {
      console.error('Error with quick resume edit:', error);
      throw error;
    }
  },

  /**
   * Process resume update request from chat
   */
  processResumeUpdateFromChat: async (message, resumeId, conversationId) => {
    try {
      const response = await api.post('/assistant/chat', {
        message,
        context: {
          page: 'resumes',
          currentResume: { id: resumeId },
          intent: 'resume_update'
        },
        conversationId,
        resumeUpdateMode: true
      }, {
        timeout: 60000 // Extended timeout for resume updates
      });

      return response.data;

    } catch (error) {
      console.error('Error processing resume update from chat:', error);
      throw error;
    }
  },

  /**
   * Bulk update multiple resume sections
   */
  bulkUpdateResume: async (resumeId, updates) => {
    try {
      const response = await api.post('/assistant/resume/bulk-update', {
        resumeId,
        updates
      }, {
        timeout: 60000 // Extended timeout for bulk updates
      });

      return response.data;

    } catch (error) {
      console.error('Error with bulk resume update:', error);
      throw error;
    }
  },

  /**
   * Get resume improvement suggestions
   */
  getResumeImprovements: async (resumeId, focusArea = 'all') => {
    try {
      const response = await api.post('/assistant/resume/improvements', {
        resumeId,
        focusArea, // 'ats', 'content', 'keywords', 'formatting', 'all'
        useMemoryContext: true
      }, {
        timeout: 30000
      });

      return response.data;

    } catch (error) {
      console.error('Error getting resume improvements:', error);
      throw error;
    }
  },

  // ===================================================================
  // JOB MATCHING & CAREER GUIDANCE
  // ===================================================================

  /**
   * Get job matching insights with memory context
   */
  analyzeJobMatch: async (resumeId, jobId) => {
    try {
      const response = await api.post('/assistant/analyze-job-match', {
        resumeId,
        jobId,
        includeImprovements: true,
        includeTailoringAdvice: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing job match:', error);
      throw error;
    }
  },

  /**
   * Generate personalized cover letter
   */
  generateCoverLetter: async (resumeId, jobId, style = 'professional') => {
    try {
      const response = await api.post('/assistant/generate-cover-letter', {
        resumeId,
        jobId,
        style,
        customization: 'high',
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error generating cover letter:', error);
      throw error;
    }
  },

  /**
   * Get career advice and guidance with memory context
   */
  getCareerAdvice: async (userProfile, specificQuestion = null) => {
    try {
      const response = await api.post('/assistant/career-advice', {
        userProfile,
        question: specificQuestion,
        includeJobSuggestions: true,
        includeSkillGaps: true,
        useMemoryContext: true
      });

      return response.data;

    } catch (error) {
      console.error('Error getting career advice:', error);
      throw error;
    }
  },

  /**
   * Get contextual suggestions for current page
   */
  getContextualSuggestions: async (page, contextData = {}) => {
    try {
      const response = await api.post('/assistant/contextual-suggestions', {
        page,
        contextData,
        maxSuggestions: 5,
        useMemoryContext: true
      });

      return response.data.suggestions || [];

    } catch (error) {
      console.error('Error getting contextual suggestions:', error);
      return assistantService.getFallbackSuggestions(page, contextData);
    }
  },

  /**
   * Get personalized tips based on user profile and memory
   */
  getPersonalizedTips: async (category = 'general') => {
    try {
      const response = await api.post('/assistant/personalized-tips', {
        category,
        includeActions: true,
        useMemoryContext: true
      });

      return response.data.tips || [];

    } catch (error) {
      console.error('Error getting personalized tips:', error);
      return assistantService.getFallbackTips(category);
    }
  },

  // ===================================================================
  // SYSTEM & HEALTH
  // ===================================================================

  /**
   * Get AI Assistant capabilities and status
   */
  getCapabilities: async () => {
    try {
      const response = await api.get('/assistant/capabilities');
      return response.data;
    } catch (error) {
      console.error('Error getting AI capabilities:', error);
      return {
        available: false,
        features: ['basic_chat', 'contextual_suggestions'],
        limitations: ['Full AI features unavailable in test mode'],
        memory_features: {
          available: false
        },
        resume_features: {
          available: false
        }
      };
    }
  },

  /**
   * Check AI Assistant health
   */
  checkHealth: async () => {
    try {
      const response = await api.get('/assistant/health');
      return response.data;
    } catch (error) {
      console.error('Health check failed:', error);
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  },

  /**
   * Get user's AI usage statistics
   */
  getUsageStats: async () => {
    try {
      const response = await api.get('/assistant/usage-stats');
      return response.data;
    } catch (error) {
      console.error('Error getting usage stats:', error);
      return {
        messagesThisMonth: 0,
        resumeAnalyses: 0,
        jobMatches: 0,
        careerAdviceRequests: 0,
        conversationsCreated: 0,
        memoriesStored: 0,
        resumeEdits: 0,
        atsOptimizations: 0
      };
    }
  },

  /**
   * Track user interaction
   */
  trackInteraction: async (interactionType, data) => {
    try {
      await api.post('/assistant/track-interaction', {
        type: interactionType,
        data,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      // Non-critical, just log
      console.warn('Failed to track interaction:', error);
    }
  },

  /**
   * Reset AI conversation context
   */
  resetContext: async () => {
    try {
      await api.post('/assistant/reset-context');
      return { success: true };
    } catch (error) {
      console.error('Error resetting context:', error);
      return { success: false };
    }
  },

  // ===================================================================
  // CONVERSATION UTILITIES
  // ===================================================================

  /**
   * Auto-generate conversation title based on content
   */
  generateConversationTitle: async (messages, context = {}) => {
    try {
      if (!messages || messages.length === 0) return 'New Conversation';

      // Use the first user message to generate title
      const firstUserMessage = messages.find(m => m.type === 'user');
      if (!firstUserMessage) return 'New Conversation';

      // Simple client-side title generation for immediate feedback
      const content = firstUserMessage.content.toLowerCase();
      
      if (content.includes('resume')) return 'Resume Assistance';
      if (content.includes('job') || content.includes('application')) return 'Job Search Help';
      if (content.includes('interview')) return 'Interview Preparation';
      if (content.includes('career')) return 'Career Guidance';
      if (content.includes('skill')) return 'Skill Development';
      
      // Fallback based on context
      const contextTitles = {
        'resumes': 'Resume Help',
        'jobs': 'Job Search',
        'dashboard': 'Career Planning'
      };
      
      return contextTitles[context.page] || 'Career Assistance';

    } catch (error) {
      console.error('Error generating conversation title:', error);
      return 'New Conversation';
    }
  },

  /**
   * Format conversation for display
   */
  formatConversation: (conversation) => {
    if (!conversation) return null;

    return {
      ...conversation,
      formattedDate: new Date(conversation.createdAt).toLocaleDateString(),
      formattedTime: new Date(conversation.lastActiveAt).toLocaleTimeString(),
      preview: conversation.messages && conversation.messages.length > 0
        ? conversation.messages[conversation.messages.length - 1].content.substring(0, 100) + '...'
        : conversation.description || 'No messages yet',
      messageCount: conversation.messages ? conversation.messages.length : 0,
      isRecent: Date.now() - new Date(conversation.lastActiveAt).getTime() < 24 * 60 * 60 * 1000
    };
  },

  /**
   * Format memory for display
   */
  formatMemory: (memory) => {
    if (!memory) return null;

    return {
      ...memory,
      formattedDate: new Date(memory.createdAt).toLocaleDateString(),
      confidencePercentage: Math.round(memory.confidence * 100),
      isHighConfidence: memory.confidence >= 0.8,
      isRecentlyAccessed: memory.usage?.lastAccessedAt && 
        Date.now() - new Date(memory.usage.lastAccessedAt).getTime() < 7 * 24 * 60 * 60 * 1000,
      typeLabel: assistantService.getMemoryTypeLabel(memory.type),
      categoryLabel: assistantService.getCategoryLabel(memory.category)
    };
  },

  /**
   * Get human-readable memory type labels
   */
  getMemoryTypeLabel: (type) => {
    const labels = {
      'preference': 'Preference',
      'skill': 'Skill',
      'career_goal': 'Career Goal',
      'experience': 'Experience',
      'achievement': 'Achievement',
      'challenge': 'Challenge',
      'personality_trait': 'Personality',
      'communication_style': 'Communication Style',
      'work_style': 'Work Style',
      'industry_knowledge': 'Industry Knowledge',
      'tool_preference': 'Tool Preference',
      'feedback_pattern': 'Feedback Pattern'
    };
    return labels[type] || type;
  },

  /**
   * Get human-readable category labels
   */
  getCategoryLabel: (category) => {
    const labels = {
      'personal': 'Personal',
      'professional': 'Professional',
      'technical': 'Technical',
      'behavioral': 'Behavioral',
      'contextual': 'Contextual'
    };
    return labels[category] || category;
  },

  // ===================================================================
  // ENHANCED FALLBACK RESPONSES
  // ===================================================================

  /**
   * Enhanced fallback responses based on context
   */
  getContextualFallback: (message, context) => {
    const lowercaseMessage = message?.toLowerCase() || '';

    // Resume-related queries
    if (lowercaseMessage.includes('resume') || lowercaseMessage.includes('cv')) {
      if (context?.page === 'resumes' && context?.currentResume) {
        return {
          message: `I can see you're working on "${context.currentResume.name}". While I can't access my full AI capabilities right now, I can still help with resume improvements, ATS optimization, and real-time editing. What would you like me to update?`,
          suggestions: [
            'Improve work experience section',
            'Optimize for ATS',
            'Add missing skills',
            'Enhance summary section'
          ]
        };
      }
      return {
        message: "I'd love to help improve your resume! I can edit resumes in real-time, optimize for ATS systems, and provide personalized suggestions. Which resume would you like to work on?",
        suggestions: [
          'Analyze my best resume',
          'Edit resume content',
          'Optimize for ATS',
          'Add new skills'
        ]
      };
    }

    // Job-related queries
    if (lowercaseMessage.includes('job') || lowercaseMessage.includes('application') || lowercaseMessage.includes('interview')) {
      if (context?.page === 'jobs' && context?.currentJob) {
        return {
          message: `Looking at "${context.currentJob.title}" at ${context.currentJob.company}. I can help optimize your resume for this specific position and improve your match score.`,
          suggestions: [
            'Tailor resume to this job',
            'What skills am I missing?',
            'Optimize for ATS',
            'Generate cover letter'
          ]
        };
      }
      return {
        message: "I can help you with job applications, resume tailoring, and interview preparation! What specific aspect would you like assistance with?",
        suggestions: [
          'Find matching jobs',
          'Improve application materials',
          'Interview preparation',
          'Salary negotiation'
        ]
      };
    }

    // Career guidance queries
    if (lowercaseMessage.includes('career') || lowercaseMessage.includes('advice') || lowercaseMessage.includes('guidance')) {
      return {
        message: "I'm here to provide personalized career guidance! I can help with career planning, skill development, resume optimization, and strategic job search approaches. What's your biggest career challenge right now?",
        suggestions: [
          'Plan my next career move',
          'Identify skill gaps',
          'Industry insights',
          'Resume improvements'
        ]
      };
    }

    // Resume editing specific queries
    if (lowercaseMessage.includes('edit') || lowercaseMessage.includes('update') || lowercaseMessage.includes('change')) {
      return {
        message: "I can edit your resume in real-time! Just tell me what you'd like to change - whether it's updating your experience, adding new skills, or optimizing for specific jobs. I'll make the changes immediately.",
        suggestions: [
          'Update work experience',
          'Add new skills',
          'Improve summary',
          'Optimize formatting'
        ]
      };
    }

    // Default fallback
    return {
      message: "I'm here to help with your career and can edit resumes in real-time! I remember our previous conversations and can provide personalized advice. What would you like to explore?",
      suggestions: [
        'Edit my resume',
        'Career guidance',
        'Job search help',
        'Skill development'
      ],
      error: 'AI service temporarily experiencing connectivity issues'
    };
  },

  /**
   * Get fallback suggestions based on page context
   */
  getFallbackSuggestions: (page, contextData) => {
    const suggestions = {
      dashboard: [
        'Review my career progress',
        'What should I focus on today?',
        'Find new job opportunities',
        'Edit my resume'
      ],
      resumes: [
        'Edit this resume',
        'Optimize for ATS',
        'Add missing skills',
        'Improve work experience'
      ],
      jobs: [
        'Tailor resume to this job',
        'Find similar positions',
        'Improve match score',
        'Generate cover letter'
      ],
      'ai-searches': [
        'Optimize search criteria',
        'Review found opportunities',
        'Adjust parameters',
        'Set up new searches'
      ]
    };

    return suggestions[page] || [
      'Edit my resume',
      'Find job opportunities',
      'Career guidance',
      'Skill development'
    ];
  },

  /**
   * Get fallback tips based on category
   */
  getFallbackTips: (category) => {
    const fallbackTips = {
      resume: [
        'Use action verbs to start bullet points',
        'Quantify achievements with numbers',
        'Tailor keywords to job descriptions',
        'Keep formatting ATS-friendly',
        'Update regularly with new skills'
      ],
      job_search: [
        'Apply within 24-48 hours of posting',
        'Customize resume for each application',
        'Research company culture',
        'Follow up professionally',
        'Leverage your network'
      ],
      career: [
        'Set SMART career goals',
        'Build professional network',
        'Stay updated with trends',
        'Invest in skill development',
        'Seek feedback regularly'
      ],
      interview: [
        'Practice common questions',
        'Research company thoroughly',
        'Prepare STAR examples',
        'Ask thoughtful questions',
        'Send thank-you notes'
      ],
      general: [
        'Keep LinkedIn updated',
        'Track applications systematically',
        'Practice interviewing',
        'Maintain online presence',
        'Document achievements'
      ]
    };

    return fallbackTips[category] || fallbackTips.general;
  },

  // ===================================================================
  // VALIDATION & UTILITIES
  // ===================================================================

  /**
   * Validate message content before sending
   */
  validateMessage: (message) => {
    if (!message || typeof message !== 'string') {
      return { valid: false, error: 'Message must be a non-empty string' };
    }

    if (message.trim().length === 0) {
      return { valid: false, error: 'Message cannot be empty' };
    }

    if (message.length > 3000) {
      return { valid: false, error: 'Message too long (max 3000 characters)' };
    }

    // Check for potential harmful content
    const harmfulPatterns = [
      /password/i,
      /credit card/i,
      /social security/i,
      /ssn/i
    ];

    for (const pattern of harmfulPatterns) {
      if (pattern.test(message)) {
        return { 
          valid: false, 
          error: 'Please avoid sharing sensitive personal information' 
        };
        }
   }

   return { valid: true };
 },


/**
 * Format AI response for display
 */
formatResponse: (response) => {
  if (!response || typeof response !== 'string') {
    return 'I encountered an issue processing that request. Please try again.';
  }

  // Clean up common AI response artifacts and convert markdown to HTML
  let formatted = response
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Convert **text** to <strong>text</strong>
    .replace(/\*(.*?)\*/g, '<em>$1</em>')           // Convert *text* to <em>text</em>
    .replace(/\n\n+/g, '\n\n')                      // Normalize line breaks
    .trim();

  // Ensure proper sentence structure
  if (formatted && !formatted.endsWith('.') && !formatted.endsWith('!') && !formatted.endsWith('?')) {
    formatted += '.';
  }

  return formatted;
},

 /**
  * Check if AI service is available
  */
 isAvailable: async () => {
   try {
     const response = await api.get('/assistant/health');
     return response.data.status === 'healthy';
   } catch (error) {
     console.warn('AI Assistant service unavailable:', error.message);
     return false;
   }
 },

 /**
  * Get conversation statistics
  */
 getConversationStats: async () => {
   try {
     const analytics = await assistantService.getAnalytics('30d');
     return {
       totalConversations: analytics.totalConversations || 0,
       totalMessages: analytics.totalMessages || 0,
       avgEngagement: analytics.avgEngagement || 0,
       mostActiveCategory: analytics.categoryDistribution ? 
         Object.keys(analytics.categoryDistribution)[0] : 'general'
     };
   } catch (error) {
     console.error('Error getting conversation stats:', error);
     return {
       totalConversations: 0,
       totalMessages: 0,
       avgEngagement: 0,
       mostActiveCategory: 'general'
     };
   }
 },

 /**
  * Estimate tokens for message
  */
 estimateTokens: (text) => {
   // Rough estimation: ~4 characters per token
   return Math.ceil(text.length / 4);
 },

 /**
  * Calculate estimated cost
  */
 estimateCost: (tokens) => {
   // GPT-4 Turbo pricing estimate
   const inputCost = 0.01 / 1000;
   const outputCost = 0.03 / 1000;
   return ((tokens * 0.5 * inputCost) + (tokens * 0.5 * outputCost)).toFixed(4);
 },

 // ===================================================================
 // RESUME EDITING HELPER METHODS
 // ===================================================================

 /**
  * Detect if message is a resume edit request
  */
 isResumeEditRequest: (message, context) => {
   if (context?.page !== 'resumes' || !context?.currentResume) {
     return false;
   }

   const editKeywords = [
     'update', 'change', 'edit', 'modify', 'improve', 'enhance', 
     'add', 'remove', 'rewrite', 'fix', 'optimize', 'tailor'
   ];

   const messageWords = message.toLowerCase().split(' ');
   return editKeywords.some(keyword => 
     messageWords.some(word => word.includes(keyword))
   );
 },

 /**
  * Parse resume edit intent from natural language
  */
 parseResumeEditIntent: (message) => {
   const intent = {
     type: 'general',
     section: null,
     action: null,
     content: message
   };

   const messageLower = message.toLowerCase();

   // Detect section
   if (messageLower.includes('summary') || messageLower.includes('objective')) {
     intent.section = 'summary';
   } else if (messageLower.includes('experience') || messageLower.includes('work') || messageLower.includes('job')) {
     intent.section = 'experience';
   } else if (messageLower.includes('skill')) {
     intent.section = 'skills';
   } else if (messageLower.includes('education') || messageLower.includes('degree')) {
     intent.section = 'education';
   } else if (messageLower.includes('certification')) {
     intent.section = 'certifications';
   } else if (messageLower.includes('project')) {
     intent.section = 'projects';
   }

   // Detect action
   if (messageLower.includes('add') || messageLower.includes('include')) {
     intent.action = 'add';
   } else if (messageLower.includes('remove') || messageLower.includes('delete')) {
     intent.action = 'remove';
   } else if (messageLower.includes('update') || messageLower.includes('change')) {
     intent.action = 'update';
   } else if (messageLower.includes('rewrite') || messageLower.includes('improve')) {
     intent.action = 'enhance';
   } else if (messageLower.includes('optimize') || messageLower.includes('ats')) {
     intent.action = 'optimize';
     intent.type = 'ats_optimization';
   }

   return intent;
 },

 /**
  * Generate resume edit confirmation message
  */
 generateEditConfirmation: (changes, resumeName) => {
   if (!changes || changes.length === 0) {
     return `I've updated your resume "${resumeName}" as requested.`;
   }

   const changeDescriptions = changes.map(change => {
     const section = change.section || 'content';
     const action = change.action || 'updated';
     return `${action} ${section}`;
   });

   return `✅ I've successfully updated your resume "${resumeName}"! Changes made: ${changeDescriptions.join(', ')}.`;
 },

 // ===================================================================
 // RESUME REAL-TIME EDITING WORKFLOW
 // ===================================================================

 /**
  * Handle complete resume editing workflow from chat
  */
 handleResumeEditWorkflow: async (message, context, conversationId) => {
   try {
     const { currentResume } = context;
     
     if (!currentResume) {
       throw new Error('No resume context available');
     }

     console.log(`🔧 Starting resume edit workflow for: ${currentResume.name}`);

     // Step 1: Parse the edit intent
     const editIntent = assistantService.parseResumeEditIntent(message);
     
     // Step 2: Apply the changes
     const result = await assistantService.applyResumeChanges(
       currentResume.id,
       message,
       editIntent.type || 'ai_enhancement'
     );

     // Step 3: Generate confirmation
     const confirmation = assistantService.generateEditConfirmation(
       result.result?.changes,
       currentResume.name
     );

     // Step 4: Return structured response
     return {
       success: true,
       message: confirmation,
       suggestions: [
         'Make more changes',
         'Optimize for ATS',
         'View updated resume',
         'Download new version'
       ],
       resumeUpdated: true,
       updatedResume: result.result?.updatedResume,
       changes: result.result?.changes,
       newFileUrl: result.result?.newFileUrl
     };

   } catch (error) {
     console.error('Resume edit workflow error:', error);
     throw error;
   }
 },

 /**
  * Quick resume fixes with predefined templates
  */
 applyQuickResumeFix: async (resumeId, fixType) => {
   const quickFixes = {
     'action-verbs': 'Replace weak verbs with strong action verbs throughout the resume',
     'quantify': 'Add specific numbers and metrics to achievements where possible',
     'keywords': 'Add relevant industry keywords to improve ATS compatibility',
     'formatting': 'Optimize formatting for better ATS parsing and readability',
     'grammar': 'Fix any grammar, spelling, or punctuation errors',
     'consistency': 'Ensure consistent formatting, dates, and style throughout'
   };

   const instruction = quickFixes[fixType] || quickFixes['formatting'];
   
   return await assistantService.applyResumeChanges(
     resumeId,
     instruction,
     'quick_fix'
   );
 },

 // ===================================================================
 // ERROR HANDLING & RETRY LOGIC
 // ===================================================================

 /**
  * Retry failed requests with exponential backoff
  */
 retryWithBackoff: async (operation, maxRetries = 3) => {
   let lastError;
   
   for (let attempt = 1; attempt <= maxRetries; attempt++) {
     try {
       return await operation();
     } catch (error) {
       lastError = error;
       
       if (attempt === maxRetries) {
         break;
       }
       
       // Don't retry on client errors (4xx)
       if (error.response?.status >= 400 && error.response?.status < 500) {
         break;
       }
       
       // Exponential backoff: 1s, 2s, 4s
       const delay = Math.pow(2, attempt - 1) * 1000;
       console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
       await new Promise(resolve => setTimeout(resolve, delay));
     }
   }
   
   throw lastError;
 },

 /**
  * Handle network errors gracefully
  */
 handleNetworkError: (error, operation) => {
   if (error.code === 'ECONNABORTED') {
     return {
       success: false,
       error: 'Request timed out. Please try again.',
       canRetry: true
     };
   }
   
   if (error.code === 'ECONNREFUSED') {
     return {
       success: false,
       error: 'Unable to connect to AI service. Please check your connection.',
       canRetry: true
     };
   }
   
   if (error.response?.status === 429) {
     return {
       success: false,
       error: 'Rate limit exceeded. Please wait a moment before trying again.',
       canRetry: true,
       retryAfter: error.response.headers['retry-after'] || 60
     };
   }
   
   return {
     success: false,
     error: `Failed to ${operation}. Please try again.`,
     canRetry: false
   };
 },

 // ===================================================================
 // ADVANCED RESUME FEATURES
 // ===================================================================

 /**
  * Compare resume versions
  */
 compareResumeVersions: async (resumeId, version1, version2) => {
   try {
     const response = await api.post('/assistant/resume/compare-versions', {
       resumeId,
       version1,
       version2
     });

     return response.data;

   } catch (error) {
     console.error('Error comparing resume versions:', error);
     throw error;
   }
 },

 /**
  * Generate resume metrics and insights
  */
 getResumeMetrics: async (resumeId) => {
   try {
     const response = await api.get(`/assistant/resume/${resumeId}/metrics`);
     return response.data;

   } catch (error) {
     console.error('Error getting resume metrics:', error);
     throw error;
   }
 },

 /**
  * Export resume in different formats
  */
 exportResume: async (resumeId, format = 'pdf', options = {}) => {
   try {
     const response = await api.post(`/assistant/resume/${resumeId}/export`, {
       format,
       options
     });

     return response.data;

   } catch (error) {
     console.error('Error exporting resume:', error);
     throw error;
   }
 },

 /**
  * Schedule resume review reminders
  */
 scheduleResumeReview: async (resumeId, reminderSettings) => {
   try {
     const response = await api.post(`/assistant/resume/${resumeId}/schedule-review`, {
       reminderSettings
     });

     return response.data;

   } catch (error) {
     console.error('Error scheduling resume review:', error);
     throw error;
   }
 },

 // ===================================================================
 // CONTEXTUAL HELPERS
 // ===================================================================

 /**
  * Get page-specific AI capabilities
  */
 getPageCapabilities: (page) => {
   const capabilities = {
     dashboard: [
       'career_overview',
       'progress_tracking',
       'goal_setting',
       'quick_insights'
     ],
     resumes: [
       'real_time_editing',
       'ats_optimization',
       'content_enhancement',
       'version_management',
       'comparative_analysis'
     ],
     jobs: [
       'job_matching',
       'resume_tailoring',
       'application_optimization',
       'cover_letter_generation'
     ],
     recruiters: [
       'outreach_personalization',
       'relationship_tracking',
       'message_optimization'
     ],
     applications: [
       'status_tracking',
       'follow_up_reminders',
       'interview_preparation'
     ]
   };

   return capabilities[page] || ['basic_chat', 'contextual_suggestions'];
 },

 /**
  * Get contextual AI prompts based on current state
  */
 getContextualPrompts: (context) => {
   const prompts = [];

   if (context?.currentResume) {
     const score = context.currentResume.score || 0;
     if (score < 70) {
       prompts.push({
         type: 'improvement',
         message: 'I notice your resume score could be improved. Would you like me to help optimize it?',
         action: 'optimize_resume'
       });
     }

     if (score >= 80) {
       prompts.push({
         type: 'congratulations',
         message: 'Great resume score! Want me to help you find jobs that match your profile?',
         action: 'find_jobs'
       });
     }
   }

   if (context?.page === 'jobs' && context?.currentJob) {
     prompts.push({
       type: 'matching',
       message: `Want me to check how well your resume matches "${context.currentJob.title}"?`,
       action: 'analyze_match'
     });
   }

   return prompts;
 },

 /**
  * Handle contextual AI suggestions
  */
 processContextualAction: async (action, context) => {
   try {
     switch (action) {
       case 'optimize_resume':
         if (context?.currentResume?.id) {
           return await assistantService.optimizeForATS(context.currentResume.id);
         }
         break;

       case 'find_jobs':
         return await assistantService.getContextualSuggestions('jobs', context);

       case 'analyze_match':
         if (context?.currentResume?.id && context?.currentJob?.id) {
           return await assistantService.analyzeJobMatch(
             context.currentResume.id,
             context.currentJob.id
           );
         }
         break;

       default:
         return { success: false, error: 'Unknown action' };
     }
   } catch (error) {
     console.error('Error processing contextual action:', error);
     throw error;
   }
 }
};

// ===================================================================
// HELPER FUNCTIONS (Outside of object for proper scoping)
// ===================================================================

/**
* Detect if message is a resume edit request - FIXED FUNCTION
*/
function detectResumeEditRequest(message, context) {
 if (context?.page !== 'resumes' || !context?.currentResume?.id) {
   return false;
 }

 const messageLower = message.toLowerCase();
 const editingKeywords = [
   'update', 'change', 'edit', 'modify', 'improve', 'enhance', 
   'add', 'remove', 'rewrite', 'fix', 'optimize', 'tailor'
 ];

 const hasEditingKeyword = editingKeywords.some(keyword => messageLower.includes(keyword));
 const hasResumeReference = messageLower.includes('resume') || 
                            messageLower.includes('cv') ||
                            messageLower.includes('experience') ||
                            messageLower.includes('work');

 return hasEditingKeyword && hasResumeReference;
}

/**
* Format error messages for user display
*/
function formatErrorMessage(error, context) {
 if (error.message?.includes('timeout')) {
   if (context?.page === 'resumes') {
     return 'Resume processing is taking longer than expected. Your changes may still be applying in the background.';
   }
   return 'The request is taking longer than usual. Please try again.';
 }

 if (error.response?.status === 429) {
   return 'Too many requests. Please wait a moment before trying again.';
 }

 if (error.response?.status === 503) {
   return 'AI service is temporarily unavailable. Please try again in a few moments.';
 }

 return error.message || 'An unexpected error occurred. Please try again.';
}

/**
* Validate context data for AI requests
*/
function validateContext(context) {
 const validContext = {
   page: context?.page || 'unknown',
   currentResume: null,
   currentJob: null,
   resumeCount: 0,
   jobCount: 0,
   userProfile: null
 };

 if (context?.currentResume && context.currentResume.id) {
   validContext.currentResume = {
     id: context.currentResume.id,
     name: context.currentResume.name || 'Resume',
     score: context.currentResume.score || 0
   };
 }

 if (context?.currentJob && context.currentJob.id) {
   validContext.currentJob = {
     id: context.currentJob.id,
     title: context.currentJob.title || 'Job',
     company: context.currentJob.company || 'Company'
   };
 }

 validContext.resumeCount = Number(context?.resumeCount) || 0;
 validContext.jobCount = Number(context?.jobCount) || 0;

 if (context?.userProfile) {
   validContext.userProfile = {
     name: context.userProfile.name || 'User',
     email: context.userProfile.email || ''
   };
 }

 return validContext;
}

export default assistantService;

================
File: src/utils/axios.js
================
// frontend/src/utils/axios.js - ENHANCED WITH RATE LIMITING PROTECTION
import axios from 'axios';

// Create axios instance with base configuration
const api = axios.create({
  baseURL: 'http://localhost:5000/api',
  withCredentials: true, // Send cookies with requests
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
  timeout: 60000, // 60 second timeout for AI requests
});

// Rate limiting state
let isRateLimited = false;
let rateLimitTimeout = null;
let retryQueue = [];

// Helper function to handle rate limit delays
const handleRateLimit = (retryAfter = 60) => {
  console.log(`⏱️ Rate limited - waiting ${retryAfter} seconds before retrying`);
  isRateLimited = true;
  
  if (rateLimitTimeout) {
    clearTimeout(rateLimitTimeout);
  }
  
  rateLimitTimeout = setTimeout(() => {
    console.log('✅ Rate limit window expired, resuming requests');
    isRateLimited = false;
    
    // Process any queued requests
    const queue = [...retryQueue];
    retryQueue = [];
    queue.forEach(({ resolve, config }) => {
      api.request(config).then(resolve).catch(err => {
        // If still rate limited, re-queue
        if (err.response?.status === 429) {
          retryQueue.push({ resolve, config });
        } else {
          resolve(Promise.reject(err));
        }
      });
    });
  }, retryAfter * 1000);
};

// Request interceptor to add auth token and handle requests
api.interceptors.request.use(
  (config) => {
    // Add timestamp to prevent caching issues
    config.metadata = { startTime: new Date() };
    
    // Get token from localStorage
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // Log request in development
    if (process.env.NODE_ENV === 'development') {
      console.log(`🚀 API Request: ${config.method?.toUpperCase()} ${config.baseURL}${config.url}`);
    }
    
    return config;
  },
  (error) => {
    console.error('❌ Request interceptor error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor to handle responses and errors
api.interceptors.response.use(
  (response) => {
    // Log response time in development
    if (process.env.NODE_ENV === 'development' && response.config.metadata) {
      const duration = new Date() - response.config.metadata.startTime;
      console.log(`✅ API Response: ${response.config.method?.toUpperCase()} ${response.config.url} - ${duration}ms - Status: ${response.status}`);
    }
    
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    
    // Log error details
    console.error('❌ API Error Details:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      url: error.config?.url,
      method: error.config?.method?.toUpperCase(),
      responseData: error.response?.data,
      timeout: error.config?.timeout
    });
    
    // Handle rate limiting (429) - NEW FEATURE
    if (error.response?.status === 429) {
      const retryAfter = parseInt(error.response.headers['retry-after']) || 60;
      
      console.warn(`⏱️ Rate limited - too many requests. Waiting ${retryAfter} seconds.`);
      
      // If not already handling rate limit, start the delay
      if (!isRateLimited) {
        handleRateLimit(retryAfter);
      }
      
      // Queue the request for retry
      return new Promise((resolve) => {
        retryQueue.push({ resolve, config: originalRequest });
      });
    }
    
    // Handle different types of errors
    if (error.response) {
      // Server responded with error status
      const { status, data } = error.response;
      
      switch (status) {
        case 401:
          // Unauthorized - token expired or invalid
          console.warn('🔒 Authentication error - clearing token and redirecting');
          localStorage.removeItem('token');
          delete api.defaults.headers.common['Authorization'];
          
          // Only redirect if not already on auth pages
          const currentPath = window.location.pathname;
          if (!currentPath.includes('/login') && 
              !currentPath.includes('/register') && 
              !currentPath.includes('/forgot-password') &&
              !currentPath.includes('/reset-password')) {
            
            // Use a small delay to prevent multiple redirects
            setTimeout(() => {
              window.location.href = '/login?expired=true';
            }, 100);
          }
          break;
          
        case 403:
          // Forbidden - user doesn't have permission
          console.warn('🚫 Access forbidden:', data?.error || 'Permission denied');
          break;
          
        case 404:
          // Not found - API endpoint doesn't exist
          console.warn('🔍 API endpoint not found:', error.config?.url);
          console.warn('💡 Check if the backend server is running and routes are properly configured');
          break;
          
        case 429:
          // Rate limited - already handled above
          console.warn('⏱️ Rate limited - request queued for retry');
          break;
          
        case 500:
          // Server error
          console.error('🔥 Server error occurred');
          break;
          
        default:
          console.error(`❌ HTTP ${status}:`, data?.error || error.message);
      }
      
      // Enhance error object with additional info
      error.isApiError = true;
      error.apiStatus = status;
      error.apiMessage = data?.error || data?.message || 'An error occurred';
      
    } else if (error.request) {
      // Network error - no response received
      if (error.code === 'ECONNABORTED' && error.message.includes('timeout')) {
        console.error('⏱️ Request timed out after', error.config?.timeout, 'ms');
        error.isTimeoutError = true;
        error.apiMessage = 'The request is taking longer than expected. AI processing can take up to 60 seconds for complex requests. Please try again.';
      } else {
        console.error('🌐 Network error - server may be down:', error.message);
        error.isNetworkError = true;
        error.apiMessage = 'Network error - please check your connection and try again';
        
        // Check if backend server is running
        if (error.code === 'ECONNREFUSED' || error.message.includes('Network Error')) {
          error.apiMessage = 'Cannot connect to server. Please ensure the backend is running on http://localhost:5000';
          console.error('💡 Backend server might not be running. Check: npm start in backend directory');
        }
      }
      
    } else {
      // Request setup error
      console.error('⚙️ Request setup error:', error.message);
      error.apiMessage = 'Request configuration error';
    }
    
    return Promise.reject(error);
  }
);

// Helper function to check if error is authentication related
export const isAuthError = (error) => {
  return error?.response?.status === 401 || 
         error?.apiStatus === 401 ||
         error?.message?.includes('token');
};

// Helper function to check if error is network related
export const isNetworkError = (error) => {
  return error?.isNetworkError || 
         error?.code === 'ECONNREFUSED' ||
         error?.message === 'Network Error';
};

// Helper function to check if error is timeout related
export const isTimeoutError = (error) => {
  return error?.isTimeoutError ||
         error?.code === 'ECONNABORTED' ||
         error?.message?.includes('timeout');
};

// Helper function to check if error is rate limit related - NEW
export const isRateLimitError = (error) => {
  return error?.response?.status === 429 ||
         error?.apiStatus === 429 ||
         error?.message?.includes('rate limit');
};

// Helper function to get user-friendly error message
export const getErrorMessage = (error) => {
  // Handle rate limiting with specific message
  if (isRateLimitError(error)) {
    return 'Too many requests. Please wait a moment before trying again.';
  }
  
  if (error?.apiMessage) {
    return error.apiMessage;
  }
  
  if (error?.response?.data?.error) {
    return error.response.data.error;
  }
  
  if (error?.response?.data?.message) {
    return error.response.data.message;
  }
  
  if (error?.message) {
    return error.message;
  }
  
  return 'An unexpected error occurred. Please try again.';
};

// Helper function to handle API responses consistently
export const handleApiResponse = (response) => {
  if (response?.data?.success === false) {
    throw new Error(response.data.error || 'API returned unsuccessful response');
  }
  return response.data;
};

// Helper function to check if we're currently rate limited - NEW
export const isCurrentlyRateLimited = () => isRateLimited;

// Helper function to clear rate limit state (for testing) - NEW
export const clearRateLimit = () => {
  isRateLimited = false;
  if (rateLimitTimeout) {
    clearTimeout(rateLimitTimeout);
    rateLimitTimeout = null;
  }
  retryQueue = [];
};

export default api;

================
File: src/utils/jobService.js
================
// src/utils/jobService.js - Updated with Analysis Status Polling
import api from './axios';

const jobService = {
  // Create a new job
  createJob: async (jobData) => {
    try {
      const response = await api.post('/jobs', jobData);
      return response.data;
    } catch (error) {
      console.error('Error creating job:', error);
      throw error;
    }
  },

  // Get all user jobs
  getUserJobs: async () => {
    try {
      const response = await api.get('/jobs');
      return response.data.jobs;
    } catch (error) {
      console.error('Error fetching user jobs:', error);
      throw error;
    }
  },

  // Alias for backward compatibility
  getAllJobs: async () => {
    try {
      const response = await api.get('/jobs');
      return response.data.jobs;
    } catch (error) {
      console.error('Error fetching user jobs:', error);
      throw error;
    }
  },

  // Get job by ID
  getJobById: async (jobId) => {
    try {
      const response = await api.get(`/jobs/${jobId}`);
      return response.data.job;
    } catch (error) {
      console.error('Error fetching job:', error);
      throw error;
    }
  },

  // Get job analysis status
  getJobAnalysisStatus: async (jobId) => {
    try {
      const response = await api.get(`/jobs/analysis-status/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching job analysis status:', error);
      throw error;
    }
  },

  pollJobAnalysisStatus: async (jobId, onProgress = null, maxAttempts = 30) => {
    let attempts = 0;
    
    while (attempts < maxAttempts) {
      try {
        console.log(`📊 Polling attempt ${attempts + 1} for job ${jobId}`);
        
        const statusData = await jobService.getJobAnalysisStatus(jobId);
        const { analysisStatus } = statusData;
        
        console.log(`📊 Status: ${analysisStatus.status} (${analysisStatus.progress}%) - ${analysisStatus.message}`);
        
        // Call progress callback if provided
        if (onProgress) {
          onProgress(analysisStatus);
        }
        
        // Check if analysis is complete
        if (analysisStatus.status === 'completed' || analysisStatus.status === 'error') {
          console.log(`✅ Polling completed for job ${jobId}: ${analysisStatus.status}`);
          return statusData;
        }
        
        // Wait before next poll (2 seconds)
        await new Promise(resolve => setTimeout(resolve, 2000));
        attempts++;
        
      } catch (error) {
        console.error(`❌ Error polling job analysis status (attempt ${attempts + 1}):`, error);
        attempts++;
        
        // Wait a bit longer on error
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }
    
    // Timeout reached
    console.error(`⏰ Analysis status polling timed out for job ${jobId}`);
    throw new Error('Analysis status polling timed out');
  },

  // NEW: Check if job can be viewed (analysis complete)
  canJobBeViewed: async (jobId) => {
    try {
      const statusData = await jobService.getJobAnalysisStatus(jobId);
      return statusData.analysisStatus.canViewJob;
    } catch (error) {
      console.error('Error checking if job can be viewed:', error);
      return false;
    }
  },

  // Get resume match status for a specific job
  getResumeMatchStatus: async (jobId) => {
    try {
      const response = await api.get(`/jobs/${jobId}/resume-match-status`);
      return response.data;
    } catch (error) {
      console.error('Error fetching resume match status:', error);
      throw error;
    }
  },

  // Update job
  updateJob: async (jobId, jobData) => {
    try {
      const response = await api.put(`/jobs/${jobId}`, jobData);
      return response.data;
    } catch (error) {
      console.error('Error updating job:', error);
      throw error;
    }
  },

  // Delete job
  deleteJob: async (jobId) => {
    try {
      const response = await api.delete(`/jobs/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting job:', error);
      throw error;
    }
  },

  // Enhanced match resume with job (now returns detailed analysis)
  matchResumeWithJob: async (jobId, resumeId) => {
    try {
      const response = await api.post(`/jobs/match/${jobId}/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error matching resume with job:', error);
      throw error;
    }
  },

  // Get tailoring recommendations
  getTailoringRecommendations: async (jobId, resumeId) => {
    try {
      const response = await api.post(`/jobs/tailor/${jobId}/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error getting tailoring recommendations:', error);
      throw error;
    }
  },

  // Re-analyze a job with updated AI algorithm
  reAnalyzeJob: async (jobId) => {
    try {
      const response = await api.post(`/jobs/re-analyze/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error re-analyzing job:', error);
      throw error;
    }
  },

  // Get job analysis insights and statistics
  getJobAnalysisInsights: async () => {
    try {
      const response = await api.get('/jobs/analysis-insights');
      return response.data;
    } catch (error) {
      console.error('Error fetching job analysis insights:', error);
      throw error;
    }
  },

  // Bulk match resume against multiple jobs
  bulkMatchResume: async (resumeId, jobIds) => {
    try {
      const response = await api.post(`/jobs/bulk-match/${resumeId}`, { jobIds });
      return response.data;
    } catch (error) {
      console.error('Error bulk matching resume:', error);
      throw error;
    }
  },

  // Enhanced: Find jobs with AI (now with better error handling and status)
  findJobsWithAi: async (resumeId) => {
    try {
      const response = await api.post(`/jobs/find-with-ai/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error finding jobs with AI:', error);
      throw error;
    }
  },

  // AI Job Search Management
  getAiSearches: async () => {
    try {
      const response = await api.get('/jobs/ai-searches');
      return response.data.searches;
    } catch (error) {
      console.error('Error fetching AI searches:', error);
      throw error;
    }
  },

  pauseAiSearch: async (searchId) => {
    try {
      const response = await api.post(`/jobs/ai-search/${searchId}/pause`);
      return response.data;
    } catch (error) {
      console.error('Error pausing AI search:', error);
      throw error;
    }
  },

  resumeAiSearch: async (searchId) => {
    try {
      const response = await api.post(`/jobs/ai-search/${searchId}/resume`);
      return response.data;
    } catch (error) {
      console.error('Error resuming AI search:', error);
      throw error;
    }
  },

  deleteAiSearch: async (searchId) => {
    try {
      const response = await api.delete(`/jobs/ai-search/${searchId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting AI search:', error);
      throw error;
    }
  },

  // Get detailed match history for a job
  getMatchHistory: async (jobId) => {
    try {
      const response = await api.get(`/jobs/match-history/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching match history:', error);
      throw error;
    }
  },

  // Analyze job description text (for manual job entry)
  analyzeJobDescription: async (jobId) => {
    try {
      const response = await api.post(`/jobs/analyze/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error analyzing job description:', error);
      throw error;
    }
  },

  // Get job matching trends and analytics
  getMatchingTrends: async (timeframe = '30d') => {
    try {
      const response = await api.get(`/jobs/trends?timeframe=${timeframe}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching matching trends:', error);
      throw error;
    }
  },

  // Re-match job with best available resume
  rematchJobWithBestResume: async (jobId) => {
    try {
      const response = await api.post(`/jobs/rematch-best/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error re-matching job:', error);
      throw error;
    }
  },

  // UTILITY: Check if job analysis is complete
  isJobAnalysisComplete: (job) => {
    return job && 
           job.analysisStatus && 
           job.analysisStatus.status === 'completed' &&
           job.parsedData && 
           Object.keys(job.parsedData).length > 0 && 
           !job.parsedData.analysisError;
  },

  // UTILITY: Check if job has match analysis
  hasMatchAnalysis: (job) => {
    return job && 
           job.matchAnalysis && 
           job.matchAnalysis.overallScore !== undefined;
  },

  // UTILITY: Get match quality description
  getMatchQualityDescription: (score) => {
    if (score >= 85) return { label: 'Excellent', color: 'success' };
    if (score >= 70) return { label: 'Good', color: 'info' };
    if (score >= 55) return { label: 'Fair', color: 'warning' };
    return { label: 'Needs Work', color: 'error' };
  },

  // UTILITY: Get analysis status description
  getAnalysisStatusDescription: (status) => {
    switch (status) {
      case 'pending':
        return { label: 'Queued', color: 'info', icon: 'HourglassEmpty' };
      case 'analyzing':
        return { label: 'Analyzing', color: 'primary', icon: 'AutoAwesome' };
      case 'completed':
        return { label: 'Complete', color: 'success', icon: 'CheckCircle' };
      case 'error':
        return { label: 'Failed', color: 'error', icon: 'Error' };
      default:
        return { label: 'Unknown', color: 'default', icon: 'Help' };
    }
  },

  // UTILITY: Format skill importance level
  getSkillImportanceLabel: (importance) => {
    if (importance >= 9) return 'Critical';
    if (importance >= 7) return 'Very Important';
    if (importance >= 5) return 'Important';
    if (importance >= 3) return 'Nice to Have';
    return 'Optional';
  },

  // UTILITY: Extract skill name safely
  getSkillName: (skill) => {
    if (typeof skill === 'string') {
      return skill;
    }
    if (skill && typeof skill === 'object') {
      return skill.name || skill.skill || 'Unknown Skill';
    }
    return 'Unknown Skill';
  },

  // NEW: Create job with status tracking
  createJobWithStatusTracking: async (jobData, onProgress = null) => {
    try {
      // Create the job
      const createResponse = await jobService.createJob(jobData);
      const jobId = createResponse.job.id;
      
      // Start polling for status if callback provided
      if (onProgress) {
        setTimeout(() => {
          jobService.pollJobAnalysisStatus(jobId, onProgress).catch(error => {
            console.error('Error polling job status:', error);
            onProgress({
              status: 'error',
              message: 'Status polling failed',
              progress: 0
            });
          });
        }, 1000);
      }
      
      return createResponse;
    } catch (error) {
      console.error('Error creating job with status tracking:', error);
      throw error;
    }
  }
};

export default jobService;

================
File: src/utils/recruiterService.js
================
// frontend/src/utils/recruiterService.js - COMPLETE UPDATED VERSION
import api from './axios';

const recruiterService = {
  // ===================================================================
  // RECRUITER SEARCH & DISCOVERY
  // ===================================================================

  /**
   * Search recruiters with advanced filtering
   */
  searchRecruiters: async (filters = {}) => {
    try {
      const {
        query = '',
        company = '',
        industry = '',
        location = '',
        title = '',
        experienceMin = '',
        experienceMax = '',
        experience_min = '', // Support both formats
        experience_max = '', // Support both formats
        limit = 20,
        offset = 0,
        sortBy = 'last_active_date',
        sortOrder = 'DESC',
        sort_by = '', // Support both formats
        sort_order = '' // Support both formats
      } = filters;

      console.log('🔍 Searching recruiters with filters:', filters);

      const params = new URLSearchParams();
      if (query) params.append('query', query);
      if (company) params.append('company', company);
      if (industry) params.append('industry', industry);
      if (location) params.append('location', location);
      if (title) params.append('title', title);
      if (experienceMin || experience_min) params.append('experience_min', experienceMin || experience_min);
      if (experienceMax || experience_max) params.append('experience_max', experienceMax || experience_max);
      params.append('limit', limit);
      params.append('offset', offset);
      params.append('sort_by', sort_by || sortBy);
      params.append('sort_order', sort_order || sortOrder);

      const response = await api.get(`/recruiters/search?${params}`);
      
      console.log(`✅ Found ${response.data.recruiters.length} recruiters`);
      return response.data;

    } catch (error) {
      console.error('Search recruiters error:', error);
      throw error;
    }
  },

  /**
   * Get recruiter details by ID
   */
  getRecruiterDetails: async (recruiterId) => {
    try {
      console.log(`👤 Fetching details for recruiter ${recruiterId}`);
      const response = await api.get(`/recruiters/${recruiterId}`);
      
      console.log(`✅ Retrieved recruiter: ${response.data.recruiter.fullName}`);
      return response.data;

    } catch (error) {
      console.error('Get recruiter details error:', error);
      throw error;
    }
  },

  // Alias for compatibility with components
  getRecruiterById: async (recruiterId) => {
    return await recruiterService.getRecruiterDetails(recruiterId);
  },

  /**
   * Get filter options for search
   */
  getFilterOptions: async () => {
    try {
      console.log('📊 Fetching filter options');
      const response = await api.get('/recruiters/filters');
      
      console.log('✅ Retrieved filter options');
      return response.data;

    } catch (error) {
      console.error('Get filter options error:', error);
      throw error;
    }
  },

  // ===================================================================
  // OUTREACH MANAGEMENT
  // ===================================================================

  /**
   * Create outreach campaign
   */
  createOutreach: async (outreachData) => {
    try {
      const {
        recruiterId,
        jobId,
        messageContent,
        messageTemplate,
        sentVia = 'linkedin',
        customizations = []
      } = outreachData;

      console.log(`📧 Creating outreach for recruiter ${recruiterId}`);

      const response = await api.post('/recruiters/outreach', {
        recruiterId,
        jobId,
        messageContent,
        messageTemplate,
        sentVia,
        customizations
      });

      console.log(`✅ Created outreach campaign: ${response.data.outreach.id}`);
      return response.data;

    } catch (error) {
      console.error('Create outreach error:', error);
      throw error;
    }
  },

  /**
   * Update outreach campaign
   */
  updateOutreach: async (outreachId, updates) => {
    try {
      console.log(`📝 Updating outreach ${outreachId}`);
      const response = await api.put(`/recruiters/outreach/${outreachId}`, updates);
      
      console.log('✅ Outreach updated successfully');
      return response.data;

    } catch (error) {
      console.error('Update outreach error:', error);
      throw error;
    }
  },

  /**
   * Delete outreach campaign
   */
  deleteOutreach: async (outreachId) => {
    try {
      console.log(`🗑️ Deleting outreach ${outreachId}`);
      const response = await api.delete(`/recruiters/outreach/${outreachId}`);
      
      console.log('✅ Outreach deleted successfully');
      return response.data;

    } catch (error) {
      console.error('Delete outreach error:', error);
      throw error;
    }
  },

  /**
   * Send outreach message
   */
  sendOutreach: async (outreachId) => {
    try {
      console.log(`📤 Sending outreach ${outreachId}`);
      const response = await api.put(`/recruiters/outreach/${outreachId}/send`);
      
      console.log('✅ Outreach sent successfully');
      return response.data;

    } catch (error) {
      console.error('Send outreach error:', error);
      throw error;
    }
  },

  /**
   * Get user's outreach campaigns
   */
  getUserOutreach: async (filters = {}) => {
    try {
      const {
        status = '',
        limit = 20,
        offset = 0
      } = filters;

      console.log('📋 Fetching user outreach campaigns');

      const params = new URLSearchParams();
      if (status) params.append('status', status);
      params.append('limit', limit);
      params.append('offset', offset);

      const response = await api.get(`/recruiters/outreach?${params}`);
      
      console.log(`✅ Retrieved ${response.data.outreaches.length} outreach campaigns`);
      return response.data;

    } catch (error) {
      console.error('Get user outreach error:', error);
      throw error;
    }
  },

  // ===================================================================
  // AI-POWERED FEATURES
  // ===================================================================

  /**
   * Generate personalized message using AI
   */
  generatePersonalizedMessage: async (messageParams) => {
    try {
      const {
        recruiterId,
        resumeId,
        jobId,
        messageType = 'introduction',
        tone = 'professional',
        customRequirements = ''
      } = messageParams;

      console.log(`🤖 Generating personalized message for recruiter ${recruiterId}`);

      const response = await api.post('/recruiters/generate-message', {
        recruiterId,
        resumeId,
        jobId,
        messageType,
        tone,
        customRequirements
      });

      console.log(`✅ Generated ${response.data.message.length} character message`);
      return response.data;

    } catch (error) {
      console.error('Generate message error:', error);
      throw error;
    }
  },

  // ===================================================================
  // ANALYTICS & REPORTING
  // ===================================================================

  /**
   * Get outreach analytics
   */
  getAnalytics: async (timeframe = '30d') => {
    try {
      console.log(`📊 Fetching outreach analytics for ${timeframe}`);
      const response = await api.get(`/recruiters/analytics?timeframe=${timeframe}`);
      
      console.log('✅ Retrieved outreach analytics');
      
      // Ensure consistent response format
      if (response.data.analytics) {
        return response.data;
      } else {
        return { analytics: response.data };
      }

    } catch (error) {
      console.error('Get analytics error:', error);
      throw error;
    }
  },

  // ===================================================================
  // UTILITY FUNCTIONS
  // ===================================================================

  /**
   * Format recruiter data for display
   */
  formatRecruiterForDisplay: (recruiter) => {
    if (!recruiter) return null;

    return {
      ...recruiter,
      displayName: recruiter.fullName || `${recruiter.firstName} ${recruiter.lastName}`,
      companyDisplay: recruiter.company?.name || 'Unknown Company',
      locationDisplay: recruiter.location ? 
        `${recruiter.location.city || ''}${recruiter.location.state ? `, ${recruiter.location.state}` : ''}${recruiter.location.country ? `, ${recruiter.location.country}` : ''}`.replace(/^, /, '') :
        'Location not specified',
      experienceDisplay: recruiter.experienceYears ? 
        `${recruiter.experienceYears} year${recruiter.experienceYears !== 1 ? 's' : ''} experience` :
        'Experience not specified',
      lastActiveDisplay: recruiter.lastActiveDate ? 
        new Date(recruiter.lastActiveDate).toLocaleDateString() :
        'Last active not specified',
      hasContactInfo: !!(recruiter.email || recruiter.phone || recruiter.linkedinUrl),
      hasBeenContacted: recruiter.outreach?.hasContacted || false,
      outreachStatus: recruiter.outreach?.status || 'not_contacted'
    };
  },

  /**
   * Format outreach campaign for display
   */
  formatOutreachForDisplay: (outreach) => {
    if (!outreach) return null;

    return {
      ...outreach,
      recruiterDisplay: outreach.recruiter?.name || 'Unknown Recruiter',
      companyDisplay: outreach.recruiter?.company?.name || 'Unknown Company',
      statusDisplay: outreach.status.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase()),
      createdDisplay: new Date(outreach.createdAt).toLocaleDateString(),
      sentDisplay: outreach.sentAt ? new Date(outreach.sentAt).toLocaleDateString() : null,
      messagePreview: outreach.messageContent.length > 100 ? 
        outreach.messageContent.substring(0, 100) + '...' :
        outreach.messageContent,
      canSend: outreach.status === 'drafted',
      canEdit: outreach.status === 'drafted',
      hasReplies: outreach.repliesCount > 0,
      hasFollowUps: outreach.followUpsCount > 0
    };
  },

  /**
   * Validate outreach data before sending
   */
  validateOutreachData: (outreachData) => {
    const errors = [];

    if (!outreachData.recruiterId) {
      errors.push('Recruiter selection is required');
    }

    if (!outreachData.messageContent || outreachData.messageContent.trim().length < 10) {
      errors.push('Message content must be at least 10 characters');
    }

    if (outreachData.messageContent && outreachData.messageContent.length > 2000) {
      errors.push('Message content must be less than 2000 characters');
    }

    if (!['email', 'linkedin', 'phone', 'other'].includes(outreachData.sentVia)) {
      errors.push('Invalid communication method');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Get default message templates
   */
  getMessageTemplates: () => {
    return {
      introduction: {
        name: 'Introduction',
        description: 'Initial outreach to introduce yourself',
        defaultTone: 'professional',
        suggestedLength: '150-250 words'
      },
      follow_up: {
        name: 'Follow Up',
        description: 'Follow up on previous communication',
        defaultTone: 'friendly',
        suggestedLength: '100-200 words'
      },
      application: {
        name: 'Job Application',
        description: 'Express interest in a specific position',
        defaultTone: 'professional',
        suggestedLength: '200-300 words'
      },
      thank_you: {
        name: 'Thank You',
        description: 'Thank recruiter for their time or assistance',
        defaultTone: 'grateful',
        suggestedLength: '75-150 words'
      }
    };
  },

  /**
   * Get available tone options
   */
  getToneOptions: () => {
    return [
      { value: 'professional', label: 'Professional', description: 'Formal and business-appropriate' },
      { value: 'friendly', label: 'Friendly', description: 'Warm and approachable' },
      { value: 'casual', label: 'Casual', description: 'Relaxed and conversational' },
      { value: 'formal', label: 'Formal', description: 'Very structured and traditional' }
    ];
  },

  /**
   * Get experience level filters
   */
  getExperienceLevels: () => {
    return [
      { value: '0-2', label: '0-2 years', min: 0, max: 2 },
      { value: '3-5', label: '3-5 years', min: 3, max: 5 },
      { value: '6-10', label: '6-10 years', min: 6, max: 10 },
      { value: '11-15', label: '11-15 years', min: 11, max: 15 },
      { value: '16+', label: '16+ years', min: 16, max: 50 }
    ];
  },

  /**
   * Calculate outreach success metrics
   */
  calculateSuccessMetrics: (outreaches) => {
    if (!outreaches || outreaches.length === 0) {
      return {
        totalSent: 0,
        responseRate: 0,
        averageResponseTime: 0,
        topPerformingTemplate: null,
        engagementScore: 0
      };
    }

    const sent = outreaches.filter(o => ['sent', 'delivered', 'opened', 'replied'].includes(o.status));
    const replied = outreaches.filter(o => o.status === 'replied');
    
    const responseRate = sent.length > 0 ? (replied.length / sent.length) * 100 : 0;
    
    // Calculate template performance
    const templateStats = {};
    outreaches.forEach(outreach => {
      const template = outreach.messageTemplate || 'custom';
      if (!templateStats[template]) {
        templateStats[template] = { total: 0, replied: 0 };
      }
      templateStats[template].total++;
      if (outreach.status === 'replied') {
        templateStats[template].replied++;
      }
    });

    const topTemplate = Object.entries(templateStats)
      .map(([template, stats]) => ({
        template,
        responseRate: stats.total > 0 ? (stats.replied / stats.total) * 100 : 0,
        total: stats.total
      }))
      .sort((a, b) => b.responseRate - a.responseRate)[0];

    return {
      totalSent: sent.length,
      totalReplies: replied.length,
      responseRate: Math.round(responseRate * 100) / 100,
      topPerformingTemplate: topTemplate?.template || null,
      topPerformingRate: topTemplate?.responseRate || 0,
      engagementScore: Math.round(responseRate * 2) // Simple engagement calculation
    };
  },

  /**
   * Export outreach data for external use
   */
  exportOutreachData: async (format = 'csv', filters = {}) => {
    try {
      console.log(`📤 Exporting outreach data in ${format} format`);
      
      const outreachData = await recruiterService.getUserOutreach({
        ...filters,
        limit: 1000 // Get all data for export
      });

      if (format === 'csv') {
        return recruiterService.convertToCSV(outreachData.outreaches);
      } else if (format === 'json') {
        return JSON.stringify(outreachData.outreaches, null, 2);
      }

      throw new Error('Unsupported export format');

    } catch (error) {
      console.error('Export outreach data error:', error);
      throw error;
    }
  },

  /**
   * Convert outreach data to CSV format
   */
  convertToCSV: (outreaches) => {
    if (!outreaches || outreaches.length === 0) {
      return 'No data to export';
    }

    const headers = [
      'Recruiter Name',
      'Company',
      'Email',
      'Status',
      'Message Type',
      'Sent Via',
      'Created Date',
      'Sent Date',
      'Replies Count',
      'Message Preview'
    ];

    const rows = outreaches.map(outreach => [
      outreach.recruiter?.name || 'Unknown',
      outreach.recruiter?.company?.name || 'Unknown',
      outreach.recruiter?.email || '',
      outreach.status,
      outreach.messageTemplate || 'custom',
      outreach.sentVia,
      new Date(outreach.createdAt).toLocaleDateString(),
      outreach.sentAt ? new Date(outreach.sentAt).toLocaleDateString() : '',
      outreach.repliesCount || 0,
      outreach.messageContent.substring(0, 100) + '...'
    ]);

    const csvContent = [headers, ...rows]
      .map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
      .join('\n');

    return csvContent;
  },

  /**
   * Get intelligent recommendations for message improvements
   */
  getMessageRecommendations: (messageContent, recruiterData, userContext = {}) => {
    const recommendations = [];
    const content = messageContent.toLowerCase();

    // Length recommendations
    if (messageContent.length < 50) {
      recommendations.push({
        type: 'length',
        severity: 'warning',
        message: 'Message is quite short. Consider adding more context about your background or interest.'
      });
    } else if (messageContent.length > 1500) {
      recommendations.push({
        type: 'length',
        severity: 'warning',
        message: 'Message is quite long. Consider shortening it for better readability.'
      });
    }

    // Personalization recommendations
    if (!content.includes(recruiterData.firstName?.toLowerCase()) && 
        !content.includes(recruiterData.company?.name?.toLowerCase())) {
      recommendations.push({
        type: 'personalization',
        severity: 'info',
        message: 'Consider mentioning the recruiter\'s name or company for better personalization.'
      });
    }

    // Call-to-action recommendations
    if (!content.includes('would love to') && 
        !content.includes('would like to') && 
        !content.includes('schedule') && 
        !content.includes('discuss')) {
      recommendations.push({
        type: 'call_to_action',
        severity: 'info',
        message: 'Consider adding a clear call-to-action like "Would love to schedule a brief call".'
      });
    }

    // Subject matter recommendations
    if (userContext.targetRole && !content.includes(userContext.targetRole.toLowerCase())) {
      recommendations.push({
        type: 'relevance',
        severity: 'info',
        message: `Consider mentioning your target role (${userContext.targetRole}) to show clear intent.`
      });
    }

    return recommendations;
  }
};

export default recruiterService;

================
File: src/utils/resumeService.js
================
// src/utils/resumeService.js
import api from './axios';

const resumeService = {
  // Get all resumes for the user
  getUserResumes: async () => {
    try {
      const response = await api.get('/resumes');
      return response.data.resumes || [];
    } catch (error) {
      console.error('Error fetching resumes:', error);
      throw error;
    }
  },
  
  // Get a specific resume by ID
  getResumeById: async (resumeId) => {
    try {
      const response = await api.get(`/resumes/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching resume:', error);
      throw error;
    }
  },
  
  // Upload a new resume
  uploadResume: async (formData) => {
    try {
      const response = await api.post('/resumes/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading resume:', error);
      throw error;
    }
  },
  
  // Check resume processing status
  checkResumeStatus: async (resumeId) => {
    try {
      const response = await api.get(`/resumes/status/${resumeId}`);
      return response.data.processingStatus;
    } catch (error) {
      console.error('Error checking resume status:', error);
      throw error;
    }
  },
  
  // Poll resume status until completion or timeout
  pollResumeStatus: async (resumeId, onProgress, timeout = 300000) => {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const interval = 2000; // Poll every 2 seconds
      
      const checkStatus = async () => {
        try {
          if (Date.now() - startTime > timeout) {
            clearInterval(pollInterval);
            reject(new Error('Resume processing timed out'));
            return;
          }
          
          const status = await resumeService.checkResumeStatus(resumeId);
          
          if (onProgress) onProgress(status);
          
          if (status.status === 'completed') {
            clearInterval(pollInterval);
            resolve(status);
          }
          
          if (status.status === 'error') {
            clearInterval(pollInterval);
            reject(new Error(status.error || 'Processing failed'));
          }
        } catch (error) {
          console.error('Error polling status:', error);
        }
      };
      
      const pollInterval = setInterval(checkStatus, interval);
      checkStatus(); // Immediate first check
    });
  },
  
  // Analyze a resume
  analyzeResume: async (resumeId) => {
    try {
      const response = await api.post(`/resumes/analyze/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error analyzing resume:', error);
      throw error;
    }
  },
  
  // Add a new version to an existing resume
  addResumeVersion: async (resumeId, formData) => {
    try {
      const response = await api.post(`/resumes/versions/${resumeId}`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error adding resume version:', error);
      throw error;
    }
  },
  
  // Create a tailored resume
  createTailoredResume: async (resumeId, jobId, options = {}) => {
    try {
      const response = await api.post(`/resumes/tailor/${resumeId}/${jobId}`, options);
      return response.data;
    } catch (error) {
      console.error('Error creating tailored resume:', error);
      throw error;
    }
  },
  
  // Delete a resume
  deleteResume: async (resumeId) => {
    try {
      const response = await api.delete(`/resumes/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting resume:', error);
      throw error;
    }
  }
};

export default resumeService;

================
File: src/utils/searchService.js
================
// src/utils/searchService.js
import api from './axios';

const searchService = {
  /**
   * Global search across all content types
   */
  globalSearch: async (query, options = {}) => {
    try {
      const {
        category = 'all',
        limit = 20,
        includeContent = false
      } = options;

      if (!query || query.trim().length < 2) {
        return {
          success: false,
          error: 'Search query must be at least 2 characters long'
        };
      }

      console.log(`🔍 Searching for: "${query}" in category: ${category}`);

      const params = new URLSearchParams();
      params.append('query', query.trim());
      params.append('category', category);
      params.append('limit', limit);
      if (includeContent) params.append('includeContent', 'true');

      const response = await api.get(`/search?${params}`);
      
      console.log(`✅ Search completed: ${response.data.data.results.totalCount} results`);
      return response.data;

    } catch (error) {
      console.error('Global search error:', error);
      throw error;
    }
  },

  /**
   * Get search suggestions as user types
   */
  getSuggestions: async (query, limit = 5) => {
    try {
      if (!query || query.length < 2) {
        return { suggestions: [] };
      }

      const params = new URLSearchParams();
      params.append('query', query);
      params.append('limit', limit);

      const response = await api.get(`/search/suggestions?${params}`);
      return response.data.data;

    } catch (error) {
      console.error('Get suggestions error:', error);
      return { suggestions: [] };
    }
  },

  /**
   * Get popular searches
   */
  getPopularSearches: async () => {
    try {
      const response = await api.get('/search/popular');
      return response.data.data;
    } catch (error) {
      console.error('Get popular searches error:', error);
      return { searches: [] };
    }
  },

  /**
   * Search specific category with custom parameters
   */
  searchJobs: async (query, options = {}) => {
    try {
      const result = await searchService.globalSearch(query, {
        ...options,
        category: 'jobs'
      });
      return result.data?.results?.jobs || [];
    } catch (error) {
      console.error('Search jobs error:', error);
      return [];
    }
  },

  searchResumes: async (query, options = {}) => {
    try {
      const result = await searchService.globalSearch(query, {
        ...options,
        category: 'resumes'
      });
      return result.data?.results?.resumes || [];
    } catch (error) {
      console.error('Search resumes error:', error);
      return [];
    }
  },

  searchRecruiters: async (query, options = {}) => {
    try {
      const result = await searchService.globalSearch(query, {
        ...options,
        category: 'recruiters'
      });
      return result.data?.results?.recruiters || [];
    } catch (error) {
      console.error('Search recruiters error:', error);
      return [];
    }
  },

  /**
   * Format search results for display
   */
  formatSearchResults: (results) => {
    const formatted = {
      all: [],
      jobs: [],
      resumes: [],
      recruiters: [],
      totalCount: 0
    };

    if (!results) return formatted;

    // Combine all results for 'all' category view
    const allResults = [
      ...(results.jobs || []),
      ...(results.resumes || []),
      ...(results.recruiters || [])
    ];

    // Sort all results by relevance/date
    allResults.sort((a, b) => {
      // Prioritize by type relevance, then by date
      const typeOrder = { job: 0, resume: 1, recruiter: 2 };
      if (typeOrder[a.type] !== typeOrder[b.type]) {
        return typeOrder[a.type] - typeOrder[b.type];
      }
      return new Date(b.createdAt || b.lastActiveDate) - new Date(a.createdAt || a.lastActiveDate);
    });

    formatted.all = allResults;
    formatted.jobs = results.jobs || [];
    formatted.resumes = results.resumes || [];
    formatted.recruiters = results.recruiters || [];
    formatted.totalCount = results.totalCount || 0;

    return formatted;
  },

  /**
   * Get result type icon and color
   */
  getResultTypeDisplay: (type) => {
    const displays = {
      job: {
        icon: 'Work',
        color: '#4285f4',
        label: 'Job'
      },
      resume: {
        icon: 'Description',
        color: '#34a853',
        label: 'Resume'
      },
      recruiter: {
        icon: 'Person',
        color: '#00c4b4',
        label: 'Recruiter'
      }
    };

    return displays[type] || {
      icon: 'Search',
      color: '#666',
      label: 'Unknown'
    };
  },

  /**
   * Highlight search terms in text
   */
  highlightSearchTerms: (text, searchQuery) => {
    if (!text || !searchQuery) return text;

    const regex = new RegExp(`(${searchQuery.split(' ').join('|')})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  },

  /**
   * Get search categories for filtering
   */
  getSearchCategories: () => {
    return [
      { value: 'all', label: 'All Results', icon: 'Search' },
      { value: 'jobs', label: 'Jobs', icon: 'Work' },
      { value: 'resumes', label: 'Resumes', icon: 'Description' },
      { value: 'recruiters', label: 'Recruiters', icon: 'Person' }
    ];
  },

  /**
   * Debounced search function
   */
  createDebouncedSearch: (callback, delay = 300) => {
    let timeoutId;
    
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => callback.apply(null, args), delay);
    };
  },

  /**
   * Save search to local storage for recent searches
   */
  saveRecentSearch: (query, results) => {
    try {
      const recentSearches = searchService.getRecentSearches();
      
      // Remove if already exists
      const filtered = recentSearches.filter(search => 
        search.query.toLowerCase() !== query.toLowerCase()
      );
      
      // Add to beginning
      filtered.unshift({
        query,
        timestamp: new Date().toISOString(),
        resultCount: results.totalCount || 0
      });
      
      // Keep only last 10 searches
      const limited = filtered.slice(0, 10);
      
      localStorage.setItem('recentSearches', JSON.stringify(limited));
    } catch (error) {
      console.error('Save recent search error:', error);
    }
  },

  /**
   * Get recent searches from local storage
   */
  getRecentSearches: () => {
    try {
      const stored = localStorage.getItem('recentSearches');
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Get recent searches error:', error);
      return [];
    }
  },

  /**
   * Clear recent searches
   */
  clearRecentSearches: () => {
    try {
      localStorage.removeItem('recentSearches');
    } catch (error) {
      console.error('Clear recent searches error:', error);
    }
  },

  /**
   * Validate search query
   */
  validateSearchQuery: (query) => {
    const errors = [];
    
    if (!query || query.trim().length === 0) {
      errors.push('Search query cannot be empty');
    }
    
    if (query && query.trim().length < 2) {
      errors.push('Search query must be at least 2 characters long');
    }
    
    if (query && query.length > 100) {
      errors.push('Search query must be less than 100 characters');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Get search keyboard shortcuts
   */
  getKeyboardShortcuts: () => {
    return {
      openSearch: ['/', 'Ctrl+K', 'Cmd+K'],
      closeSearch: ['Escape'],
      navigateResults: ['ArrowUp', 'ArrowDown'],
      selectResult: ['Enter'],
      nextCategory: ['Tab'],
      previousCategory: ['Shift+Tab']
    };
  }
};

export default searchService;

================
File: src/utils/settingsService.js
================
// src/utils/settingsService.js
import api from './axios';

const settingsService = {
  /**
   * Get user profile information
   */
  getProfile: async () => {
    try {
      console.log('📋 Fetching user profile...');
      const response = await api.get('/settings/profile');
      console.log('✅ Profile fetched successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Get profile error:', error);
      throw error;
    }
  },

  /**
   * Update user profile information
   */
  updateProfile: async (profileData) => {
    try {
      console.log('📝 Updating user profile...', profileData);
      const response = await api.put('/settings/profile', profileData);
      console.log('✅ Profile updated successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Update profile error:', error);
      throw error;
    }
  },

  /**
   * Change user password
   */
  changePassword: async (passwordData) => {
    try {
      console.log('🔒 Changing password...');
      const response = await api.put('/settings/change-password', passwordData);
      console.log('✅ Password changed successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Change password error:', error);
      throw error;
    }
  },

  /**
   * Delete user account
   */
  deleteAccount: async (confirmationData = {}) => {
    try {
      console.log('🗑️ Deleting account...');
      const response = await api.delete('/settings/delete-account', {
        data: confirmationData
      });
      console.log('✅ Account deleted successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Delete account error:', error);
      throw error;
    }
  },

  /**
   * Send email verification
   */
  sendVerificationEmail: async () => {
    try {
      console.log('📧 Sending verification email...');
      const response = await api.post('/settings/send-verification-email');
      console.log('✅ Verification email sent');
      return response.data;
    } catch (error) {
      console.error('❌ Send verification email error:', error);
      throw error;
    }
  },

  /**
   * Verify email address
   */
  verifyEmail: async (token) => {
    try {
      console.log('✉️ Verifying email...');
      const response = await api.get(`/settings/verify-email/${token}`);
      console.log('✅ Email verified successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Verify email error:', error);
      throw error;
    }
  },

  /**
   * Validate profile data before submission
   */
  validateProfileData: (profileData) => {
    const errors = [];

    // Required fields
    if (!profileData.firstName?.trim()) {
      errors.push('First name is required');
    }

    if (!profileData.lastName?.trim()) {
      errors.push('Last name is required');
    }

    if (!profileData.email?.trim()) {
      errors.push('Email address is required');
    }

    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (profileData.email && !emailRegex.test(profileData.email)) {
      errors.push('Please enter a valid email address');
    }

    // Phone number validation (optional)
    if (profileData.phoneNumber) {
      const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/;
      if (!phoneRegex.test(profileData.phoneNumber.replace(/\D/g, ''))) {
        errors.push('Please enter a valid phone number');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Validate password data before submission
   */
  validatePasswordData: (passwordData) => {
    const errors = [];

    if (!passwordData.currentPassword) {
      errors.push('Current password is required');
    }

    if (!passwordData.newPassword) {
      errors.push('New password is required');
    }

    if (!passwordData.confirmPassword) {
      errors.push('Please confirm your new password');
    }

    if (passwordData.newPassword && passwordData.newPassword.length < 8) {
      errors.push('New password must be at least 8 characters long');
    }

    if (passwordData.newPassword && passwordData.confirmPassword && 
        passwordData.newPassword !== passwordData.confirmPassword) {
      errors.push('New passwords do not match');
    }

    if (passwordData.currentPassword && passwordData.newPassword && 
        passwordData.currentPassword === passwordData.newPassword) {
      errors.push('New password must be different from current password');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Calculate password strength
   */
  calculatePasswordStrength: (password) => {
    if (!password) return { strength: 0, label: '', color: 'default' };

    let score = 0;
    const checks = {
      length: password.length >= 8,
      lowercase: /[a-z]/.test(password),
      uppercase: /[A-Z]/.test(password),
      numbers: /\d/.test(password),
      symbols: /[^A-Za-z0-9]/.test(password)
    };

    // Calculate score
    Object.values(checks).forEach(check => {
      if (check) score += 20;
    });

    // Bonus for length
    if (password.length >= 12) score += 10;
    if (password.length >= 16) score += 10;

    // Determine strength level
    let strength, label, color;
    if (score < 40) {
      strength = score;
      label = 'Weak';
      color = 'error';
    } else if (score < 60) {
      strength = score;
      label = 'Fair';
      color = 'warning';
    } else if (score < 80) {
      strength = score;
      label = 'Good';
      color = 'info';
    } else {
      strength = Math.min(score, 100);
      label = 'Strong';
      color = 'success';
    }

    return { strength, label, color, checks };
  },

  /**
   * Format phone number for display
   */
  formatPhoneNumber: (phoneNumber) => {
    if (!phoneNumber) return '';
    
    // Remove all non-digit characters
    const digits = phoneNumber.replace(/\D/g, '');
    
    // Format US phone numbers
    if (digits.length === 10) {
      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
    } else if (digits.length === 11 && digits[0] === '1') {
      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
    }
    
    // Return original if can't format
    return phoneNumber;
  },

  /**
   * Get error message from API response
   */
  getErrorMessage: (error) => {
    if (error.response?.data?.error) {
      return error.response.data.error;
    } else if (error.response?.data?.message) {
      return error.response.data.message;
    } else if (error.message) {
      return error.message;
    } else {
      return 'An unexpected error occurred';
    }
  },

  /**
   * Check if email verification is needed
   */
  needsEmailVerification: (user) => {
    return user && !user.isEmailVerified;
  },

  /**
   * Calculate profile completion percentage
   */
  calculateProfileCompletion: (user) => {
    if (!user) return 0;

    const fields = [
      user.firstName,
      user.lastName,
      user.email,
      user.phoneNumber
    ];

    const completedFields = fields.filter(field => field && field.trim()).length;
    return Math.round((completedFields / fields.length) * 100);
  },

  /**
   * Get account security score
   */
  getSecurityScore: (user) => {
    if (!user) return 0;

    let score = 0;
    const maxScore = 100;

    // Email verification (40 points)
    if (user.isEmailVerified) score += 40;

    // Profile completeness (30 points)
    const completionPercentage = settingsService.calculateProfileCompletion(user);
    score += (completionPercentage / 100) * 30;

    // Account age (15 points)
    if (user.createdAt) {
      const accountAge = Date.now() - new Date(user.createdAt).getTime();
      const daysOld = accountAge / (1000 * 60 * 60 * 24);
      if (daysOld > 30) score += 15;
      else score += (daysOld / 30) * 15;
    }

    // Phone number (15 points)
    if (user.phoneNumber) score += 15;

    return Math.min(Math.round(score), maxScore);
  }
};

export default settingsService;

================
File: frontend/src/App.js
================
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import { AiAssistantProvider } from './context/AiAssistantContext';
import ThemeProvider from './ThemeProvider';
import ProtectedRoute from './components/auth/ProtectedRoute';
import Login from './components/auth/Login';
import Register from './components/auth/Register';
import ForgotPassword from './components/auth/ForgotPassword';
import ResetPassword from './components/auth/ResetPassword';
import EmailVerification from './components/auth/EmailVerification';
import Dashboard from './components/Dashboard';
import ResumesPage from './components/resumes/ResumesPage';
import ResumeUploadDialog from './components/resumes/ResumeUploadDialog';
import ResumeDetail from './components/resumes/ResumeDetail';

// Import job-related components
import JobsPage from './components/jobs/JobsPage';
import JobDetail from './components/jobs/JobDetail';
import ResumeTailoring from './components/jobs/ResumeTailoring';
import AiSearchesPage from './components/jobs/AiSearchesPage';

// Import recruiter-related components
import RecruiterPage from './components/recruiters/RecruiterPage';
import RecruiterDetails from './components/recruiters/RecruiterDetails';
import OutreachTracker from './components/recruiters/OutreachTracker';

// Import Settings
import SettingsPage from './components/SettingsPage';

// Import Global AI Assistant
import GlobalAiAssistant from './components/assistant/GlobalAiAssistant';

// Placeholder components for other sections
const ApplicationsPage = () => <div>Applications Page (Coming Soon)</div>;
const AISettingsPage = () => <div>AI Settings Page (Coming Soon)</div>;

function App() {
  return (
    <ThemeProvider>
      <AuthProvider>
        <Router>
          <Routes>
            {/* Public Auth Routes - NO AiAssistantProvider wrapper */}
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            <Route path="/forgot-password" element={<ForgotPassword />} />
            <Route path="/reset-password/:token" element={<ResetPassword />} />
            <Route path="/verify-email/:token" element={<EmailVerification />} />
            
            {/* Protected Routes - WITH AiAssistantProvider wrapper */}
            <Route
              path="/dashboard"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <Dashboard />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Resume Routes */}
            <Route
              path="/resumes"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumesPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/resumes/upload"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumeUploadDialog />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/resumes/:id"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumeDetail />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Job Routes */}
            <Route
              path="/jobs"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <JobsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/jobs/:id"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <JobDetail />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/jobs/:jobId/tailor/:resumeId"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ResumeTailoring />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/jobs/ai-searches"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <AiSearchesPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Recruiter Routes */}
            <Route
              path="/recruiters"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <RecruiterPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/recruiters/:id"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <RecruiterDetails />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/recruiters/outreach"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <OutreachTracker />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Settings Route */}
            <Route
              path="/settings"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <SettingsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Other Routes */}
            <Route
              path="/applications"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <ApplicationsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            <Route
              path="/ai-settings"
              element={
                <ProtectedRoute>
                  <AiAssistantProvider>
                    <AISettingsPage />
                    <GlobalAiAssistant />
                  </AiAssistantProvider>
                </ProtectedRoute>
              }
            />
            
            {/* Default Route */}
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
          </Routes>
        </Router>
      </AuthProvider>
    </ThemeProvider>
  );
}

export default App;

================
File: frontend/src/components/assistant/AiAssistantWidget.js
================
// src/components/assistant/AiAssistantWidget.js - UPDATED VERSION
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Fab,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Paper,
  TextField,
  IconButton,
  Typography,
  Avatar,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  Chip,
  Button,
  Divider,
  Slide,
  CircularProgress,
  Tooltip,
  useTheme,
  alpha
} from '@mui/material';
import {
  SmartToy as RobotIcon,
  Send as SendIcon,
  Close as CloseIcon,
  Fullscreen as FullscreenIcon,
  FullscreenExit as FullscreenExitIcon,
  Refresh as RefreshIcon,
  Description as ResumeIcon,
  Edit as EditIcon,
  AutoFixHigh as SuggestionIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
// import assistantService from '../../utils/assistantService'; // Comment out for now

const Transition = React.forwardRef(function Transition(props, ref) {
  return <Slide direction="up" ref={ref} {...props} />;
});

const AiAssistantWidget = ({ 
  resumeId = null, 
  resumeData = null, 
  onResumeUpdate = null,
  position = { bottom: 24, right: 24 },
  // NEW: Accept external open control
  externalOpen = null,
  onExternalClose = null,
  showFab = true // NEW: Control whether to show the floating button
}) => {
  const theme = useTheme();
  const { currentUser } = useAuth();
  
  // Use external open state if provided, otherwise use internal state
  const [internalOpen, setInternalOpen] = useState(false);
  const isOpen = externalOpen !== null ? externalOpen : internalOpen;
  
  const [fullscreen, setFullscreen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState('');
  const [loading, setLoading] = useState(false);
  const [sessionId, setSessionId] = useState(null);
  const [assistantTyping, setAssistantTyping] = useState(false);
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);

  // Initialize chat session
  useEffect(() => {
    if (isOpen && !sessionId) {
      initializeSession();
    }
  }, [isOpen]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const initializeSession = async () => {
    try {
      console.log('🤖 Initializing AI Assistant session...');
      
      // For now, just add a welcome message without backend call
      const welcomeMessage = {
        id: Date.now(),
        type: 'assistant',
        content: `Hi! I'm AJ, your AI career assistant. I'm here to help you optimize your resume and discuss your career goals. ${resumeData ? `I can see you're working on your resume.` : ''} How can I help you today?`,
        timestamp: new Date(),
        suggestions: [
          'Analyze my resume strengths',
          'Suggest improvements', 
          'Help with job descriptions',
          'Review my experience section'
        ]
      };
      
      setMessages([welcomeMessage]);
      setSessionId('test-session-' + Date.now()); // Temporary session ID
      
      console.log('✅ AI Assistant session initialized (test mode)');
    } catch (error) {
      console.error('❌ Failed to initialize assistant session:', error);
    }
  };

  const handleSendMessage = async () => {
    if (!inputMessage.trim() || loading) return;

    const userMessage = {
      id: Date.now(),
      type: 'user', 
      content: inputMessage.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    const currentMessage = inputMessage.trim();
    setInputMessage('');
    setLoading(true);
    setAssistantTyping(true);

    try {
      // Simulate AI response for testing
      setTimeout(() => {
        const aiResponse = {
          id: Date.now() + 1,
          type: 'assistant',
          content: `Thanks for your message: "${currentMessage}". This is a test response! In the full version, I'll analyze your resume and provide specific suggestions based on your content.`,
          timestamp: new Date(),
          suggestions: ['Tell me more', 'Analyze my experience', 'Help with skills section']
        };

        setMessages(prev => [...prev, aiResponse]);
        setLoading(false);
        setAssistantTyping(false);
      }, 1500);

    } catch (error) {
      console.error('❌ Failed to send message:', error);
      const errorMessage = {
        id: Date.now() + 1,
        type: 'assistant',
        content: 'I apologize, but I encountered an error. This is test mode - the full AI backend is not yet connected.',
        timestamp: new Date(),
        isError: true
      };
      setMessages(prev => [...prev, errorMessage]);
      setLoading(false);
      setAssistantTyping(false);
    }
  };

  const handleSuggestionClick = (suggestion) => {
    setInputMessage(suggestion);
    inputRef.current?.focus();
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleOpen = () => {
    console.log('🤖 Opening AI Assistant...');
    if (externalOpen !== null) {
      // If externally controlled, don't set internal state
      return;
    }
    setInternalOpen(true);
  };

  const handleClose = () => {
    console.log('🤖 Closing AI Assistant...');
    setFullscreen(false);
    
    if (onExternalClose) {
      onExternalClose();
    } else {
      setInternalOpen(false);
    }
  };

  const toggleFullscreen = () => {
    setFullscreen(!fullscreen);
  };

  const MessageBubble = ({ message }) => {
    const isUser = message.type === 'user';
    const isError = message.isError;

    return (
      <ListItem 
        sx={{ 
          flexDirection: isUser ? 'row-reverse' : 'row',
          alignItems: 'flex-start',
          pb: 2
        }}
      >
        <ListItemAvatar sx={{ 
          minWidth: 'auto', 
          ml: isUser ? 1 : 0, 
          mr: isUser ? 0 : 1 
        }}>
          <Avatar 
            sx={{ 
              width: 32, 
              height: 32,
              bgcolor: isUser ? theme.palette.primary.main : theme.palette.secondary.main,
              fontSize: '0.875rem'
            }}
          >
            {isUser ? currentUser?.firstName?.[0] || 'U' : <RobotIcon fontSize="small" />}
          </Avatar>
        </ListItemAvatar>
        
        <Box sx={{ 
          maxWidth: '75%',
          display: 'flex',
          flexDirection: 'column',
          alignItems: isUser ? 'flex-end' : 'flex-start'
        }}>
          <Paper
            elevation={1}
            sx={{
              p: 2,
              bgcolor: isError 
                ? alpha(theme.palette.error.main, 0.1)
                : isUser 
                  ? theme.palette.primary.main 
                  : theme.palette.background.paper,
              color: isUser ? 'white' : 'inherit',
              borderRadius: 2,
              border: isError ? `1px solid ${theme.palette.error.main}` : 'none'
            }}
          >
            <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>
              {message.content}
            </Typography>
          </Paper>

          {/* Suggestions */}
          {message.suggestions && (
            <Box sx={{ mt: 1, display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
              {message.suggestions.map((suggestion, index) => (
                <Chip
                  key={index}
                  label={suggestion}
                  size="small"
                  variant="outlined"
                  onClick={() => handleSuggestionClick(suggestion)}
                  sx={{ 
                    cursor: 'pointer',
                    '&:hover': {
                      bgcolor: alpha(theme.palette.primary.main, 0.1)
                    }
                  }}
                />
              ))}
            </Box>
          )}

          {/* Resume Edit Actions */}
          {message.resumeEdits && (
            <Box sx={{ mt: 1 }}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 1.5, 
                  bgcolor: alpha(theme.palette.success.main, 0.1),
                  border: `1px solid ${alpha(theme.palette.success.main, 0.3)}`
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                  <EditIcon fontSize="small" color="success" sx={{ mr: 1 }} />
                  <Typography variant="body2" fontWeight={500}>
                    Resume Updates Available
                  </Typography>
                </Box>
                <Button
                  size="small"
                  variant="contained"
                  color="success"
                  onClick={() => onResumeUpdate && onResumeUpdate(message.resumeEdits)}
                  startIcon={<SuggestionIcon />}
                >
                  Apply Changes
                </Button>
              </Paper>
            </Box>
          )}

          <Typography 
            variant="caption" 
            color="text.secondary" 
            sx={{ mt: 0.5 }}
          >
            {message.timestamp.toLocaleTimeString()}
          </Typography>
        </Box>
      </ListItem>
    );
  };

  const ChatInterface = () => (
    <Box sx={{ 
      height: fullscreen ? '100vh' : 500,
      display: 'flex',
      flexDirection: 'column'
    }}>
      {/* Header */}
      <Box sx={{ 
        p: 2, 
        borderBottom: `1px solid ${theme.palette.divider}`,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        bgcolor: alpha(theme.palette.primary.main, 0.05)
      }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Avatar sx={{ 
            width: 40, 
            height: 40, 
            bgcolor: theme.palette.secondary.main, 
            mr: 2 
          }}>
            <RobotIcon />
          </Avatar>
          <Box>
            <Typography variant="h6" fontWeight={600}>
              AJ Assistant
            </Typography>
            <Typography variant="caption" color="text.secondary">
              {resumeData ? `Working on your resume` : 'Ready to help with your resume'}
            </Typography>
          </Box>
        </Box>
        
        <Box>
          <Tooltip title={fullscreen ? 'Exit Fullscreen' : 'Fullscreen'}>
            <IconButton onClick={toggleFullscreen}>
              {fullscreen ? <FullscreenExitIcon /> : <FullscreenIcon />}
            </IconButton>
          </Tooltip>
          <Tooltip title="Close">
            <IconButton onClick={handleClose}>
              <CloseIcon />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>

      {/* Messages */}
      <Box sx={{ 
        flex: 1, 
        overflow: 'auto',
        bgcolor: alpha(theme.palette.background.default, 0.3)
      }}>
        <List sx={{ p: 1 }}>
          {messages.map((message) => (
            <MessageBubble key={message.id} message={message} />
          ))}
          
          {/* Typing indicator */}
          {assistantTyping && (
            <ListItem>
              <ListItemAvatar>
                <Avatar sx={{ 
                  width: 32, 
                  height: 32, 
                  bgcolor: theme.palette.secondary.main 
                }}>
                  <RobotIcon fontSize="small" />
                </Avatar>
              </ListItemAvatar>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <CircularProgress size={16} sx={{ mr: 1 }} />
                <Typography variant="body2" color="text.secondary">
                  AJ is thinking...
                </Typography>
              </Box>
            </ListItem>
          )}
          
          <div ref={messagesEndRef} />
        </List>
      </Box>

      {/* Input */}
      <Box sx={{ 
        p: 2, 
        borderTop: `1px solid ${theme.palette.divider}`,
        bgcolor: theme.palette.background.paper
      }}>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <TextField
            ref={inputRef}
            fullWidth
            multiline
            maxRows={3}
            placeholder="Ask AJ about your resume, career goals, or get editing suggestions..."
            value={inputMessage}
            onChange={(e) => setInputMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            disabled={loading}
            variant="outlined"
            size="small"
            sx={{
              '& .MuiOutlinedInput-root': {
                borderRadius: 3
              }
            }}
          />
          <IconButton
            onClick={handleSendMessage}
            disabled={!inputMessage.trim() || loading}
            color="primary"
            sx={{
              bgcolor: theme.palette.primary.main,
              color: 'white',
              '&:hover': {
                bgcolor: theme.palette.primary.dark
              },
              '&:disabled': {
                bgcolor: theme.palette.action.disabled
              }
            }}
          >
            {loading ? <CircularProgress size={20} color="inherit" /> : <SendIcon />}
          </IconButton>
        </Box>
        
        {resumeData && (
          <Box sx={{ mt: 1, display: 'flex', alignItems: 'center' }}>
            <ResumeIcon fontSize="small" color="primary" sx={{ mr: 1 }} />
            <Typography variant="caption" color="text.secondary">
              Context: Resume with {resumeData.experience?.length || 0} jobs
            </Typography>
          </Box>
        )}
      </Box>
    </Box>
  );

  return (
    <>
      {/* Floating Action Button - Only show if not externally controlled */}
      {showFab && externalOpen === null && (
        <Tooltip title="Chat with AJ - Your AI Career Assistant">
          <Fab
            color="secondary"
            onClick={handleOpen}
            sx={{
              position: 'fixed',
              bottom: position.bottom,
              right: position.right,
              zIndex: 1000,
              background: `linear-gradient(45deg, ${theme.palette.secondary.main} 30%, ${theme.palette.secondary.light} 90%)`,
              boxShadow: '0 8px 24px rgba(0, 196, 180, 0.3)',
              '&:hover': {
                background: `linear-gradient(45deg, ${theme.palette.secondary.dark} 30%, ${theme.palette.secondary.main} 90%)`,
                transform: 'scale(1.05)',
              },
              transition: 'all 0.2s ease-in-out'
            }}
          >
            <RobotIcon sx={{ fontSize: 28 }} />
          </Fab>
        </Tooltip>
      )}

      {/* Chat Dialog */}
      <Dialog
        open={isOpen}
        onClose={handleClose}
        TransitionComponent={Transition}
        maxWidth={fullscreen ? false : 'sm'}
        fullWidth
        fullScreen={fullscreen}
        PaperProps={{
          sx: {
            borderRadius: fullscreen ? 0 : 2,
            overflow: 'hidden'
          }
        }}
      >
        <ChatInterface />
      </Dialog>
    </>
  );
};

export default AiAssistantWidget;

================
File: frontend/src/components/assistant/GlobalAiAssistant.js
================
// src/components/assistant/GlobalAiAssistant.js - WITH WORKING CONVERSATION DELETION
import React, { useState, useRef, useEffect, useCallback } from 'react';
import {
  Box,
  Paper,
  Typography,
  TextField,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Fade,
  Tooltip,
  CircularProgress,
  Alert,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  List,
  ListItem,
  ListItemButton,
  ListItemText,
  ListItemIcon,
  Menu,
  MenuItem,
  Tab,
  Tabs,
  LinearProgress,
  Card,
  CardContent,
  Autocomplete,
  InputAdornment,
  Popper,
  ClickAwayListener,
  Snackbar
} from '@mui/material';
import {
  Send as SendIcon,
  Close as CloseIcon,
  ExpandLess as ChevronUpIcon,
  ExpandMore as ChevronDownIcon,
  Add as AddIcon,
  History as HistoryIcon,
  MoreVert as MoreVertIcon,
  Chat as ChatIcon,
  Delete as DeleteIcon,
  Star as StarIcon,
  StarBorder as StarBorderIcon,
  PushPin as PushPinIcon,
  AutoFixHigh as AutoFixHighIcon,
  Description as DescriptionIcon,
  TrendingUp as TrendingUpIcon,
  CheckCircle as CheckCircleIcon,
  Work as WorkIcon,
  Search as SearchIcon,
  Clear as ClearIcon,
  Warning as WarningIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import { useAiAssistant } from '../../context/AiAssistantContext';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';
import assistantService from '../../utils/assistantService';


// Confirmation Dialog Component for Conversation Deletion
const DeleteConfirmationDialog = ({ 
  open, 
  onClose, 
  onConfirm, 
  conversationTitle,
  isDeleting 
}) => {
  const theme = useTheme();

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="sm"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2,
          boxShadow: theme.shadows[20]
        }
      }}
    >
      <DialogTitle sx={{ 
        display: 'flex', 
        alignItems: 'center', 
        gap: 1,
        pb: 1,
        color: theme.palette.error.main
      }}>
        <WarningIcon />
        Delete Conversation?
      </DialogTitle>
      
      <DialogContent>
        <Typography variant="body1" sx={{ mb: 2 }}>
          Are you sure you want to delete this conversation?
        </Typography>
        
        <Typography 
          variant="body2" 
          sx={{ 
            fontWeight: 600,
            p: 2,
            bgcolor: theme.palette.grey[100],
            borderRadius: 1,
            mb: 2
          }}
        >
          "{conversationTitle || 'Untitled Conversation'}"
        </Typography>
        
        <Typography variant="body2" color="text.secondary">
          This action cannot be undone. All messages in this conversation will be permanently deleted.
        </Typography>
      </DialogContent>
      
      <DialogActions sx={{ p: 3, pt: 1 }}>
        <Button 
          onClick={onClose} 
          disabled={isDeleting}
          variant="outlined"
          sx={{ mr: 1 }}
        >
          Cancel
        </Button>
        <Button 
          onClick={onConfirm}
          disabled={isDeleting}
          variant="contained"
          color="error"
          startIcon={isDeleting ? <CircularProgress size={16} /> : <DeleteIcon />}
          sx={{ minWidth: 120 }}
        >
          {isDeleting ? 'Deleting...' : 'Delete'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

// @-Mention Component for RAG Context Selection
const MentionInput = ({ 
  inputValue, 
  setInputValue, 
  onSendMessage, 
  disabled, 
  currentContext, 
  attachedContext, 
  onAttachContext, 
  onRemoveContext 
}) => {
  const theme = useTheme();
  const [showMentions, setShowMentions] = useState(false);
  const [mentionQuery, setMentionQuery] = useState('');
  const [mentionOptions, setMentionOptions] = useState({ resumes: [], jobs: [] });
  const [loading, setLoading] = useState(false);
  const [cursorPosition, setCursorPosition] = useState(0);
  const inputRef = useRef(null);
  const popperRef = useRef(null);

  // Handle input changes and detect @ mentions
  const handleInputChange = async (event) => {
    const value = event.target.value;
    const cursorPos = event.target.selectionStart;
    
    setInputValue(value);
    setCursorPosition(cursorPos);

    // Check if user typed @ at current position
    const textBeforeCursor = value.substring(0, cursorPos);
    const lastAtIndex = textBeforeCursor.lastIndexOf('@');
    
    if (lastAtIndex !== -1 && lastAtIndex === cursorPos - 1) {
      // User just typed @, show mention popup
      setShowMentions(true);
      setMentionQuery('');
      await loadMentionOptions('');
    } else if (lastAtIndex !== -1 && cursorPos > lastAtIndex) {
      // User is typing after @, filter options
      const query = textBeforeCursor.substring(lastAtIndex + 1);
      if (query.length <= 50 && !query.includes(' ')) { // Reasonable query length
        setMentionQuery(query);
        await loadMentionOptions(query);
      } else {
        setShowMentions(false);
      }
    } else {
      setShowMentions(false);
    }
  };

  // Load mention options from API
  const loadMentionOptions = async (query) => {
    setLoading(true);
    try {
      const options = await assistantService.getMentionSuggestions(query);
      setMentionOptions(options);
    } catch (error) {
      console.error('Failed to load mention options:', error);
      setMentionOptions({ resumes: [], jobs: [] });
    } finally {
      setLoading(false);
    }
  };

  // Handle selecting a mention option - FIXED
  const handleSelectMention = (item, type) => {
    const textBeforeCursor = inputValue.substring(0, cursorPosition);
    const textAfterCursor = inputValue.substring(cursorPosition);
    const lastAtIndex = textBeforeCursor.lastIndexOf('@');
    
    // Replace @query with @[ItemName]
    const beforeAt = inputValue.substring(0, lastAtIndex);
    const mentionText = `@[${item.name || item.title}] `;
    const newValue = beforeAt + mentionText + textAfterCursor;
    
    setInputValue(newValue);
    setShowMentions(false);
    
    // Attach context to conversation
    onAttachContext(item, type);
    
    // FIXED: Use setTimeout with proper null checks for focus management
    setTimeout(() => {
      if (inputRef.current) {
        try {
          const newPos = beforeAt.length + mentionText.length;
          inputRef.current.focus();
          
          // Only call setSelectionRange if the method exists and input is focused
          if (inputRef.current.setSelectionRange && document.activeElement === inputRef.current) {
            inputRef.current.setSelectionRange(newPos, newPos);
          }
        } catch (error) {
          console.warn('Focus management error (non-critical):', error);
          // Fallback: just focus without setting cursor position
          if (inputRef.current.focus) {
            inputRef.current.focus();
          }
        }
      }
    }, 100); // Increased timeout for better reliability
  };

  // Handle key presses
  const handleKeyPress = (event) => {
    if (event.key === 'Enter' && !event.shiftKey && !showMentions) {
      event.preventDefault();
      onSendMessage();
    } else if (event.key === 'Escape') {
      setShowMentions(false);
    }
  };

  const handleClickAway = () => {
    setShowMentions(false);
  };

  return (
    <ClickAwayListener onClickAway={handleClickAway}>
      <Box sx={{ position: 'relative' }}>
        {/* Attached Context Display */}
        {(attachedContext.resumes.length > 0 || attachedContext.jobs.length > 0) && (
          <Box sx={{ mb: 1, display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
            {attachedContext.resumes.map((resume) => (
              <Chip
                key={resume.id}
                icon={<DescriptionIcon />}
                label={resume.name}
                size="small"
                variant="outlined"
                color="secondary"
                onDelete={() => onRemoveContext(resume.id, 'resume')}
                sx={{ fontSize: '0.75rem' }}
              />
            ))}
            {attachedContext.jobs.map((job) => (
              <Chip
                key={job.id}
                icon={<WorkIcon />}
                label={`${job.title} at ${job.company}`}
                size="small"
                variant="outlined"
                color="primary"
                onDelete={() => onRemoveContext(job.id, 'job')}
                sx={{ fontSize: '0.75rem' }}
              />
            ))}
          </Box>
        )}

        {/* Input Field */}
        <TextField
          ref={inputRef}
          fullWidth
          multiline
          maxRows={3}
          value={inputValue}
          onChange={handleInputChange}
          onKeyPress={handleKeyPress}
          placeholder="Ask AJ anything about your career... Type @ to reference resumes or jobs"
          variant="outlined"
          size="small"
          disabled={disabled}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AutoJobLogo variant="icon-only" size="small" />
              </InputAdornment>
            ),
            endAdornment: (
              <InputAdornment position="end">
                <Tooltip title="Type @ to reference resumes or jobs">
                  <IconButton size="small" disabled>
                    <SearchIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </InputAdornment>
            )
          }}
          sx={{
            '& .MuiOutlinedInput-root': {
              borderRadius: 2,
              fontSize: '0.875rem'
            }
          }}
        />

        {/* Mention Suggestions Popup */}
        {showMentions && (
          <Paper
            ref={popperRef}
            elevation={8}
            sx={{
              position: 'absolute',
              bottom: '100%',
              left: 0,
              right: 0,
              mb: 1,
              maxHeight: 300,
              overflow: 'auto',
              zIndex: 1400,
              border: `1px solid ${theme.palette.divider}`
            }}
          >
            <Box sx={{ p: 1 }}>
              <Typography variant="caption" color="text.secondary" sx={{ px: 1 }}>
                Select an item to add context:
              </Typography>
            </Box>
            
            {loading ? (
              <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
                <CircularProgress size={20} />
              </Box>
            ) : (
              <List dense>
                {/* Resumes Section */}
                {mentionOptions.resumes.length > 0 && (
                  <>
                    <ListItem>
                      <Typography variant="overline" color="text.secondary">
                        Resumes
                      </Typography>
                    </ListItem>
                    {mentionOptions.resumes.map((resume) => (
                      <ListItemButton
                        key={resume._id}
                        onClick={() => handleSelectMention(resume, 'resume')}
                        sx={{ py: 0.5 }}
                      >
                        <ListItemIcon sx={{ minWidth: 32 }}>
                          <DescriptionIcon fontSize="small" color="secondary" />
                        </ListItemIcon>
                        <ListItemText
                          primary={resume.name}
                          secondary={`Score: ${resume.analysis?.overallScore || 'N/A'}%`}
                          primaryTypographyProps={{ variant: 'body2' }}
                          secondaryTypographyProps={{ variant: 'caption' }}
                        />
                      </ListItemButton>
                    ))}
                  </>
                )}

                {/* Jobs Section */}
                {mentionOptions.jobs.length > 0 && (
                  <>
                    <ListItem>
                      <Typography variant="overline" color="text.secondary">
                        Jobs
                      </Typography>
                    </ListItem>
                    {mentionOptions.jobs.map((job) => (
                      <ListItemButton
                        key={job._id}
                        onClick={() => handleSelectMention(job, 'job')}
                        sx={{ py: 0.5 }}
                      >
                        <ListItemIcon sx={{ minWidth: 32 }}>
                          <WorkIcon fontSize="small" color="primary" />
                        </ListItemIcon>
                        <ListItemText
                          primary={job.title}
                          secondary={job.company}
                          primaryTypographyProps={{ variant: 'body2' }}
                          secondaryTypographyProps={{ variant: 'caption' }}
                        />
                      </ListItemButton>
                    ))}
                  </>
                )}

                {/* No Results */}
                {mentionOptions.resumes.length === 0 && mentionOptions.jobs.length === 0 && (
                  <ListItem>
                    <ListItemText
                      primary="No items found"
                      secondary="Try a different search term"
                      primaryTypographyProps={{ variant: 'body2', color: 'text.secondary' }}
                      secondaryTypographyProps={{ variant: 'caption' }}
                    />
                  </ListItem>
                )}
              </List>
            )}
          </Paper>
        )}
      </Box>
    </ClickAwayListener>
  );
};

// Resume Editing Intelligence Hook (keep existing)
const useResumeEditingIntelligence = (attachedContext, sendMessage) => {
  const [isProcessingResumeEdit, setIsProcessingResumeEdit] = useState(false);
  const [lastResumeAction, setLastResumeAction] = useState(null);

  const detectResumeEditIntent = useCallback((message) => {
    const resumeEditKeywords = [
      'update', 'improve', 'enhance', 'optimize', 'fix', 'add', 'remove', 'change',
      'work experience', 'skills', 'summary', 'education', 'ats', 'keywords',
      'bullet points', 'achievements', 'quantify', 'metrics', 'action verbs',
      'help', 'suggestions', 'advice', 'better'
    ];

    const messageLower = message.toLowerCase();
    return resumeEditKeywords.some(keyword => messageLower.includes(keyword)) &&
           attachedContext.resumes.length > 0; // Check if resume is attached
  }, [attachedContext.resumes.length]);

  const processResumeEdit = useCallback(async (message, attachedResume) => {
    if (!attachedResume || !detectResumeEditIntent(message)) {
      // 🔧 FIXED: Build proper context when not doing resume editing
      const contextData = {
        attachedResumes: attachedContext.resumes.map(resume => ({
          id: resume.id,
          name: resume.name,
          score: resume.score,
          data: resume.data
        })),
        attachedJobs: attachedContext.jobs.map(job => ({
          id: job.id,
          title: job.title,
          company: job.company,
          data: job.data
        }))
      };
      return sendMessage(message, contextData);
    }

    setIsProcessingResumeEdit(true);
    setLastResumeAction('Analyzing resume editing request...');

    try {
      // 🔧 FIXED: Build proper context for resume editing
      const enhancedMessage = `[RESUME EDITING REQUEST]
Resume: ${attachedResume.name}
Current Score: ${attachedResume.score || 'Unknown'}
Request: ${message}

Please provide specific improvements and apply them to the resume.`;

      const contextData = {
        attachedResumes: [{
          id: attachedResume.id,
          name: attachedResume.name,
          score: attachedResume.score,
          data: attachedResume.data
        }],
        attachedJobs: attachedContext.jobs.map(job => ({
          id: job.id,
          title: job.title,
          company: job.company,
          data: job.data
        })),
        isResumeEdit: true,
        resumeId: attachedResume.id
      };

      console.log('🎯 Processing resume edit with context:', contextData);

      const response = await sendMessage(enhancedMessage, contextData);

      setLastResumeAction('Applying changes to resume...');
      
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('resumeUpdated', {
          detail: { 
            resumeId: attachedResume.id, 
            message: '✅ Resume successfully updated!',
            changes: message
          }
        }));
        setLastResumeAction('Resume updated successfully!');
        setTimeout(() => setLastResumeAction(null), 3000);
      }, 2000);

      return response;
    } catch (error) {
      console.error('Resume editing failed:', error);
      setLastResumeAction('❌ Resume editing failed. Please try again.');
      setTimeout(() => setLastResumeAction(null), 3000);
      throw error;
    } finally {
      setIsProcessingResumeEdit(false);
    }
  }, [detectResumeEditIntent, sendMessage, attachedContext]);

  return {
    detectResumeEditIntent,
    processResumeEdit,
    isProcessingResumeEdit,
    lastResumeAction
  };
};

// Context-Aware Suggestions Component (updated)
const ContextualSuggestionsBar = ({ attachedContext, onSuggestionClick }) => {
  const theme = useTheme();
  
  const getContextualSuggestions = () => {
    const hasResume = attachedContext.resumes.length > 0;
    const hasJob = attachedContext.jobs.length > 0;

    if (hasResume && hasJob) {
      return [
        'How well do I match this job?',
        'Tailor my resume for this role',
        'Prepare interview questions',
        'Write a cover letter'
      ];
    }
    
    if (hasResume) {
      return [
        'Improve this resume',
        'Optimize for ATS',
        'Add missing skills',
        'Enhance work experience'
      ];
    }
    
    if (hasJob) {
      return [
        'Analyze this job posting',
        'What skills are required?',
        'Interview preparation tips',
        'Company research insights'
      ];
    }

    return [
      'Help improve my resume',
      'Find job opportunities',
      'Career guidance',
      'Interview preparation'
    ];
  };

  const suggestions = getContextualSuggestions();

  if (!suggestions.length) return null;

  return (
    <Box sx={{ 
      p: 1.5, 
      borderBottom: `1px solid ${theme.palette.divider}`,
      bgcolor: theme.palette.background.default
    }}>
      <Typography variant="caption" color="text.secondary" sx={{ mb: 1, display: 'block' }}>
        Quick Actions:
      </Typography>
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
        {suggestions.slice(0, 3).map((suggestion, index) => (
          <Chip
            key={index}
            label={suggestion}
            size="small"
            variant="outlined"
            clickable
            onClick={() => onSuggestionClick(suggestion)}
            sx={{
              fontSize: '0.7rem',
              height: 22,
              '&:hover': {
                bgcolor: theme.palette.primary.light,
                color: 'white'
              }
            }}
          />
        ))}
      </Box>
    </Box>
  );
};

// Enhanced Message Component (keep existing logic)
const EnhancedMessage = ({ message, theme, currentUser, onSuggestionClick, hasAttachedContext }) => {
  const formatTime = (timestamp) => {
    if (!timestamp) return '';
    
    try {
      const date = new Date(timestamp);
      if (isNaN(date.getTime())) return '';
      
      const now = new Date();
      const diffMs = now.getTime() - date.getTime();
      const diffMins = Math.floor(diffMs / (1000 * 60));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      
      if (diffMins < 1) return 'just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      
      return date.toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit',
        month: 'short',
        day: 'numeric'
      });
    } catch (error) {
      console.warn('Error formatting timestamp:', error);
      return '';
    }
  };

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: message.type === 'user' ? 'row-reverse' : 'row',
        alignItems: 'flex-start',
        gap: 1.5
      }}
    >
      {/* Avatar */}
      <Avatar
        sx={{
          width: 32,
          height: 32,
          fontSize: '0.875rem',
          fontWeight: 600,
          ...(message.type === 'user' ? {
            bgcolor: theme.palette.primary.main,
            color: 'white'
          } : {
            bgcolor: 'transparent',
            p: 0.5
          })
        }}
      >
        {message.type === 'user' ? (
          `${currentUser?.firstName?.[0] || 'U'}${currentUser?.lastName?.[0] || ''}`
        ) : (
          <AutoJobLogo 
            variant="icon-only" 
            size="small"
          />
        )}
      </Avatar>

      {/* Message Content */}
      <Box
        sx={{
          maxWidth: '75%',
          display: 'flex',
          flexDirection: 'column',
          gap: 1
        }}
      >
        <Paper
          elevation={message.type === 'user' ? 2 : 1}
          sx={{
            p: 1.5,
            borderRadius: 2,
            ...(message.type === 'user' ? {
              bgcolor: theme.palette.primary.main,
              color: 'white',
              borderBottomRightRadius: 4
            } : {
              bgcolor: message.isError ? theme.palette.error.light :
                       hasAttachedContext ? theme.palette.primary.light + '10' :
                       '#f5f5f5',
              color: message.isError ? theme.palette.error.contrastText :
                     theme.palette.text.primary,
              borderBottomLeftRadius: 4,
              border: hasAttachedContext ? `1px solid ${theme.palette.primary.light}30` : 'none'
            })
          }}
        >
          <Typography 
            variant="body2" 
            sx={{ whiteSpace: 'pre-wrap' }}
            dangerouslySetInnerHTML={{ 
              __html: assistantService.formatResponse(message.content)
            }}
          />
        </Paper>

        {/* Suggestions */}
        {message.suggestions && message.suggestions.length > 0 && (
          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 0.5 }}>
            {message.suggestions.map((suggestion, index) => (
              <Chip
                key={index}
                label={suggestion}
                size="small"
                variant="outlined"
                clickable
                onClick={() => onSuggestionClick(suggestion)}
                sx={{
                  fontSize: '0.75rem',
                  height: 24,
                  '&:hover': {
                    bgcolor: theme.palette.primary.light,
                    color: 'white'
                  }
                }}
              />
            ))}
          </Box>
        )}

        {/* Timestamp */}
        <Typography
          variant="caption"
          sx={{
            color: theme.palette.text.disabled,
            fontSize: '0.6875rem',
            textAlign: message.type === 'user' ? 'right' : 'left'
          }}
        >
          {formatTime(message.timestamp)}
        </Typography>
      </Box>
    </Box>
  );
};

// FIXED Conversation List Component with Working Deletion


const ConversationList = ({ 
  conversations, 
  currentConversationId, 
  onSelectConversation, 
  onCreateNew,
  onUpdateConversation,
  onDeleteConversation,
  loading 
}) => {
  const theme = useTheme();
  const [menuAnchor, setMenuAnchor] = useState(null);
  const [selectedConv, setSelectedConv] = useState(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [successMessage, setSuccessMessage] = useState('');

  // FIXED: Better menu handling with proper conversation tracking
  const handleMenuClick = (event, conversation) => {
    event.stopPropagation();
    event.preventDefault();
    
    console.log('🔍 Menu clicked for conversation:', {
      id: conversation._id,
      title: conversation.title,
      conversation: conversation
    });
    
    setMenuAnchor(event.currentTarget);
    setSelectedConv(conversation); // Make sure we store the full conversation object
  };

  const handleMenuClose = () => {
    console.log('🔄 Closing menu, selectedConv was:', selectedConv?._id);
    setMenuAnchor(null);
    // Don't clear selectedConv here - keep it for the delete dialog
  };

  const handleDeleteClick = () => {
    console.log('🗑️ Delete clicked for conversation:', {
      selectedConv: selectedConv,
      id: selectedConv?._id,
      title: selectedConv?.title
    });
    
    if (!selectedConv) {
      console.error('❌ No conversation selected when delete clicked');
      return;
    }
    
    setDeleteDialogOpen(true);
    handleMenuClose();
  };

  const handleDeleteCancel = () => {
    console.log('🚫 Delete cancelled');
    setDeleteDialogOpen(false);
    setSelectedConv(null); // Clear selection when cancelled
  };

  const handleDeleteConfirm = async () => {
    console.log('🗑️ Delete confirm clicked, selectedConv:', {
      selectedConv: selectedConv,
      id: selectedConv?._id,
      title: selectedConv?.title
    });

    if (!selectedConv || !selectedConv._id) {
      console.error('❌ No conversation selected for deletion', { selectedConv });
      alert('Error: No conversation selected for deletion');
      return;
    }

    setIsDeleting(true);
    try {
      console.log('🗑️ Starting deletion process for:', selectedConv._id);
      
      // Call the deleteConversation function from context
      const result = await onDeleteConversation(selectedConv._id);
      
      console.log('✅ Conversation deleted successfully:', result);
      
      // Show success message
      setSuccessMessage(`Conversation "${selectedConv.title || 'Untitled'}" deleted successfully`);
      
      // Close dialog and reset state
      setDeleteDialogOpen(false);
      setSelectedConv(null);
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(''), 3000);
      
    } catch (error) {
      console.error('❌ Error deleting conversation:', error);
      
      // Show error to user
      alert(`Failed to delete conversation: ${error.message || 'Unknown error'}`);
      
      // Close dialog but keep selectedConv for retry
      setDeleteDialogOpen(false);
    } finally {
      setIsDeleting(false);
    }
  };

  // Debug: Log whenever selectedConv changes
  useEffect(() => {
    console.log('🔄 selectedConv changed:', {
      id: selectedConv?._id,
      title: selectedConv?.title,
      hasConversation: !!selectedConv
    });
  }, [selectedConv]);

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
        <CircularProgress size={24} />
        <Typography variant="body2" sx={{ ml: 1 }}>
          Loading conversations...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      {/* Success Message */}
      <Snackbar
        open={!!successMessage}
        autoHideDuration={3000}
        onClose={() => setSuccessMessage('')}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert severity="success" onClose={() => setSuccessMessage('')}>
          {successMessage}
        </Alert>
      </Snackbar>

      <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}` }}>
        <Button
          fullWidth
          variant="outlined"
          startIcon={<AddIcon />}
          onClick={onCreateNew}
          sx={{ mb: 1 }}
        >
          New Conversation
        </Button>
      </Box>

      <List sx={{ flex: 1, overflow: 'auto', py: 0 }}>
        {conversations.map((conversation) => (
          <ListItem key={conversation._id} disablePadding>
            <ListItemButton
              selected={conversation._id === currentConversationId}
              onClick={() => onSelectConversation(conversation._id)}
              sx={{ py: 1.5, px: 2, borderRadius: 1, mx: 1, my: 0.5 }}
            >
              <ListItemIcon sx={{ minWidth: 36 }}>
                <ChatIcon fontSize="small" />
              </ListItemIcon>
              
              <ListItemText
                primary={conversation.title || 'Untitled Conversation'}
                secondary={`${conversation.messageCount || 0} messages`}
                primaryTypographyProps={{
                  variant: 'body2',
                  noWrap: true,
                  fontWeight: conversation._id === currentConversationId ? 600 : 400,
                  component: 'span'
                }}
                secondaryTypographyProps={{
                  variant: 'caption',
                  component: 'span'
                }}
                sx={{
                  '& .MuiListItemText-primary': {
                    display: 'block'
                  },
                  '& .MuiListItemText-secondary': {
                    display: 'block',
                    mt: 0.5
                  }
                }}
              />
              
              <IconButton
                size="small"
                onClick={(e) => handleMenuClick(e, conversation)}
                sx={{ 
                  opacity: 0.7, 
                  '&:hover': { opacity: 1 },
                  ml: 1
                }}
              >
                <MoreVertIcon fontSize="small" />
              </IconButton>
            </ListItemButton>
          </ListItem>
        ))}
        
        {conversations.length === 0 && (
          <Box sx={{ p: 3, textAlign: 'center' }}>
            <ChatIcon sx={{ fontSize: 48, color: 'text.disabled', mb: 1 }} />
            <Typography variant="body2" color="text.secondary" gutterBottom>
              No conversations yet
            </Typography>
            <Typography variant="caption" color="text.disabled">
              Start a new conversation to see your chat history here
            </Typography>
          </Box>
        )}
      </List>

      {/* Context Menu */}
      <Menu
        anchorEl={menuAnchor}
        open={Boolean(menuAnchor)}
        onClose={handleMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
        onClick={(e) => e.stopPropagation()}
      >
        <MenuItem 
          onClick={handleDeleteClick} 
          sx={{ 
            color: 'error.main',
            '&:hover': {
              backgroundColor: 'error.light',
              color: 'error.contrastText'
            }
          }}
        >
          <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
          Delete
        </MenuItem>
      </Menu>

      {/* Delete Confirmation Dialog */}
      <DeleteConfirmationDialog
        open={deleteDialogOpen}
        onClose={handleDeleteCancel}
        onConfirm={handleDeleteConfirm}
        conversationTitle={selectedConv?.title}
        isDeleting={isDeleting}
      />
      

    </Box>
  );
};

// Main AI Assistant Component (UPDATED - REMOVED MEMORY TAB)
const GlobalAiAssistant = () => {
  const theme = useTheme();
  const { currentUser } = useAuth();
  const {
    // State
    isOpen,
    setIsOpen,
    isMinimized,
    setIsMinimized,
    
    // Conversations
    conversations,
    currentConversationId,
    currentConversation,
    conversationsLoading,
    
    // Chat
    messages,
    isLoading,
    error,
    
    // Actions
    sendMessage,
    createNewConversation,
    switchConversation,
    updateConversation,
    deleteConversation,
    handleSuggestionClick,
    
    // Utilities
    setError,
    setMessages,
    setCurrentConversationId,
    setCurrentConversation
  } = useAiAssistant();

  // Local state
  const [showSidebar, setShowSidebar] = useState(false);
  const [inputValue, setInputValue] = useState('');
  const [attachedContext, setAttachedContext] = useState({
    resumes: [],
    jobs: []
  });

  // Resume editing intelligence
  const attachedResume = attachedContext.resumes[0] || null;
  const {
    detectResumeEditIntent,
    processResumeEdit,
    isProcessingResumeEdit,
    lastResumeAction
  } = useResumeEditingIntelligence(attachedContext, sendMessage);

  // Refs
  const messagesEndRef = useRef(null);

  // Auto-scroll to bottom of messages
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Handle context attachment
  const handleAttachContext = (item, type) => {
    setAttachedContext(prev => {
      if (type === 'resume') {
        // Replace existing resume (only one at a time for simplicity)
        return {
          ...prev,
          resumes: [{
            id: item._id,
            name: item.name,
            score: item.analysis?.overallScore || 0,
            data: item
          }]
        };
      } else if (type === 'job') {
        // Replace existing job (only one at a time for simplicity)
        return {
          ...prev,
          jobs: [{
            id: item._id,
            title: item.title,
            company: item.company,
            data: item
          }]
        };
      }
      return prev;
    });
  };

  // Handle context removal
  const handleRemoveContext = (id, type) => {
    setAttachedContext(prev => {
      if (type === 'resume') {
        return {
          ...prev,
          resumes: prev.resumes.filter(r => r.id !== id)
        };
      } else if (type === 'job') {
        return {
          ...prev,
          jobs: prev.jobs.filter(j => j.id !== id)
        };
      }
      return prev;
    });
  };

  // Enhanced message sending with context - FIXED
  const handleSendMessage = async () => {
    if (!inputValue.trim() || isLoading || isProcessingResumeEdit) return;

    const messageText = inputValue.trim();
    setInputValue('');

    try {
      // 🔧 FIXED: Build proper context data for RAG
      const contextData = {
        attachedResumes: attachedContext.resumes.map(resume => ({
          id: resume.id,
          name: resume.name,
          score: resume.score,
          data: resume.data // Include full data if available
        })),
        attachedJobs: attachedContext.jobs.map(job => ({
          id: job.id,
          title: job.title,
          company: job.company,
          data: job.data // Include full data if available
        })),
        // Additional context
        page: 'assistant', // Current page context
        hasContext: attachedContext.resumes.length > 0 || attachedContext.jobs.length > 0
      };

      console.log('🚀 Sending message with context:', {
        message: messageText.substring(0, 50) + '...',
        hasAttachedResumes: contextData.attachedResumes.length > 0,
        hasAttachedJobs: contextData.attachedJobs.length > 0,
        resumeNames: contextData.attachedResumes.map(r => r.name),
        jobTitles: contextData.attachedJobs.map(j => j.title)
      });

      // Check if this is a resume editing request
      if (attachedResume && detectResumeEditIntent(messageText)) {
        console.log('🎯 Detected resume editing intent with attached context');
        await processResumeEdit(messageText, attachedResume);
      } else {
        // 🔧 FIXED: Pass contextData properly to sendMessage
        await sendMessage(messageText, contextData);
      }
    } catch (error) {
      console.error('Failed to send message:', error);
    }
  };

  // Handle creating new conversation
  const handleCreateNewConversation = async () => {
    const title = attachedContext.resumes.length > 0 || attachedContext.jobs.length > 0
      ? `Conversation with Context`
      : `New Conversation ${conversations.length + 1}`;
    await createNewConversation(title, 'general');
    setShowSidebar(false);
    // Keep attached context for new conversation
  };

  // Handle conversation selection (continued)
  const handleSelectConversation = (conversationId) => {
    switchConversation(conversationId);
    setShowSidebar(false);
    // Clear attached context when switching conversations
    setAttachedContext({ resumes: [], jobs: [] });
  };

  // Handle conversation deletion with proper error handling
  const handleDeleteConversation = async (conversationId) => {
    try {
      console.log('🗑️ GlobalAiAssistant: Attempting to delete conversation:', conversationId);
      
      // Call the deleteConversation function from the AI Assistant context
      const result = await deleteConversation(conversationId);
      
      console.log('✅ GlobalAiAssistant: Conversation deleted successfully');
      
      // If the deleted conversation was the current one, switch to another or clear
      if (currentConversationId === conversationId) {
        if (conversations.length > 1) {
          // Switch to the first conversation that's not being deleted
          const nextConversation = conversations.find(conv => conv._id !== conversationId);
          if (nextConversation) {
            switchConversation(nextConversation._id);
          } else {
            // No conversations left, clear current conversation
            setCurrentConversationId(null);
            setCurrentConversation(null);
            setMessages([]);
          }
        } else {
          // This was the only conversation, clear everything
          setCurrentConversationId(null);
          setCurrentConversation(null);
          setMessages([]);
        }
      }
      
      return result;
    } catch (error) {
      console.error('❌ GlobalAiAssistant: Failed to delete conversation:', error);
      throw error; // Re-throw so the ConversationList component can handle the error
    }
  };

  // Handle key press
  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // Handle suggestion clicks
  const handleSuggestionClickInternal = (suggestion) => {
    setInputValue(suggestion);
  };

  // Enhanced close handler
  const handleClose = useCallback(() => {
    setInputValue('');
    setShowSidebar(false);
    setError(null);
    setIsOpen(false);
    // Keep attached context when closing (user might reopen)
    console.log('🔄 AI Assistant closed - conversation and context preserved');
  }, [setIsOpen, setError]);

  // Check if we have attached context
  const hasAttachedContext = attachedContext.resumes.length > 0 || attachedContext.jobs.length > 0;

  // Don't render if not open
  if (!isOpen) {
    return (
      <Tooltip title="Ask AJ - Your AI Job Assistant" placement="left">
        <Box
          sx={{
            position: 'fixed',
            bottom: 24,
            right: 24,
            zIndex: 1300,
            cursor: 'pointer'
          }}
          onClick={() => setIsOpen(true)}
        >
          <Paper
            elevation={8}
            sx={{
              width: 64,
              height: 64,
              borderRadius: '50%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              background: hasAttachedContext 
                ? `linear-gradient(135deg, ${theme.palette.secondary.main} 0%, ${theme.palette.secondary.light} 100%)`
                : `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.light} 100%)`,
              color: 'white',
              transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
              '&:hover': {
                transform: 'translateY(-4px) scale(1.05)',
                boxShadow: hasAttachedContext 
                  ? '0 12px 24px rgba(0, 188, 180, 0.3)'
                  : '0 12px 24px rgba(26, 115, 232, 0.3)'
              }
            }}
          >
            <AutoJobLogo 
              variant="icon-only" 
              size="small" 
              color="white"
            />
          </Paper>
        </Box>
      </Tooltip>
    );
  }

  return (
    <>
      <Fade in={isOpen}>
        <Paper
          elevation={16}
          sx={{
            position: 'fixed',
            bottom: 24,
            right: 24,
            width: isMinimized ? 400 : 500,
            height: isMinimized ? 60 : 700,
            zIndex: 1300,
            borderRadius: 3,
            overflow: 'hidden',
            display: 'flex',
            flexDirection: 'column',
            background: 'linear-gradient(to bottom, #ffffff 0%, #f8f9fa 100%)',
            boxShadow: '0 20px 40px rgba(0, 0, 0, 0.15)',
            border: hasAttachedContext 
              ? `2px solid ${theme.palette.secondary.main}30`
              : `1px solid ${theme.palette.divider}`
          }}
        >
          {/* Header */}
          <Box
            sx={{
              p: 2,
              background: hasAttachedContext
                ? `linear-gradient(135deg, ${theme.palette.secondary.main} 0%, ${theme.palette.secondary.light} 100%)`
                : `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.light} 100%)`,
              color: 'white',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              minHeight: isMinimized ? 60 : 'auto',
              overflow: 'hidden'
            }}
          >
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 1.5,
              flex: 1,
              minWidth: 0
            }}>
              <AutoJobLogo 
                variant="icon-only" 
                size="small" 
                color="white"
              />
              <Box sx={{ 
                minWidth: 0,
                flex: 1 
              }}>
                <Typography 
                  variant="subtitle1" 
                  fontWeight={600}
                  sx={{
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    fontSize: isMinimized ? '0.9rem' : '1rem',
                    lineHeight: 1.2
                  }}
                >
                  AJ - Your AI Job Assistant {hasAttachedContext && '• Context Mode'}
                </Typography>
                {!isMinimized && (
                  <Typography 
                    variant="caption" 
                    sx={{ 
                      opacity: 0.8,
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      whiteSpace: 'nowrap',
                      display: 'block'
                    }}
                  >
                    {currentConversation?.title || 'AI Career Assistant'}
                  </Typography>
                )}
              </Box>
            </Box>
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 0.5,
              flexShrink: 0
            }}>
              <IconButton
                size="small"
                onClick={() => setShowSidebar(!showSidebar)}
                sx={{ 
                  color: 'white',
                  display: isMinimized ? 'none' : 'flex'
                }}
              >
                <HistoryIcon />
              </IconButton>
              <IconButton
                size="small"
                onClick={() => setIsMinimized(!isMinimized)}
                sx={{ color: 'white' }}
              >
                {isMinimized ? <ChevronUpIcon /> : <ChevronDownIcon />}
              </IconButton>
              <IconButton
                size="small"
                onClick={handleClose}
                sx={{ color: 'white' }}
              >
                <CloseIcon />
              </IconButton>
            </Box>
          </Box>

          {/* Context Status Display */}
          {!isMinimized && hasAttachedContext && (
            <Box sx={{ px: 2, py: 1, bgcolor: theme.palette.info.light + '20' }}>
              <Typography variant="caption" color="info.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <CheckCircleIcon fontSize="small" />
                Context Active: {attachedContext.resumes.length > 0 && `${attachedContext.resumes[0].name}`}
                {attachedContext.resumes.length > 0 && attachedContext.jobs.length > 0 && ' + '}
                {attachedContext.jobs.length > 0 && `${attachedContext.jobs[0].title}`}
              </Typography>
            </Box>
          )}

          {/* Resume Processing Indicator */}
          {!isMinimized && (isProcessingResumeEdit || lastResumeAction) && (
            <Box sx={{ px: 2, py: 1, bgcolor: theme.palette.info.light + '20' }}>
              {isProcessingResumeEdit && (
                <LinearProgress sx={{ mb: 1, borderRadius: 1 }} />
              )}
              <Typography variant="caption" color="info.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <AutoFixHighIcon fontSize="small" />
                {lastResumeAction || 'Processing resume changes...'}
              </Typography>
            </Box>
          )}

          {/* Main Content - Hidden when minimized */}
          {!isMinimized && (
            <Box sx={{ flex: 1, display: 'flex', overflow: 'hidden' }}>
              {/* Sidebar */}
              {showSidebar && (
                <Box
                  sx={{
                    width: 280,
                    borderRight: `1px solid ${theme.palette.divider}`,
                    display: 'flex',
                    flexDirection: 'column'
                  }}
                >
                  <ConversationList
                    conversations={conversations}
                    currentConversationId={currentConversationId}
                    onSelectConversation={handleSelectConversation}
                    onCreateNew={handleCreateNewConversation}
                    onUpdateConversation={updateConversation}
                    onDeleteConversation={handleDeleteConversation}
                    loading={conversationsLoading}
                  />
                </Box>
              )}

              {/* Chat Area */}
              <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                {/* SIMPLIFIED HEADER - Only Chat (no tabs) */}
                <Box sx={{ 
                  p: 1.5, 
                  borderBottom: `1px solid ${theme.palette.divider}`,
                  bgcolor: theme.palette.background.paper
                }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <ChatIcon color="primary" />
                    <Typography variant="h6" sx={{ flex: 1 }}>
                      Chat with AJ
                    </Typography>
                    {hasAttachedContext && (
                      <Chip 
                        label="Context Active" 
                        size="small" 
                        color="secondary" 
                        variant="outlined"
                      />
                    )}
                  </Box>
                </Box>

                {/* Contextual Suggestions Bar */}
                <ContextualSuggestionsBar 
                  attachedContext={attachedContext}
                  onSuggestionClick={handleSuggestionClickInternal}
                />

                {/* Messages */}
                <Box
                  sx={{
                    flex: 1,
                    overflow: 'auto',
                    p: 2,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: 2
                  }}
                >
                  {messages.map((message) => (
                    <EnhancedMessage
                      key={message.id}
                      message={message}
                      theme={theme}
                      currentUser={currentUser}
                      onSuggestionClick={handleSuggestionClickInternal}
                      hasAttachedContext={hasAttachedContext}
                    />
                  ))}

                  {/* Loading indicator */}
                  {(isLoading || isProcessingResumeEdit) && (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                      <Avatar sx={{ width: 32, height: 32, bgcolor: 'transparent', p: 0.5 }}>
                        <AutoJobLogo variant="icon-only" size="small" />
                      </Avatar>
                      <Paper
                        elevation={1}
                        sx={{
                          p: 2,
                          borderRadius: 2,
                          bgcolor: isProcessingResumeEdit ? theme.palette.secondary.light + '20' : '#f5f5f5',
                          borderBottomLeftRadius: 4,
                          display: 'flex',
                          alignItems: 'center',
                          gap: 1,
                          border: isProcessingResumeEdit ? `1px solid ${theme.palette.secondary.light}50` : 'none'
                        }}
                      >
                        <CircularProgress size={16} color={isProcessingResumeEdit ? 'secondary' : 'primary'} />
                        <Typography variant="body2" color="text.secondary">
                          {isProcessingResumeEdit ? 'AJ is updating your resume...' : 'AJ is thinking...'}
                        </Typography>
                      </Paper>
                    </Box>
                  )}

                  {/* Error message */}
                  {error && (
                    <Alert 
                      severity="error" 
                      onClose={() => setError(null)}
                      sx={{ fontSize: '0.875rem' }}
                    >
                      {error}
                    </Alert>
                  )}

                  <div ref={messagesEndRef} />
                </Box>

                <Divider />

                {/* Enhanced Input with @-mention RAG */}
                <Box sx={{ p: 2 }}>
                  <Box sx={{ display: 'flex', gap: 1, alignItems: 'flex-end' }}>
                    <Box sx={{ flex: 1 }}>
                      <MentionInput
                        inputValue={inputValue}
                        setInputValue={setInputValue}
                        onSendMessage={handleSendMessage}
                        disabled={isLoading || isProcessingResumeEdit}
                        currentContext={null}
                        attachedContext={attachedContext}
                        onAttachContext={handleAttachContext}
                        onRemoveContext={handleRemoveContext}
                      />
                    </Box>
                    <IconButton
                      color={hasAttachedContext ? 'secondary' : 'primary'}
                      onClick={handleSendMessage}
                      disabled={!inputValue.trim() || isLoading || isProcessingResumeEdit}
                      sx={{
                        bgcolor: hasAttachedContext ? theme.palette.secondary.main : theme.palette.primary.main,
                        color: 'white',
                        '&:hover': {
                          bgcolor: hasAttachedContext ? theme.palette.secondary.dark : theme.palette.primary.dark
                        },
                        '&:disabled': {
                          bgcolor: theme.palette.action.disabled
                        }
                      }}
                    >
                      <SendIcon fontSize="small" />
                    </IconButton>
                  </Box>
                  
                  {/* Context Hint */}
                  {hasAttachedContext ? (
                    <Typography variant="caption" color="text.secondary" sx={{ mt: 0.5, display: 'block' }}>
                      💡 AJ now has full context of your {attachedContext.resumes.length > 0 ? 'resume' : ''}{attachedContext.resumes.length > 0 && attachedContext.jobs.length > 0 ? ' and ' : ''}{attachedContext.jobs.length > 0 ? 'job posting' : ''}
                    </Typography>
                  ) : (
                    <Typography variant="caption" color="text.secondary" sx={{ mt: 0.5, display: 'block' }}>
                      💡 Type @ to reference specific resumes or jobs for contextual help
                    </Typography>
                  )}
                </Box>
              </Box>
            </Box>
          )}
        </Paper>
      </Fade>
    </>
  );
};

export default GlobalAiAssistant;

================
File: frontend/src/components/auth/EmailVerification.js
================
// src/components/auth/EmailVerification.js
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  Alert,
  CircularProgress,
  Card,
  CardContent,
  Container
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Email as EmailIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import settingsService from '../../utils/settingsService';
import AutoJobLogo from '../common/AutoJobLogo';

const EmailVerification = () => {
  const theme = useTheme();
  const { token } = useParams();
  const navigate = useNavigate();
  
  const [status, setStatus] = useState('verifying'); // 'verifying', 'success', 'error'
  const [message, setMessage] = useState('');
  const [isResending, setIsResending] = useState(false);

  useEffect(() => {
    if (token) {
      verifyEmail(token);
    }
  }, [token]);

  const verifyEmail = async (verificationToken) => {
    try {
      const response = await settingsService.verifyEmail(verificationToken);
      setStatus('success');
      setMessage(response.message || 'Email verified successfully!');
      
      // Redirect to dashboard after 3 seconds
      setTimeout(() => {
        navigate('/dashboard');
      }, 3000);
      
    } catch (error) {
      setStatus('error');
      setMessage(settingsService.getErrorMessage(error));
    }
  };

  const handleResendVerification = async () => {
    try {
      setIsResending(true);
      await settingsService.sendVerificationEmail();
      setMessage('Verification email sent! Please check your inbox.');
      setStatus('success');
    } catch (error) {
      setMessage(settingsService.getErrorMessage(error));
      setStatus('error');
    } finally {
      setIsResending(false);
    }
  };

  const getStatusIcon = () => {
    switch (status) {
      case 'verifying':
        return <CircularProgress size={48} color="primary" />;
      case 'success':
        return <CheckCircleIcon sx={{ fontSize: 48, color: theme.palette.success.main }} />;
      case 'error':
        return <ErrorIcon sx={{ fontSize: 48, color: theme.palette.error.main }} />;
      default:
        return null;
    }
  };

  const getStatusColor = () => {
    switch (status) {
      case 'success':
        return 'success';
      case 'error':
        return 'error';
      default:
        return 'info';
    }
  };

  return (
    <Container maxWidth="sm" sx={{ mt: 8 }}>
      <Box sx={{ textAlign: 'center', mb: 4 }}>
        <AutoJobLogo 
          variant="stacked" 
          size="large" 
          color="primary"
          showTagline={false}
        />
      </Box>

      <Card sx={{ borderRadius: 3, boxShadow: theme.shadows[8] }}>
        <CardContent sx={{ p: 4, textAlign: 'center' }}>
          <Box sx={{ mb: 3 }}>
            {getStatusIcon()}
          </Box>

          <Typography variant="h4" sx={{ fontWeight: 600, mb: 2 }}>
            {status === 'verifying' && 'Verifying Email...'}
            {status === 'success' && 'Email Verified!'}
            {status === 'error' && 'Verification Failed'}
          </Typography>

          {message && (
            <Alert 
              severity={getStatusColor()} 
              sx={{ mb: 3, textAlign: 'left', borderRadius: 2 }}
            >
              {message}
            </Alert>
          )}

          {status === 'success' && (
            <Box>
              <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
                Your email has been successfully verified. You'll be redirected to your dashboard shortly.
              </Typography>
              <Button
                variant="contained"
                onClick={() => navigate('/dashboard')}
                sx={{ borderRadius: 2 }}
              >
                Go to Dashboard
              </Button>
            </Box>
          )}

          {status === 'error' && (
            <Box>
              <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
                The verification link may have expired or is invalid.
              </Typography>
              <Box sx={{ display: 'flex', gap: 2, justifyContent: 'center' }}>
                <Button
                  variant="outlined"
                  onClick={() => navigate('/login')}
                  sx={{ borderRadius: 2 }}
                >
                  Back to Login
                </Button>
                <Button
                  variant="contained"
                  startIcon={isResending ? <CircularProgress size={20} /> : <EmailIcon />}
                  onClick={handleResendVerification}
                  disabled={isResending}
                  sx={{ borderRadius: 2 }}
                >
                  {isResending ? 'Sending...' : 'Resend Email'}
                </Button>
              </Box>
            </Box>
          )}

          {status === 'verifying' && (
            <Typography variant="body2" color="text.secondary">
              Please wait while we verify your email address...
            </Typography>
          )}
        </CardContent>
      </Card>
    </Container>
  );
};

export default EmailVerification;

================
File: frontend/src/components/auth/ForgotPassword.js
================
// src/components/auth/ForgotPassword.js - CENTERED DESIGN WITHOUT HOW IT WORKS SECTION
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { 
  TextField, 
  Button, 
  Typography, 
  Box, 
  Alert, 
  Paper,
  InputAdornment,
  CircularProgress,
  Divider
} from '@mui/material';
import { 
  Email as EmailIcon,
  ArrowBack as ArrowBackIcon,
  Help as HelpIcon,
  Security as SecurityIcon,
  CheckCircle as CheckCircleIcon,
  Send as SendIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const ForgotPassword = () => {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const { forgotPassword, loading } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    
    if (!email) {
      setError('Please enter your email address');
      return;
    }
    
    const result = await forgotPassword(email);
    
    if (result.success) {
      setSuccess('If an account with that email exists, you will receive password reset instructions shortly.');
    } else {
      setError(result.error);
    }
  };

  return (
    <Box sx={{ 
      // Ensure full viewport coverage
      minHeight: '100vh',
      minHeight: '100dvh',
      height: '100%',
      background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #00c4b4 100%)',
      // Fix for white bar - ensure background covers everything
      backgroundAttachment: 'fixed',
      backgroundSize: 'cover',
      backgroundRepeat: 'no-repeat',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'center',
      alignItems: 'center',
      padding: { xs: 2, sm: 3 },
      overflowY: 'auto',
      overflowX: 'hidden',
      // Ensure proper scrolling behavior
      position: 'relative',
      // Custom scrollbar styling
      '&::-webkit-scrollbar': {
        width: '6px',
      },
      '&::-webkit-scrollbar-track': {
        backgroundColor: 'rgba(255, 255, 255, 0.1)',
        borderRadius: '3px',
      },
      '&::-webkit-scrollbar-thumb': {
        backgroundColor: 'rgba(255, 255, 255, 0.3)',
        borderRadius: '3px',
        '&:hover': {
          backgroundColor: 'rgba(255, 255, 255, 0.5)',
        },
      },
    }}>
      <Box 
        sx={{ 
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          width: '100%',
          // BACK TO ORIGINAL WIDTH
          maxWidth: { xs: '450px', sm: '500px' },
          mx: 'auto',
          my: { xs: 3, sm: 4 }, // Margin top and bottom for proper spacing
          position: 'relative',
          flex: '0 1 auto', // Allow shrinking but don't grow
        }}
      >
        {/* Main Form Container */}
        <Paper 
          elevation={0}
          sx={{ 
            p: { xs: 3, sm: 4 },
            width: '100%',
            background: 'rgba(255, 255, 255, 0.98)',
            backdropFilter: 'blur(20px)',
            border: '1px solid rgba(255, 255, 255, 0.3)',
            boxShadow: '0 20px 40px rgba(0,0,0,0.1)',
            borderRadius: 3
          }}
        >
          {/* Header with Logo */}
          <Box sx={{ textAlign: 'center', mb: 3 }}>
            <Box sx={{ mb: 2 }}>
              <AutoJobLogo 
                variant="icon-only"
                size="medium"
                color="primary"
              />
            </Box>
            
            <Typography 
              component="h1" 
              variant="h4" 
              sx={{ 
                fontWeight: 600,
                color: 'text.primary',
                mb: 1,
                fontSize: { xs: '1.625rem', sm: '1.75rem' }
              }}
            >
              Reset Your Password
            </Typography>
            <Typography 
              variant="body1" 
              color="text.secondary"
              sx={{ 
                fontSize: { xs: '0.875rem', sm: '0.95rem' }
              }}
            >
              Enter your email address and we'll send you instructions to reset your password
            </Typography>
          </Box>
          
          {error && (
            <Alert 
              severity="error" 
              sx={{ 
                mb: 3,
                '& .MuiAlert-icon': {
                  fontSize: '1.25rem'
                }
              }}
            >
              {error}
            </Alert>
          )}
          
          {success && (
            <Alert 
              severity="success" 
              sx={{ 
                mb: 3,
                '& .MuiAlert-icon': {
                  fontSize: '1.25rem'
                }
              }}
            >
              {success}
            </Alert>
          )}
          
          <Box component="form" onSubmit={handleSubmit}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              autoFocus
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <EmailIcon color="primary" />
                  </InputAdornment>
                ),
              }}
              sx={{ 
                mb: 3,
                '& .MuiOutlinedInput-root': {
                  '& fieldset': {
                    borderColor: 'rgba(0, 0, 0, 0.12)',
                  },
                }
              }}
            />
            
            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              disabled={loading}
              startIcon={!loading && <SendIcon />}
              sx={{ 
                py: 1.5,
                fontSize: '1rem',
                fontWeight: 600,
                mb: 3,
                background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 100%)',
                borderRadius: 2,
                textTransform: 'none',
                '&:hover': {
                  background: 'linear-gradient(135deg, #1557b0 0%, #3367d6 100%)',
                },
                '&:disabled': {
                  background: theme => theme.palette.action.disabledBackground
                }
              }}
            >
              {loading ? (
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <CircularProgress size={20} color="inherit" />
                  Sending reset link...
                </Box>
              ) : (
                'Send Reset Instructions'
              )}
            </Button>

            <Divider sx={{ my: 2 }}>
              <Typography 
                variant="body2" 
                color="text.secondary"
                sx={{ fontSize: '0.875rem' }}
              >
                Remember your password?
              </Typography>
            </Divider>
            
            <Button
              component={Link}
              to="/login"
              fullWidth
              variant="outlined"
              size="large"
              startIcon={<ArrowBackIcon />}
              sx={{ 
                py: 1.5,
                fontSize: '0.9rem',
                fontWeight: 500,
                borderRadius: 2,
                textTransform: 'none',
                borderColor: 'primary.main',
                color: 'primary.main',
                '&:hover': {
                  borderColor: 'primary.dark',
                  backgroundColor: 'rgba(26, 115, 232, 0.04)'
                }
              }}
            >
              Back to Sign In
            </Button>
          </Box>

          {/* Simple Security Note */}
          <Box sx={{ 
            mt: 3,
            pt: 3,
            borderTop: '1px solid',
            borderColor: 'divider',
            textAlign: 'center'
          }}>
            <Box sx={{ 
              background: 'rgba(52, 168, 83, 0.04)', 
              border: '1px solid rgba(52, 168, 83, 0.12)',
              borderRadius: 2,
              p: 2.5,
              mb: 2
            }}>
              <Box sx={{ display: 'flex', alignItems: 'flex-start', justifyContent: 'center' }}>
                <SecurityIcon sx={{ 
                  mr: 1.5, 
                  color: '#34a853', 
                  mt: 0.25,
                  fontSize: '1.5rem',
                  flexShrink: 0
                }} />
                <Box sx={{ textAlign: 'left' }}>
                  <Typography 
                    variant="subtitle1" 
                    sx={{ 
                      fontWeight: 600, 
                      mb: 0.5,
                      fontSize: '1rem'
                    }}
                  >
                    Security First
                  </Typography>
                  <Typography 
                    variant="body2" 
                    color="text.secondary"
                    sx={{ 
                      lineHeight: 1.4,
                      fontSize: '0.875rem'
                    }}
                  >
                    For your security, password reset links expire after 1 hour. 
                    If you don't see our email, check your spam folder.
                  </Typography>
                </Box>
              </Box>
            </Box>

            <Typography 
              variant="body2" 
              color="text.secondary" 
              sx={{ 
                mb: 1.5,
                fontSize: '0.875rem'
              }}
            >
              Still having trouble? We're here to help.
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              justifyContent: 'center', 
              alignItems: 'center', 
              gap: { xs: 2, sm: 3 },
              flexWrap: 'wrap'
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <HelpIcon sx={{ fontSize: 16, color: 'primary.main' }} />
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ fontSize: '0.75rem' }}
                >
                  <Link to="/help" style={{ color: 'inherit', textDecoration: 'underline' }}>
                    Contact Support
                  </Link>
                </Typography>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ fontSize: '0.75rem' }}
                >
                  Available 24/7
                </Typography>
              </Box>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Box>
  );
};

export default ForgotPassword;

================
File: frontend/src/components/auth/Login.js
================
// src/components/auth/Login.js - CENTERED DESIGN MATCHING YOUR IMAGE
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { 
  TextField, 
  Button, 
  Typography, 
  Box, 
  Alert, 
  Paper,
  InputAdornment,
  IconButton,
  Divider,
  CircularProgress
} from '@mui/material';
import { 
  Email as EmailIcon,
  Lock as LockIcon,
  Visibility,
  VisibilityOff,
  PersonAdd as PersonAddIcon,
  Help as HelpIcon,
  CheckCircle as CheckCircleIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const Login = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  const [error, setError] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const { login, loading } = useAuth();
  const navigate = useNavigate();

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    
    const result = await login(formData.email, formData.password);
    
    if (result.success) {
      navigate('/dashboard');
    } else {
      setError(result.error);
    }
  };

  const handleClickShowPassword = () => {
    setShowPassword(!showPassword);
  };

  return (
    <Box sx={{ 
      minHeight: '100vh',
      minHeight: '100dvh',
      background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #00c4b4 100%)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: { xs: 3, sm: 4 }, // Increased padding
      overflowY: 'auto',
      overflowX: 'hidden',
      paddingBottom: { xs: 4, sm: 5 }, // Extra bottom padding to prevent cutoff
    }}>
      <Box 
        sx={{ 
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          width: '100%',
          maxWidth: { xs: '400px', sm: '450px' }, // Made wider
          mx: 'auto'
        }}
      >
        {/* Main Form Container - Proper width like in image */}
        <Paper 
          elevation={0}
          sx={{ 
            p: { xs: 3, sm: 4 },
            width: '100%',
            background: 'rgba(255, 255, 255, 0.98)',
            backdropFilter: 'blur(20px)',
            border: '1px solid rgba(255, 255, 255, 0.3)',
            boxShadow: '0 20px 40px rgba(0,0,0,0.1)',
            borderRadius: 3
          }}
        >
          {/* Header with Logo */}
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Box sx={{ mb: 3 }}>
              <AutoJobLogo 
                variant="icon-only"
                size="medium"
                color="primary"
              />
            </Box>
            
            <Typography 
              component="h1" 
              variant="h4" 
              sx={{ 
                fontWeight: 600,
                color: 'text.primary',
                mb: 1,
                fontSize: { xs: '1.75rem', sm: '2rem' }
              }}
            >
              Welcome Back
            </Typography>
            <Typography 
              variant="body1" 
              color="text.secondary"
              sx={{ 
                fontSize: { xs: '0.9rem', sm: '1rem' }
              }}
            >
              Sign in to continue your AI-powered job search journey
            </Typography>
          </Box>
          
          {error && (
            <Alert 
              severity="error" 
              sx={{ 
                mb: 3,
                '& .MuiAlert-icon': {
                  fontSize: '1.25rem'
                }
              }}
            >
              {error}
            </Alert>
          )}
          
          <Box component="form" onSubmit={handleSubmit}>
            {/* Email Field */}
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              autoFocus
              value={formData.email}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <EmailIcon color="primary" />
                  </InputAdornment>
                ),
              }}
              sx={{ 
                mb: 2,
                '& .MuiOutlinedInput-root': {
                  '& fieldset': {
                    borderColor: 'rgba(0, 0, 0, 0.12)',
                  },
                }
              }}
            />
            
            {/* Password Field */}
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="current-password"
              value={formData.password}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <LockIcon color="primary" />
                  </InputAdornment>
                ),
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={handleClickShowPassword}
                      edge="end"
                      size="small"
                    >
                      {showPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
              sx={{ 
                mb: 3,
                '& .MuiOutlinedInput-root': {
                  '& fieldset': {
                    borderColor: 'rgba(0, 0, 0, 0.12)',
                  },
                }
              }}
            />
            
            {/* Sign In Button */}
            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              disabled={loading}
              sx={{ 
                py: 1.5,
                fontSize: '1rem',
                fontWeight: 600,
                mb: 3,
                background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 100%)',
                borderRadius: 2,
                textTransform: 'none',
                '&:hover': {
                  background: 'linear-gradient(135deg, #1557b0 0%, #3367d6 100%)',
                },
                '&:disabled': {
                  background: theme => theme.palette.action.disabledBackground
                }
              }}
            >
              {loading ? (
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <CircularProgress size={20} color="inherit" />
                  Signing you in...
                </Box>
              ) : (
                'Sign In'
              )}
            </Button>

            {/* Divider */}
            <Divider sx={{ my: 2 }}>
              <Typography 
                variant="body2" 
                color="text.secondary"
                sx={{ fontSize: '0.875rem' }}
              >
                New to auto-job.ai?
              </Typography>
            </Divider>
            
            {/* Create Account Button */}
            <Button
              component={Link}
              to="/register"
              fullWidth
              variant="outlined"
              size="large"
              startIcon={<PersonAddIcon />}
              sx={{ 
                py: 1.5,
                fontSize: '0.9rem',
                fontWeight: 500,
                mb: 2,
                borderRadius: 2,
                textTransform: 'none',
                borderColor: 'primary.main',
                color: 'primary.main',
                '&:hover': {
                  borderColor: 'primary.dark',
                  backgroundColor: 'rgba(26, 115, 232, 0.04)'
                }
              }}
            >
              Create Your Free Account
            </Button>
            
            {/* Forgot Password Link */}
            <Button
              component={Link}
              to="/forgot-password"
              fullWidth
              variant="text"
              startIcon={<HelpIcon />}
              sx={{ 
                py: 1,
                color: 'text.secondary',
                fontSize: '0.875rem',
                textTransform: 'none',
                '&:hover': {
                  backgroundColor: 'rgba(0, 0, 0, 0.04)'
                }
              }}
            >
              Forgot your password?
            </Button>
          </Box>

          {/* Trust Indicators Footer */}
          <Box sx={{ 
            mt: 3, // Reduced top margin 
            pt: 2, // Reduced top padding
            borderTop: '1px solid',
            borderColor: 'divider',
            textAlign: 'center'
          }}>
            <Typography 
              variant="body2" 
              color="text.secondary" 
              sx={{ 
                mb: 1.5, // Reduced bottom margin
                fontSize: '0.875rem'
              }}
            >
              Trusted by professionals worldwide
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              justifyContent: 'center', 
              alignItems: 'center', 
              gap: { xs: 2, sm: 3 }, // Responsive gap
              flexWrap: 'wrap'
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ fontSize: '0.75rem' }}
                >
                  Bank-Level Security
                </Typography>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ fontSize: '0.75rem' }}
                >
                  GDPR Compliant
                </Typography>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ fontSize: '0.75rem' }}
                >
                  24/7 Support
                </Typography>
              </Box>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Box>
  );
};

export default Login;

================
File: frontend/src/components/auth/ProtectedRoute.js
================
// src/components/auth/ProtectedRoute.js - typical implementation
import React, { useContext } from 'react';
import { Navigate } from 'react-router-dom';
import { AuthContext } from '../../context/AuthContext';

const ProtectedRoute = ({ children }) => {
  console.log('ProtectedRoute rendering');
  const { isAuthenticated, loading } = useContext(AuthContext);
  console.log('Auth in ProtectedRoute:', { isAuthenticated, loading });

  if (loading) {
    // Add a simple loading indicator here
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    console.log('Not authenticated, redirecting to login');
    return <Navigate to="/login" replace />;
  }

  console.log('Authenticated, rendering children');
  return children;
};

export default ProtectedRoute;

================
File: frontend/src/components/auth/Register.js
================
// src/components/auth/Register.js - CENTERED DESIGN MATCHING LOGIN THEME
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { 
  TextField, 
  Button, 
  Typography, 
  Box, 
  Alert, 
  Paper, 
  Grid,
  InputAdornment,
  IconButton,
  Divider,
  LinearProgress,
  CircularProgress
} from '@mui/material';
import { 
  Person as PersonIcon,
  Email as EmailIcon,
  Lock as LockIcon,
  Visibility,
  VisibilityOff,
  Login as LoginIcon,
  CheckCircle as CheckCircleIcon,
  Security as SecurityIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const Register = () => {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const { register, loading } = useAuth();
  const navigate = useNavigate();

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const validateForm = () => {
    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match');
      return false;
    }
    
    const passwordRegex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(formData.password)) {
      setError('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
      return false;
    }
    
    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    
    if (!validateForm()) {
      return;
    }
    
    const { confirmPassword, ...registrationData } = formData;
    const result = await register(registrationData);
    
    if (result.success) {
      setSuccess('Registration successful! Please check your email to verify your account.');
      setTimeout(() => {
        navigate('/dashboard');
      }, 3000);
    } else {
      setError(result.error);
    }
  };

  // Password strength indicator
  const getPasswordStrength = () => {
    if (!formData.password) return { score: 0, label: '', color: 'error' };
    
    let score = 0;
    const checks = {
      length: formData.password.length >= 8,
      lowercase: /[a-z]/.test(formData.password),
      uppercase: /[A-Z]/.test(formData.password),
      number: /\d/.test(formData.password),
      special: /[!@#$%^&*]/.test(formData.password)
    };
    
    score = Object.values(checks).filter(Boolean).length;
    
    if (score === 5) return { score: 100, label: 'Strong', color: 'success' };
    if (score >= 3) return { score: 60, label: 'Medium', color: 'warning' };
    return { score: 20, label: 'Weak', color: 'error' };
  };

  const passwordStrength = getPasswordStrength();

  return (
    <Box sx={{ 
      // Ensure full viewport coverage
      minHeight: '100vh',
      minHeight: '100dvh',
      height: '100%',
      background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #00c4b4 100%)',
      // Fix for white bar - ensure background covers everything
      backgroundAttachment: 'fixed',
      backgroundSize: 'cover',
      backgroundRepeat: 'no-repeat',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'center',
      alignItems: 'center',
      padding: { xs: 2, sm: 3 },
      overflowY: 'auto',
      overflowX: 'hidden',
      // Ensure proper scrolling behavior
      position: 'relative',
      // Custom scrollbar styling
      '&::-webkit-scrollbar': {
        width: '6px',
      },
      '&::-webkit-scrollbar-track': {
        backgroundColor: 'rgba(255, 255, 255, 0.1)',
        borderRadius: '3px',
      },
      '&::-webkit-scrollbar-thumb': {
        backgroundColor: 'rgba(255, 255, 255, 0.3)',
        borderRadius: '3px',
        '&:hover': {
          backgroundColor: 'rgba(255, 255, 255, 0.5)',
        },
      },
    }}>
      <Box 
        sx={{ 
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          width: '100%',
          maxWidth: { xs: '450px', sm: '500px' },
          mx: 'auto',
          my: { xs: 3, sm: 4 }, // Margin top and bottom for proper spacing
          position: 'relative',
          flex: '0 1 auto', // Allow shrinking but don't grow
        }}
      >
        {/* Main Form Container */}
        <Paper 
          elevation={0}
          sx={{ 
            p: { xs: 3, sm: 4 },
            width: '100%',
            background: 'rgba(255, 255, 255, 0.98)',
            backdropFilter: 'blur(20px)',
            border: '1px solid rgba(255, 255, 255, 0.3)',
            boxShadow: '0 20px 40px rgba(0,0,0,0.1)',
            borderRadius: 3
          }}
        >
          {/* Header with Logo */}
          <Box sx={{ textAlign: 'center', mb: 3 }}>
            <Box sx={{ mb: 2 }}>
              <AutoJobLogo 
                variant="icon-only"
                size="medium"
                color="primary"
              />
            </Box>
            
            <Typography 
              component="h1" 
              variant="h4" 
              sx={{ 
                fontWeight: 600,
                color: 'text.primary',
                mb: 1,
                fontSize: { xs: '1.625rem', sm: '1.75rem' }
              }}
            >
              Create Your Account
            </Typography>
            <Typography 
              variant="body1" 
              color="text.secondary"
              sx={{ 
                fontSize: { xs: '0.875rem', sm: '0.95rem' }
              }}
            >
              Join auto-job.ai and accelerate your career today
            </Typography>
          </Box>
          
          {error && (
            <Alert 
              severity="error" 
              sx={{ 
                mb: 3,
                '& .MuiAlert-icon': {
                  fontSize: '1.25rem'
                }
              }}
            >
              {error}
            </Alert>
          )}
          
          {success && (
            <Alert 
              severity="success" 
              sx={{ 
                mb: 3,
                '& .MuiAlert-icon': {
                  fontSize: '1.25rem'
                }
              }}
            >
              {success}
            </Alert>
          )}
          
          <Box component="form" onSubmit={handleSubmit}>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <TextField
                  required
                  fullWidth
                  id="firstName"
                  label="First Name"
                  name="firstName"
                  autoComplete="given-name"
                  value={formData.firstName}
                  onChange={handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="primary" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{
                    '& .MuiOutlinedInput-root': {
                      '& fieldset': {
                        borderColor: 'rgba(0, 0, 0, 0.12)',
                      },
                    }
                  }}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  required
                  fullWidth
                  id="lastName"
                  label="Last Name"
                  name="lastName"
                  autoComplete="family-name"
                  value={formData.lastName}
                  onChange={handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PersonIcon color="primary" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{
                    '& .MuiOutlinedInput-root': {
                      '& fieldset': {
                        borderColor: 'rgba(0, 0, 0, 0.12)',
                      },
                    }
                  }}
                />
              </Grid>
              <Grid item xs={12}>
                <TextField
                  required
                  fullWidth
                  id="email"
                  label="Email Address"
                  name="email"
                  autoComplete="email"
                  value={formData.email}
                  onChange={handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <EmailIcon color="primary" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{
                    mb: 1,
                    '& .MuiOutlinedInput-root': {
                      '& fieldset': {
                        borderColor: 'rgba(0, 0, 0, 0.12)',
                      },
                    }
                  }}
                />
              </Grid>
              <Grid item xs={12}>
                <TextField
                  required
                  fullWidth
                  name="password"
                  label="Password"
                  type={showPassword ? 'text' : 'password'}
                  id="password"
                  autoComplete="new-password"
                  value={formData.password}
                  onChange={handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LockIcon color="primary" />
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          aria-label="toggle password visibility"
                          onClick={() => setShowPassword(!showPassword)}
                          edge="end"
                          size="small"
                        >
                          {showPassword ? <VisibilityOff /> : <Visibility />}
                        </IconButton>
                      </InputAdornment>
                    ),
                  }}
                  helperText="At least 8 characters with uppercase, lowercase, number, and special character"
                  sx={{
                    '& .MuiOutlinedInput-root': {
                      '& fieldset': {
                        borderColor: 'rgba(0, 0, 0, 0.12)',
                      },
                    }
                  }}
                />
                {formData.password && (
                  <Box sx={{ mt: 1, mb: 1 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                      <Typography 
                        variant="caption" 
                        color="text.secondary"
                        sx={{ fontSize: '0.75rem' }}
                      >
                        Password strength:
                      </Typography>
                      <Typography 
                        variant="caption" 
                        color={`${passwordStrength.color}.main`}
                        sx={{ 
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      >
                        {passwordStrength.label}
                      </Typography>
                    </Box>
                    <LinearProgress 
                      variant="determinate" 
                      value={passwordStrength.score} 
                      color={passwordStrength.color}
                      sx={{ height: 4, borderRadius: 2 }}
                    />
                  </Box>
                )}
              </Grid>
              <Grid item xs={12}>
                <TextField
                  required
                  fullWidth
                  name="confirmPassword"
                  label="Confirm Password"
                  type={showConfirmPassword ? 'text' : 'password'}
                  id="confirmPassword"
                  value={formData.confirmPassword}
                  onChange={handleChange}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LockIcon color="primary" />
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          aria-label="toggle confirm password visibility"
                          onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                          edge="end"
                          size="small"
                        >
                          {showConfirmPassword ? <VisibilityOff /> : <Visibility />}
                        </IconButton>
                      </InputAdornment>
                    ),
                  }}
                  sx={{
                    '& .MuiOutlinedInput-root': {
                      '& fieldset': {
                        borderColor: 'rgba(0, 0, 0, 0.12)',
                      },
                    }
                  }}
                />
              </Grid>
            </Grid>
            
            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              disabled={loading}
              sx={{ 
                mt: 3, 
                mb: 3,
                py: 1.5,
                fontSize: '1rem',
                fontWeight: 600,
                background: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 100%)',
                borderRadius: 2,
                textTransform: 'none',
                '&:hover': {
                  background: 'linear-gradient(135deg, #1557b0 0%, #3367d6 100%)',
                },
                '&:disabled': {
                  background: theme => theme.palette.action.disabledBackground
                }
              }}
            >
              {loading ? (
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <CircularProgress size={20} color="inherit" />
                  Creating your account...
                </Box>
              ) : (
                'Create Your Free Account'
              )}
            </Button>
            
            <Divider sx={{ my: 2 }}>
              <Typography 
                variant="body2" 
                color="text.secondary"
                sx={{ fontSize: '0.875rem' }}
              >
                Already have an account?
              </Typography>
            </Divider>
            
            <Button
              component={Link}
              to="/login"
              fullWidth
              variant="outlined"
              size="large"
              startIcon={<LoginIcon />}
              sx={{ 
                py: 1.5,
                fontSize: '0.9rem',
                fontWeight: 500,
                borderRadius: 2,
                textTransform: 'none',
                borderColor: 'primary.main',
                color: 'primary.main',
                '&:hover': {
                  borderColor: 'primary.dark',
                  backgroundColor: 'rgba(26, 115, 232, 0.04)'
                }
              }}
            >
              Sign In Instead
            </Button>
          </Box>

          {/* Terms and Trust Indicators Footer */}
          <Box sx={{ 
            mt: 3,
            pt: 2,
            borderTop: '1px solid',
            borderColor: 'divider',
            textAlign: 'center'
          }}>
            <Typography 
              variant="body2" 
              color="text.secondary" 
              sx={{ 
                mb: 1.5,
                fontSize: '0.8rem'
              }}
            >
              By creating an account, you agree to our{' '}
              <Link to="/terms" style={{ color: 'inherit', textDecoration: 'underline' }}>
                Terms of Service
              </Link>
              {' '}and{' '}
              <Link to="/privacy" style={{ color: 'inherit', textDecoration: 'underline' }}>
                Privacy Policy
              </Link>
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              justifyContent: 'center', 
              alignItems: 'center', 
              gap: { xs: 2, sm: 3 },
              flexWrap: 'wrap'
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <SecurityIcon sx={{ fontSize: 16, color: 'success.main' }} />
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ fontSize: '0.75rem' }}
                >
                  SSL Encrypted
                </Typography>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <CheckCircleIcon sx={{ fontSize: 16, color: 'success.main' }} />
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ fontSize: '0.75rem' }}
                >
                  No Spam Guarantee
                </Typography>
              </Box>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Box>
  );
};

export default Register;

================
File: frontend/src/components/auth/ResetPassword.js
================
import React, { useState } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import { TextField, Button, Typography, Container, Box, Alert, Paper } from '@mui/material';
import { useAuth } from '../../context/AuthContext';

const ResetPassword = () => {
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const { resetPassword, loading } = useAuth();
  const { token } = useParams();
  const navigate = useNavigate();

  const validateForm = () => {
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return false;
    }
    
    const passwordRegex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(password)) {
      setError('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
      return false;
    }
    
    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    
    if (!validateForm()) {
      return;
    }
    
    const result = await resetPassword(token, password);
    
    if (result.success) {
      setSuccess('Your password has been reset successfully.');
      setTimeout(() => {
        navigate('/dashboard');
      }, 3000);
    } else {
      setError(result.error);
    }
  };

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 8 }}>
        <Paper sx={{ p: 4 }}>
          <Typography component="h1" variant="h5" align="center" gutterBottom>
            Reset Password
          </Typography>
          
          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}
          
          {success && (
            <Alert severity="success" sx={{ mb: 2 }}>
              {success}
            </Alert>
          )}
          
          <Box component="form" onSubmit={handleSubmit}>
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="New Password"
              type="password"
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              helperText="At least 8 characters with uppercase, lowercase, number, and special character"
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type="password"
              id="confirmPassword"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? 'Resetting...' : 'Reset Password'}
            </Button>
            <Box sx={{ textAlign: 'center' }}>
              <Link to="/login" style={{ textDecoration: 'none' }}>
                <Typography variant="body2" color="primary">
                  Back to Login
                </Typography>
              </Link>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default ResetPassword;

================
File: frontend/src/components/common/AutoJobLogo.js
================
// src/components/common/AutoJobLogo.js - FIXED VERSION
import React from 'react';
import { Box, Typography, useTheme } from '@mui/material';

/**
 * Shared logo component for auto-job.ai
 * Can be used across the application with different variants and sizes
 */
const AutoJobLogo = ({ 
  variant = 'horizontal', // 'horizontal', 'stacked', 'icon-only'
  size = 'medium', // 'small', 'medium', 'large', 'xlarge'
  showTagline = true,
  customTagline = null,
  color = 'primary', // 'primary', 'white', 'gradient'
  className = '',
  onClick = null,
  sx = {}
}) => {
  const theme = useTheme();

  // Size configurations
  const sizeConfig = {
    small: {
      icon: 32,
      logoText: '1.25rem',
      taglineText: '0.75rem',
      gap: 1
    },
    medium: {
      icon: 48,
      logoText: '1.75rem',
      taglineText: '0.875rem',
      gap: 1.5
    },
    large: {
      icon: 64,
      logoText: '2.25rem',
      taglineText: '1rem',
      gap: 2
    },
    xlarge: {
      icon: 80,
      logoText: '2.75rem',
      taglineText: '1.125rem',
      gap: 2.5
    }
  };

  const config = sizeConfig[size] || sizeConfig.medium;

  // Color configurations - FIXED: Now properly handles theme functions
  const getColorConfig = () => {
    switch (color) {
      case 'primary':
        return {
          logoText: theme.palette.primary.main,
          taglineText: theme.palette.text.secondary,
          robotFill: '#e3f2fd',
          robotStroke: theme.palette.primary.main,
          antennaColor: theme.palette.success.main,
          eyeColor: theme.palette.primary.main,
          mouthColor: theme.palette.success.main,
          sidePanelColor: theme.palette.warning.main
        };
      case 'white':
        return {
          logoText: '#ffffff',
          taglineText: 'rgba(255, 255, 255, 0.8)',
          robotFill: 'rgba(255, 255, 255, 0.9)',
          robotStroke: '#ffffff',
          antennaColor: '#4caf50',
          eyeColor: '#2196f3',
          mouthColor: '#4caf50',
          sidePanelColor: '#ff9800'
        };
      case 'gradient':
        return {
          logoText: 'linear-gradient(135deg, #1a73e8 0%, #4285f4 50%, #34a853 100%)',
          taglineText: theme.palette.text.secondary,
          robotFill: '#e3f2fd',
          robotStroke: '#1a73e8',
          antennaColor: '#34a853',
          eyeColor: '#1a73e8',
          mouthColor: '#34a853',
          sidePanelColor: '#fbbc04'
        };
      default:
        return {
          logoText: theme.palette.primary.main,
          taglineText: theme.palette.text.secondary,
          robotFill: '#e3f2fd',
          robotStroke: theme.palette.primary.main,
          antennaColor: theme.palette.success.main,
          eyeColor: theme.palette.primary.main,
          mouthColor: theme.palette.success.main,
          sidePanelColor: theme.palette.warning.main
        };
    }
  };

  const colors = getColorConfig();

  // Robot SVG Component
  const RobotIcon = () => (
    <svg 
      width={config.icon} 
      height={config.icon} 
      viewBox="0 0 64 64" 
      xmlns="http://www.w3.org/2000/svg"
      style={{ display: 'block' }}
    >
      {/* Robot Head Background */}
      <rect 
        x="8" 
        y="12" 
        width="48" 
        height="40" 
        rx="8" 
        ry="8" 
        fill={colors.robotFill}
        stroke={colors.robotStroke}
        strokeWidth="2"
      />
      
      {/* Antenna */}
      <circle 
        cx="32" 
        cy="8" 
        r="2" 
        fill={colors.antennaColor}
      />
      <line 
        x1="32" 
        y1="10" 
        x2="32" 
        y2="12" 
        stroke={colors.antennaColor}
        strokeWidth="2"
      />
      
      {/* Eyes */}
      <circle cx="22" cy="26" r="4" fill="#ffffff"/>
      <circle cx="42" cy="26" r="4" fill="#ffffff"/>
      <circle cx="22" cy="26" r="2" fill={colors.eyeColor}/>
      <circle cx="42" cy="26" r="2" fill={colors.eyeColor}/>
      
      {/* Mouth */}
      <rect 
        x="26" 
        y="36" 
        width="12" 
        height="6" 
        rx="3" 
        ry="3" 
        fill={colors.mouthColor}
      />
      <rect x="28" y="38" width="2" height="2" fill="#ffffff"/>
      <rect x="32" y="38" width="2" height="2" fill="#ffffff"/>
      <rect x="36" y="38" width="2" height="2" fill="#ffffff"/>
      
      {/* Side panels */}
      <rect 
        x="4" 
        y="20" 
        width="6" 
        height="16" 
        rx="3" 
        ry="3" 
        fill={colors.sidePanelColor}
      />
      <rect 
        x="54" 
        y="20" 
        width="6" 
        height="16" 
        rx="3" 
        ry="3" 
        fill={colors.sidePanelColor}
      />
    </svg>
  );

  // Logo text styles - FIXED: Now properly handles gradient colors
  const logoTextStyle = {
    fontSize: config.logoText,
    fontWeight: 700,
    lineHeight: 1,
    ...(color === 'gradient' ? {
      background: colors.logoText,
      WebkitBackgroundClip: 'text',
      WebkitTextFillColor: 'transparent',
      backgroundClip: 'text'
    } : {
      color: colors.logoText
    })
  };

  const taglineTextStyle = {
    fontSize: config.taglineText,
    fontWeight: 500,
    color: colors.taglineText,
    mt: 0.5
  };

  // Default tagline
  const taglineText = customTagline || 'Secure interviews faster with AI agents';

  // Render based on variant
  const renderLogo = () => {
    switch (variant) {
      case 'stacked':
        return (
          <Box
            sx={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              gap: config.gap / 2,
              cursor: onClick ? 'pointer' : 'default',
              ...sx
            }}
            className={className}
            onClick={onClick}
          >
            <RobotIcon />
            <Box sx={{ textAlign: 'center' }}>
              <Typography sx={logoTextStyle}>
                auto-job.ai
              </Typography>
              {showTagline && (
                <Typography sx={taglineTextStyle}>
                  {taglineText}
                </Typography>
              )}
            </Box>
          </Box>
        );

      case 'icon-only':
        return (
          <Box
            sx={{
              display: 'inline-flex',
              cursor: onClick ? 'pointer' : 'default',
              ...sx
            }}
            className={className}
            onClick={onClick}
          >
            <RobotIcon />
          </Box>
        );

      case 'horizontal':
      default:
        return (
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              gap: config.gap,
              cursor: onClick ? 'pointer' : 'default',
              ...sx
            }}
            className={className}
            onClick={onClick}
          >
            <RobotIcon />
            <Box>
              <Typography sx={logoTextStyle}>
                auto-job.ai
              </Typography>
              {showTagline && (
                <Typography sx={taglineTextStyle}>
                  {taglineText}
                </Typography>
              )}
            </Box>
          </Box>
        );
    }
  };

  return renderLogo();
};

export default AutoJobLogo;

================
File: frontend/src/components/common/GlobalSearch.js
================
// src/components/common/GlobalSearch.js
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  InputBase,
  IconButton,
  Paper,
  Typography,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Divider,
  CircularProgress,
  Tabs,
  Tab,
  Badge,
  useTheme,
  alpha,
  ClickAwayListener,
  Popper,
  Fade,
  ListItemButton
} from '@mui/material';
import {
  Search as SearchIcon,
  Work as WorkIcon,
  Description as DescriptionIcon,
  Person as PersonIcon,
  Clear as ClearIcon,
  History as HistoryIcon,
  TrendingUp as TrendingUpIcon,
  KeyboardArrowRight as KeyboardArrowRightIcon,
  Close as CloseIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import searchService from '../../utils/searchService';
import RecruiterDetails from '../recruiters/RecruiterDetails';

const GlobalSearch = ({ sx = {} }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const [query, setQuery] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [results, setResults] = useState(null);
  const [suggestions, setSuggestions] = useState([]);
  const [recentSearches, setRecentSearches] = useState([]);
  const [popularSearches, setPopularSearches] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const [error, setError] = useState(null);
  const [selectedRecruiter, setSelectedRecruiter] = useState(null);
  const [recruiterModalOpen, setRecruiterModalOpen] = useState(false);
  
  const inputRef = useRef(null);
  const resultsRef = useRef(null);
  const debouncedSearchRef = useRef(null);

  // Search categories
  const categories = searchService.getSearchCategories();

  // Initialize debounced search with dependency on selectedCategory
  useEffect(() => {
    debouncedSearchRef.current = searchService.createDebouncedSearch(
      async (searchQuery) => {
        if (searchQuery.trim().length >= 2) {
          await performSearch(searchQuery);
        } else {
          setResults(null);
          if (searchQuery.length >= 1) {
            await loadSuggestions(searchQuery);
          }
        }
      },
      300
    );
  }, []); // Remove selectedCategory dependency to prevent recreating debounced function

  // Load initial data when search opens
  useEffect(() => {
    if (isOpen) {
      loadInitialData();
    }
  }, [isOpen]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event) => {
      // Global search shortcut (Ctrl/Cmd + K or /)
      if ((event.ctrlKey || event.metaKey) && event.key === 'k' || event.key === '/') {
        event.preventDefault();
        openSearch();
      }
      
      // Escape to close
      if (event.key === 'Escape' && isOpen) {
        closeSearch();
      }
      
      // Arrow navigation
      if (isOpen && results) {
        if (event.key === 'ArrowDown') {
          event.preventDefault();
          navigateResults(1);
        } else if (event.key === 'ArrowUp') {
          event.preventDefault();
          navigateResults(-1);
        } else if (event.key === 'Enter' && selectedIndex >= 0) {
          event.preventDefault();
          selectResult();
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, results, selectedIndex]);

  const loadInitialData = async () => {
    try {
      // Load recent searches
      const recent = searchService.getRecentSearches();
      setRecentSearches(recent);
      
      // Load popular searches
      const popular = await searchService.getPopularSearches();
      setPopularSearches(popular.searches || []);
    } catch (error) {
      console.error('Error loading initial data:', error);
    }
  };

  const loadSuggestions = async (searchQuery) => {
    try {
      const suggestionsData = await searchService.getSuggestions(searchQuery);
      setSuggestions(suggestionsData.suggestions || []);
    } catch (error) {
      console.error('Error loading suggestions:', error);
    }
  };

  const performSearch = async (searchQuery) => {
    try {
      setIsLoading(true);
      const searchResults = await searchService.globalSearch(searchQuery, {
        category: selectedCategory,
        limit: 20
      });
      
      if (searchResults.success) {
        const formattedResults = searchService.formatSearchResults(searchResults.data.results);
        setResults(formattedResults);
        
        // Save to recent searches
        searchService.saveRecentSearch(searchQuery, searchResults.data.results);
      }
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleInputChange = (event) => {
    const value = event.target.value;
    setQuery(value);
    setSelectedIndex(-1);
    
    // Clear previous results when query changes and reset to 'all' category
    if (value.trim().length < 2) {
      setResults(null);
      setError(null);
      // Also clear recruiter modal state when query changes
      setSelectedRecruiter(null);
      setRecruiterModalOpen(false);
      if (value.trim().length === 0) {
        setSelectedCategory('all'); // Reset category when query is completely cleared
      }
    }
    
    if (debouncedSearchRef.current) {
      debouncedSearchRef.current(value);
    }
  };

  const openSearch = () => {
    setIsOpen(true);
    // Don't reset category when opening search - keep user's current tab
    setTimeout(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, 100);
  };

  const closeSearch = () => {
    setIsOpen(false);
    // Don't clear query and results when closing - keep them for when user reopens
    setSelectedIndex(-1);
  };

  const handleRecruiterModalClose = () => {
    setRecruiterModalOpen(false);
    setSelectedRecruiter(null);
    // Don't clear the search results when closing the recruiter modal
    // This keeps the search context intact
  };

  const handleStartOutreach = (recruiter) => {
    // Close the modal and search
    handleRecruiterModalClose();
    closeSearch();
    // Navigate to outreach page or handle outreach
    console.log('Starting outreach for:', recruiter);
    // You can add navigation logic here if needed
  };

  const clearAll = () => {
    setQuery('');
    setResults(null);
    setSuggestions([]);
    setSelectedIndex(-1);
    setError(null);
  };

  const navigateResults = (direction) => {
    if (!results) return;
    
    const currentResults = results[selectedCategory] || [];
    const maxIndex = currentResults.length - 1;
    
    if (direction === 1) {
      setSelectedIndex(prev => prev < maxIndex ? prev + 1 : 0);
    } else {
      setSelectedIndex(prev => prev > 0 ? prev - 1 : maxIndex);
    }
  };

  const selectResult = () => {
    if (!results || selectedIndex < 0) return;
    
    const currentResults = results[selectedCategory] || [];
    const selectedResult = currentResults[selectedIndex];
    
    if (selectedResult) {
      navigate(selectedResult.url);
      closeSearch();
    }
  };

  const handleResultClick = (result) => {
    // Handle recruiter results differently - open modal instead of navigating
    if (result.type === 'recruiter') {
      setSelectedRecruiter(result.id);
      setRecruiterModalOpen(true);
    } else {
      // For jobs and resumes, navigate normally
      navigate(result.url);
      closeSearch();
    }
  };

  const handleCategoryChange = (event, newCategory) => {
    console.log(`🔄 Switching category from ${selectedCategory} to ${newCategory}`);
    const oldCategory = selectedCategory;
    setSelectedCategory(newCategory);
    setSelectedIndex(-1);
    
    // Don't re-search when switching categories - just show the existing results
    // The search was already performed with category 'all', so we have all the data
    console.log(`📊 Showing results for ${newCategory} from existing search results`);
    
    if (results) {
      console.log(`📊 Available results:`, {
        totalCount: results.totalCount,
        jobs: results.jobs?.length || 0,
        resumes: results.resumes?.length || 0,
        recruiters: results.recruiters?.length || 0,
        currentCategory: newCategory,
        resultsForCategory: getResultsForCategory(newCategory).length
      });
    }
  };

  const handleSuggestionClick = (suggestion) => {
    setQuery(suggestion.text);
    performSearch(suggestion.text);
  };

  const handleRecentSearchClick = (recentSearch) => {
    setQuery(recentSearch.query);
    performSearch(recentSearch.query);
  };

  const clearQuery = () => {
    setQuery('');
    setResults(null);
    setSuggestions([]);
    setSelectedIndex(-1);
    setError(null);
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  const getResultIcon = (type) => {
    switch (type) {
      case 'job': return <WorkIcon fontSize="small" />;
      case 'resume': return <DescriptionIcon fontSize="small" />;
      case 'recruiter': return <PersonIcon fontSize="small" />;
      default: return <SearchIcon fontSize="small" />;
    }
  };

  const getResultsForCategory = (category) => {
    if (!results) return [];
    
    // Handle 'all' category by combining results
    if (category === 'all') {
      const allResults = [
        ...(results.jobs || []),
        ...(results.resumes || []),
        ...(results.recruiters || [])
      ];
      
      // Sort by relevance/type
      return allResults.sort((a, b) => {
        // Prioritize by match score if available
        if (a.matchScore && b.matchScore) {
          return b.matchScore - a.matchScore;
        }
        // Then by creation date
        const aDate = new Date(a.createdAt || a.lastActiveDate || 0);
        const bDate = new Date(b.createdAt || b.lastActiveDate || 0);
        return bDate - aDate;
      });
    }
    
    // Return specific category results
    return results[category] || [];
  };

  const getResultCount = (category) => {
    if (!results) return 0;
    return results[category]?.length || 0;
  };

  const renderEmptyState = () => {
    if (query.trim().length === 0) {
      return (
        <Box sx={{ p: 3 }}>
          {/* Recent Searches */}
          {recentSearches.length > 0 && (
            <Box sx={{ mb: 3 }}>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <HistoryIcon fontSize="small" sx={{ mr: 1 }} />
                Recent Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {recentSearches.slice(0, 5).map((search, index) => (
                  <Chip
                    key={index}
                    label={search.query}
                    size="small"
                    onClick={() => handleRecentSearchClick(search)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
          
          {/* Popular Searches */}
          {popularSearches.length > 0 && (
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <TrendingUpIcon fontSize="small" sx={{ mr: 1 }} />
                Popular Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {popularSearches.slice(0, 6).map((search, index) => (
                  <Chip
                    key={index}
                    label={search}
                    size="small"
                    variant="outlined"
                    onClick={() => handleSuggestionClick({ text: search })}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
          
          {/* Keyboard Shortcuts */}
          <Box sx={{ mt: 3, pt: 2, borderTop: '1px solid', borderColor: 'divider' }}>
            <Typography variant="caption" color="text.secondary">
              Tip: Use <kbd>/</kbd> or <kbd>Ctrl+K</kbd> to search from anywhere
            </Typography>
          </Box>
        </Box>
      );
    }

    if (query.trim().length >= 2 && results && results.totalCount === 0) {
      return (
        <Box sx={{ p: 3, textAlign: 'center' }}>
          <SearchIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2 }} />
          <Typography variant="h6" gutterBottom>
            No results found
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Try different keywords or check spelling
          </Typography>
          
          {/* Suggestions */}
          {suggestions.length > 0 && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Did you mean:
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, justifyContent: 'center' }}>
                {suggestions.map((suggestion, index) => (
                  <Chip
                    key={index}
                    label={suggestion.text}
                    size="small"
                    onClick={() => handleSuggestionClick(suggestion)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
        </Box>
      );
    }

    return null;
  };

  const renderResults = () => {
    if (!results || results.totalCount === 0) {
      return renderEmptyState();
    }

    const currentResults = results[selectedCategory] || [];

    return (
      <Box>
        {/* Category Tabs */}
        <Tabs
          value={selectedCategory}
          onChange={handleCategoryChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{ borderBottom: 1, borderColor: 'divider', px: 2 }}
        >
          {categories.map((category) => (
            <Tab
              key={category.value}
              value={category.value}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  {category.label}
                  {getResultCount(category.value) > 0 && (
                    <Badge
                      badgeContent={getResultCount(category.value)}
                      color="primary"
                      sx={{
                        '& .MuiBadge-badge': {
                          fontSize: '0.7rem',
                          height: 16,
                          minWidth: 16
                        }
                      }}
                    />
                  )}
                </Box>
              }
            />
          ))}
        </Tabs>

        {/* Results List */}
        <List sx={{ maxHeight: 400, overflow: 'auto' }}>
          {currentResults.map((result, index) => {
            const isSelected = index === selectedIndex;
            const typeDisplay = searchService.getResultTypeDisplay(result.type);
            
            return (
              <ListItemButton
                key={`${result.type}-${result.id}`}
                selected={isSelected}
                onClick={() => handleResultClick(result)}
                sx={{
                  py: 1.5,
                  '&.Mui-selected': {
                    backgroundColor: alpha(theme.palette.primary.main, 0.08),
                  }
                }}
              >
                <ListItemIcon sx={{ minWidth: 40 }}>
                  <Box
                    sx={{
                      width: 32,
                      height: 32,
                      borderRadius: 1,
                      backgroundColor: alpha(typeDisplay.color, 0.1),
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      color: typeDisplay.color
                    }}
                  >
                    {getResultIcon(result.type)}
                  </Box>
                </ListItemIcon>
                
                <ListItemText
                  primary={
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>
                        {result.title}
                      </Typography>
                      {result.matchScore && (
                        <Chip
                          label={`${result.matchScore}% match`}
                          size="small"
                          color={result.matchScore >= 80 ? 'success' : result.matchScore >= 60 ? 'info' : 'warning'}
                          sx={{ height: 20, fontSize: '0.7rem' }}
                        />
                      )}
                      {result.isActive && (
                        <Chip
                          label="Active"
                          size="small"
                          color="success"
                          sx={{ height: 20, fontSize: '0.7rem' }}
                        />
                      )}
                    </Box>
                  }
                  secondary={
                    <Box>
                      <Typography variant="caption" color="text.secondary">
                        {result.subtitle}
                      </Typography>
                      {result.description && (
                        <Typography variant="caption" display="block" color="text.secondary">
                          {result.description}
                        </Typography>
                      )}
                      {result.skills && result.skills.length > 0 && (
                        <Box sx={{ mt: 0.5, display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                          {result.skills.slice(0, 3).map((skill, skillIndex) => (
                            <Chip
                              key={skillIndex}
                              label={typeof skill === 'string' ? skill : skill.name}
                              size="small"
                              variant="outlined"
                              sx={{ height: 18, fontSize: '0.65rem' }}
                            />
                          ))}
                          {result.skills.length > 3 && (
                            <Typography variant="caption" color="text.secondary">
                              +{result.skills.length - 3} more
                            </Typography>
                          )}
                        </Box>
                      )}
                    </Box>
                  }
                />
                
                <KeyboardArrowRightIcon fontSize="small" color="action" />
              </ListItemButton>
            );
          })}
        </List>
      </Box>
    );
  };

  return (
    <>
      <ClickAwayListener onClickAway={() => {
        if (isOpen) {
          closeSearch();
        }
      }}>
        <Box sx={{ position: 'relative', ...sx }}>
          {/* Search Input */}
          <Box
            sx={{
              display: 'flex',
              position: 'relative',
              borderRadius: 2,
              backgroundColor: alpha(theme.palette.common.black, 0.04),
              '&:hover': {
                backgroundColor: alpha(theme.palette.common.black, 0.06),
              },
              '&:focus-within': {
                backgroundColor: alpha(theme.palette.primary.main, 0.08),
                outline: `2px solid ${alpha(theme.palette.primary.main, 0.2)}`,
              },
              width: '100%',
              maxWidth: { xs: '100%', sm: 400, md: 500 },
              transition: 'all 0.2s ease-in-out',
            }}
          >
            <IconButton 
              sx={{ 
                p: 1.5,
                color: 'text.secondary',
                '&:hover': {
                  color: 'primary.main'
                }
              }} 
              aria-label="search"
              onClick={openSearch}
            >
              <SearchIcon />
            </IconButton>
            
            <InputBase
              ref={inputRef}
              placeholder="Search jobs, companies, skills..."
              value={query}
              onChange={handleInputChange}
              onFocus={openSearch}
              sx={{
                color: 'text.primary',
                flex: 1,
                '& .MuiInputBase-input': {
                  padding: theme.spacing(1.5, 1, 1.5, 0),
                  width: '100%',
                  fontSize: '0.95rem',
                  '&::placeholder': {
                    color: 'text.secondary',
                    opacity: 0.7
                  }
                },
              }}
            />
            
            {isLoading && (
              <Box sx={{ display: 'flex', alignItems: 'center', pr: 1 }}>
                <CircularProgress size={20} />
              </Box>
            )}
            
            {query && !isLoading && (
              <IconButton
                onClick={clearQuery}
                size="small"
                sx={{ mr: 1 }}
              >
                <ClearIcon fontSize="small" />
              </IconButton>
            )}
          </Box>

          {/* Search Results Dropdown */}
          {isOpen && (
            <Paper
              ref={resultsRef}
              elevation={8}
              sx={{
                position: 'absolute',
                top: '100%',
                left: 0,
                right: 0,
                mt: 1,
                maxHeight: 500,
                overflow: 'hidden',
                boxShadow: '0 8px 32px rgba(0,0,0,0.12)',
                border: '1px solid',
                borderColor: 'divider',
                zIndex: theme.zIndex.modal + 1,
                width: inputRef.current?.offsetWidth || '100%'
              }}
            >
              {/* Close button for mobile */}
              <Box sx={{ 
                display: { xs: 'block', md: 'none' },
                p: 1,
                borderBottom: '1px solid',
                borderColor: 'divider'
              }}>
                <IconButton
                  onClick={closeSearch}
                  size="small"
                  sx={{ float: 'right' }}
                >
                  <CloseIcon />
                </IconButton>
                <Typography variant="subtitle2" sx={{ pt: 1 }}>
                  Search Results
                </Typography>
              </Box>

              {renderResults()}
            </Paper>
          )}
        </Box>
      </ClickAwayListener>

      {/* Recruiter Details Modal */}
      <RecruiterDetails
        open={recruiterModalOpen}
        onClose={handleRecruiterModalClose}
        recruiterId={selectedRecruiter}
        onStartOutreach={handleStartOutreach}
      />
    </>
  );
};

export default GlobalSearch;

================
File: frontend/src/components/common/PageHeader.js
================
// src/components/common/PageHeader.js
import React from 'react';
import { Typography, Box, Paper, Breadcrumbs, Link } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';

const PageHeader = ({ title, breadcrumbs }) => {
  return (
    <Paper 
      elevation={0} 
      sx={{ 
        backgroundColor: 'background.default', 
        padding: 2, 
        marginBottom: 3,
        borderRadius: 1
      }}
    >
      <Typography variant="h4" component="h1" gutterBottom>
        {title}
      </Typography>
      
      {breadcrumbs && (
        <Breadcrumbs aria-label="breadcrumb">
          <Link component={RouterLink} to="/" color="inherit">
            Dashboard
          </Link>
          {breadcrumbs.map((crumb, index) => (
            <React.Fragment key={index}>
              {index === breadcrumbs.length - 1 ? (
                <Typography color="text.primary">{crumb.label}</Typography>
              ) : (
                <Link component={RouterLink} to={crumb.link} color="inherit">
                  {crumb.label}
                </Link>
              )}
            </React.Fragment>
          ))}
        </Breadcrumbs>
      )}
    </Paper>
  );
};

export default PageHeader;

================
File: frontend/src/components/Dashboard.js
================
// src/components/Dashboard.js - Redesigned Dashboard
import React, { useState, useEffect, useContext } from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  LinearProgress,
  Chip,
  useTheme,
  Paper,
  Alert,
  Skeleton,
  Avatar,
} from '@mui/material';
import {
  Description as DescriptionIcon,
  Work as WorkIcon,
  Assignment as AssignmentIcon,
  CheckCircle as CheckCircleIcon,
  Search as SearchIcon,
  People as PeopleIcon,
  Speed as SpeedIcon,
  AutoAwesome as AutoAwesomeIcon,
  Send as SendIcon,
  SmartToy as SmartToyIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';
import MainLayout from './layout/MainLayout';
import AutoJobLogo from './common/AutoJobLogo';
import resumeService from '../utils/resumeService';
import jobService from '../utils/jobService';

const Dashboard = () => {
  const theme = useTheme();
  const { currentUser } = useContext(AuthContext);
  const navigate = useNavigate();
  
  // State management
  const [loading, setLoading] = useState(true);
  const [resumes, setResumes] = useState([]);
  const [jobs, setJobs] = useState([]);
  const [stats, setStats] = useState({
    resumeCount: 0,
    jobMatches: 0,
    applications: 0,
    resumeScore: 0,
    hasActiveResume: false,
    hasAnalyzedResumes: false
  });

  // Load dashboard data
  useEffect(() => {
    const loadDashboardData = async () => {
      try {
        setLoading(true);
        
        // Load resumes and jobs in parallel
        const [resumesData, jobsData] = await Promise.all([
          resumeService.getUserResumes().catch(() => []),
          jobService.getUserJobs().catch(() => [])
        ]);
        
        setResumes(resumesData);
        setJobs(jobsData);
        
        // Calculate stats
        const activeResume = resumesData.find(r => r.isActive);
        const completedJobs = jobsData.filter(j => j.analysisStatus?.status === 'completed');
        const applications = jobsData.filter(j => j.applicationStatus && j.applicationStatus !== 'Not Applied');
        
        // Calculate average resume score from all analyzed resumes
        let resumeScore = 0;
        const analyzedResumes = resumesData.filter(r => r.analysis?.overallScore);
        if (analyzedResumes.length > 0) {
          const totalScore = analyzedResumes.reduce((sum, r) => sum + r.analysis.overallScore, 0);
          resumeScore = Math.round(totalScore / analyzedResumes.length);
        }
        
        setStats({
          resumeCount: resumesData.length,
          jobMatches: completedJobs.length,
          applications: applications.length,
          resumeScore: resumeScore,
          hasActiveResume: !!activeResume
        });
        
      } catch (error) {
        console.error('Error loading dashboard data:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadDashboardData();
  }, []);

  // Get user's first name
  const firstName = currentUser?.firstName || 'there';
  
  // Determine user journey stage
  const isFirstTimeUser = stats.resumeCount === 0;
  const hasResumes = stats.resumeCount > 0;
  const hasJobs = stats.jobMatches > 0;
  const hasApplications = stats.applications > 0;

  // Get contextual message based on user journey
  const getContextualMessage = () => {
    if (isFirstTimeUser) {
      return {
        title: `Welcome to auto-job.ai, ${firstName}!`,
        message: "Let's get you started! Upload your resume and I'll analyze it with AI to help you find perfect job matches and optimize your applications."
      };
    }
    
    if (!stats.hasAnalyzedResumes) {
      return {
        title: `Hi ${firstName}! Let's analyze your resumes`,
        message: "I see you have resumes uploaded. Let me analyze them with AI to identify strengths, weaknesses, and optimization opportunities for better job matches."
      };
    }
    
    if (stats.resumeScore > 0 && stats.resumeScore < 70) {
      return {
        title: `Hi ${firstName}! Your resume shows potential`,
        message: `Your average resume score is ${stats.resumeScore}/100. Let's work together to boost that score and find you better job opportunities!`
      };
    }
    
    if (stats.resumeScore >= 70 && stats.resumeScore < 85 && !hasJobs) {
      return {
        title: `Great progress, ${firstName}! Ready to find jobs?`,
        message: `Your resumes average ${stats.resumeScore}/100 - solid! Now let's put my AI agents to work finding you the perfect job matches.`
      };
    }

    if (stats.resumeScore >= 85 && !hasJobs) {
      return {
        title: `Excellent work, ${firstName}! Time to hunt for jobs`,
        message: `Your resumes average ${stats.resumeScore}/100 - outstanding! With scores like these, let's find you some amazing opportunities.`
      };
    }
    
    if (hasJobs && !hasApplications) {
      return {
        title: `Perfect timing, ${firstName}!`,
        message: `I found ${stats.jobMatches} job matches for you! Ready to start applying? I can help you tailor your applications for better results.`
      };
    }
    
    if (hasApplications && stats.applications < 10) {
      return {
        title: `You're building momentum, ${firstName}!`,
        message: `You've applied to ${stats.applications} positions - great start! Let's keep the applications flowing and find even more opportunities.`
      };
    }
    
    return {
      title: `You're crushing it, ${firstName}!`,
      message: `With ${stats.applications} applications and ${stats.jobMatches} matches, you're in full job-hunting mode! I'm continuously finding new opportunities that match your profile.`
    };
  };

  // Welcome Speech Bubble Component
  const WelcomeSpeechBubble = () => {
    const contextMessage = getContextualMessage();
    
    return (
      <Paper
        elevation={0}
        sx={{
          p: 3,
          mb: 4,
          background: `linear-gradient(135deg, ${theme.palette.primary.main}12 0%, ${theme.palette.secondary.main}08 100%)`,
          border: `2px solid ${theme.palette.primary.main}25`,
          borderRadius: 3,
          position: 'relative',
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 2 }}>
          <Box sx={{ flexShrink: 0, mt: 0.5 }}>
            <AutoJobLogo variant="icon-only" size="medium" />
          </Box>
          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" gutterBottom sx={{ fontWeight: 600, color: 'primary.main' }}>
              {contextMessage.title}
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ lineHeight: 1.6 }}>
              {contextMessage.message}
            </Typography>
          </Box>
        </Box>
      </Paper>
    );
  };

  // Progress Steps Component
  const ProgressSteps = () => {
    const steps = [
      {
        id: 'upload',
        title: 'Upload Resume',
        description: 'Add your resume files',
        completed: hasResumes,
        action: () => navigate('/resumes'),
        icon: <DescriptionIcon />,
        actionText: hasResumes ? 'Add More Resumes' : 'Upload Resume'
      },
      {
        id: 'analyze',
        title: 'Analysis',
        description: 'Get resume insights',
        completed: stats.hasAnalyzedResumes,
        action: () => navigate('/resumes'),
        icon: <AutoAwesomeIcon />,
        actionText: stats.hasAnalyzedResumes ? 'View Analysis' : 'Analyze Resumes'
      },
      {
        id: 'search',
        title: 'Find Jobs',
        description: 'Discover opportunities',
        completed: hasJobs,
        action: () => hasJobs ? navigate('/jobs') : navigate('/jobs/ai-searches'),
        icon: <SearchIcon />,
        actionText: hasJobs ? 'View Matches' : 'Start Job Search'
      },
      {
        id: 'apply',
        title: 'Apply & Track',
        description: 'Submit applications',
        completed: hasApplications,
        action: () => navigate('/jobs'),
        icon: <SendIcon />,
        actionText: hasApplications ? 'Track Applications' : 'Start Applying'
      }
    ];

    const completedSteps = steps.filter(s => s.completed).length;
    const progressPercentage = (completedSteps / steps.length) * 100;

    return (
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h6" sx={{ fontWeight: 600 }}>
              Your Journey Progress
            </Typography>
            <Chip 
              label={`${completedSteps}/${steps.length} Complete`}
              color={completedSteps === steps.length ? 'success' : 'primary'}
              variant="outlined"
              size="small"
            />
          </Box>
          
          <LinearProgress 
            variant="determinate" 
            value={progressPercentage} 
            sx={{ 
              height: 8, 
              borderRadius: 4, 
              mb: 3,
              backgroundColor: theme.palette.grey[200],
              '& .MuiLinearProgress-bar': {
                borderRadius: 4,
                background: `linear-gradient(90deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`
              }
            }} 
          />
          
          <Grid container spacing={2}>
            {steps.map((step, index) => (
              <Grid item xs={12} sm={6} md={3} key={step.id}>
                <Box
                  sx={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    p: 2,
                    height: 140, // Fixed height for consistency
                    borderRadius: 2,
                    backgroundColor: step.completed ? 'success.main' : 'background.paper',
                    color: step.completed ? 'white' : 'text.primary',
                    border: step.completed ? 'none' : `2px solid ${theme.palette.grey[200]}`,
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    '&:hover': {
                      transform: 'translateY(-2px)',
                      boxShadow: theme.shadows[4],
                      borderColor: step.completed ? 'transparent' : theme.palette.primary.main,
                      backgroundColor: step.completed ? 'success.dark' : 'background.paper'
                    }
                  }}
                  onClick={step.action}
                >
                  <Box sx={{ color: step.completed ? 'white' : theme.palette.primary.main, mb: 1 }}>
                    {step.completed ? <CheckCircleIcon /> : step.icon}
                  </Box>
                  
                  <Box sx={{ textAlign: 'center', flex: 1 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 600, mb: 0.5 }}>
                      {step.title}
                    </Typography>
                    <Typography variant="caption" sx={{ opacity: 0.8, display: 'block', mb: 1 }}>
                      {step.description}
                    </Typography>
                  </Box>
                  
                  {!step.completed && (
                    <Button
                      size="small"
                      variant="text"
                      sx={{ 
                        fontSize: '0.7rem', 
                        minHeight: 'auto',
                        py: 0.5,
                        px: 1,
                        color: 'primary.main',
                        '&:hover': {
                          backgroundColor: 'primary.main',
                          color: 'white'
                        }
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        step.action();
                      }}
                    >
                      {step.actionText}
                    </Button>
                  )}
                </Box>
              </Grid>
            ))}
          </Grid>
        </CardContent>
      </Card>
    );
  };

  // Stats Overview for existing users
  const StatsOverview = () => {
    if (isFirstTimeUser) return null;

    return (
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <SpeedIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.resumeScore}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Resume Score
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.info.main} 0%, ${theme.palette.info.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <WorkIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.jobMatches}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Job Matches
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.success.main} 0%, ${theme.palette.success.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <AssignmentIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.applications}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Applications
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card sx={{ 
            background: `linear-gradient(135deg, ${theme.palette.secondary.main} 0%, ${theme.palette.secondary.dark} 100%)`,
            color: 'white'
          }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <DescriptionIcon sx={{ fontSize: 32, color: 'white', mb: 1 }} />
              <Typography variant="h4" sx={{ fontWeight: 600, color: 'white' }}>
                {stats.resumeCount}
              </Typography>
              <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
                Resumes
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    );
  };

  // Feature Discovery Component
  const FeatureDiscovery = () => (
    <Card sx={{ mb: 3 }}>
      <CardContent>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <AutoJobLogo variant="icon-only" size="small" sx={{ mr: 1 }} />
          <Typography variant="h6" sx={{ fontWeight: 600 }}>
            AI-Powered Features
          </Typography>
        </Box>
        <Grid container spacing={2}>
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
              <Avatar sx={{ bgcolor: 'primary.main', width: 32, height: 32, mr: 2, mt: 0.5 }}>
                <AutoAwesomeIcon fontSize="small" />
              </Avatar>
              <Box>
                <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                  Smart Resume Analysis
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  AI analyzes your resume and suggests improvements for better job matches
                </Typography>
              </Box>
            </Box>
          </Grid>
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
              <Avatar sx={{ bgcolor: 'secondary.main', width: 32, height: 32, mr: 2, mt: 0.5 }}>
                <SearchIcon fontSize="small" />
              </Avatar>
              <Box>
                <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                  Intelligent Job Discovery
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Our AI agents continuously search for jobs that match your profile
                </Typography>
              </Box>
            </Box>
          </Grid>
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
              <Avatar sx={{ bgcolor: 'success.main', width: 32, height: 32, mr: 2, mt: 0.5 }}>
                <PeopleIcon fontSize="small" />
              </Avatar>
              <Box>
                <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                  Recruiter Outreach
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Connect directly with recruiters and hiring managers in your field
                </Typography>
              </Box>
            </Box>
          </Grid>
        </Grid>
      </CardContent>
    </Card>
  );

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Skeleton variant="rectangular" height={120} sx={{ borderRadius: 3, mb: 3 }} />
          <Skeleton variant="rectangular" height={200} sx={{ borderRadius: 2, mb: 3 }} />
          <Grid container spacing={3}>
            {[...Array(4)].map((_, i) => (
              <Grid item xs={12} sm={6} md={3} key={i}>
                <Skeleton variant="rectangular" height={150} sx={{ borderRadius: 2 }} />
              </Grid>
            ))}
          </Grid>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <WelcomeSpeechBubble />
        
        {!isFirstTimeUser && <StatsOverview />}
        
        <ProgressSteps />
        
        {!isFirstTimeUser && <FeatureDiscovery />}
        
        {/* First-time user special prompt */}
        {isFirstTimeUser && (
          <Alert 
            severity="info" 
            sx={{ 
              mb: 3,
              borderRadius: 2,
              '& .MuiAlert-icon': {
                fontSize: 28
              }
            }}
            action={
              <Button 
                color="inherit" 
                size="small" 
                onClick={() => navigate('/resumes')}
                sx={{ fontWeight: 600 }}
              >
                Upload Now
              </Button>
            }
          >
            <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
              Ready to get started?
            </Typography>
            Upload your resume to unlock AI-powered job matching, resume optimization, and recruiter connections.
          </Alert>
        )}
      </Box>
    </MainLayout>
  );
};

export default Dashboard;

================
File: frontend/src/components/jobs/AiSearchesPage.js
================
// src/components/jobs/AiSearchesPage.js
import React, { useState } from 'react';
import {
  Box,
  Typography,
  Button,
  CircularProgress,
  Alert,
  Grid,
  Snackbar
} from '@mui/material';
import {
  SmartToy as SmartToyIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import MainLayout from '../layout/MainLayout';
import PageHeader from '../common/PageHeader';
import { useAiSearches } from './hooks/useAiSearches';
import EmptySearchState from './components/EmptySearchState';
import AiSearchSummaryCards from './components/AiSearchSummaryCards';
import AiSearchTable from './components/AiSearchTable';
import AiSearchDetailsDialog from './components/AiSearchDetailsDialog';
import AiSearchDeleteDialog from './components/AiSearchDeleteDialog';

const AiSearchesPage = () => {
  const navigate = useNavigate();
  const {
    searches,
    loading,
    error,
    actionLoading,
    setError,
    fetchSearches,
    handlePauseResume,
    handleDelete
  } = useAiSearches();

  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [selectedSearch, setSelectedSearch] = useState(null);
  const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
  const [expandedRows, setExpandedRows] = useState({});
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  const toggleRowExpansion = (searchId) => {
    setExpandedRows(prev => ({
      ...prev,
      [searchId]: !prev[searchId]
    }));
  };

  const showSnackbar = (message, severity) => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };

  const handleCloseSnackbar = () => {
    setSnackbar({
      ...snackbar,
      open: false
    });
  };

  const openDeleteDialog = (search) => {
    setSelectedSearch(search);
    setDeleteDialogOpen(true);
  };

  const closeDeleteDialog = () => {
    setDeleteDialogOpen(false);
    setSelectedSearch(null);
  };

  const openDetailsDialog = (search) => {
    setSelectedSearch(search);
    setDetailsDialogOpen(true);
  };

  const closeDetailsDialog = () => {
    setDetailsDialogOpen(false);
    setSelectedSearch(null);
  };

  const handlePauseResumeWithFeedback = async (searchId, currentStatus) => {
    const result = await handlePauseResume(searchId, currentStatus);
    if (result) {
      showSnackbar(result.message, result.success ? 'success' : 'error');
    }
  };

  const handleDeleteWithFeedback = async () => {
    if (!selectedSearch) return;
    
    const result = await handleDelete(selectedSearch._id);
    if (result) {
      showSnackbar(result.message, result.success ? 'success' : 'error');
      if (result.success) {
        closeDeleteDialog();
      }
    }
  };

  const handleStartSearch = () => {
    navigate('/jobs');
  };

  const handleViewJobs = () => {
    closeDetailsDialog();
    navigate('/jobs');
  };

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', height: '60vh' }}>
          <CircularProgress size={60} thickness={4} color="primary" />
          <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
            Loading your AI searches...
          </Typography>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      {/* Removed maxWidth constraint to match other pages */}
      <Box sx={{ p: 3 }}>
        <PageHeader
          title="Agent Job Searches"
          subtitle="Manage your automated AI job searches"
          icon={<SmartToyIcon />}
          action={
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={fetchSearches}
              >
                Refresh
              </Button>
              <Button
                variant="contained"
                color="primary"
                onClick={() => navigate('/jobs')}
              >
                View Jobs
              </Button>
            </Box>
          }
        />

        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError('')}>
            {error}
          </Alert>
        )}

        {searches.length === 0 ? (
          <EmptySearchState onStartSearch={handleStartSearch} />
        ) : (
          <Grid container spacing={3}>
            {/* Summary Cards */}
            <Grid item xs={12}>
              <AiSearchSummaryCards searches={searches} />
            </Grid>

            {/* Enhanced Searches Table */}
            <Grid item xs={12}>
              <AiSearchTable
                searches={searches}
                expandedRows={expandedRows}
                onToggleExpansion={toggleRowExpansion}
                onPauseResume={handlePauseResumeWithFeedback}
                onDelete={openDeleteDialog}
                onViewDetails={openDetailsDialog}
                actionLoading={actionLoading}
              />
            </Grid>
          </Grid>
        )}

        {/* Delete Confirmation Dialog */}
        <AiSearchDeleteDialog
          open={deleteDialogOpen}
          onClose={closeDeleteDialog}
          onConfirm={handleDeleteWithFeedback}
          selectedSearch={selectedSearch}
          isLoading={actionLoading[selectedSearch?._id]}
        />

        {/* Enhanced Details Dialog */}
        <AiSearchDetailsDialog
          open={detailsDialogOpen}
          onClose={closeDetailsDialog}
          selectedSearch={selectedSearch}
          onViewJobs={handleViewJobs}
        />

        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={handleCloseSnackbar}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        >
          <Alert 
            onClose={handleCloseSnackbar} 
            severity={snackbar.severity}
            variant="filled"
            sx={{ width: '100%' }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </Box>
    </MainLayout>
  );
};

export default AiSearchesPage;

================
File: frontend/src/components/jobs/components/AiReasoningLogs.js
================
// src/components/jobs/components/AiReasoningLogs.js
import React from 'react';
import {
  Box,
  Typography,
  Paper,
  Stack,
  Avatar,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  useTheme
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  AccessTime as TimeIcon,
  Speed as SpeedIcon,
  ExpandMore as ExpandMoreIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';
import { getReasoningIcon, getReasoningColor, formatDate, formatDuration } from '../utils/searchUtils';

const AiReasoningLogs = ({ search }) => {
  const theme = useTheme();

  if (!search.reasoningLogs || search.reasoningLogs.length === 0) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography variant="body2" color="text.secondary">
          No reasoning logs available for this search yet.
        </Typography>
      </Box>
    );
  }

  // Sort logs by timestamp, most recent first
  const sortedLogs = [...search.reasoningLogs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  
  return (
    <Box sx={{ maxHeight: 400, overflow: 'auto', p: 2 }}>
      <Stack spacing={2}>
        {sortedLogs.slice(0, 10).map((log, index) => (
          <Paper 
            key={index}
            elevation={1} 
            sx={{ 
              p: 2.5, 
              backgroundColor: log.success === false ? 'rgba(234, 67, 53, 0.04)' : 
                             log.success === true ? 'rgba(52, 168, 83, 0.04)' : 
                             'rgba(0, 0, 0, 0.02)',
              border: `1px solid ${log.success === false ? 'rgba(234, 67, 53, 0.2)' : 
                                  log.success === true ? 'rgba(52, 168, 83, 0.2)' : 
                                  theme.palette.divider}`,
              borderRadius: 2,
              position: 'relative',
              transition: 'all 0.2s ease-in-out',
              '&:hover': {
                backgroundColor: log.success === false ? 'rgba(234, 67, 53, 0.06)' : 
                               log.success === true ? 'rgba(52, 168, 83, 0.06)' : 
                               'rgba(26, 115, 232, 0.02)',
                borderColor: log.success === false ? 'rgba(234, 67, 53, 0.3)' : 
                            log.success === true ? 'rgba(52, 168, 83, 0.3)' : 
                            'rgba(26, 115, 232, 0.2)',
                transform: 'translateY(-1px)',
                boxShadow: '0px 6px 12px rgba(0, 0, 0, 0.08)'
              }
            }}
          >
            {/* Custom Timeline Connection Line */}
            {index < sortedLogs.slice(0, 10).length - 1 && (
              <Box sx={{
                position: 'absolute',
                left: 18,
                top: 50,
                bottom: -16,
                width: 2,
                backgroundColor: theme.palette.divider,
                zIndex: 0
              }} />
            )}

            <Box sx={{ display: 'flex', gap: 2, position: 'relative', zIndex: 1 }}>
              {/* Custom Avatar Timeline Dot */}
              <Avatar sx={{ 
                width: 36, 
                height: 36,
                backgroundColor: getReasoningColor(log.phase, log.success, theme),
                border: `2px solid ${theme.palette.background.paper}`,
                boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                '& .MuiSvgIcon-root': {
                  color: theme.palette.background.paper,
                  fontSize: '18px'
                }
              }}>
                {getReasoningIcon(log.phase)}
              </Avatar>

              <Box sx={{ flex: 1, minWidth: 0 }}>
                {/* Header with phase, success indicator, and timestamp */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <Typography variant="subtitle2" sx={{ 
                      fontWeight: 600,
                      color: log.success === false ? theme.palette.error.main : 
                             log.success === true ? theme.palette.success.main : 
                             theme.palette.text.primary
                    }}>
                      {log.phase ? log.phase.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown Phase'}
                    </Typography>
                    {log.success === true && (
                      <CheckCircleIcon sx={{ fontSize: '16px', color: theme.palette.success.main }} />
                    )}
                    {log.success === false && (
                      <ErrorIcon sx={{ fontSize: '16px', color: theme.palette.error.main }} />
                    )}
                  </Box>
                  <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                      <TimeIcon sx={{ fontSize: '12px', color: 'text.secondary' }} />
                      <Typography variant="caption" color="text.secondary">
                        {formatDate(log.timestamp)}
                      </Typography>
                    </Box>
                    {log.duration && log.duration > 0 && (
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mt: 0.5 }}>
                        <SpeedIcon sx={{ fontSize: '12px', color: 'text.secondary' }} />
                        <Typography variant="caption" color="text.secondary">
                          {formatDuration(log.duration)}
                        </Typography>
                      </Box>
                    )}
                  </Box>
                </Box>

                {/* Message */}
                <Typography variant="body2" sx={{ 
                  mb: 1.5, 
                  lineHeight: 1.5,
                  color: log.success === false ? theme.palette.error.dark : theme.palette.text.primary
                }}>
                  {log.message}
                </Typography>
                
                {/* Details/Metadata Accordion */}
                {((log.details && Object.keys(log.details).length > 0) || 
                  (log.metadata && Object.keys(log.metadata).length > 0)) && (
                  <Accordion 
                    elevation={0} 
                    sx={{ 
                      backgroundColor: 'transparent',
                      '&:before': { display: 'none' },
                      '& .MuiAccordionSummary-root': {
                        minHeight: 'auto',
                        padding: 0,
                        '& .MuiAccordionSummary-content': { 
                          margin: '8px 0',
                          '&.Mui-expanded': { margin: '8px 0' }
                        }
                      }
                    }}
                  >
                    <AccordionSummary
                      expandIcon={<ExpandMoreIcon sx={{ fontSize: '18px', color: theme.palette.primary.main }} />}
                    >
                      <Typography variant="caption" color="primary.main" sx={{ fontWeight: 500 }}>
                        View Technical Details
                      </Typography>
                    </AccordionSummary>
                    <AccordionDetails sx={{ pt: 0, pb: 1 }}>
                      {log.details && Object.keys(log.details).length > 0 && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="caption" fontWeight={600} color="primary.main">
                            Details:
                          </Typography>
                          <Box component="pre" sx={{ 
                            fontSize: '0.75rem', 
                            backgroundColor: theme.palette.background.default, 
                            p: 1.5, 
                            borderRadius: 1,
                            overflow: 'auto',
                            maxHeight: 150,
                            fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                            whiteSpace: 'pre-wrap',
                            lineHeight: 1.4,
                            border: `1px solid ${theme.palette.divider}`,
                            mt: 1
                          }}>
                            {JSON.stringify(log.details, null, 2)}
                          </Box>
                        </Box>
                      )}
                      
                      {log.metadata && Object.keys(log.metadata).length > 0 && (
                        <Box>
                          <Typography variant="caption" fontWeight={600} color="secondary.main">
                            Metadata:
                          </Typography>
                          <Box component="pre" sx={{ 
                            fontSize: '0.75rem', 
                            backgroundColor: theme.palette.background.default, 
                            p: 1.5, 
                            borderRadius: 1,
                            overflow: 'auto',
                            maxHeight: 150,
                            fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                            whiteSpace: 'pre-wrap',
                            lineHeight: 1.4,
                            border: `1px solid ${theme.palette.divider}`,
                            mt: 1
                          }}>
                            {JSON.stringify(log.metadata, null, 2)}
                          </Box>
                        </Box>
                      )}
                    </AccordionDetails>
                  </Accordion>
                )}
              </Box>
            </Box>
          </Paper>
        ))}
      </Stack>
      
      {sortedLogs.length > 10 && (
        <Box sx={{ textAlign: 'center', mt: 3, p: 2 }}>
          <Typography variant="caption" color="text.secondary" sx={{ 
            fontStyle: 'italic',
            backgroundColor: theme.palette.background.default,
            px: 2,
            py: 1,
            borderRadius: 1,
            border: `1px dashed ${theme.palette.divider}`
          }}>
            Showing latest 10 of {sortedLogs.length} reasoning logs
          </Typography>
        </Box>
      )}
    </Box>
  );
};

export default AiReasoningLogs;

================
File: frontend/src/components/jobs/components/AiSearchDeleteDialog.js
================
// src/components/jobs/components/AiSearchDeleteDialog.js
import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  CircularProgress,
  useTheme
} from '@mui/material';
import {
  Delete as DeleteIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  Assessment as AssessmentIcon
} from '@mui/icons-material';

const AiSearchDeleteDialog = ({ 
  open, 
  onClose, 
  onConfirm, 
  selectedSearch, 
  isLoading 
}) => {
  const theme = useTheme();

  return (
    <Dialog 
      open={open} 
      onClose={onClose}
      PaperProps={{
        sx: {
          borderRadius: 2,
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12)'
        }
      }}
    >
      <DialogTitle sx={{ pb: 1 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <DeleteIcon color="error" />
          <Typography variant="h6">Cancel Agent Job Search?</Typography>
        </Box>
      </DialogTitle>
      <DialogContent sx={{ pt: 2 }}>
        <Typography>
          Are you sure you want to cancel this Agent job search? This action cannot be undone.
          The search will be stopped and removed from your active searches.
        </Typography>
        {selectedSearch && (
          <Box sx={{ mt: 3, p: 2, backgroundColor: 'rgba(0, 0, 0, 0.03)', borderRadius: 1 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <DescriptionIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
              <Typography variant="body2" fontWeight={500}>
                Resume: {selectedSearch.resumeName}
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <WorkIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
              <Typography variant="body2" fontWeight={500}>
                Jobs found: {selectedSearch.totalJobsFound}
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <AssessmentIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
              <Typography variant="body2" fontWeight={500}>
                Status: {selectedSearch.status}
              </Typography>
            </Box>
          </Box>
        )}
      </DialogContent>
      <DialogActions sx={{ px: 3, pb: 2 }}>
        <Button 
          onClick={onClose}
          variant="outlined"
        >
          Keep Search
        </Button>
        <Button
          onClick={onConfirm}
          color="error"
          variant="contained"
          disabled={isLoading}
          startIcon={isLoading ? <CircularProgress size={20} /> : <DeleteIcon />}
        >
          Cancel Search
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default AiSearchDeleteDialog;

================
File: frontend/src/components/jobs/components/AiSearchDetailsDialog.js
================
// src/components/jobs/components/AiSearchDetailsDialog.js
import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Grid,
  Paper,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Divider,
  useTheme
} from '@mui/material';
import {
  Description as DescriptionIcon,
  Work as WorkIcon,
  LocationOn as LocationIcon,
  TrendingUp as TrendingUpIcon,
  CalendarToday as CalendarIcon,
  Assessment as AssessmentIcon,
  Code as CodeIcon,
  Search as SearchIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';
import { getStatusColor, getStatusIcon, formatDate } from '../utils/searchUtils';
import AiReasoningLogs from './AiReasoningLogs';

const AiSearchDetailsDialog = ({ 
  open, 
  onClose, 
  selectedSearch, 
  onViewJobs 
}) => {
  const theme = useTheme();

  if (!selectedSearch) return null;

  return (
    <Dialog 
      open={open} 
      onClose={onClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2,
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12)',
          maxHeight: '90vh'
        }
      }}
    >
      <DialogTitle sx={{ 
        pb: 2,
        background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.primary.light} 90%)`,
        color: 'white',
        borderBottom: '1px solid rgba(0, 0, 0, 0.1)'
      }}>
        <Box sx={{ 
          display: 'flex', 
          alignItems: 'center', 
          gap: 1.5,
          minHeight: '32px' // Ensure consistent height
        }}>
          <AutoJobLogo 
            variant="icon-only" 
            size="medium" 
            color="white"
            sx={{ 
              width: 32, 
              height: 32,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          />
          <Typography 
            variant="h6" 
            sx={{ 
              lineHeight: 1.2,
              display: 'flex',
              alignItems: 'center'
            }}
          >
            AI Search Details & Reasoning
          </Typography>
        </Box>
      </DialogTitle>
      <DialogContent sx={{ pt: 3, pb: 1 }}>
        <Box>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(26, 115, 232, 0.04)',
                  borderRadius: 2,
                  height: '100%'
                }}
              >
                <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.primary.main }}>
                  Search Configuration
                </Typography>
                <List disablePadding>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <DescriptionIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Resume</Typography>}
                      secondary={selectedSearch.resumeName}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <WorkIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Target Job Title</Typography>}
                      secondary={selectedSearch.searchCriteria.jobTitle}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <LocationIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Location</Typography>}
                      secondary={selectedSearch.searchCriteria.location}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <TrendingUpIcon color="primary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Experience Level</Typography>}
                      secondary={selectedSearch.searchCriteria.experienceLevel}
                    />
                  </ListItem>
                </List>
              </Paper>
            </Grid>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(0, 196, 180, 0.04)',
                  borderRadius: 2,
                  height: '100%'
                }}
              >
                <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.secondary.main }}>
                  Search Performance
                </Typography>
                <List disablePadding>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <CalendarIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Started</Typography>}
                      secondary={formatDate(selectedSearch.createdAt)}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <WorkIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Total Jobs Found</Typography>}
                      secondary={`${selectedSearch.totalJobsFound} jobs`}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <TrendingUpIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Today's Progress</Typography>}
                      secondary={`${selectedSearch.jobsFoundToday}/${selectedSearch.dailyLimit} jobs`}
                    />
                  </ListItem>
                  <ListItem sx={{ px: 0, py: 1 }}>
                    <ListItemIcon sx={{ minWidth: 36 }}>
                      <AssessmentIcon color="secondary" />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" fontWeight={500}>Current Status</Typography>}
                      secondary={
                        <Chip 
                          label={selectedSearch.status} 
                          size="small" 
                          color={getStatusColor(selectedSearch.status)}
                          icon={getStatusIcon(selectedSearch.status)}
                        />
                      }
                    />
                  </ListItem>
                </List>
              </Paper>
            </Grid>
          </Grid>

          {selectedSearch.searchCriteria.skills && selectedSearch.searchCriteria.skills.length > 0 && (
            <Box sx={{ mt: 3 }}>
              <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.info.main }}>
                Target Skills
              </Typography>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(33, 150, 243, 0.04)',
                  borderRadius: 2
                }}
              >
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {selectedSearch.searchCriteria.skills.slice(0, 10).map((skill, index) => (
                    <Chip 
                      key={index}
                      label={skill} 
                      size="small" 
                      variant="outlined"
                      color="info"
                      icon={<CodeIcon />}
                    />
                  ))}
                  {selectedSearch.searchCriteria.skills.length > 10 && (
                    <Chip 
                      label={`+${selectedSearch.searchCriteria.skills.length - 10} more`}
                      size="small" 
                      variant="outlined"
                      color="default"
                    />
                  )}
                </Box>
              </Paper>
            </Box>
          )}

          {selectedSearch.jobsFound && selectedSearch.jobsFound.length > 0 && (
            <Box sx={{ mt: 3 }}>
              <Typography variant="subtitle1" fontWeight={600} sx={{ mb: 2, color: theme.palette.success.main }}>
                Recent Jobs Found
              </Typography>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  backgroundColor: 'rgba(52, 168, 83, 0.04)',
                  borderRadius: 2,
                  maxHeight: 200,
                  overflow: 'auto'
                }}
              >
                {selectedSearch.jobsFound.slice(-5).reverse().map((job, index) => (
                  <Box key={index} sx={{ mb: index < 4 ? 2 : 0 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <WorkIcon 
                          fontSize="small" 
                          sx={{ mr: 1, color: theme.palette.success.main }} 
                        />
                        <Typography variant="body2" fontWeight={500}>
                          {job.title} at {job.company}
                        </Typography>
                      </Box>
                      <Typography 
                        variant="caption" 
                        color="text.secondary"
                        sx={{ ml: 2 }}
                      >
                        {formatDate(job.foundAt)}
                      </Typography>
                    </Box>
                    {index < 4 && <Divider sx={{ mt: 1.5 }} />}
                  </Box>
                ))}
              </Paper>
            </Box>
          )}

          {/* AI Reasoning Logs Section */}
          <Box sx={{ mt: 3 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, mb: 2 }}>
              <AutoJobLogo 
                variant="icon-only" 
                size="small" 
                sx={{ width: 24, height: 24 }}
              />
              <Typography variant="subtitle1" fontWeight={600} color="primary.main">
                AI Reasoning & Decision Making
              </Typography>
              <Chip 
                label={`${selectedSearch.reasoningLogs?.length || 0} entries`}
                size="small" 
                color="primary"
                variant="outlined"
              />
            </Box>
            <Paper 
              elevation={0} 
              sx={{ 
                backgroundColor: 'rgba(26, 115, 232, 0.02)',
                borderRadius: 2,
                border: '1px solid rgba(26, 115, 232, 0.1)',
                maxHeight: 400,
                overflow: 'hidden'
              }}
            >
              <AiReasoningLogs search={selectedSearch} />
            </Paper>
          </Box>
        </Box>
      </DialogContent>
      <DialogActions sx={{ px: 3, pb: 2 }}>
        <Button 
          onClick={onClose}
          variant="outlined"
        >
          Close
        </Button>
        <Button
          variant="contained"
          onClick={onViewJobs}
          startIcon={<SearchIcon />}
        >
          View All Jobs
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default AiSearchDetailsDialog;

================
File: frontend/src/components/jobs/components/AiSearchExpandableRow.js
================
// src/components/jobs/components/AiSearchExpandableRow.js
import React from 'react';
import {
  TableRow,
  TableCell,
  Collapse,
  Box,
  Typography,
  Chip,
  useTheme
} from '@mui/material';
import AutoJobLogo from '../../common/AutoJobLogo';
import AiReasoningLogs from './AiReasoningLogs';

const AiSearchExpandableRow = ({ search, expanded }) => {
  const theme = useTheme();

  return (
    <TableRow>
      <TableCell 
        style={{ paddingBottom: 0, paddingTop: 0 }} 
        colSpan={8}
      >
        <Collapse 
          in={expanded} 
          timeout="auto" 
          unmountOnExit
        >
          <Box sx={{ 
            margin: 2, 
            backgroundColor: 'rgba(26, 115, 232, 0.02)',
            borderRadius: 2,
            border: '1px solid rgba(26, 115, 232, 0.1)'
          }}>
            <Box sx={{ 
              p: 2.5, 
              borderBottom: '1px solid rgba(26, 115, 232, 0.1)',
              backgroundColor: 'rgba(26, 115, 232, 0.05)'
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                <AutoJobLogo 
                  variant="icon-only" 
                  size="small" 
                  sx={{ width: 28, height: 28 }}
                />
                <Box>
                  <Typography variant="h6" fontWeight={600}>
                    AI Search Reasoning & Progress
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Detailed step-by-step AI reasoning and decision-making process
                  </Typography>
                </Box>
                <Box sx={{ ml: 'auto' }}>
                  <Chip 
                    label={`${search.reasoningLogs?.length || 0} logs`}
                    size="small" 
                    color="primary"
                    variant="outlined"
                    sx={{ fontWeight: 500 }}
                  />
                </Box>
              </Box>
            </Box>
            
            <AiReasoningLogs search={search} />
          </Box>
        </Collapse>
      </TableCell>
    </TableRow>
  );
};

export default AiSearchExpandableRow;

================
File: frontend/src/components/jobs/components/AiSearchSummaryCards.js
================
// src/components/jobs/components/AiSearchSummaryCards.js
import React from 'react';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Box,
  useTheme
} from '@mui/material';
import {
  PlayArrow as PlayIcon,
  Work as WorkIcon,
  TrendingUp as TrendingUpIcon,
  Schedule as ScheduleIcon
} from '@mui/icons-material';

const AiSearchSummaryCards = ({ searches }) => {
  const theme = useTheme();

  const summaryData = [
    {
      title: 'Active Searches',
      value: searches.filter(s => s.status === 'running').length,
      subtitle: 'Currently running',
      icon: <PlayIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.primary.light} 90%)`,
      shadowColor: 'rgba(26, 115, 232, 0.25)'
    },
    {
      title: 'Total Jobs Found',
      value: searches.reduce((sum, s) => sum + s.totalJobsFound, 0),
      subtitle: 'Across all searches',
      icon: <WorkIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.secondary.main} 30%, ${theme.palette.secondary.light} 90%)`,
      shadowColor: 'rgba(0, 196, 180, 0.25)'
    },
    {
      title: 'Jobs Found Today',
      value: searches.reduce((sum, s) => sum + s.jobsFoundToday, 0),
      subtitle: 'New discoveries',
      icon: <TrendingUpIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.success.main} 30%, ${theme.palette.success.light} 90%)`,
      shadowColor: 'rgba(52, 168, 83, 0.25)'
    },
    {
      title: 'Daily Limit',
      value: searches.reduce((sum, s) => sum + s.dailyLimit, 0),
      subtitle: 'Maximum per day',
      icon: <ScheduleIcon fontSize="small" sx={{ mr: 0.5, opacity: 0.8 }} />,
      gradient: `linear-gradient(45deg, ${theme.palette.warning.main} 30%, ${theme.palette.warning.light} 90%)`,
      shadowColor: 'rgba(251, 188, 4, 0.25)'
    }
  ];

  return (
    <Grid container spacing={2}>
      {summaryData.map((item, index) => (
        <Grid item xs={12} sm={6} md={3} key={index}>
          <Card sx={{ 
            background: item.gradient,
            color: 'white',
            boxShadow: `0 4px 20px ${item.shadowColor}`,
            transition: 'transform 0.2s',
            '&:hover': {
              transform: 'translateY(-4px)',
            }
          }}>
            <CardContent>
              <Typography variant="overline" sx={{ opacity: 0.8 }} gutterBottom>
                {item.title}
              </Typography>
              <Typography variant="h3" sx={{ fontWeight: 600 }}>
                {item.value}
              </Typography>
              <Box sx={{ mt: 1, display: 'flex', alignItems: 'center' }}>
                {item.icon}
                <Typography variant="body2" sx={{ opacity: 0.8 }}>
                  {item.subtitle}
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      ))}
    </Grid>
  );
};

export default AiSearchSummaryCards;

================
File: frontend/src/components/jobs/components/AiSearchTable.js
================
// src/components/jobs/components/AiSearchTable.js
import React from 'react';
import {
  TableContainer,
  Table,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  Paper
} from '@mui/material';
import AiSearchTableRow from './AiSearchTableRow';
import AiSearchExpandableRow from './AiSearchExpandableRow';

const AiSearchTable = ({ 
  searches, 
  expandedRows, 
  onToggleExpansion, 
  onPauseResume, 
  onDelete, 
  onViewDetails, 
  actionLoading 
}) => {
  return (
    <TableContainer 
      component={Paper} 
      sx={{ 
        borderRadius: 2, 
        overflow: 'hidden',
        boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)'
      }}
    >
      <Table>
        <TableHead>
          <TableRow sx={{ backgroundColor: 'rgba(26, 115, 232, 0.08)' }}>
            <TableCell sx={{ fontWeight: 600, width: 50 }}>Details</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Resume</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Search Criteria</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Status</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Progress Today</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Total Found</TableCell>
            <TableCell sx={{ fontWeight: 600 }}>Last Update</TableCell>
            <TableCell align="right" sx={{ fontWeight: 600 }}>Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {searches.map((search) => (
            <React.Fragment key={search._id}>
              <AiSearchTableRow
                search={search}
                expanded={expandedRows[search._id]}
                onToggleExpansion={onToggleExpansion}
                onPauseResume={onPauseResume}
                onDelete={onDelete}
                onViewDetails={onViewDetails}
                actionLoading={actionLoading}
              />
              <AiSearchExpandableRow
                search={search}
                expanded={expandedRows[search._id]}
              />
            </React.Fragment>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default AiSearchTable;

================
File: frontend/src/components/jobs/components/AiSearchTableRow.js
================
// src/components/jobs/components/AiSearchTableRow.js
import React from 'react';
import {
  TableRow,
  TableCell,
  Box,
  Typography,
  Chip,
  Badge,
  LinearProgress,
  IconButton,
  Tooltip,
  CircularProgress,
  useTheme
} from '@mui/material';
import {
  Description as DescriptionIcon,
  LocationOn as LocationIcon,
  Work as WorkIcon,
  PlayArrow as PlayIcon,
  Pause as PauseIcon,
  Delete as DeleteIcon,
  Info as InfoIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { getStatusColor, getStatusIcon, getProgressPercentage, formatDate } from '../utils/searchUtils';

const AiSearchTableRow = ({ 
  search, 
  expanded, 
  onToggleExpansion, 
  onPauseResume, 
  onDelete, 
  onViewDetails, 
  actionLoading 
}) => {
  const theme = useTheme();

  return (
    <TableRow 
      sx={{ 
        '&:hover': { 
          backgroundColor: 'rgba(0, 0, 0, 0.04)' 
        },
        transition: 'background-color 0.2s'
      }}
    >
      <TableCell>
        <Tooltip title={expanded ? 'Hide AI Reasoning' : 'Show AI Reasoning'}>
          <IconButton
            size="small"
            onClick={() => onToggleExpansion(search._id)}
            sx={{ 
              backgroundColor: 'rgba(26, 115, 232, 0.08)',
              '&:hover': { backgroundColor: 'rgba(26, 115, 232, 0.15)' }
            }}
          >
            {expanded ? 
              <VisibilityOffIcon fontSize="small" /> : 
              <VisibilityIcon fontSize="small" />
            }
          </IconButton>
        </Tooltip>
      </TableCell>
      <TableCell>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <DescriptionIcon 
            color="primary" 
            fontSize="small" 
            sx={{ mr: 1, opacity: 0.7 }} 
          />
          <Typography variant="body2" fontWeight={500}>
            {search.resumeName}
          </Typography>
        </Box>
      </TableCell>
      <TableCell>
        <Box>
          <Typography variant="body2" fontWeight={500}>
            {search.searchCriteria.jobTitle}
          </Typography>
          <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
            <LocationIcon 
              fontSize="small" 
              sx={{ mr: 0.5, color: theme.palette.text.secondary, fontSize: '0.875rem' }} 
            />
            <Typography variant="caption" color="text.secondary">
              {search.searchCriteria.location}
            </Typography>
          </Box>
        </Box>
      </TableCell>
      <TableCell>
        <Chip
          icon={getStatusIcon(search.status)}
          label={search.status}
          color={getStatusColor(search.status)}
          size="small"
          sx={{ 
            fontWeight: 500,
            boxShadow: '0 2px 5px rgba(0, 0, 0, 0.08)'
          }}
        />
      </TableCell>
      <TableCell>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Box sx={{ flex: 1 }}>
            <LinearProgress
              variant="determinate"
              value={getProgressPercentage(search)}
              color={search.status === 'running' ? 'primary' : 'inherit'}
              sx={{
                height: 8,
                borderRadius: 4,
                backgroundColor: 'rgba(0, 0, 0, 0.06)',
                '& .MuiLinearProgress-bar': {
                  borderRadius: 4,
                  backgroundImage: search.status === 'running' 
                    ? `linear-gradient(90deg, ${theme.palette.primary.main}, ${theme.palette.primary.light})`
                    : undefined
                }
              }}
            />
          </Box>
          <Typography 
            variant="caption" 
            fontWeight={500}
            sx={{ 
              minWidth: '45px', 
              textAlign: 'right',
              color: search.jobsFoundToday >= search.dailyLimit 
                ? theme.palette.success.main 
                : 'inherit'
            }}
          >
            {search.jobsFoundToday}/{search.dailyLimit}
          </Typography>
        </Box>
      </TableCell>
      <TableCell>
        <Badge 
          badgeContent={search.totalJobsFound} 
          color="primary"
          sx={{ 
            '& .MuiBadge-badge': { 
              fontWeight: 600,
              boxShadow: '0 2px 5px rgba(0, 0, 0, 0.1)'
            }
          }}
        >
          <WorkIcon color="action" />
        </Badge>
      </TableCell>
      <TableCell>
        <Box>
          <Typography variant="caption" fontWeight={500}>
            {formatDate(search.lastUpdated)}
          </Typography>
          {search.lastUpdateMessage && (
            <Typography 
              variant="caption" 
              display="block" 
              color="text.secondary"
              sx={{ 
                mt: 0.5,
                maxWidth: 200,
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
              }}
            >
              {search.lastUpdateMessage}
            </Typography>
          )}
        </Box>
      </TableCell>
      <TableCell align="right">
        <Box sx={{ display: 'flex', gap: 1, justifyContent: 'flex-end' }}>
          <Tooltip title="View Details">
            <IconButton
              size="small"
              color="primary"
              onClick={() => onViewDetails(search)}
              sx={{ 
                backgroundColor: 'rgba(26, 115, 232, 0.08)',
                '&:hover': { backgroundColor: 'rgba(26, 115, 232, 0.15)' }
              }}
            >
              <InfoIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          {(search.status === 'running' || search.status === 'paused') && (
            <Tooltip title={search.status === 'running' ? 'Pause' : 'Resume'}>
              <IconButton
                size="small"
                color={search.status === 'running' ? 'warning' : 'success'}
                onClick={() => onPauseResume(search._id, search.status)}
                disabled={actionLoading[search._id]}
                sx={{ 
                  backgroundColor: search.status === 'running' 
                    ? 'rgba(251, 188, 4, 0.08)'
                    : 'rgba(52, 168, 83, 0.08)',
                  '&:hover': { 
                    backgroundColor: search.status === 'running' 
                      ? 'rgba(251, 188, 4, 0.15)'
                      : 'rgba(52, 168, 83, 0.15)'
                  }
                }}
              >
                {actionLoading[search._id] ? (
                  <CircularProgress size={20} />
                ) : search.status === 'running' ? (
                  <PauseIcon fontSize="small" />
                ) : (
                  <PlayIcon fontSize="small" />
                )}
              </IconButton>
            </Tooltip>
          )}
          <Tooltip title="Cancel Search">
            <IconButton
              size="small"
              color="error"
              onClick={() => onDelete(search)}
              disabled={actionLoading[search._id]}
              sx={{ 
                backgroundColor: 'rgba(234, 67, 53, 0.08)',
                '&:hover': { backgroundColor: 'rgba(234, 67, 53, 0.15)' }
              }}
            >
              <DeleteIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        </Box>
      </TableCell>
    </TableRow>
  );
};

export default AiSearchTableRow;

================
File: frontend/src/components/jobs/components/EmptySearchState.js
================
// src/components/jobs/components/EmptySearchState.js
import React from 'react';
import {
  Box,
  Typography,
  Button,
  Paper,
  Grid,
  Alert
} from '@mui/material';
import {
  TrendingUp as TrendingUpIcon,
  Notifications as NotificationsIcon,
  Assessment as AssessmentIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

const EmptySearchState = ({ onStartSearch }) => {
  return (
    <Box sx={{ mt: 2 }}>
      <Paper 
        elevation={0} 
        sx={{ 
          p: 4, // Reduced from 5
          textAlign: 'center', 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center',
          backgroundColor: 'rgba(26, 115, 232, 0.04)',
          border: '1px dashed rgba(26, 115, 232, 0.3)',
          borderRadius: 2,
          mb: 4 // Reduced from 5
        }}
      >
        <Box sx={{ mb: 2 }}> {/* Reduced from 3 */}
          <AutoJobLogo 
            variant="icon-only" 
            size="medium" // Changed from large to medium
            color="primary"
            sx={{ 
              opacity: 0.7,
              filter: 'drop-shadow(0 2px 8px rgba(26, 115, 232, 0.2))'
            }}
          />
        </Box>
        <Typography variant="h5" gutterBottom fontWeight={600}> {/* Changed from h4 to h5 */}
          Start Your AI Agent Job Search
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 3, maxWidth: 600, fontSize: '0.95rem' }}> {/* Reduced mb and maxWidth, added smaller fontSize */}
          Let our AI Agent continuously search for job opportunities that match your resume.
          Our platform will analyze matches, find relevant positions, and track your search progress automatically.
        </Typography>
        <Box sx={{ display: 'flex', gap: 2 }}>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<AutoJobLogo variant="icon-only" size="small" />} // Changed icon to AutoJobLogo
            onClick={onStartSearch}
            size="medium" // Changed from large to medium
            sx={{ 
              py: 1.2, // Reduced from 1.5
              px: 3, // Reduced from 4
              fontSize: '1rem', // Reduced from 1.1rem
              fontWeight: 500,
              boxShadow: '0 4px 12px rgba(26, 115, 232, 0.2)'
            }}
          >
            Begin AI Job Search {/* Updated text */}
          </Button>
        </Box>
        <Alert severity="info" sx={{ mt: 2.5, maxWidth: 550, fontSize: '0.875rem' }}> {/* Reduced mt and maxWidth, added smaller fontSize */}
          You need at least one resume to use the AI Agent search feature.
          Please upload a resume first.
        </Alert>
      </Paper>

      <Typography variant="h6" sx={{ mb: 2.5, fontWeight: 600 }}> {/* Changed from h5 to h6, reduced mb */}
        How Our AI Agent Search Works
      </Typography>

      <Grid container spacing={2.5} sx={{ mb: 3 }}> {/* Reduced spacing and mb */}
        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #4caf50',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              1. AI Resume Analysis
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <AutoJobLogo 
                variant="icon-only" 
                size="medium" // Reduced from large equivalent
                color="primary"
                sx={{ opacity: 0.7 }}
              />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Our AI analyzes your resume and career preferences to understand your ideal job profile
              and search criteria.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #2196f3',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              2. Continuous Job Discovery
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <TrendingUpIcon sx={{ fontSize: 60, color: '#2196f3', opacity: 0.7 }} /> {/* Reduced from 80 */}
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Searches multiple job boards and company websites 24/7 to find relevant opportunities
              matching your profile.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #ff9800',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              3. Smart Notifications
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <NotificationsIcon sx={{ fontSize: 60, color: '#ff9800', opacity: 0.7 }} /> {/* Reduced from 80 */}
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Get notified when new relevant jobs are found and receive detailed AI reasoning
              for each match.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={6}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #9c27b0',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              4. Intelligent Matching
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <AssessmentIcon sx={{ fontSize: 60, color: '#9c27b0', opacity: 0.7 }} /> {/* Reduced from 80 */}
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Each found job is automatically analyzed for compatibility with your resume,
              providing match scores and improvement suggestions.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={6}>
          <Paper elevation={1} sx={{ 
            p: 2.5, // Reduced from 3
            borderRadius: 2, 
            borderLeft: '4px solid #00bcd4',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={500}> {/* Changed from h6 to subtitle1 */}
              5. Progress Tracking
            </Typography>
            <Box sx={{ 
                height: 100, // Reduced from 140
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5 // Reduced from 2
              }}
            >
              <AutoJobLogo 
                variant="icon-only" 
                size="medium" // Reduced from large equivalent
                color="primary"
                sx={{ opacity: 0.7 }}
              />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', fontSize: '0.875rem' }}> {/* Added smaller fontSize */}
              Monitor your AI Agent's progress, view detailed reasoning logs, and manage
              your automated job search campaigns.
            </Typography>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default EmptySearchState;

================
File: frontend/src/components/jobs/components/EnhancedCircularProgress.js
================
// src/components/jobs/components/EnhancedCircularProgress.js
import React from 'react';
import {
  Box,
  Typography,
  CircularProgress,
  useTheme
} from '@mui/material';

export const EnhancedCircularProgress = ({ value, size = 120 }) => {
  const theme = useTheme();
  
  const getColor = (score) => {
    if (score >= 85) return theme.palette.success.main;
    if (score >= 70) return theme.palette.info.main;
    if (score >= 55) return theme.palette.warning.main;
    return theme.palette.error.main;
  };

  const getQualityLabel = (score) => {
    if (score >= 85) return 'Excellent';
    if (score >= 70) return 'Good';
    if (score >= 55) return 'Fair';
    return 'Needs Work';
  };

  return (
    <Box sx={{ position: 'relative', display: 'inline-flex', flexDirection: 'column', alignItems: 'center' }}>
      <Box sx={{ position: 'relative', display: 'inline-flex' }}>
        {/* Background circle */}
        <CircularProgress
          variant="determinate"
          size={size}
          thickness={6}
          value={100}
          sx={{ 
            color: getColor(value),
            opacity: 0.1,
            position: 'absolute'
          }}
        />
        {/* Progress circle */}
        <CircularProgress
          variant="determinate"
          size={size}
          thickness={6}
          value={value}
          sx={{ 
            color: getColor(value),
            transition: 'all 0.3s ease',
            '& .MuiCircularProgress-circle': {
              strokeLinecap: 'round',
            }
          }}
        />
        <Box
          sx={{
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
            position: 'absolute',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column'
          }}
        >
          <Typography variant="h3" component="div" fontWeight="bold" color={getColor(value)}>
            {Math.round(value)}%
          </Typography>
          <Typography variant="body2" color="text.secondary" fontWeight={500}>
            {getQualityLabel(value)}
          </Typography>
        </Box>
      </Box>
    </Box>
  );
};

================
File: frontend/src/components/jobs/components/JobAnalysisStatus.js
================
// src/components/jobs/components/JobAnalysisStatus.js
import React from 'react';
import {
  Box,
  Typography,
  LinearProgress,
  Chip,
  CircularProgress,
  Tooltip,
  Alert
} from '@mui/material';
import {
  HourglassEmpty as HourglassEmptyIcon,
  AutoAwesome as AutoAwesomeIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  SmartToy as SmartToyIcon
} from '@mui/icons-material';

const JobAnalysisStatus = ({ 
  analysisStatus, 
  size = 'normal', // 'small', 'normal', 'large'
  variant = 'full', // 'full', 'chip', 'progress-only'
  showDetails = true 
}) => {
  if (!analysisStatus) {
    return null;
  }

  const { status, progress, message, skillsFound, experienceLevel } = analysisStatus;

  // Status configuration
  const statusConfig = {
    pending: {
      label: 'Analysis Queued',
      color: 'info',
      icon: HourglassEmptyIcon,
      bgColor: 'rgba(2, 136, 209, 0.1)',
      textColor: '#0288d1'
    },
    analyzing: {
      label: 'Analyzing Job',
      color: 'primary',
      icon: AutoAwesomeIcon,
      bgColor: 'rgba(26, 115, 232, 0.1)',
      textColor: '#1a73e8'
    },
    completed: {
      label: 'Analysis Complete',
      color: 'success',
      icon: CheckCircleIcon,
      bgColor: 'rgba(52, 168, 83, 0.1)',
      textColor: '#34a853'
    },
    error: {
      label: 'Analysis Failed',
      color: 'error',
      icon: ErrorIcon,
      bgColor: 'rgba(234, 67, 53, 0.1)',
      textColor: '#ea4335'
    }
  };

  const config = statusConfig[status] || statusConfig.pending;
  const IconComponent = config.icon;

  // Size configurations
  const sizeConfig = {
    small: {
      iconSize: 16,
      chipHeight: 24,
      typography: 'caption',
      progressHeight: 4
    },
    normal: {
      iconSize: 20,
      chipHeight: 28,
      typography: 'body2',
      progressHeight: 6
    },
    large: {
      iconSize: 24,
      chipHeight: 32,
      typography: 'body1',
      progressHeight: 8
    }
  };

  const currentSize = sizeConfig[size];

  // Render chip variant
  if (variant === 'chip') {
    return (
      <Chip
        icon={
          status === 'analyzing' ? (
            <CircularProgress 
              size={currentSize.iconSize} 
              thickness={6} 
              color={config.color}
            />
          ) : (
            <IconComponent 
              sx={{ 
                fontSize: `${currentSize.iconSize}px !important`,
                color: config.textColor 
              }} 
            />
          )
        }
        label={config.label}
        size={size}
        sx={{
          height: currentSize.chipHeight,
          backgroundColor: config.bgColor,
          color: config.textColor,
          border: `1px solid ${config.textColor}`,
          fontWeight: 500,
          '& .MuiChip-icon': {
            color: `${config.textColor} !important`
          }
        }}
      />
    );
  }

  // Render progress only
  if (variant === 'progress-only') {
    return (
      <Box sx={{ width: '100%' }}>
        <LinearProgress
          variant="determinate"
          value={progress}
          color={config.color}
          sx={{
            height: currentSize.progressHeight,
            borderRadius: currentSize.progressHeight / 2,
            backgroundColor: config.bgColor,
            '& .MuiLinearProgress-bar': {
              borderRadius: currentSize.progressHeight / 2,
            }
          }}
        />
        {showDetails && (
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
            <Typography variant={currentSize.typography} color="text.secondary">
              {message}
            </Typography>
            <Typography variant={currentSize.typography} color="text.secondary">
              {progress}%
            </Typography>
          </Box>
        )}
      </Box>
    );
  }

  // Render full variant
  return (
    <Box
      sx={{
        p: size === 'small' ? 1.5 : 2,
        borderRadius: 2,
        backgroundColor: config.bgColor,
        border: `1px solid ${config.textColor}`,
        display: 'flex',
        alignItems: 'center',
        gap: 1.5
      }}
    >
      {/* Status Icon */}
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        {status === 'analyzing' ? (
          <CircularProgress 
            size={currentSize.iconSize} 
            thickness={6} 
            color={config.color}
          />
        ) : (
          <IconComponent 
            sx={{ 
              fontSize: currentSize.iconSize,
              color: config.textColor 
            }} 
          />
        )}
      </Box>

      {/* Status Content */}
      <Box sx={{ flex: 1, minWidth: 0 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
          <Typography 
            variant={currentSize.typography} 
            fontWeight={600}
            color={config.textColor}
            noWrap
          >
            {config.label}
          </Typography>
          
          {/* AI Badge for analyzing status */}
          {status === 'analyzing' && (
            <Chip
              icon={<SmartToyIcon sx={{ fontSize: '14px !important' }} />}
              label="AI"
              size="small"
              sx={{
                height: 18,
                fontSize: '0.7rem',
                backgroundColor: config.textColor,
                color: 'white',
                '& .MuiChip-icon': {
                  color: 'white !important'
                }
              }}
            />
          )}
        </Box>

        {/* Progress Bar for non-completed status */}
        {status !== 'completed' && status !== 'error' && (
          <Box sx={{ mb: 1 }}>
            <LinearProgress
              variant="determinate"
              value={progress}
              color={config.color}
              sx={{
                height: currentSize.progressHeight,
                borderRadius: currentSize.progressHeight / 2,
                backgroundColor: 'rgba(255,255,255,0.3)',
                '& .MuiLinearProgress-bar': {
                  borderRadius: currentSize.progressHeight / 2,
                }
              }}
            />
          </Box>
        )}

        {/* Status Message */}
        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          color={config.textColor}
          sx={{ opacity: 0.9 }}
        >
          {message}
        </Typography>

        {/* Success Details */}
        {status === 'completed' && showDetails && skillsFound !== undefined && (
          <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            <Chip
              label={`${skillsFound} skills found`}
              size="small"
              variant="outlined"
              sx={{
                height: 20,
                fontSize: '0.7rem',
                borderColor: config.textColor,
                color: config.textColor
              }}
            />
            {experienceLevel && (
              <Chip
                label={`${experienceLevel} level`}
                size="small"
                variant="outlined"
                sx={{
                  height: 20,
                  fontSize: '0.7rem',
                  borderColor: config.textColor,
                  color: config.textColor
                }}
              />
            )}
          </Box>
        )}

        {/* Error Details */}
        {status === 'error' && showDetails && (
          <Alert 
            severity="error" 
            sx={{ 
              mt: 1, 
              py: 0.5,
              fontSize: '0.75rem',
              '& .MuiAlert-icon': {
                fontSize: '1rem'
              }
            }}
          >
            Analysis failed. You can still view the job, but some features may be limited.
          </Alert>
        )}
      </Box>

      {/* Progress Percentage */}
      {(status === 'analyzing' || status === 'pending') && (
        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          fontWeight={600}
          color={config.textColor}
        >
          {progress}%
        </Typography>
      )}
    </Box>
  );
};

export default JobAnalysisStatus;

================
File: frontend/src/components/jobs/components/JobDetailsCard.js
================
// src/components/jobs/components/JobDetailsCard.js
import React from 'react';
import {
  Card,
  CardHeader,
  CardContent,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Typography,
  Divider
} from '@mui/material';
import {
  Work as WorkIcon,
  Business as BusinessIcon,
  LocationOn as LocationOnIcon,
  Schedule as ScheduleIcon,
  TrendingUp as TrendingUpIcon,
  AttachMoney as AttachMoneyIcon
} from '@mui/icons-material';

const JobDetailsCard = ({ job }) => {
  return (
    <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
      <CardHeader 
        title="Job Details" 
        avatar={<WorkIcon color="primary" />}
        sx={{ 
          pb: 1, 
          '& .MuiCardHeader-title': { fontWeight: 600 } 
        }}
      />
      <CardContent>
        <List sx={{ '& .MuiListItem-root': { py: 1.5 } }}>
          <ListItem>
            <ListItemIcon>
              <BusinessIcon color="primary" />
            </ListItemIcon>
            <ListItemText
              primary={<Typography variant="body2" color="text.secondary">Company</Typography>}
              secondary={<Typography variant="body1" fontWeight={500}>{job.company}</Typography>}
            />
          </ListItem>
          <Divider variant="inset" component="li" />
          
          <ListItem>
            <ListItemIcon>
              <LocationOnIcon color="primary" />
            </ListItemIcon>
            <ListItemText
              primary={<Typography variant="body2" color="text.secondary">Location</Typography>}
              secondary={
                <Typography variant="body1" fontWeight={500}>
                  {job.location?.city 
                    ? `${job.location.city}${job.location.state ? `, ${job.location.state}` : ''}`
                    : job.location?.remote ? 'Remote' : 'Location not specified'}
                </Typography>
              }
            />
          </ListItem>
          <Divider variant="inset" component="li" />
          
          <ListItem>
            <ListItemIcon>
              <ScheduleIcon color="primary" />
            </ListItemIcon>
            <ListItemText
              primary={<Typography variant="body2" color="text.secondary">Job Type</Typography>}
              secondary={<Typography variant="body1" fontWeight={500}>{job.jobType?.replace('_', ' ') || 'Full-time'}</Typography>}
            />
          </ListItem>
          
          {job.parsedData?.yearsOfExperience && (
            <>
              <Divider variant="inset" component="li" />
              <ListItem>
                <ListItemIcon>
                  <TrendingUpIcon color="primary" />
                </ListItemIcon>
                <ListItemText
                  primary={<Typography variant="body2" color="text.secondary">Experience Required</Typography>}
                  secondary={
                    <Typography variant="body1" fontWeight={500}>
                      {job.parsedData.yearsOfExperience.minimum || 0}
                      {job.parsedData.yearsOfExperience.preferred && job.parsedData.yearsOfExperience.preferred !== job.parsedData.yearsOfExperience.minimum 
                        ? `-${job.parsedData.yearsOfExperience.preferred}` 
                        : '+'} years
                    </Typography>
                  }
                />
              </ListItem>
            </>
          )}
          
          {job.salary?.min && (
            <>
              <Divider variant="inset" component="li" />
              <ListItem>
                <ListItemIcon>
                  <AttachMoneyIcon color="primary" />
                </ListItemIcon>
                <ListItemText
                  primary={<Typography variant="body2" color="text.secondary">Salary Range</Typography>}
                  secondary={
                    <Typography variant="body1" fontWeight={500}>
                      {`${job.salary.currency || '$'}${job.salary.min}${job.salary.max ? ` - ${job.salary.max}` : '+'}`}
                    </Typography>
                  }
                />
              </ListItem>
            </>
          )}
        </List>
      </CardContent>
    </Card>
  );
};

export default JobDetailsCard;

================
File: frontend/src/components/jobs/components/JobHeader.js
================
// src/components/jobs/components/JobHeader.js
import React from 'react';
import {
  Paper,
  Typography,
  Box,
  Chip,
  Button,
  IconButton,
  useTheme
} from '@mui/material';
import {
  Business as BusinessIcon,
  LocationOn as LocationOnIcon,
  SmartToy as SmartToyIcon,
  OpenInNew as OpenInNewIcon,
  MoreVert as MoreVertIcon,
  TrendingUp as TrendingUpIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

const JobHeader = ({ 
  job, 
  onTailorClick, 
  onMenuClick, 
  onOpenOriginal 
}) => {
  const theme = useTheme();

  // Safe AutoJobLogo wrapper component
  const SafeAutoJobLogo = ({ size = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={size} 
          showTagline={false}
        />
      );
    } catch (error) {
      // Fallback to SmartToy icon if AutoJobLogo fails
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: size === 'small' ? 16 : 20 }} />;
    }
  };

  // Custom chip icon for discovered jobs - properly sized and positioned
  const DiscoveredChipIcon = () => {
    try {
      return (
        <Box sx={{ 
          display: 'flex', 
          alignItems: 'center', 
          justifyContent: 'center', 
          width: 18, 
          height: 18,
          ml: 0.5  // Add left margin to bring logo closer to "Discovered" text
        }}>
          <AutoJobLogo 
            variant="icon-only" 
            size="small"
            showTagline={false}
            sx={{ 
              '& svg': { 
                width: 14, 
                height: 14,
                display: 'block'
              } 
            }}
          />
        </Box>
      );
    } catch (error) {
      console.warn('AutoJobLogo failed to render in chip:', error);
      return <SmartToyIcon sx={{ fontSize: 16 }} />;
    }
  };

  return (
    <Paper 
      elevation={2} 
      sx={{ 
        p: 3, 
        mb: 4, 
        borderRadius: 3,
        backgroundImage: `linear-gradient(135deg, ${theme.palette.background.paper} 0%, ${theme.palette.primary.light}15 100%)` 
      }}
    >
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap' }}>
        <Box>
          <Typography variant="h4" component="h1" fontWeight={700} color="primary">
            {job.title}
          </Typography>
          <Box sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
            <Chip 
              icon={<BusinessIcon />} 
              label={job.company} 
              size="small" 
              sx={{ mr: 1 }} 
            />
            {job.location && (
              <Chip 
                icon={<LocationOnIcon />} 
                label={job.location.city ? 
                  `${job.location.city}${job.location.state ? `, ${job.location.state}` : ''}` : 
                  job.location.remote ? 'Remote' : 'Location not specified'} 
                size="small"
                sx={{ mr: 1 }} 
              />
            )}
            {job.isAiGenerated && (
              <Chip 
                icon={<DiscoveredChipIcon />} 
                label="Discovered" 
                size="small"
                sx={{ 
                  mr: 1,
                  backgroundColor: '#00c4b4',
                  color: 'white',
                  '& .MuiChip-icon': {
                    color: 'white'
                  }
                }} 
              />
            )}
            {job.parsedData?.experienceLevel && (
              <Chip 
                icon={<TrendingUpIcon />} 
                label={job.parsedData.experienceLevel.charAt(0).toUpperCase() + job.parsedData.experienceLevel.slice(1)} 
                size="small"
                color="secondary"
                sx={{ mr: 1 }} 
              />
            )}
          </Box>
        </Box>
        
        <Box sx={{ display: 'flex', gap: 1 }}>
          {job.sourceUrl && (
            <Button
              variant="outlined"
              startIcon={<OpenInNewIcon />}
              onClick={onOpenOriginal}
              sx={{ borderRadius: 2 }}
            >
              Open Original
            </Button>
          )}
          <Button
            variant="contained"
            color="secondary"
            startIcon={<SafeAutoJobLogo size="small" />}
            onClick={onTailorClick}
            sx={{ borderRadius: 2 }}
          >
            Get Tailored Resume
          </Button>
          <IconButton
            onClick={onMenuClick}
            size="large"
            sx={{ ml: 1, border: '1px solid', borderColor: 'divider', borderRadius: 2 }}
          >
            <MoreVertIcon />
          </IconButton>
        </Box>
      </Box>
    </Paper>
  );
};

export default JobHeader;

================
File: frontend/src/components/jobs/components/MatchAnalysisCard.js
================
// src/components/jobs/components/MatchAnalysisCard.js
import React from 'react';
import {
  Card,
  CardHeader,
  CardContent,
  Box,
  Typography,
  LinearProgress,
  Chip,
  useTheme
} from '@mui/material';
import {
  Speed as SpeedIcon,
  CheckCircle as CheckCircleIcon,
  Info as InfoIcon,
  Warning as WarningIcon,
  Error as ErrorIcon
} from '@mui/icons-material';
import { EnhancedCircularProgress } from './EnhancedCircularProgress';

const MatchAnalysisCard = ({ job }) => {
  const theme = useTheme();

  const getScoreColor = (score) => {
    if (score >= 85) return 'success';
    if (score >= 70) return 'info';
    if (score >= 55) return 'warning';
    return 'error';
  };

  const getScoreIcon = (score) => {
    if (score >= 85) return <CheckCircleIcon color="success" />;
    if (score >= 70) return <InfoIcon color="info" />;
    if (score >= 55) return <WarningIcon color="warning" />;
    return <ErrorIcon color="error" />;
  };

  if (!job.matchAnalysis?.overallScore) {
    return null;
  }

  return (
    <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
      <CardHeader 
        title="Match Analysis" 
        avatar={<SpeedIcon color="primary" />}
        sx={{ 
          pb: 1, 
          '& .MuiCardHeader-title': { fontWeight: 600 } 
        }}
      />
      <CardContent sx={{ display: 'flex', justifyContent: 'center', flexDirection: 'column', alignItems: 'center' }}>
        <EnhancedCircularProgress 
          value={job.matchAnalysis.overallScore}
          size={120}
        />
        
        <Box sx={{ width: '100%', mt: 3 }}>
          {['skills', 'experience', 'education'].map((category) => {
            const score = job.matchAnalysis.categoryScores?.[category] || 0;
            return (
              <Box key={category} sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body1" sx={{ textTransform: 'capitalize' }}>
                    {category} Match
                  </Typography>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    {getScoreIcon(score)}
                    <Typography variant="h6" fontWeight="medium" color={getScoreColor(score)}>
                      {score}%
                    </Typography>
                  </Box>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={score}
                  sx={{
                    height: 8,
                    borderRadius: 4,
                    bgcolor: 'rgba(0,0,0,0.1)',
                    '& .MuiLinearProgress-bar': {
                      borderRadius: 4,
                      bgcolor: theme.palette[getScoreColor(score)].main,
                    }
                  }}
                />
              </Box>
            );
          })}
        </Box>

        {job.matchAnalysis.matchedSkills && (
          <Box sx={{ width: '100%', mt: 2, p: 2, bgcolor: 'action.hover', borderRadius: 2 }}>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              <strong>Skills:</strong> {job.matchAnalysis.matchedSkills.filter(s => s.found).length} of {job.matchAnalysis.matchedSkills.length} matched
            </Typography>
            {job.matchAnalysis.experienceAnalysis && (
              <Typography variant="body2" color="text.secondary">
                <strong>Experience:</strong> {job.matchAnalysis.experienceAnalysis.relevantYearsExperience || 0} years relevant
              </Typography>
            )}
          </Box>
        )}
      </CardContent>
    </Card>
  );
};

export default MatchAnalysisCard;

================
File: frontend/src/components/jobs/components/SkillChip.js
================
// src/components/jobs/components/SkillChip.js
import React from 'react';
import {
  Chip,
  Tooltip,
  Box,
  Typography,
  useTheme
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  Info as InfoIcon
} from '@mui/icons-material';

const SkillChip = ({ skill, isMatched, importance, matchQuality }) => {
  const theme = useTheme();
  
  // Extract skill name safely from different skill object structures
  const getSkillName = (skillObj) => {
    if (!skillObj) return 'Unknown Skill';
    if (typeof skillObj === 'string') return skillObj;
    if (typeof skillObj === 'object') {
      return skillObj.name || skillObj.skill || (skillObj.toString && typeof skillObj.toString === 'function' ? skillObj.toString() : 'Unknown Skill');
    }
    return 'Unknown Skill';
  };

  const skillName = getSkillName(skill);
  
  const getImportanceColor = (imp) => {
    if (!imp && imp !== 0) return theme.palette.info.main;
    if (imp >= 8) return theme.palette.error.main;
    if (imp >= 6) return theme.palette.warning.main;
    return theme.palette.info.main;
  };

  const getMatchQualityIcon = (quality) => {
    if (!quality) return null;
    switch (quality) {
      case 'exact': return <CheckCircleIcon fontSize="small" />;
      case 'partial': return <WarningIcon fontSize="small" />;
      case 'related': return <InfoIcon fontSize="small" />;
      default: return null;
    }
  };

  return (
    <Tooltip 
      title={
        <Box>
          <Typography variant="body2" fontWeight="bold">{skillName}</Typography>
          {importance && <Typography variant="caption">Importance: {importance}/10</Typography>}
          {matchQuality && <Typography variant="caption" display="block">Match: {matchQuality}</Typography>}
        </Box>
      }
    >
      <Chip 
        label={skillName}
        icon={isMatched ? getMatchQualityIcon(matchQuality) : null}
        variant={isMatched ? 'filled' : 'outlined'}
        color={isMatched ? 'success' : 'default'}
        size="medium"
        sx={{ 
          bgcolor: isMatched ? `${theme.palette.success.main}30` : 'transparent',
          color: isMatched ? theme.palette.success.dark : theme.palette.text.primary,
          fontWeight: 500,
          borderRadius: 2,
          border: isMatched 
            ? `2px solid ${theme.palette.success.main}` 
            : `1px solid ${getImportanceColor(importance || 5)}40`,
          borderLeftWidth: 4,
          borderLeftColor: getImportanceColor(importance || 5),
          transition: 'all 0.2s ease',
          '&:hover': {
            transform: 'translateY(-1px)',
            boxShadow: 2,
            bgcolor: isMatched ? `${theme.palette.success.main}40` : `${getImportanceColor(importance || 5)}10`,
          }
        }}
      />
    </Tooltip>
  );
};

export default SkillChip;

================
File: frontend/src/components/jobs/FindJobsDialog.js
================
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Stepper,
  Step,
  StepLabel,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  CircularProgress,
  IconButton,
  Chip,
  Paper,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Divider,
  StepConnector,
  stepConnectorClasses,
  styled
} from '@mui/material';
import {
  Close as CloseIcon,
  Description as DescriptionIcon,
  Search as SearchIcon,
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
  TrendingUp as TrendingUpIcon,
  Work as WorkIcon,
  CalendarToday as CalendarIcon,
  Speed as SpeedIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import resumeService from '../../utils/resumeService';
import jobService from '../../utils/jobService';
import AutoJobLogo from '../common/AutoJobLogo';

// Custom styled components for better theming
const CustomStepConnector = styled(StepConnector)(({ theme }) => ({
  [`&.${stepConnectorClasses.alternativeLabel}`]: {
    top: 22,
  },
  [`&.${stepConnectorClasses.active}`]: {
    [`& .${stepConnectorClasses.line}`]: {
      backgroundColor: theme.palette.primary.main,
    },
  },
  [`&.${stepConnectorClasses.completed}`]: {
    [`& .${stepConnectorClasses.line}`]: {
      backgroundColor: theme.palette.success.main,
    },
  },
  [`& .${stepConnectorClasses.line}`]: {
    height: 3,
    border: 0,
    backgroundColor: theme.palette.divider,
    borderRadius: 1,
  },
}));

const FeatureBox = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(2.5),
  backgroundColor: theme.palette.background.default,
  border: `1px solid ${theme.palette.divider}`,
  borderRadius: theme.spacing(1.5),
  transition: 'all 0.2s ease-in-out',
  '&:hover': {
    borderColor: theme.palette.primary.light,
    backgroundColor: theme.palette.background.paper,
  },
}));

const SuccessBox = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(3),
  backgroundColor: theme.palette.success.light,
  border: `1px solid ${theme.palette.success.main}`,
  borderRadius: theme.spacing(1.5),
  '& .MuiTypography-root': {
    color: theme.palette.success.contrastText,
  },
}));

const FindJobsDialog = ({ open, onClose }) => {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  const [resumes, setResumes] = useState([]);
  const [selectedResumeId, setSelectedResumeId] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [searchStarted, setSearchStarted] = useState(false);
  const [resumesLoading, setResumesLoading] = useState(true);

  const steps = ['Select Resume', 'Confirm Search', 'Search Started'];

  useEffect(() => {
    if (open) {
      fetchResumes();
      // Reset state when dialog opens
      setActiveStep(0);
      setSelectedResumeId('');
      setError('');
      setSearchStarted(false);
    }
  }, [open]);

  const fetchResumes = async () => {
    try {
      setResumesLoading(true);
      setError('');
      const resumesData = await resumeService.getUserResumes();
      setResumes(resumesData || []);
      
      if (resumesData && resumesData.length === 1) {
        setSelectedResumeId(resumesData[0]._id);
      }
    } catch (err) {
      console.error('Error fetching resumes:', err);
      setError('Failed to load resumes. Please try again.');
    } finally {
      setResumesLoading(false);
    }
  };

  const handleNext = () => {
    if (activeStep === 0 && !selectedResumeId) {
      setError('Please select a resume to continue');
      return;
    }
    
    if (activeStep === 1) {
      handleStartSearch();
    } else {
      setActiveStep((prevStep) => prevStep + 1);
      setError('');
    }
  };

  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
    setError('');
  };

  const handleClose = () => {
    if (!searchStarted || activeStep === 2) {
      setActiveStep(0);
      setSelectedResumeId('');
      setError('');
      setSearchStarted(false);
      onClose();
    }
  };

  const handleStartSearch = async () => {
    try {
      setLoading(true);
      setError('');
      setSearchStarted(true);

      const response = await jobService.findJobsWithAi(selectedResumeId);
      
      // The backend returns a 202 status with a message
      // This is actually a success response, not an error
      console.log('AI Search Response:', response);
      
      // Move to success step
      setActiveStep(2);
    } catch (err) {
      console.error('Error starting AI job search:', err);
      
      // Check if this is actually a success response (202 status)
      if (err.response && err.response.status === 202) {
        // This is actually success - the backend returns 202 for async operations
        setActiveStep(2);
      } else {
        // This is a real error
        setError(err.response?.data?.message || err.message || 'Failed to start job search. Please try again.');
        setSearchStarted(false);
      }
    } finally {
      setLoading(false);
    }
  };

  const getSelectedResume = () => {
    return resumes.find(r => r._id === selectedResumeId);
  };

  const renderStepContent = () => {
    switch (activeStep) {
      case 0:
        return (
          <Box sx={{ mt: 2 }}>
            <Typography variant="body1" paragraph color="text.secondary">
              Select a resume to use for AI job discovery. AJ will analyze your resume and search for relevant job opportunities for you.
            </Typography>
            
            {resumesLoading ? (
              <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                <CircularProgress size={40} thickness={4} />
              </Box>
            ) : resumes.length === 0 ? (
              <Alert 
                severity="warning" 
                sx={{ 
                  mt: 2,
                  borderRadius: 2,
                  '& .MuiAlert-icon': {
                    fontSize: '1.5rem'
                  }
                }}
              >
                <Typography variant="body2" fontWeight={500} gutterBottom>
                  You don't have any resumes uploaded yet.
                </Typography>
                <Typography variant="body2">
                  Please upload a resume first before using the AI job search feature.
                </Typography>
              </Alert>
            ) : (
              <>
                <FormControl fullWidth sx={{ mt: 3 }}>
                  <InputLabel id="resume-select-label">Select Resume</InputLabel>
                  <Select
                    labelId="resume-select-label"
                    value={selectedResumeId}
                    onChange={(e) => setSelectedResumeId(e.target.value)}
                    label="Select Resume"
                    sx={{
                      borderRadius: 2,
                      '& .MuiSelect-select': {
                        py: 1.5,
                      }
                    }}
                  >
                    {resumes.map((resume) => (
                      <MenuItem key={resume._id} value={resume._id}>
                        <Box sx={{ width: '100%' }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                            <Typography variant="body1" fontWeight={500}>{resume.name}</Typography>
                            {resume.isTailored && (
                              <Chip 
                                label="AI Tailored" 
                                size="small" 
                                color="secondary"
                                sx={{ ml: 1, borderRadius: 1 }}
                              />
                            )}
                          </Box>
                          <Typography variant="caption" color="text.secondary">
                            Updated: {new Date(resume.updatedAt || resume.createdAt).toLocaleDateString()}
                            {resume.analysis?.overallScore && ` • Score: ${resume.analysis.overallScore}/100`}
                          </Typography>
                        </Box>
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>

                {selectedResumeId && getSelectedResume() && (
                  <FeatureBox sx={{ mt: 3 }}>
                    <Typography variant="subtitle2" fontWeight={600} gutterBottom color="primary">
                      Selected Resume Details
                    </Typography>
                    {(() => {
                      const selected = getSelectedResume();
                      return (
                        <List dense disablePadding>
                          <ListItem disableGutters>
                            <ListItemIcon sx={{ minWidth: 36 }}>
                              <DescriptionIcon fontSize="small" color="primary" />
                            </ListItemIcon>
                            <ListItemText 
                              primary={selected.name}
                              secondary={`File type: ${selected.fileType}`}
                              primaryTypographyProps={{ fontWeight: 500 }}
                            />
                          </ListItem>
                          {selected.parsedData?.experience?.[0] && (
                            <ListItem disableGutters>
                              <ListItemIcon sx={{ minWidth: 36 }}>
                                <WorkIcon fontSize="small" color="info" />
                              </ListItemIcon>
                              <ListItemText 
                                primary="Current/Recent Role"
                                secondary={`${selected.parsedData.experience[0].title} at ${selected.parsedData.experience[0].company}`}
                                primaryTypographyProps={{ fontWeight: 500 }}
                              />
                            </ListItem>
                          )}
                        </List>
                      );
                    })()}
                  </FeatureBox>
                )}
              </>
            )}
          </Box>
        );

      case 1:
        const selectedResume = getSelectedResume();
        return (
          <Box sx={{ mt: 2 }}>
            <Box sx={{ textAlign: 'center', mb: 3 }}>
              <AutoJobLogo 
                variant="icon-only" 
                size="large" 
                color="primary"
                sx={{ mb: 2 }}
              />
              <Typography variant="h6" gutterBottom fontWeight={600} color="text.primary">
                Ready to Let AJ our AI Agent Do Your Job Search?
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Our trained AI Agent will search for real job openings that match your profile
              </Typography>
            </Box>

            <Alert 
              severity="info" 
              icon={<InfoIcon />} 
              sx={{ 
                mb: 3,
                borderRadius: 2,
                backgroundColor: 'info.light',
                border: '1px solid',
                borderColor: 'info.main',
                '& .MuiAlert-icon': {
                  fontSize: '1.5rem'
                }
              }}
            >
              <Typography variant="body2" fontWeight={600} gutterBottom>
                Daily Job Limit: Up to 10 Jobs
              </Typography>
              <Typography variant="body2">
                AJ will find and add up to 10 relevant job openings per day to your job list. 
                The search will continue running daily until you pause or cancel it.
              </Typography>
            </Alert>

            <FeatureBox sx={{ mb: 3 }}>
              <Typography variant="subtitle2" fontWeight={600} gutterBottom color="primary">
                How it works:
              </Typography>
              <List dense>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <SearchIcon fontSize="small" color="success" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Real Job Search"
                    secondary="Our AI Agent acts like a human and searches for real openings"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <CalendarIcon fontSize="small" color="info" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Daily Updates"
                    secondary="Finds up to 10 new jobs per day matching your profile"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <SpeedIcon fontSize="small" color="warning" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Automatic Process"
                    secondary="Runs in the background - you can close this and check back later"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <CheckCircleIcon fontSize="small" color="success" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Quality Matches"
                    secondary="Only adds jobs that closely match your skills and experience"
                    primaryTypographyProps={{ fontWeight: 500 }}
                  />
                </ListItem>
              </List>
            </FeatureBox>

            <Alert 
              severity="warning" 
              icon={<WarningIcon />}
              sx={{
                borderRadius: 2,
                backgroundColor: 'warning.light',
                border: '1px solid',
                borderColor: 'warning.main',
                '& .MuiAlert-icon': {
                  fontSize: '1.5rem'
                }
              }}
            >
              <Typography variant="body2">
                <strong>Note:</strong> If no matching jobs are found, the search will notify you and provide suggestions for improving your search criteria.
              </Typography>
            </Alert>

            {loading && (
              <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                <CircularProgress size={40} thickness={4} />
              </Box>
            )}
          </Box>
        );

      case 2:
        return (
          <Box sx={{ mt: 2, textAlign: 'center' }}>
            <CheckCircleIcon sx={{ fontSize: 80, color: 'success.main', mb: 2 }} />
            <Typography variant="h6" gutterBottom fontWeight={600}>
              AI Job Search Started!
            </Typography>
            <Typography variant="body1" paragraph color="text.secondary">
              Your AI job search is now running in the background.
            </Typography>
            
            <SuccessBox sx={{ mb: 3 }}>
              <Typography variant="body1" fontWeight={600} gutterBottom sx={{ color: 'success.dark !important' }}>
                What happens next:
              </Typography>
              <List dense>
                <ListItem sx={{ px: 0 }}>
                  <ListItemText 
                    primary="• Up to 10 relevant jobs will be added daily"
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      sx: { color: 'success.dark' }
                    }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemText 
                    primary="• Jobs will appear in your job list marked with 'AI Found'"
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      sx: { color: 'success.dark' }
                    }}
                  />
                </ListItem>
                <ListItem sx={{ px: 0 }}>
                  <ListItemText 
                    primary="• You'll receive notifications for new matches"
                    primaryTypographyProps={{ 
                      variant: 'body2',
                      sx: { color: 'success.dark' }
                    }}
                  />
                </ListItem>
              </List>
            </SuccessBox>
            
            <Button
              variant="contained"
              color="primary"
              onClick={() => {
                handleClose();
                navigate('/jobs/ai-searches');
              }}
              sx={{ 
                mb: 2,
                px: 4,
                py: 1.5,
                borderRadius: 2,
                fontWeight: 600,
                textTransform: 'none'
              }}
            >
              View AI Searches
            </Button>
            
            <Typography variant="body2" color="text.secondary">
              You can manage your AI job searches from the AI Discovery page
            </Typography>
          </Box>
        );

      default:
        return null;
    }
  };

  return (
    <Dialog 
      open={open} 
      onClose={handleClose}
      maxWidth="sm"
      fullWidth
      disableEscapeKeyDown={searchStarted && activeStep !== 2}
      PaperProps={{
        sx: {
          borderRadius: 3,
          boxShadow: '0px 8px 32px rgba(0, 0, 0, 0.12)',
        }
      }}
    >
      <DialogTitle>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <AutoJobLogo 
              variant="icon-only" 
              size="small" 
              color="primary"
              sx={{ mr: 1.5 }}
            />
            <Typography variant="h6" fontWeight={600}>Find Jobs with AJ</Typography>
          </Box>
          <IconButton 
            onClick={handleClose} 
            size="small"
            disabled={searchStarted && activeStep !== 2}
            sx={{
              '&:hover': {
                backgroundColor: 'action.hover',
              }
            }}
          >
            <CloseIcon />
          </IconButton>
        </Box>
      </DialogTitle>
      
      <DialogContent sx={{ px: 3 }}>
        <Stepper 
          activeStep={activeStep} 
          connector={<CustomStepConnector />}
          sx={{ 
            mb: 3,
            '& .MuiStepLabel-label': {
              fontWeight: 500,
              fontSize: '0.875rem'
            },
            '& .MuiStepLabel-label.Mui-active': {
              fontWeight: 600,
              color: 'primary.main'
            },
            '& .MuiStepLabel-label.Mui-completed': {
              color: 'success.main'
            }
          }}
        >
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {error && (
          <Alert 
            severity="error" 
            sx={{ 
              mb: 2,
              borderRadius: 2,
              '& .MuiAlert-icon': {
                fontSize: '1.5rem'
              }
            }} 
            onClose={() => setError('')}
          >
            {error}
          </Alert>
        )}
        
        {renderStepContent()}
      </DialogContent>
      
      <DialogActions sx={{ px: 3, pb: 3, gap: 1 }}>
        {activeStep === 0 && (
          <>
            <Button 
              onClick={handleClose}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 500
              }}
            >
              Cancel
            </Button>
            <Button 
              variant="contained" 
              onClick={handleNext}
              disabled={!selectedResumeId || resumesLoading}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 600,
                px: 3
              }}
            >
              Next
            </Button>
          </>
        )}
        
        {activeStep === 1 && (
          <>
            <Button 
              onClick={handleBack} 
              disabled={loading}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 500
              }}
            >
              Back
            </Button>
            <Button 
              variant="contained" 
              onClick={handleNext}
              disabled={loading}
              startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <SearchIcon />}
              sx={{ 
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 600,
                px: 3
              }}
            >
              {loading ? 'Starting...' : 'Start AI Search'}
            </Button>
          </>
        )}
        
        {activeStep === 2 && (
          <Button 
            variant="contained" 
            onClick={handleClose}
            sx={{ 
              borderRadius: 2,
              textTransform: 'none',
              fontWeight: 600,
              px: 4
            }}
          >
            Done
          </Button>
        )}
      </DialogActions>
    </Dialog>
  );
};

export default FindJobsDialog;

================
File: frontend/src/components/jobs/hooks/useAiSearches.js
================
// src/components/jobs/hooks/useAiSearches.js
import { useState, useEffect } from 'react';
import jobService from '../../../utils/jobService';

export const useAiSearches = () => {
  const [searches, setSearches] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [actionLoading, setActionLoading] = useState({});

  const fetchSearches = async () => {
    try {
      const data = await jobService.getAiSearches();
      // Filter out cancelled searches from the UI
      const activeSearches = data.filter(search => search.status !== 'cancelled');
      setSearches(activeSearches);
      setError('');
    } catch (err) {
      console.error('Error fetching AI searches:', err);
      setError('Failed to load AI searches');
    } finally {
      setLoading(false);
    }
  };

  const handlePauseResume = async (searchId, currentStatus) => {
    setActionLoading(prev => ({ ...prev, [searchId]: true }));
    try {
      if (currentStatus === 'running') {
        await jobService.pauseAiSearch(searchId);
        return { success: true, message: 'Search paused successfully' };
      } else if (currentStatus === 'paused') {
        await jobService.resumeAiSearch(searchId);
        return { success: true, message: 'Search resumed successfully' };
      }
      await fetchSearches();
    } catch (err) {
      console.error('Error updating search:', err);
      setError('Failed to update search status');
      return { success: false, message: 'Failed to update search status' };
    } finally {
      setActionLoading(prev => ({ ...prev, [searchId]: false }));
    }
  };

  const handleDelete = async (searchId) => {
    setActionLoading(prev => ({ ...prev, [searchId]: true }));
    try {
      await jobService.deleteAiSearch(searchId);
      await fetchSearches();
      return { success: true, message: 'Search cancelled successfully' };
    } catch (err) {
      console.error('Error deleting search:', err);
      setError('Failed to delete search');
      return { success: false, message: 'Failed to cancel search' };
    } finally {
      setActionLoading(prev => ({ ...prev, [searchId]: false }));
    }
  };

  useEffect(() => {
    fetchSearches();
    // Refresh every 30 seconds to show updates
    const interval = setInterval(fetchSearches, 30000);
    return () => clearInterval(interval);
  }, []);

  return {
    searches,
    loading,
    error,
    actionLoading,
    setError,
    fetchSearches,
    handlePauseResume,
    handleDelete
  };
};

================
File: frontend/src/components/jobs/hooks/useJobAnalysis.js
================
// src/components/jobs/hooks/useJobAnalysis.js
import { useState, useEffect, useCallback } from 'react';
import jobService from '../../../utils/jobService';

/**
 * Custom hook for managing job analysis status and polling
 * @param {string} jobId - The ID of the job to monitor
 * @param {Object} options - Configuration options
 * @returns {Object} Analysis status and control functions
 */
export const useJobAnalysis = (jobId, options = {}) => {
  const {
    autoStart = true,
    pollInterval = 2000,
    maxAttempts = 30,
    onComplete = null,
    onError = null,
    onProgress = null
  } = options;

  const [analysisStatus, setAnalysisStatus] = useState(null);
  const [isPolling, setIsPolling] = useState(false);
  const [error, setError] = useState(null);
  const [attempts, setAttempts] = useState(0);

  // Check if analysis is complete
  const isComplete = analysisStatus?.status === 'completed' || analysisStatus?.status === 'error';
  const canViewJob = analysisStatus?.canViewJob === true;

  // Fetch current status
  const fetchStatus = useCallback(async () => {
    if (!jobId) return null;

    try {
      const response = await jobService.getJobAnalysisStatus(jobId);
      const status = response.analysisStatus;
      
      setAnalysisStatus(status);
      setError(null);
      
      // Call progress callback
      if (onProgress && typeof onProgress === 'function') {
        onProgress(status);
      }
      
      return status;
    } catch (err) {
      console.error('Error fetching job analysis status:', err);
      setError(err.message || 'Failed to fetch analysis status');
      
      if (onError && typeof onError === 'function') {
        onError(err);
      }
      
      return null;
    }
  }, [jobId, onProgress, onError]);

  // Start polling for status updates
  const startPolling = useCallback(async () => {
    if (!jobId || isPolling) return;

    setIsPolling(true);
    setAttempts(0);
    setError(null);

    let currentAttempts = 0;
    let pollTimeoutId;

    const poll = async () => {
      try {
        currentAttempts++;
        setAttempts(currentAttempts);

        const status = await fetchStatus();
        
        if (!status) {
          throw new Error('Failed to fetch status');
        }

        // Check if analysis is complete
        if (status.status === 'completed' || status.status === 'error') {
          setIsPolling(false);
          
          if (onComplete && typeof onComplete === 'function') {
            onComplete(status);
          }
          
          return;
        }

        // Check if we've reached max attempts
        if (currentAttempts >= maxAttempts) {
          setIsPolling(false);
          const timeoutError = new Error('Analysis polling timed out');
          setError(timeoutError.message);
          
          if (onError && typeof onError === 'function') {
            onError(timeoutError);
          }
          
          return;
        }

        // Schedule next poll
        pollTimeoutId = setTimeout(poll, pollInterval);
        
      } catch (err) {
        console.error('Error during polling:', err);
        setIsPolling(false);
        setError(err.message || 'Polling failed');
        
        if (onError && typeof onError === 'function') {
          onError(err);
        }
      }
    };

    // Start polling
    await poll();

    // Return cleanup function
    return () => {
      if (pollTimeoutId) {
        clearTimeout(pollTimeoutId);
      }
      setIsPolling(false);
    };
  }, [jobId, isPolling, fetchStatus, pollInterval, maxAttempts, onComplete, onError]);

  // Stop polling
  const stopPolling = useCallback(() => {
    setIsPolling(false);
  }, []);

  // Reset analysis status
  const reset = useCallback(() => {
    setAnalysisStatus(null);
    setError(null);
    setAttempts(0);
    setIsPolling(false);
  }, []);

  // Auto-start polling if job needs analysis
  useEffect(() => {
    if (!autoStart || !jobId) return;

    const initializeAnalysis = async () => {
      const status = await fetchStatus();
      
      // Start polling if analysis is in progress
      if (status && (status.status === 'pending' || status.status === 'analyzing')) {
        startPolling();
      }
    };

    initializeAnalysis();
  }, [jobId, autoStart, fetchStatus, startPolling]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      setIsPolling(false);
    };
  }, []);

  return {
    // Status data
    analysisStatus,
    isPolling,
    error,
    attempts,
    
    // Computed states
    isComplete,
    canViewJob,
    isPending: analysisStatus?.status === 'pending',
    isAnalyzing: analysisStatus?.status === 'analyzing',
    hasError: analysisStatus?.status === 'error',
    progress: analysisStatus?.progress || 0,
    message: analysisStatus?.message || '',
    skillsFound: analysisStatus?.skillsFound || 0,
    experienceLevel: analysisStatus?.experienceLevel,
    
    // Control functions
    startPolling,
    stopPolling,
    fetchStatus,
    reset
  };
};

/**
 * Hook for managing multiple job analysis statuses
 * @param {Array} jobIds - Array of job IDs to monitor
 * @param {Object} options - Configuration options
 * @returns {Object} Analysis statuses and control functions
 */
export const useMultipleJobAnalysis = (jobIds = [], options = {}) => {
  const [statuses, setStatuses] = useState({});
  const [pollingJobs, setPollingJobs] = useState(new Set());

  const updateJobStatus = useCallback((jobId, status) => {
    setStatuses(prev => ({
      ...prev,
      [jobId]: status
    }));
  }, []);

  const startPollingJob = useCallback(async (jobId) => {
    if (pollingJobs.has(jobId)) return;

    setPollingJobs(prev => new Set([...prev, jobId]));

    try {
      await jobService.pollJobAnalysisStatus(
        jobId,
        (status) => updateJobStatus(jobId, status),
        options.maxAttempts || 30
      );
    } catch (error) {
      console.error(`Polling failed for job ${jobId}:`, error);
      updateJobStatus(jobId, {
        status: 'error',
        message: 'Polling failed',
        progress: 0
      });
    } finally {
      setPollingJobs(prev => {
        const newSet = new Set(prev);
        newSet.delete(jobId);
        return newSet;
      });
    }
  }, [pollingJobs, updateJobStatus, options.maxAttempts]);

  // Initialize polling for jobs that need it
  useEffect(() => {
    jobIds.forEach(async (jobId) => {
      if (!statuses[jobId] && !pollingJobs.has(jobId)) {
        try {
          const response = await jobService.getJobAnalysisStatus(jobId);
          const status = response.analysisStatus;
          
          updateJobStatus(jobId, status);
          
          // Start polling if needed
          if (status.status === 'pending' || status.status === 'analyzing') {
            startPollingJob(jobId);
          }
        } catch (error) {
          console.error(`Error fetching status for job ${jobId}:`, error);
        }
      }
    });
  }, [jobIds, statuses, pollingJobs, updateJobStatus, startPollingJob]);

  const getJobStatus = useCallback((jobId) => {
    return statuses[jobId] || null;
  }, [statuses]);

  const isJobPolling = useCallback((jobId) => {
    return pollingJobs.has(jobId);
  }, [pollingJobs]);

  const getAnalyzingCount = useCallback(() => {
    return Object.values(statuses).filter(status => 
      status.status === 'pending' || status.status === 'analyzing'
    ).length;
  }, [statuses]);

  const getCompletedCount = useCallback(() => {
    return Object.values(statuses).filter(status => 
      status.status === 'completed'
    ).length;
  }, [statuses]);

  const getErrorCount = useCallback(() => {
    return Object.values(statuses).filter(status => 
      status.status === 'error'
    ).length;
  }, [statuses]);

  return {
    statuses,
    pollingJobs,
    getJobStatus,
    isJobPolling,
    getAnalyzingCount,
    getCompletedCount,
    getErrorCount,
    updateJobStatus,
    startPollingJob
  };
};

export default useJobAnalysis;

================
File: frontend/src/components/jobs/JobCreateDialog.js
================
// src/components/jobs/JobCreateDialog.js
import React, { useState } from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Button, 
  TextField, 
  Grid, 
  Box, 
  FormControl, 
  InputLabel, 
  Select, 
  MenuItem, 
  Switch, 
  FormControlLabel, 
  Typography, 
  Divider, 
  Alert,
  CircularProgress,
  Paper,
  InputAdornment,
  useTheme
} from '@mui/material';
import { 
  Add as AddIcon,
  Close as CloseIcon,
  Work as WorkIcon,
  Business as BusinessIcon,
  Link as LinkIcon,
  LocationOn as LocationOnIcon,
  Public as PublicIcon,
  Schedule as ScheduleIcon,
  AttachMoney as AttachMoneyIcon,
  Description as DescriptionIcon,
  Home as HomeIcon
} from '@mui/icons-material';
import jobService from '../../utils/jobService';

const JobCreateDialog = ({ open, onClose, onJobCreated }) => {
  const theme = useTheme();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  const [jobData, setJobData] = useState({
    title: '',
    company: '',
    location: {
      city: '',
      state: '',
      country: 'US',
      remote: false
    },
    description: '',
    sourceUrl: '',
    salary: {
      min: '',
      max: '',
      currency: 'USD'
    },
    jobType: 'FULL_TIME'
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    
    // Handle nested properties
    if (name.includes('.')) {
      const [parent, child] = name.split('.');
      setJobData(prev => ({
        ...prev,
        [parent]: {
          ...prev[parent],
          [child]: value
        }
      }));
    } else {
      setJobData(prev => ({
        ...prev,
        [name]: value
      }));
    }
  };

  const handleSwitchChange = (e) => {
    const { name, checked } = e.target;
    
    if (name === 'location.remote') {
      setJobData(prev => ({
        ...prev,
        location: {
          ...prev.location,
          remote: checked
        }
      }));
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate form
    if (!jobData.title || !jobData.company || !jobData.description) {
      setError('Job title, company, and description are required');
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      // Clean up salary data
      const formattedJobData = {
        ...jobData,
        salary: {
          ...jobData.salary,
          min: jobData.salary.min ? Number(jobData.salary.min) : undefined,
          max: jobData.salary.max ? Number(jobData.salary.max) : undefined
        }
      };
      
      await jobService.createJob(formattedJobData);
      
      // Clear form and close dialog
      setJobData({
        title: '',
        company: '',
        location: {
          city: '',
          state: '',
          country: 'US',
          remote: false
        },
        description: '',
        sourceUrl: '',
        salary: {
          min: '',
          max: '',
          currency: 'USD'
        },
        jobType: 'FULL_TIME'
      });
      
      onJobCreated();
    } catch (err) {
      console.error('Error creating job:', err);
      setError(err.response?.data?.message || 'Failed to create job. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleCancel = () => {
    // Clear form
    setJobData({
      title: '',
      company: '',
      location: {
        city: '',
        state: '',
        country: 'US',
        remote: false
      },
      description: '',
      sourceUrl: '',
      salary: {
        min: '',
        max: '',
        currency: 'USD'
      },
      jobType: 'FULL_TIME'
    });
    setError('');
    onClose();
  };

  return (
    <Dialog 
      open={open} 
      onClose={loading ? null : handleCancel}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: { 
          borderRadius: 3,
          // Custom scrollbar styling specifically for this dialog
          '& .MuiDialogContent-root': {
            // Override scrollbar for dialog content
            '&::-webkit-scrollbar': {
              width: '4px',
            },
            '&::-webkit-scrollbar-track': {
              backgroundColor: 'transparent',
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0, 0, 0, 0.2)',
              borderRadius: '2px',
              '&:hover': {
                backgroundColor: 'rgba(0, 0, 0, 0.3)',
              },
              '&:active': {
                backgroundColor: 'rgba(0, 0, 0, 0.4)',
              },
            },
            '&::-webkit-scrollbar-corner': {
              backgroundColor: 'transparent',
            },
            // Firefox scrollbar styling
            scrollbarWidth: 'thin',
            scrollbarColor: 'rgba(0, 0, 0, 0.2) transparent',
          }
        }
      }}
    >
      <DialogTitle sx={{ 
        background: `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.light} 100%)`,
        color: 'white',
        py: 2
      }}>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
            <WorkIcon sx={{ fontSize: 28 }} />
            <Typography variant="h6" fontWeight={600}>Add New Job</Typography>
          </Box>
          <Button 
            color="inherit" 
            onClick={handleCancel}
            disabled={loading}
            sx={{ 
              minWidth: 'auto', 
              p: 1,
              borderRadius: 2,
              '&:hover': {
                bgcolor: 'rgba(255,255,255,0.1)'
              }
            }}
          >
            <CloseIcon />
          </Button>
        </Box>
      </DialogTitle>
      
      <form onSubmit={handleSubmit}>
        <DialogContent sx={{ 
          p: 3,
          // Enhanced scrollbar styling for the content area
          maxHeight: '70vh',
          overflowY: 'auto',
          // Custom scrollbar that matches your theme
          '&::-webkit-scrollbar': {
            width: '4px',
          },
          '&::-webkit-scrollbar-track': {
            backgroundColor: 'transparent',
          },
          '&::-webkit-scrollbar-thumb': {
            backgroundColor: 'rgba(0, 0, 0, 0.2)',
            borderRadius: '2px',
            '&:hover': {
              backgroundColor: 'rgba(0, 0, 0, 0.3)',
            },
            '&:active': {
              backgroundColor: 'rgba(0, 0, 0, 0.4)',
            },
          },
          '&::-webkit-scrollbar-corner': {
            backgroundColor: 'transparent',
          },
          // Firefox scrollbar styling
          scrollbarWidth: 'thin',
          scrollbarColor: 'rgba(0, 0, 0, 0.2) transparent',
        }}>
          {error && (
            <Alert 
              severity="error" 
              sx={{ 
                mb: 3, 
                borderRadius: 2,
                '& .MuiAlert-icon': {
                  fontSize: '1.2rem'
                }
              }}
            >
              {error}
            </Alert>
          )}
          
          {/* Basic Job Information Section */}
          <Paper elevation={1} sx={{ p: 2.5, mb: 3, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <WorkIcon color="primary" />
              <Typography variant="subtitle1" fontWeight={600} color="primary">
                Basic Job Information
              </Typography>
            </Box>
            
            <Grid container spacing={2.5}>
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Job Title"
                  name="title"
                  value={jobData.title}
                  onChange={handleChange}
                  fullWidth
                  required
                  disabled={loading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <WorkIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Company"
                  name="company"
                  value={jobData.company}
                  onChange={handleChange}
                  fullWidth
                  required
                  disabled={loading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <BusinessIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12}>
                <TextField
                  label="Job URL (Original Listing)"
                  name="sourceUrl"
                  value={jobData.sourceUrl}
                  onChange={handleChange}
                  fullWidth
                  placeholder="https://example.com/job-listing"
                  disabled={loading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LinkIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
            </Grid>
          </Paper>
          
          {/* Location Section */}
          <Paper elevation={1} sx={{ p: 2.5, mb: 3, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <LocationOnIcon color="secondary" />
              <Typography variant="subtitle1" fontWeight={600} color="secondary">
                Location
              </Typography>
            </Box>
            
            <Grid container spacing={2.5}>
              <Grid item xs={12}>
                <FormControlLabel
                  control={
                    <Switch 
                      checked={jobData.location.remote} 
                      onChange={handleSwitchChange}
                      name="location.remote"
                      disabled={loading}
                      color="secondary"
                    />
                  }
                  label={
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <HomeIcon fontSize="small" color="secondary" />
                      <Typography variant="body2" fontWeight={500}>Remote Position</Typography>
                    </Box>
                  }
                />
              </Grid>
              
              <Grid item xs={12} sm={4}>
                <TextField
                  label="City"
                  name="location.city"
                  value={jobData.location.city}
                  onChange={handleChange}
                  fullWidth
                  disabled={loading || jobData.location.remote}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <LocationOnIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={4}>
                <TextField
                  label="State/Province"
                  name="location.state"
                  value={jobData.location.state}
                  onChange={handleChange}
                  fullWidth
                  disabled={loading || jobData.location.remote}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={4}>
                <FormControl fullWidth disabled={loading || jobData.location.remote}>
                  <InputLabel>Country</InputLabel>
                  <Select
                    name="location.country"
                    value={jobData.location.country}
                    onChange={handleChange}
                    label="Country"
                    startAdornment={
                      <InputAdornment position="start">
                        <PublicIcon color="action" fontSize="small" />
                      </InputAdornment>
                    }
                    sx={{ borderRadius: 2 }}
                  >
                    <MenuItem value="US">🇺🇸 United States</MenuItem>
                    <MenuItem value="CA">🇨🇦 Canada</MenuItem>
                    <MenuItem value="UK">🇬🇧 United Kingdom</MenuItem>
                    <MenuItem value="AU">🇦🇺 Australia</MenuItem>
                    <MenuItem value="IN">🇮🇳 India</MenuItem>
                    <MenuItem value="DE">🇩🇪 Germany</MenuItem>
                    <MenuItem value="FR">🇫🇷 France</MenuItem>
                    <MenuItem value="OTHER">🌍 Other</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          </Paper>
          
          {/* Job Details Section */}
          <Paper elevation={1} sx={{ p: 2.5, mb: 3, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <ScheduleIcon color="success" />
              <Typography variant="subtitle1" fontWeight={600} color="success.main">
                Job Details
              </Typography>
            </Box>
            
            <Grid container spacing={2.5}>
              <Grid item xs={12} sm={6}>
                <FormControl fullWidth disabled={loading}>
                  <InputLabel>Job Type</InputLabel>
                  <Select
                    name="jobType"
                    value={jobData.jobType}
                    onChange={handleChange}
                    label="Job Type"
                    startAdornment={
                      <InputAdornment position="start">
                        <ScheduleIcon color="action" fontSize="small" />
                      </InputAdornment>
                    }
                    sx={{ borderRadius: 2 }}
                  >
                    <MenuItem value="FULL_TIME">💼 Full-time</MenuItem>
                    <MenuItem value="PART_TIME">⏰ Part-time</MenuItem>
                    <MenuItem value="CONTRACT">📋 Contract</MenuItem>
                    <MenuItem value="FREELANCE">🎯 Freelance</MenuItem>
                    <MenuItem value="INTERNSHIP">🎓 Internship</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <FormControl fullWidth disabled={loading}>
                  <InputLabel>Currency</InputLabel>
                  <Select
                    name="salary.currency"
                    value={jobData.salary.currency}
                    onChange={handleChange}
                    label="Currency"
                    startAdornment={
                      <InputAdornment position="start">
                        <AttachMoneyIcon color="action" fontSize="small" />
                      </InputAdornment>
                    }
                    sx={{ borderRadius: 2 }}
                  >
                    <MenuItem value="USD">💵 USD ($)</MenuItem>
                    <MenuItem value="EUR">💶 EUR (€)</MenuItem>
                    <MenuItem value="GBP">💷 GBP (£)</MenuItem>
                    <MenuItem value="CAD">🍁 CAD (C$)</MenuItem>
                    <MenuItem value="AUD">🦘 AUD (A$)</MenuItem>
                    <MenuItem value="INR">🇮🇳 INR (₹)</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Minimum Salary"
                  name="salary.min"
                  value={jobData.salary.min}
                  onChange={handleChange}
                  fullWidth
                  type="number"
                  InputProps={{ 
                    inputProps: { min: 0 },
                    startAdornment: (
                      <InputAdornment position="start">
                        <AttachMoneyIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  disabled={loading}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Maximum Salary"
                  name="salary.max"
                  value={jobData.salary.max}
                  onChange={handleChange}
                  fullWidth
                  type="number"
                  InputProps={{ 
                    inputProps: { min: 0 },
                    startAdornment: (
                      <InputAdornment position="start">
                        <AttachMoneyIcon color="action" fontSize="small" />
                      </InputAdornment>
                    ),
                  }}
                  disabled={loading}
                  sx={{ '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
                />
              </Grid>
            </Grid>
          </Paper>

          {/* Job Description Section */}
          <Paper elevation={1} sx={{ p: 2.5, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <DescriptionIcon color="warning" />
              <Typography variant="subtitle1" fontWeight={600} color="warning.main">
                Job Description
              </Typography>
            </Box>
            
            <TextField
              label="Job Description"
              name="description"
              value={jobData.description}
              onChange={handleChange}
              fullWidth
              required
              multiline
              rows={8}
              placeholder="Paste the full job description here..."
              disabled={loading}
              sx={{ 
                '& .MuiOutlinedInput-root': { 
                  borderRadius: 2,
                  '& textarea': {
                    fontSize: '0.9rem',
                    lineHeight: 1.5,
                    // Custom scrollbar for textarea
                    '&::-webkit-scrollbar': {
                      width: '4px',
                    },
                    '&::-webkit-scrollbar-track': {
                      backgroundColor: 'transparent',
                    },
                    '&::-webkit-scrollbar-thumb': {
                      backgroundColor: 'rgba(0, 0, 0, 0.2)',
                      borderRadius: '2px',
                      '&:hover': {
                        backgroundColor: 'rgba(0, 0, 0, 0.3)',
                      },
                    },
                    '&::-webkit-scrollbar-corner': {
                      backgroundColor: 'transparent',
                    },
                  }
                } 
              }}
            />
          </Paper>
        </DialogContent>
        
        <DialogActions sx={{ 
          px: 3, 
          py: 2, 
          borderTop: `1px solid ${theme.palette.divider}`,
          bgcolor: 'rgba(0,0,0,0.02)'
        }}>
          <Button 
            onClick={handleCancel} 
            disabled={loading}
            variant="outlined"
            sx={{ 
              borderRadius: 2,
              px: 3
            }}
          >
            Cancel
          </Button>
          <Button 
            type="submit" 
            variant="contained" 
            color="primary" 
            disabled={loading}
            startIcon={loading ? <CircularProgress size={18} color="inherit" /> : <AddIcon />}
            sx={{ 
              borderRadius: 2,
              px: 3,
              py: 1
            }}
          >
            {loading ? 'Creating...' : 'Create Job'}
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
};

export default JobCreateDialog;

================
File: frontend/src/components/jobs/JobDetail.js
================
// src/components/jobs/JobDetail.js - Final refactored version with improved dialog
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  Tabs,
  Tab,
  CircularProgress,
  Alert,
  Snackbar,
  Menu,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  useTheme,
  Tooltip,
  Paper,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Card,
  CardContent,
  Divider,
  IconButton,
  Stack,
  Fade,
  alpha
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  SmartToy as SmartToyIcon,
  Description as DescriptionIcon,
  Lightbulb as LightbulbIcon,
  CheckCircle as CheckCircleIcon,
  AutoFixHigh as AutoFixHighIcon,
  Psychology as PsychologyIcon,
  TrendingUp as TrendingUpIcon,
  Speed as SpeedIcon,
  Insights as InsightsIcon,
  Close as CloseIcon,
  Stars as StarsIcon,
  Rocket as RocketIcon
} from '@mui/icons-material';

// Import our component files
import JobHeader from './components/JobHeader';
import OverviewTab from './tabs/OverviewTab';
import AnalysisTab from './tabs/AnalysisTab';
import ContentTab from './tabs/ContentTab';
import AutoJobLogo from '../common/AutoJobLogo';

import jobService from '../../utils/jobService';
import resumeService from '../../utils/resumeService';
import MainLayout from '../layout/MainLayout';

// Tab panel component
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`job-tabpanel-${index}`}
      aria-labelledby={`job-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const JobDetail = () => {
  const theme = useTheme();
  const { id } = useParams();
  const navigate = useNavigate();
  const [job, setJob] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [tabValue, setTabValue] = useState(0);
  const [alert, setAlert] = useState({ open: false, message: '', severity: 'success' });
  const [allResumes, setAllResumes] = useState([]);
  const [resumeMatchStatus, setResumeMatchStatus] = useState({});
  const [anchorEl, setAnchorEl] = useState(null);
  const [tailorDialogOpen, setTailorDialogOpen] = useState(false);
  const [selectedResumeId, setSelectedResumeId] = useState('');
  const [matchLoading, setMatchLoading] = useState(false);

  useEffect(() => {
    fetchJobDetails();
    fetchAllResumes();
  }, [id]);

  const fetchJobDetails = async () => {
    try {
      setLoading(true);
      const jobData = await jobService.getJobById(id);
      setJob(jobData);
      
      // Fetch resume match status
      const matchStatus = await jobService.getResumeMatchStatus(id);
      setResumeMatchStatus(matchStatus.resumeStatusMap || {});
    } catch (error) {
      console.error('Error fetching job details:', error);
      setError('Failed to load job details. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const fetchAllResumes = async () => {
    try {
      const resumesData = await resumeService.getUserResumes();
      setAllResumes(resumesData || []);
    } catch (err) {
      console.error('Error fetching resumes:', err);
    }
  };

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  const handleAlertClose = () => {
    setAlert({ ...alert, open: false });
  };

  const handleMenuClick = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleDeleteJob = async () => {
    try {
      await jobService.deleteJob(id);
      navigate('/jobs');
    } catch (error) {
      console.error('Error deleting job:', error);
      setAlert({
        open: true,
        message: 'Failed to delete job. Please try again.',
        severity: 'error'
      });
    }
  };

  const handleOpenTailorDialog = () => {
    setTailorDialogOpen(true);
    handleMenuClose();
  };

  const handleCloseTailorDialog = () => {
    setTailorDialogOpen(false);
    setSelectedResumeId('');
  };

  const handleResumeChange = (e) => {
    setSelectedResumeId(e.target.value);
  };

  const handleTailorResume = async () => {
    if (!selectedResumeId) {
      setAlert({
        open: true,
        message: 'Please select a resume to tailor',
        severity: 'warning'
      });
      return;
    }

    setMatchLoading(true);
    
    try {
      // First match the resume with the job using enhanced matching
      const matchResult = await jobService.matchResumeWithJob(id, selectedResumeId);
      
      // Show success message with match score
      setAlert({
        open: true,
        message: `Analysis complete! Match score: ${matchResult.matchAnalysis?.overallScore || 'N/A'}%`,
        severity: 'success'
      });
      
      // Refresh job data to show new match analysis
      await fetchJobDetails();
      
      // Navigate to the tailoring page
      navigate(`/jobs/${id}/tailor/${selectedResumeId}`);
    } catch (error) {
      console.error('Error initializing resume tailoring:', error);
      setAlert({
        open: true,
        message: 'Failed to start resume tailoring process. Please try again.',
        severity: 'error'
      });
      setMatchLoading(false);
    }
  };

  const renderResumeStatusChip = (resume) => {
    const status = resumeMatchStatus[resume._id];
    
    if (!status) {
      return null;
    }

    if (status.isTailored) {
      return (
        <Tooltip title={`${status.tailoredVersions.length} tailored version(s) for this job`}>
          <Chip
            icon={<AutoFixHighIcon />}
            label="Tailored"
            color="success"
            size="small"
            sx={{ ml: 1 }}
          />
        </Tooltip>
      );
    }

    if (status.isMatched) {
      return (
        <Tooltip title="Already matched with this job">
          <Chip
            icon={<CheckCircleIcon />}
            label="Matched"
            color="info"
            size="small"
            sx={{ ml: 1 }}
          />
        </Tooltip>
      );
    }

    return null;
  };

  // Render analysis status indicator
  const renderAnalysisStatus = () => {
    if (!job.parsedData || Object.keys(job.parsedData).length === 0) {
      return (
        <Alert severity="warning" sx={{ mb: 2 }}>
          <Typography variant="subtitle2">Job Analysis Pending</Typography>
          <Typography variant="body2">
            This job is still being analyzed. Some features may be limited.
          </Typography>
        </Alert>
      );
    }

    if (job.parsedData.analysisError) {
      return (
        <Alert severity="error" sx={{ mb: 2 }}>
          <Typography variant="subtitle2">Analysis Failed</Typography>
          <Typography variant="body2">
            {job.parsedData.analysisError}
          </Typography>
        </Alert>
      );
    }

    return null;
  };

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
          <CircularProgress size={60} thickness={4} />
          <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
            Loading job details...
          </Typography>
        </Box>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="error">{error}</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/jobs')}
            sx={{ mt: 2 }}
          >
            Back to Jobs
          </Button>
        </Box>
      </MainLayout>
    );
  }

  if (!job) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="info">Job not found.</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/jobs')}
            sx={{ mt: 2 }}
          >
            Back to Jobs
          </Button>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1200px', mx: 'auto' }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/jobs')}
          variant="outlined"
          sx={{ mb: 3 }}
        >
          Back to Jobs
        </Button>

        {/* Job Header Component */}
        <JobHeader 
          job={job}
          onTailorClick={handleOpenTailorDialog}
          onMenuClick={handleMenuClick}
          onOpenOriginal={() => window.open(job.sourceUrl, '_blank')}
        />

        {/* Analysis Status */}
        {renderAnalysisStatus()}

        {/* Tabs without white container background */}
        <Box sx={{ mb: 4 }}>
          <Paper sx={{ borderRadius: 3, overflow: 'hidden', mb: 2 }}>
            <Tabs
              value={tabValue}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ 
                borderBottom: 1, 
                borderColor: 'divider',
                bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.02)',
                '& .MuiTab-root': { 
                  py: 2,
                  fontWeight: 500
                }
              }}
            >
              <Tab label="Overview" icon={<DescriptionIcon />} iconPosition="start" />
              <Tab label="Analysis" icon={<LightbulbIcon />} iconPosition="start" />
              <Tab label="Content" icon={<DescriptionIcon />} iconPosition="start" />
            </Tabs>
          </Paper>

          {/* Tab content without Paper wrapper */}
          {/* Overview Tab */}
          {tabValue === 0 && (
            <Box sx={{ py: 1 }}>
              <OverviewTab 
                job={job} 
                onTailorClick={handleOpenTailorDialog}
              />
            </Box>
          )}

          {/* Analysis Tab */}
          {tabValue === 1 && (
            <Box sx={{ py: 1 }}>
              <AnalysisTab 
                job={job} 
                onTailorClick={handleOpenTailorDialog}
              />
            </Box>
          )}

          {/* Content Tab */}
          {tabValue === 2 && (
            <Box sx={{ py: 1 }}>
              <ContentTab job={job} />
            </Box>
          )}
        </Box>

        {/* Menu */}
        <Menu
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={handleMenuClose}
          PaperProps={{
            elevation: 3,
            sx: { borderRadius: 2 }
          }}
        >

          <MenuItem onClick={handleDeleteJob} sx={{ color: 'error.main' }}>
            <ListItemIcon>
              <DeleteIcon fontSize="small" color="error" />
            </ListItemIcon>
            <ListItemText primary="Delete Job" />
          </MenuItem>
        </Menu>

        {/* Enhanced AI Resume Analysis Dialog */}
        <Dialog
          open={tailorDialogOpen}
          onClose={handleCloseTailorDialog}
          maxWidth="sm"
          fullWidth
          PaperProps={{
            sx: { 
              borderRadius: 4,
              overflow: 'hidden',
              boxShadow: '0px 24px 38px rgba(0, 0, 0, 0.14), 0px 9px 46px rgba(0, 0, 0, 0.12), 0px 11px 15px rgba(0, 0, 0, 0.20)',
              height: 'auto',
              maxHeight: '90vh'
            }
          }}
          TransitionComponent={Fade}
          transitionDuration={300}
        >
          {/* Custom Header with Solid Teal */}
          <DialogTitle 
            sx={{ 
              backgroundColor: theme.palette.secondary.main,
              color: 'white',
              p: 0,
              position: 'relative',
              overflow: 'hidden'
            }}
          >
            {/* Background Pattern */}
            <Box
              sx={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: `radial-gradient(circle at 20% 50%, ${alpha('#ffffff', 0.1)} 0%, transparent 50%), 
                             radial-gradient(circle at 80% 20%, ${alpha('#ffffff', 0.08)} 0%, transparent 50%)`,
                zIndex: 0
              }}
            />
            
            {/* Header Content */}
            <Box sx={{ 
              display: 'flex', 
              alignItems: 'center', 
              justifyContent: 'space-between',
              p: 2.5,
              position: 'relative',
              zIndex: 1
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                <AutoJobLogo 
                  variant="icon-only" 
                  size="small" 
                  color="white"
                />
                <Box>
                  <Typography 
                    variant="h6" 
                    sx={{ 
                      fontWeight: 700,
                      mb: 0.25,
                      textShadow: '0 2px 4px rgba(0,0,0,0.1)'
                    }}
                  >
                    Enhanced AI Resume Analysis
                  </Typography>
                  <Typography 
                    variant="body2" 
                    sx={{ 
                      opacity: 0.9,
                      fontWeight: 500,
                      fontSize: '0.8rem'
                    }}
                  >
                    Powered by advanced AI agents
                  </Typography>
                </Box>
              </Box>
              
              <IconButton
                onClick={handleCloseTailorDialog}
                sx={{ 
                  color: 'white',
                  '&:hover': {
                    bgcolor: alpha('#ffffff', 0.1)
                  }
                }}
              >
                <CloseIcon />
              </IconButton>
            </Box>
          </DialogTitle>

          <DialogContent sx={{ p: 0, overflow: 'hidden' }}>
            {/* Hero Section */}
            <Box sx={{ 
              p: 2.5, 
              background: `linear-gradient(180deg, ${alpha(theme.palette.secondary.main, 0.02)} 0%, transparent 100%)`
            }}>
              <Typography 
                variant="body1" 
                sx={{ 
                  mb: 1.5,
                  fontWeight: 600,
                  color: 'text.primary',
                  fontSize: '1rem'
                }}
              >
                Select a resume for intelligent analysis and personalized recommendations.
              </Typography>
              
              <Typography 
                variant="body2" 
                sx={{ 
                  color: 'text.secondary',
                  lineHeight: 1.4,
                  fontSize: '0.875rem'
                }}
              >
                Our AI will analyze your resume against this job posting and provide detailed insights 
                to maximize your interview chances.
              </Typography>
            </Box>

            {/* AI Features Showcase */}
            <Box sx={{ px: 2.5, pb: 1.5 }}>
              <Card sx={{ 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.secondary.main, 0.12)}`,
                background: `linear-gradient(135deg, ${alpha(theme.palette.secondary.main, 0.02)} 0%, ${alpha(theme.palette.secondary.light, 0.02)} 100%)`
              }}>
                <CardContent sx={{ p: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1.5 }}>
                    <StarsIcon 
                      sx={{ 
                        color: theme.palette.warning.main,
                        mr: 1,
                        fontSize: '1.25rem'
                      }} 
                    />
                    <Typography 
                      variant="body2" 
                      sx={{ 
                        fontWeight: 600,
                        color: 'text.primary'
                      }}
                    >
                      Our enhanced AI will provide:
                    </Typography>
                  </Box>
                  
                  <Stack spacing={1.5}>
                    <Stack direction="row" spacing={1.5}>
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.success.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <TrendingUpIcon sx={{ color: 'success.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Dynamic Match Scores
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Real-time compatibility analysis
                        </Typography>
                      </Card>
                      
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.info.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <SpeedIcon sx={{ color: 'info.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Skill Importance Weighting
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Prioritized skill relevance
                        </Typography>
                      </Card>
                    </Stack>
                    
                    <Stack direction="row" spacing={1.5}>
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.warning.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <PsychologyIcon sx={{ color: 'warning.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Experience Level Compatibility
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Career stage alignment
                        </Typography>
                      </Card>
                      
                      <Card sx={{ flex: 1, p: 1.5, borderRadius: 1.5, bgcolor: alpha(theme.palette.secondary.main, 0.08) }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                          <InsightsIcon sx={{ color: 'secondary.main', mr: 0.75, fontSize: '1rem' }} />
                          <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '0.75rem' }}>
                            Personalized Improvement Suggestions
                          </Typography>
                        </Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.7rem' }}>
                          Tailored enhancement recommendations
                        </Typography>
                      </Card>
                    </Stack>
                  </Stack>
                </CardContent>
              </Card>
            </Box>

            {/* Resume Selection */}
            <Box sx={{ px: 2.5, pb: 2.5 }}>
              <Divider sx={{ my: 2 }} />
              
              {allResumes.length === 0 ? (
                <Alert 
                  severity="warning" 
                  sx={{ 
                    borderRadius: 2,
                    '& .MuiAlert-icon': {
                      fontSize: '1.25rem'
                    }
                  }}
                >
                  <Typography variant="body2" sx={{ fontWeight: 600, mb: 0.25 }}>
                    No resumes found
                  </Typography>
                  <Typography variant="caption">
                    You don't have any resumes uploaded. Please upload a resume first to continue.
                  </Typography>
                </Alert>
              ) : (
                <Box>
                  <Typography 
                    variant="body2" 
                    sx={{ 
                      mb: 1.5,
                      fontWeight: 600,
                      color: 'text.primary'
                    }}
                  >
                    Choose your resume for analysis
                  </Typography>
                  
                  <FormControl 
                    fullWidth 
                    sx={{ 
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  >
                    <InputLabel id="tailor-resume-label">Select Resume for Analysis</InputLabel>
                    <Select
                      labelId="tailor-resume-label"
                      value={selectedResumeId}
                      onChange={handleResumeChange}
                      label="Select Resume for Analysis"
                    >
                      {allResumes.map((resume) => (
                        <MenuItem 
                          key={resume._id} 
                          value={resume._id}
                          sx={{ 
                            minHeight: 48,
                            py: 1
                          }}
                        >
                          <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                            <DescriptionIcon sx={{ mr: 1.5, color: 'text.secondary', fontSize: '1.25rem' }} />
                            <Box sx={{ flex: 1 }}>
                              <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                {resume.name}
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                Updated {new Date(resume.updatedAt).toLocaleDateString()}
                              </Typography>
                            </Box>
                            {renderResumeStatusChip(resume)}
                          </Box>
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}
            </Box>
          </DialogContent>

          <DialogActions sx={{ 
            p: 2.5, 
            pt: 0,
            gap: 1.5,
            background: `linear-gradient(180deg, transparent 0%, ${alpha(theme.palette.background.paper, 0.8)} 100%)`
          }}>
            <Button 
              onClick={handleCloseTailorDialog}
              variant="outlined"
              sx={{ 
                borderRadius: 2,
                px: 3,
                py: 1,
                fontWeight: 600
              }}
            >
              Cancel
            </Button>
            <Button 
              onClick={handleTailorResume}
              variant="contained" 
              color="secondary"
              disabled={!selectedResumeId || matchLoading}
              startIcon={
                matchLoading ? (
                  <CircularProgress size={18} color="inherit" />
                ) : (
                  <AutoJobLogo 
                    variant="icon-only" 
                    size="small" 
                    color="white"
                    sx={{ transform: 'scale(0.7)' }}
                  />
                )
              }
              sx={{ 
                px: 3,
                py: 1,
                borderRadius: 2,
                fontWeight: 600,
                backgroundColor: theme.palette.secondary.main,
                color: 'white',
                boxShadow: `0px 8px 16px ${alpha(theme.palette.secondary.main, 0.24)}`,
                '&:hover': {
                  backgroundColor: theme.palette.secondary.dark,
                  boxShadow: `0px 12px 20px ${alpha(theme.palette.secondary.main, 0.32)}`,
                  transform: 'translateY(-1px)'
                },
                '&:disabled': {
                  backgroundColor: alpha(theme.palette.secondary.main, 0.6),
                  color: 'white'
                },
                transition: 'all 0.2s ease-in-out'
              }}
            >
              {matchLoading ? 'Analyzing Resume...' : 'Start Enhanced Analysis'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Snackbar for notifications */}
        <Snackbar
          open={alert.open}
          autoHideDuration={6000}
          onClose={handleAlertClose}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert 
            onClose={handleAlertClose} 
            severity={alert.severity} 
            sx={{ width: '100%', borderRadius: 2 }}
            variant="filled"
          >
            {alert.message}
          </Alert>
        </Snackbar>
      </Box>
    </MainLayout>
  );
};

export default JobDetail;

================
File: frontend/src/components/jobs/JobsPage.js
================
// src/components/jobs/JobsPage.js - Fixed Analysis Status Logic
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Grid, 
  Card, 
  CardContent, 
  CardActions, 
  Divider, 
  Chip, 
  CircularProgress, 
  Alert,
  LinearProgress,
  IconButton,
  Menu,
  MenuItem,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tabs,
  Tab,
  Snackbar,
  Badge,
  Backdrop
} from '@mui/material';
import { 
  Add as AddIcon, 
  Work as WorkIcon,
  ErrorOutline as ErrorOutlineIcon,
  MoreVert as MoreVertIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  ContentCopy as ContentCopyIcon,
  SmartToy as SmartToyIcon,
  OpenInNew as OpenInNewIcon,
  Refresh as RefreshIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon,
  Schedule as ScheduleIcon,
  AutoAwesome as AutoAwesomeIcon,
  CheckCircle as CheckCircleIcon,
  HourglassEmpty as HourglassEmptyIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import jobService from '../../utils/jobService';
import resumeService from '../../utils/resumeService';
import MainLayout from '../layout/MainLayout';
import JobCreateDialog from './JobCreateDialog';
import FindJobsDialog from './FindJobsDialog';
import AutoJobLogo from '../common/AutoJobLogo';

// Helper function to determine job analysis status
const getJobAnalysisStatus = (job) => {
  // If job has explicit analysisStatus field, use it
  if (job.analysisStatus && job.analysisStatus.status) {
    return {
      status: job.analysisStatus.status,
      progress: job.analysisStatus.progress || 0,
      message: job.analysisStatus.message || 'Processing...',
      canViewJob: job.analysisStatus.canViewJob !== false,
      skillsFound: job.analysisStatus.skillsFound,
      experienceLevel: job.analysisStatus.experienceLevel
    };
  }
  
  // For existing jobs without analysisStatus field, infer status from parsedData
  if (job.parsedData && Object.keys(job.parsedData).length > 0 && !job.parsedData.analysisError) {
    return {
      status: 'completed',
      progress: 100,
      message: `Analysis complete! Found ${job.parsedData.keySkills?.length || 0} key skills.`,
      canViewJob: true,
      skillsFound: job.parsedData.keySkills?.length || 0,
      experienceLevel: job.parsedData.experienceLevel
    };
  }
  
  // If parsedData exists but has errors
  if (job.parsedData && job.parsedData.analysisError) {
    return {
      status: 'error',
      progress: 0,
      message: 'Analysis failed',
      canViewJob: true,
      error: job.parsedData.analysisError
    };
  }
  
  // No parsedData means analysis hasn't been done yet
  return {
    status: 'pending',
    progress: 0,
    message: 'Analysis pending...',
    canViewJob: false
  };
};

// Inline JobAnalysisStatus component
const JobAnalysisStatus = ({ 
  analysisStatus, 
  size = 'normal', 
  variant = 'full', 
  showDetails = true 
}) => {
  if (!analysisStatus) {
    return null;
  }

  const { status, progress, message, skillsFound, experienceLevel } = analysisStatus;

  const statusConfig = {
    pending: {
      label: 'Analysis Queued',
      color: 'info',
      icon: HourglassEmptyIcon,
      bgColor: 'rgba(2, 136, 209, 0.1)',
      textColor: '#0288d1'
    },
    analyzing: {
      label: 'Analyzing Job',
      color: 'primary',
      icon: AutoAwesomeIcon,
      bgColor: 'rgba(26, 115, 232, 0.1)',
      textColor: '#1a73e8'
    },
    completed: {
      label: 'Analysis Complete',
      color: 'success',
      icon: CheckCircleIcon,
      bgColor: 'rgba(52, 168, 83, 0.1)',
      textColor: '#34a853'
    },
    error: {
      label: 'Analysis Failed',
      color: 'error',
      icon: ErrorOutlineIcon,
      bgColor: 'rgba(234, 67, 53, 0.1)',
      textColor: '#ea4335'
    }
  };

  const config = statusConfig[status] || statusConfig.pending;
  const IconComponent = config.icon;

  const sizeConfig = {
    small: {
      iconSize: 16,
      chipHeight: 24,
      typography: 'caption',
      progressHeight: 4
    },
    normal: {
      iconSize: 20,
      chipHeight: 28,
      typography: 'body2',
      progressHeight: 6
    },
    large: {
      iconSize: 24,
      chipHeight: 32,
      typography: 'body1',
      progressHeight: 8
    }
  };

  const currentSize = sizeConfig[size];

  if (variant === 'chip') {
    return (
      <Chip
        icon={
          status === 'analyzing' ? (
            <CircularProgress 
              size={currentSize.iconSize} 
              thickness={6} 
              color={config.color}
            />
          ) : (
            <IconComponent 
              sx={{ 
                fontSize: `${currentSize.iconSize}px !important`,
                color: config.textColor 
              }} 
            />
          )
        }
        label={config.label}
        size={size}
        sx={{
          height: currentSize.chipHeight,
          backgroundColor: config.bgColor,
          color: config.textColor,
          border: `1px solid ${config.textColor}`,
          fontWeight: 500,
          '& .MuiChip-icon': {
            color: `${config.textColor} !important`
          }
        }}
      />
    );
  }

  if (variant === 'progress-only') {
    return (
      <Box sx={{ width: '100%' }}>
        <LinearProgress
          variant="determinate"
          value={progress}
          color={config.color}
          sx={{
            height: currentSize.progressHeight,
            borderRadius: currentSize.progressHeight / 2,
            backgroundColor: config.bgColor,
            '& .MuiLinearProgress-bar': {
              borderRadius: currentSize.progressHeight / 2,
            }
          }}
        />
        {showDetails && (
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
            <Typography variant={currentSize.typography} color="text.secondary">
              {message}
            </Typography>
            <Typography variant={currentSize.typography} color="text.secondary">
              {progress}%
            </Typography>
          </Box>
        )}
      </Box>
    );
  }

  return (
    <Box
      sx={{
        p: size === 'small' ? 1.5 : 2,
        borderRadius: 2,
        backgroundColor: config.bgColor,
        border: `1px solid ${config.textColor}`,
        display: 'flex',
        alignItems: 'center',
        gap: 1.5
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        {status === 'analyzing' ? (
          <CircularProgress 
            size={currentSize.iconSize} 
            thickness={6} 
            color={config.color}
          />
        ) : (
          <IconComponent 
            sx={{ 
              fontSize: currentSize.iconSize,
              color: config.textColor 
            }} 
          />
        )}
      </Box>

      <Box sx={{ flex: 1, minWidth: 0 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
          <Typography 
            variant={currentSize.typography} 
            fontWeight={600}
            color={config.textColor}
            noWrap
          >
            {config.label}
          </Typography>
          
          {status === 'analyzing' && (
            <Chip
              icon={<SmartToyIcon sx={{ fontSize: '14px !important' }} />}
              label="AI"
              size="small"
              sx={{
                height: 18,
                fontSize: '0.7rem',
                backgroundColor: config.textColor,
                color: 'white',
                '& .MuiChip-icon': {
                  color: 'white !important'
                }
              }}
            />
          )}
        </Box>

        {status !== 'completed' && status !== 'error' && (
          <Box sx={{ mb: 1 }}>
            <LinearProgress
              variant="determinate"
              value={progress}
              color={config.color}
              sx={{
                height: currentSize.progressHeight,
                borderRadius: currentSize.progressHeight / 2,
                backgroundColor: 'rgba(255,255,255,0.3)',
                '& .MuiLinearProgress-bar': {
                  borderRadius: currentSize.progressHeight / 2,
                }
              }}
            />
          </Box>
        )}

        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          color={config.textColor}
          sx={{ opacity: 0.9 }}
        >
          {message}
        </Typography>

        {status === 'completed' && showDetails && skillsFound !== undefined && (
          <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            <Chip
              label={`${skillsFound} skills found`}
              size="small"
              variant="outlined"
              sx={{
                height: 20,
                fontSize: '0.7rem',
                borderColor: config.textColor,
                color: config.textColor
              }}
            />
            {experienceLevel && (
              <Chip
                label={`${experienceLevel} level`}
                size="small"
                variant="outlined"
                sx={{
                  height: 20,
                  fontSize: '0.7rem',
                  borderColor: config.textColor,
                  color: config.textColor
                }}
              />
            )}
          </Box>
        )}

        {status === 'error' && showDetails && (
          <Alert 
            severity="error" 
            sx={{ 
              mt: 1, 
              py: 0.5,
              fontSize: '0.75rem',
              '& .MuiAlert-icon': {
                fontSize: '1rem'
              }
            }}
          >
            Analysis failed. You can still view the job, but some features may be limited.
          </Alert>
        )}
      </Box>

      {(status === 'analyzing' || status === 'pending') && (
        <Typography 
          variant={size === 'small' ? 'caption' : 'body2'} 
          fontWeight={600}
          color={config.textColor}
        >
          {progress}%
        </Typography>
      )}
    </Box>
  );
};

// Tab panel component
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`job-tabpanel-${index}`}
      aria-labelledby={`job-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const JobsPage = () => {
  const navigate = useNavigate();
  const [jobs, setJobs] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [openCreateDialog, setOpenCreateDialog] = useState(false);
  const [openFindJobsDialog, setOpenFindJobsDialog] = useState(false);
  const [anchorEl, setAnchorEl] = useState(null);
  const [selectedJobId, setSelectedJobId] = useState(null);
  const [tabValue, setTabValue] = useState(0);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });
  const [activeResumes, setActiveResumes] = useState([]);
  const [pollingJobs, setPollingJobs] = useState(new Set());

  // Safe AutoJobLogo wrapper component
  const SafeAutoJobLogo = ({ size = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={size} 
          showTagline={false}
        />
      );
    } catch (error) {
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: size === 'small' ? 16 : 20 }} />;
    }
  };

  useEffect(() => {
    fetchJobs();
    fetchActiveResumes();
  }, []);

  // Poll analysis status for jobs that are still processing
  useEffect(() => {
    const jobsNeedingPolling = jobs.filter(job => {
      const status = getJobAnalysisStatus(job);
      return (status.status === 'pending' || status.status === 'analyzing') && !pollingJobs.has(job._id);
    });

    jobsNeedingPolling.forEach(job => {
      startPollingJobStatus(job._id);
    });
  }, [jobs]);

  const fetchJobs = async () => {
    try {
      setLoading(true);
      setError('');
      console.log('Fetching jobs...');
      const jobsData = await jobService.getAllJobs();
      setJobs(jobsData || []);
    } catch (err) {
      console.error('Error fetching jobs:', err);
      setError(err.response?.data?.message || 'Failed to load jobs. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const fetchActiveResumes = async () => {
    try {
      const resumesData = await resumeService.getUserResumes();
      setActiveResumes(resumesData.filter(r => r.isActive) || []);
    } catch (err) {
      console.error('Error fetching active resumes:', err);
    }
  };

  // Start polling for a specific job's analysis status
  const startPollingJobStatus = async (jobId) => {
    if (pollingJobs.has(jobId)) {
      return; // Already polling this job
    }

    setPollingJobs(prev => new Set([...prev, jobId]));

    try {
      // Check if jobService.pollJobAnalysisStatus exists before using it
      if (typeof jobService.pollJobAnalysisStatus === 'function') {
        await jobService.pollJobAnalysisStatus(
          jobId,
          (statusUpdate) => {
            // Update the specific job's status in real-time
            setJobs(prevJobs => prevJobs.map(job => 
              job._id === jobId 
                ? { ...job, analysisStatus: statusUpdate }
                : job
            ));
          },
          30 // Max 30 attempts (60 seconds)
        );
      } else {
        console.warn('pollJobAnalysisStatus method not available in jobService');
      }
    } catch (error) {
      console.error(`Polling failed for job ${jobId}:`, error);
      
      // Update job to show error state
      setJobs(prevJobs => prevJobs.map(job => 
        job._id === jobId 
          ? { 
              ...job, 
              analysisStatus: { 
                status: 'error', 
                message: 'Analysis status polling failed',
                progress: 0,
                canViewJob: true
              }
            }
          : job
      ));
    } finally {
      // Remove from polling set
      setPollingJobs(prev => {
        const newSet = new Set(prev);
        newSet.delete(jobId);
        return newSet;
      });
    }
  };

  const handleOpenCreateDialog = () => {
    setOpenCreateDialog(true);
  };

  const handleCloseCreateDialog = () => {
    setOpenCreateDialog(false);
  };

  const handleOpenFindJobsDialog = () => {
    setOpenFindJobsDialog(true);
  };

  const handleCloseFindJobsDialog = () => {
    setOpenFindJobsDialog(false);
  };

  const handleJobCreated = (newJob) => {
    fetchJobs(); // Refresh the entire list
    handleCloseCreateDialog();
    showSnackbar('Job created successfully - analysis in progress', 'success');
    
    // Start polling the new job if it has an ID
    if (newJob?.job?.id) {
      setTimeout(() => {
        startPollingJobStatus(newJob.job.id);
      }, 1000);
    }
  };

  const handleMenuOpen = (event, jobId) => {
    setAnchorEl(event.currentTarget);
    setSelectedJobId(jobId);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
    setSelectedJobId(null);
  };

  const handleDeleteJob = async () => {
    if (!selectedJobId) return;
    
    try {
      await jobService.deleteJob(selectedJobId);
      setJobs(prevJobs => prevJobs.filter(job => job._id !== selectedJobId));
      handleMenuClose();
      showSnackbar('Job deleted successfully', 'success');
    } catch (err) {
      console.error('Error deleting job:', err);
      showSnackbar('Failed to delete job', 'error');
    }
  };

  const handleJobClick = (job) => {
    const status = getJobAnalysisStatus(job);
    
    // Check if analysis is complete before allowing navigation
    if (!status.canViewJob) {
      showSnackbar('Please wait for job analysis to complete before viewing details', 'warning');
      return;
    }
    
    navigate(`/jobs/${job._id}`);
  };

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  const showSnackbar = (message, severity) => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };

  const handleCloseSnackbar = () => {
    setSnackbar({
      ...snackbar,
      open: false
    });
  };

  const handleJobsFindCompleted = () => {
    fetchJobs();
    handleCloseFindJobsDialog();
    showSnackbar('AI job search initiated. Jobs will appear as they are found.', 'success');
  };

  const renderEmptyState = () => (
    <Box sx={{ mt: 2 }}>
      <Paper 
        elevation={1} 
        sx={{ 
          p: 3, 
          textAlign: 'center', 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center',
          backgroundColor: theme => theme.palette.background.paper,
          border: `1px solid`,
          borderColor: 'divider',
          borderRadius: 3,
          mb: 3
        }}
      >
        <WorkIcon sx={{ fontSize: 48, color: 'primary.main', mb: 2, opacity: 0.8 }} />
        <Typography variant="h5" gutterBottom fontWeight={600}>
          Find Your Perfect Job Match
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 3, maxWidth: 560, lineHeight: 1.5 }}>
          Add jobs manually or let our AI find opportunities that match your resume.
          Our platform will help you analyze matches, tailor your application materials,
          and track your job search progress.
        </Typography>
        <Box sx={{ display: 'flex', gap: 1.5 }}>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<AddIcon />} 
            onClick={handleOpenCreateDialog}
            sx={{ 
              py: 1, 
              px: 3, 
              fontSize: '0.9rem', 
              fontWeight: 500,
              borderRadius: 2
            }}
          >
            Add Job Manually
          </Button>
          <Button 
            variant="outlined" 
            color="primary" 
            startIcon={<SafeAutoJobLogo size="small" />} 
            onClick={handleOpenFindJobsDialog}
            sx={{ 
              py: 1, 
              px: 3, 
              fontSize: '0.9rem', 
              fontWeight: 500,
              borderRadius: 2
            }}
          >
            Discover Jobs
          </Button>
        </Box>
        {activeResumes.length === 0 && (
          <Alert severity="info" sx={{ mt: 2.5, maxWidth: 480, fontSize: '0.85rem' }}>
            You need at least one resume to use the AI job search feature.
            Please upload a resume first.
          </Alert>
        )}
      </Paper>

      <Typography variant="h6" sx={{ mb: 2.5, fontWeight: 600 }}>
        How Our Job Matching Works
      </Typography>

      <Grid container spacing={2.5} sx={{ mb: 3 }}>
        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #4caf50',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              1. Find or Add Jobs
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <WorkIcon sx={{ fontSize: 56, color: '#4caf50', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Add jobs manually from listings you find, or let our AI find relevant positions 
              based on your resume.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #2196f3',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              2. Match Analysis
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <ContentCopyIcon sx={{ fontSize: 56, color: '#2196f3', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Our system analyzes how well your resume matches each job, identifying
              strengths and areas for improvement.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #ff9800',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              3. Tailor & Apply
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <SafeAutoJobLogo size="medium" />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Get AI-powered suggestions to tailor your resume for each job, increasing
              your chances of getting interviews.
            </Typography>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );

  const renderErrorState = () => (
    <Paper 
      elevation={0} 
      sx={{ 
        p: 4, 
        mt: 3,
        borderRadius: 2,
        border: '1px solid rgba(211, 47, 47, 0.2)',
        backgroundColor: 'rgba(211, 47, 47, 0.05)'
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
        <ErrorOutlineIcon color="error" sx={{ mr: 2, mt: 0.5 }} />
        <Box>
          <Typography variant="h6" color="error" gutterBottom fontWeight={500}>
            Error Loading Jobs
          </Typography>
          <Typography variant="body1" sx={{ mb: 3 }}>
            {error || 'Failed to load jobs. Please try again.'}
          </Typography>
        </Box>
      </Box>
      <Box sx={{ display: 'flex', gap: 2 }}>
        <Button 
          variant="outlined" 
          color="primary" 
          startIcon={<RefreshIcon />} 
          onClick={fetchJobs}
          sx={{ textTransform: 'none' }}
        >
          Try Again
        </Button>
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<AddIcon />} 
          onClick={handleOpenCreateDialog}
          sx={{ textTransform: 'none' }}
        >
          Add Job Manually
        </Button>
      </Box>
    </Paper>
  );

  const renderJobGrid = (filteredJobs) => (
    <Grid container spacing={3} sx={{ mt: 1 }}>
      {filteredJobs.map((job) => {
        // FIXED: Use the helper function to get consistent status
        const analysisStatus = getJobAnalysisStatus(job);
        const canView = analysisStatus.canViewJob;
        const isAnalyzing = analysisStatus.status === 'analyzing' || analysisStatus.status === 'pending';
        
        return (
          <Grid item xs={12} sm={6} md={4} key={job._id}>
            <Card sx={{ 
              height: '100%', 
              display: 'flex', 
              flexDirection: 'column',
              position: 'relative',
              transition: 'transform 0.2s, box-shadow 0.2s',
              opacity: canView ? 1 : 0.8,
              cursor: canView ? 'pointer' : 'default',
              '&:hover': canView ? {
                transform: 'translateY(-4px)',
                boxShadow: '0 8px 24px rgba(0,0,0,0.12)'
              } : {}
            }}>
              {/* FIXED: Only show analysis overlay for jobs that are actually being analyzed */}
              {isAnalyzing && (
                <Box
                  sx={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    zIndex: 10,
                    bgcolor: 'rgba(255,255,255,0.95)',
                    backdropFilter: 'blur(2px)',
                    p: 1
                  }}
                >
                  <JobAnalysisStatus 
                    analysisStatus={analysisStatus}
                    size="small"
                    variant="full"
                    showDetails={false}
                  />
                </Box>
              )}

{/* Discovered Badge */}
{job.isAiGenerated && (
  <Chip 
    icon={<SafeAutoJobLogo size="small" sx={{ '& svg': { width: 12, height: 12 } }} />}
    label="Discovered" 
    size="small" 
    sx={{ 
      position: 'absolute', 
      top: 12, 
      right: 12,
      height: '28px',
      fontWeight: 600,
      fontSize: '0.75rem',
      backgroundColor: '#00c4b4',
      color: '#ffffff',
      border: '1px solid #00c4b4',
      boxShadow: '0 2px 8px rgba(38, 166, 154, 0.3)',
      zIndex: 5,
      '& .MuiChip-icon': {
        color: '#ffffff !important'
      },
      '&:hover': {
        backgroundColor: '#00695C',
        boxShadow: '0 4px 12px rgba(38, 166, 154, 0.4)'
      }
    }}
  />
)}

              <CardContent sx={{ flexGrow: 1, pt: job.isAiGenerated ? 5 : 3 }}>
                <Typography variant="h6" gutterBottom noWrap fontWeight={500}>
                  {job.title}
                </Typography>
                <Typography variant="subtitle1" color="text.secondary" noWrap>
                  {job.company}
                </Typography>
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  {job.location?.city 
                    ? `${job.location.city}${job.location.state ? `, ${job.location.state}` : ''}`
                    : job.location?.remote ? 'Remote' : 'Location not specified'
                  }
                </Typography>
                <Divider sx={{ my: 2 }} />
                
{/* FIXED: Only show progress for jobs that are actually being analyzed */}
                {isAnalyzing && (
                  <Box sx={{ mb: 2 }}>
                    <JobAnalysisStatus 
                      analysisStatus={analysisStatus}
                      size="small"
                      variant="progress-only"
                      showDetails={true}
                    />
                  </Box>
                )}
                
                {/* Match Score - FIXED: Only show for completed analysis */}
                {job.matchAnalysis && job.matchAnalysis.overallScore && analysisStatus.status === 'completed' && (
                  <Box sx={{ mt: 2, mb: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                      <Typography variant="subtitle2" fontWeight={500}>
                        Match Score
                      </Typography>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Typography variant="h6" fontWeight={600} color={getScoreColor(job.matchAnalysis.overallScore)}>
                          {job.matchAnalysis.overallScore}
                        </Typography>
                        <Typography variant="body2" color="text.secondary" sx={{ ml: 0.5 }}>
                          /100
                        </Typography>
                      </Box>
                    </Box>
                    <LinearProgress 
                      variant="determinate" 
                      value={job.matchAnalysis.overallScore} 
                      sx={{ 
                        height: 8, 
                        borderRadius: 2,
                        backgroundColor: 'rgba(0,0,0,0.05)',
                        '& .MuiLinearProgress-bar': {
                          backgroundColor: getScoreColor(job.matchAnalysis.overallScore)
                        }
                      }}
                    />
                  </Box>
                )}
                
                <Box sx={{ mt: 2 }}>
                  <Typography variant="body2" color="text.secondary" noWrap>
                    Posted: {new Date(job.createdAt).toLocaleDateString()}
                  </Typography>
                  
                  <Box sx={{ mt: 2, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                    <Chip 
                      label={job.jobType?.replace('_', ' ') || 'Full-time'} 
                      size="small" 
                      variant="outlined" 
                    />
                    {job.salary?.min && (
                      <Chip 
                        label={`${job.salary.currency || '$'}${job.salary.min}${job.salary.max ? ` - ${job.salary.max}` : '+'}`} 
                        size="small" 
                        variant="outlined" 
                        color="success"
                      />
                    )}
                    <Chip 
                      label={job.applicationStatus?.replace('_', ' ') || 'Not Applied'} 
                      size="small" 
                      variant="outlined" 
                      color={job.applicationStatus === 'APPLIED' ? 'primary' : 'default'}
                    />
                  </Box>
                </Box>
              </CardContent>

              <CardActions sx={{ justifyContent: 'space-between', p: 2 }}>
                <Tooltip 
                  title={!canView ? "Analysis in progress - please wait" : "View job details"}
                  arrow
                >
                  <span> {/* Span wrapper needed for disabled button tooltip */}
                    <Button 
                      size="small" 
                      color="primary" 
                      onClick={() => handleJobClick(job)}
                      variant="contained"
                      disabled={!canView}
                      startIcon={
                        canView ? <VisibilityIcon /> : <ScheduleIcon />
                      }
                    >
                      {canView ? 'View Details' : 'Analyzing...'}
                    </Button>
                  </span>
                </Tooltip>
                <Box>
                  {job.sourceUrl && (
                    <Tooltip title="Open Original Listing">
                      <IconButton 
                        size="small" 
                        onClick={() => window.open(job.sourceUrl, '_blank')}
                        sx={{ mr: 1 }}
                      >
                        <OpenInNewIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                  )}
                  <IconButton 
                    size="small"
                    aria-controls={`job-menu-${job._id}`}
                    aria-haspopup="true"
                    onClick={(e) => handleMenuOpen(e, job._id)}
                  >
                    <MoreVertIcon fontSize="small" />
                  </IconButton>
                </Box>
              </CardActions>
            </Card>
          </Grid>
        );
      })}
      
      {/* Add Job Card */}
      <Grid item xs={12} sm={6} md={4}>
        <Card 
          sx={{ 
            height: '100%', 
            minHeight: 250,
            display: 'flex', 
            flexDirection: 'column', 
            justifyContent: 'center', 
            alignItems: 'center',
            p: 3,
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            border: '2px dashed',
            borderColor: 'divider',
            cursor: 'pointer',
            transition: 'all 0.2s ease-in-out',
            '&:hover': {
              borderColor: 'primary.main',
              backgroundColor: 'rgba(63, 81, 181, 0.04)'
            }
          }}
          onClick={handleOpenCreateDialog}
        >
          <AddIcon sx={{ fontSize: 40, color: 'primary.main', mb: 2 }} />
          <Typography variant="h6" align="center" fontWeight={500}>
            Add New Job
          </Typography>
          <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 1 }}>
            Manually add a job listing to your collection
          </Typography>
        </Card>
      </Grid>
    </Grid>
  );

  // Helper function to get color based on score
  const getScoreColor = (score) => {
    if (score >= 80) return 'success.main';
    if (score >= 60) return 'warning.main';
    return 'error.main';
  };

  // Filter jobs based on tab selection
  const getFilteredJobs = () => {
    switch (tabValue) {
      case 0: // All jobs
        return jobs;
      case 1: // AI-found jobs
        return jobs.filter(job => job.isAiGenerated);
      case 2: // Manually added jobs
        return jobs.filter(job => !job.isAiGenerated);
      case 3: // Not applied
        return jobs.filter(job => !job.applicationStatus || job.applicationStatus === 'NOT_APPLIED');
      case 4: // Applied
        return jobs.filter(job => job.applicationStatus && job.applicationStatus !== 'NOT_APPLIED');
      default:
        return jobs;
    }
  };

  const filteredJobs = getFilteredJobs();

  // FIXED: Count jobs by analysis status using the helper function
  const analyzingCount = jobs.filter(job => {
    const status = getJobAnalysisStatus(job);
    return status.status === 'analyzing' || status.status === 'pending';
  }).length;

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Box>
            <Typography variant="h4" component="h1" fontWeight={500}>
              Job Matches
            </Typography>
            {analyzingCount > 0 && (
              <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
                {analyzingCount} job{analyzingCount === 1 ? '' : 's'} currently being analyzed
              </Typography>
            )}
          </Box>
          {!loading && !error && jobs.length > 0 && (
            <Box sx={{ display: 'flex', gap: 2 }}>
              <Button 
                variant="outlined" 
                color="primary" 
                startIcon={<SafeAutoJobLogo size="small" />} 
                onClick={handleOpenFindJobsDialog}
                sx={{ textTransform: 'none' }}
              >
                Discover Jobs
              </Button>
              <Button 
                variant="contained" 
                color="primary" 
                startIcon={<AddIcon />} 
                onClick={handleOpenCreateDialog}
                sx={{ textTransform: 'none' }}
              >
                Add Job Manually
              </Button>
            </Box>
          )}
        </Box>

        {loading ? (
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '300px' }}>
            <CircularProgress size={60} thickness={4} color="primary" />
            <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
              Loading your jobs...
            </Typography>
          </Box>
        ) : error ? (
          renderErrorState()
        ) : jobs.length === 0 ? (
          renderEmptyState()
        ) : (
          <>
            <Tabs
              value={tabValue}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}
            >
              <Tab label={`All Jobs (${jobs.length})`} />
              <Tab label={`AI Found (${jobs.filter(job => job.isAiGenerated).length})`} />
              <Tab label={`Manually Added (${jobs.filter(job => !job.isAiGenerated).length})`} />
              <Tab label={`Not Applied (${jobs.filter(job => !job.applicationStatus || job.applicationStatus === 'NOT_APPLIED').length})`} />
              <Tab label={`Applied (${jobs.filter(job => job.applicationStatus && job.applicationStatus !== 'NOT_APPLIED').length})`} />
            </Tabs>
            
            {filteredJobs.length === 0 ? (
              <Box sx={{ textAlign: 'center', my: 6 }}>
                <Typography variant="h6" color="text.secondary">
                  No jobs found in this category
                </Typography>
              </Box>
            ) : (
              renderJobGrid(filteredJobs)
            )}
          </>
        )}
      </Box>

      {/* Job Create Dialog */}
      <JobCreateDialog 
        open={openCreateDialog}
        onClose={handleCloseCreateDialog}
        onJobCreated={handleJobCreated}
      />
      
      {/* Find Jobs Dialog */}
      <FindJobsDialog 
        open={openFindJobsDialog}
        onClose={handleCloseFindJobsDialog}
        onJobsFound={handleJobsFindCompleted}
        resumes={activeResumes}
      />
      
      {/* Job menu */}
      <Menu
        id="job-menu"
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <MenuItem onClick={handleDeleteJob} sx={{ color: 'error.main' }}>
          <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
          Delete Job
        </MenuItem>
      </Menu>

      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        message={snackbar.message}
        severity={snackbar.severity}
      />
    </MainLayout>
  );
};

export default JobsPage;

================
File: frontend/src/components/jobs/ResumeTailoring.js
================
// src/components/jobs/ResumeTailoring.js
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Grid,
  Paper,
  Button,
  CircularProgress,
  Alert,
  Card,
  CardContent,
  CardHeader,
  Divider,
  Stepper,
  Step,
  StepLabel,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  TextField,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Snackbar,
  useTheme,
  alpha
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  ExpandMore as ExpandMoreIcon,
  Save as SaveIcon,
  SmartToy as SmartToyIcon,
  Lightbulb as LightbulbIcon,
  Business as BusinessIcon,
  WorkOutline as WorkOutlineIcon,
  FormatListBulleted as FormatListBulletedIcon,
  CropFree as CropFreeIcon,
  Keyboard as KeyboardIcon,
  Info as InfoIcon
} from '@mui/icons-material';
import jobService from '../../utils/jobService';
import resumeService from '../../utils/resumeService';
import MainLayout from '../layout/MainLayout';

const ResumeTailoring = () => {
  const theme = useTheme();
  const { jobId, resumeId } = useParams();
  const navigate = useNavigate();
  
  const [job, setJob] = useState(null);
  const [resume, setResume] = useState(null);
  const [tailoringData, setTailoringData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [activeStep, setActiveStep] = useState(0);
  const [tailoringSaving, setTailoringSaving] = useState(false);
  const [versionName, setVersionName] = useState('');
  const [versionNotes, setVersionNotes] = useState('');
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  const steps = ['Analyze Match', 'Review Recommendations', 'Create Tailored Version'];

  useEffect(() => {
    fetchData();
  }, [jobId, resumeId]);

  useEffect(() => {
    if (resume && job) {
      setVersionName(`AI Tailored - ${resume.name} for ${job.title} at ${job.company}`);
    }
  }, [resume, job]);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError('');
      
      // Fetch job details
      const jobData = await jobService.getJobById(jobId);
      setJob(jobData);
      
      // Fetch resume details
      const resumeData = await resumeService.getResumeById(resumeId);
      setResume(resumeData.resume);
      
      // If no match analysis exists, create one
      if (!jobData.matchAnalysis || !jobData.matchAnalysis.overallScore) {
        await jobService.matchResumeWithJob(jobId, resumeId);
        // Refresh job data to get match analysis
        const updatedJobData = await jobService.getJobById(jobId);
        setJob(updatedJobData);
      }
      
      // Get tailoring recommendations
      const tailoringResult = await jobService.getTailoringRecommendations(jobId, resumeId);
      setTailoringData(tailoringResult.tailoringResult);
      
      setActiveStep(1); // Move to recommendations step
    } catch (err) {
      console.error('Error fetching tailoring data:', err);
      setError('Failed to load tailoring data. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleNext = () => {
    setActiveStep((prevStep) => prevStep + 1);
  };

  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
  };

  const handleCloseSnackbar = () => {
    setSnackbar({
      ...snackbar,
      open: false
    });
  };

  const showSnackbar = (message, severity) => {
    setSnackbar({
      open: true,
      message,
      severity
    });
  };

  const handleSaveTailoredResume = async () => {
    if (!versionName) {
      showSnackbar('Please provide a name for your tailored resume', 'warning');
      return;
    }
    
    setTailoringSaving(true);
    
    try {
      console.log('Creating tailored resume with options:', {
        name: versionName,
        notes: versionNotes
      });
      
      // Call API to create tailored resume
      const response = await resumeService.createTailoredResume(resumeId, jobId, {
        name: versionName,
        notes: versionNotes
      });
      
      console.log('Tailored resume creation response:', response);
      
      // Show success message with analysis info
      const analysisInfo = response.resume?.analysis?.overallScore 
        ? ` (New Resume Score: ${response.resume.analysis.overallScore}%)`
        : '';
      
      showSnackbar(`Tailored resume created successfully!${analysisInfo}`, 'success');
      
      // Wait a moment, then show success and navigate
      setTimeout(async () => {
        // Show final success message
        showSnackbar('✅ Tailored resume created and job match updated!', 'success');
        
        // Navigate to the new tailored resume detail page
        if (response.resume?.id) {
          setTimeout(() => {
            navigate(`/resumes/${response.resume.id}`);
          }, 1500);
        } else {
          // Fallback to resumes list
          setTimeout(() => {
            navigate('/resumes');
          }, 1500);
        }
      }, 1000);
      
    } catch (error) {
      console.error('Error saving tailored resume:', error);
      
      // More detailed error handling
      let errorMessage = 'Failed to create tailored resume. Please try again.';
      
      if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      showSnackbar(errorMessage, 'error');
      setTailoringSaving(false);
    }
  };

  const renderStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <Box sx={{ my: 2 }}>
            <Typography variant="body1" gutterBottom>
              Analyzing resume match with job description...
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', my: 4 }}>
              <CircularProgress size={60} />
            </Box>
          </Box>
        );
      
      case 1:
        return (
          <Box sx={{ my: 2 }}>
            <Typography variant="h6" fontWeight={500} gutterBottom>
              Tailoring Recommendations
            </Typography>
            
            <Grid container spacing={3}>
              {/* Summary Recommendations */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <SmartToyIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Professional Summary
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    <Grid container spacing={3}>
                      <Grid item xs={12} md={6}>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            height: '100%',
                            borderRadius: 2,
                            borderColor: theme.palette.divider,
                            boxShadow: 'none'
                          }}
                        >
                          <CardHeader 
                            title="Original Version" 
                            titleTypographyProps={{ 
                              variant: 'subtitle2', 
                              fontWeight: 600,
                              color: theme.palette.text.primary
                            }} 
                            sx={{ 
                              p: 2, 
                              pb: 1,
                              backgroundColor: alpha(theme.palette.primary.main, 0.05)
                            }}
                          />
                          <CardContent sx={{ p: 2 }}>
                            <Typography variant="body2" color="text.secondary">
                              {tailoringData?.summary?.original || "No summary found in original resume."}
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            height: '100%',
                            borderRadius: 2,
                            borderColor: theme.palette.success.main,
                            backgroundColor: alpha(theme.palette.success.main, 0.05),
                            boxShadow: 'none'
                          }}
                        >
                          <CardHeader 
                            title="Tailored Version" 
                            titleTypographyProps={{ 
                              variant: 'subtitle2', 
                              fontWeight: 600,
                              color: theme.palette.text.primary 
                            }} 
                            sx={{ 
                              p: 2, 
                              pb: 1,
                              backgroundColor: alpha(theme.palette.success.main, 0.12),
                              borderBottom: `1px solid ${alpha(theme.palette.success.main, 0.2)}`
                            }}
                          />
                          <CardContent sx={{ p: 2 }}>
                            <Typography variant="body2" color="text.secondary">
                              {tailoringData?.summary?.tailored || "No tailored summary available."}
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                    </Grid>
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Experience Improvements */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <WorkOutlineIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Experience Improvements
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    {tailoringData?.experienceImprovements?.length > 0 ? (
                      tailoringData.experienceImprovements.map((exp, index) => (
                        <Box key={index} sx={{ mb: 3 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <BusinessIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                            <Typography variant="subtitle1" fontWeight={600}>
                              {exp.company} - {exp.position}
                            </Typography>
                          </Box>
                          <Grid container spacing={3}>
                            <Grid item xs={12} md={6}>
                              <Card 
                                variant="outlined" 
                                sx={{ 
                                  mb: 2,
                                  borderRadius: 2,
                                  borderColor: theme.palette.divider,
                                  boxShadow: 'none'
                                }}
                              >
                                <CardHeader 
                                  title="Original Bullet Points" 
                                  titleTypographyProps={{ 
                                    variant: 'subtitle2', 
                                    fontWeight: 600,
                                    color: theme.palette.text.primary
                                  }} 
                                  sx={{ 
                                    p: 2, 
                                    pb: 1.5,
                                    backgroundColor: alpha(theme.palette.primary.main, 0.05)
                                  }}
                                />
                                <CardContent sx={{ p: 2 }}>
                                  <List dense disablePadding>
                                    {exp.original.map((bullet, i) => (
                                      <ListItem key={i} sx={{ px: 1, py: 0.5 }}>
                                        <ListItemIcon sx={{ minWidth: 32 }}>
                                          <FormatListBulletedIcon fontSize="small" color="action" />
                                        </ListItemIcon>
                                        <ListItemText 
                                          primary={bullet} 
                                          primaryTypographyProps={{ 
                                            variant: 'body2',
                                            color: 'text.secondary' 
                                          }} 
                                        />
                                      </ListItem>
                                    ))}
                                  </List>
                                </CardContent>
                              </Card>
                            </Grid>
                            <Grid item xs={12} md={6}>
                              <Card 
                                variant="outlined" 
                                sx={{ 
                                  mb: 2,
                                  borderRadius: 2,
                                  borderColor: theme.palette.success.main,
                                  backgroundColor: alpha(theme.palette.success.main, 0.05),
                                  boxShadow: 'none'
                                }}
                              >
                                <CardHeader 
                                  title="Tailored Bullet Points" 
                                  titleTypographyProps={{ 
                                    variant: 'subtitle2', 
                                    fontWeight: 600,
                                    color: theme.palette.text.primary
                                  }} 
                                  sx={{ 
                                    p: 2, 
                                    pb: 1.5,
                                    backgroundColor: alpha(theme.palette.success.main, 0.12),
                                    borderBottom: `1px solid ${alpha(theme.palette.success.main, 0.2)}`
                                  }}
                                />
                                <CardContent sx={{ p: 2 }}>
                                  <List dense disablePadding>
                                    {exp.tailored.map((bullet, i) => (
                                      <ListItem key={i} sx={{ px: 1, py: 0.5 }}>
                                        <ListItemIcon sx={{ minWidth: 32 }}>
                                          <CheckCircleIcon fontSize="small" color="success" />
                                        </ListItemIcon>
                                        <ListItemText 
                                          primary={bullet} 
                                          primaryTypographyProps={{ 
                                            variant: 'body2',
                                            color: 'text.secondary'  
                                          }} 
                                        />
                                      </ListItem>
                                    ))}
                                  </List>
                                </CardContent>
                              </Card>
                            </Grid>
                          </Grid>
                          {index < tailoringData.experienceImprovements.length - 1 && <Divider sx={{ my: 3 }} />}
                        </Box>
                      ))
                    ) : (
                      <Alert severity="info" sx={{ borderRadius: 2 }}>
                        No experience improvements recommended.
                      </Alert>
                    )}
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Skills Improvements */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <CropFreeIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Skills Recommendations
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    <Grid container spacing={3}>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle2" fontWeight={600} gutterBottom sx={{ display: 'flex', alignItems: 'center' }}>
                          <LightbulbIcon fontSize="small" sx={{ mr: 1, color: theme.palette.primary.main }} />
                          Skills to Add
                        </Typography>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            p: 2, 
                            borderRadius: 2,
                            borderColor: theme.palette.primary.main,
                            backgroundColor: alpha(theme.palette.primary.main, 0.05)
                          }}
                        >
                          {tailoringData?.skillsImprovements?.skillsToAdd?.length > 0 ? (
                            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                              {tailoringData.skillsImprovements.skillsToAdd.map((skill, index) => (
                                <Chip 
                                  key={index} 
                                  label={skill} 
                                  color="primary"
                                  variant="outlined"
                                  sx={{ borderRadius: 6 }}
                                />
                              ))}
                            </Box>
                          ) : (
                            <Typography variant="body2" color="text.secondary">
                              No additional skills recommended.
                            </Typography>
                          )}
                        </Card>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle2" fontWeight={600} gutterBottom sx={{ display: 'flex', alignItems: 'center' }}>
                          <CheckCircleIcon fontSize="small" sx={{ mr: 1, color: theme.palette.success.main }} />
                          Skills to Emphasize
                        </Typography>
                        <Card 
                          variant="outlined" 
                          sx={{ 
                            p: 2, 
                            borderRadius: 2,
                            borderColor: theme.palette.success.main,
                            backgroundColor: alpha(theme.palette.success.main, 0.05)
                          }}
                        >
                          {tailoringData?.skillsImprovements?.skillsToEmphasize?.length > 0 ? (
                            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                              {tailoringData.skillsImprovements.skillsToEmphasize.map((skill, index) => (
                                <Chip 
                                  key={index} 
                                  label={skill} 
                                  color="success"
                                  variant="outlined"
                                  sx={{ borderRadius: 6 }}
                                />
                              ))}
                            </Box>
                          ) : (
                            <Typography variant="body2" color="text.secondary">
                              No skills to emphasize recommended.
                            </Typography>
                          )}
                        </Card>
                      </Grid>
                    </Grid>
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Keyword Suggestions */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <KeyboardIcon sx={{ mr: 1.5, color: theme.palette.primary.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Keyword Suggestions
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                      Including these keywords will boost your resume's ATS compatibility and relevance for this job:
                    </Typography>
                    {tailoringData?.keywordSuggestions?.length > 0 ? (
                      <Box sx={{ 
                        display: 'flex', 
                        flexWrap: 'wrap', 
                        gap: 1,
                        mt: 2,
                        '& .MuiChip-root': {
                          borderRadius: 6
                        }
                      }}>
                        {tailoringData.keywordSuggestions.map((keyword, index) => (
                          <Chip 
                            key={index} 
                            label={keyword} 
                            color="info"
                            variant="outlined"
                          />
                        ))}
                      </Box>
                    ) : (
                      <Alert severity="info" sx={{ mt: 1, borderRadius: 2 }}>
                        No keyword suggestions available.
                      </Alert>
                    )}
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* Format Suggestions */}
              <Grid item xs={12}>
                <Accordion 
                  defaultExpanded
                  sx={{
                    borderRadius: 2,
                    overflow: 'hidden',
                    boxShadow: 'none',
                    border: `1px solid ${theme.palette.divider}`,
                    '&:before': {
                      display: 'none',
                    },
                    mb: 2
                  }}
                >
                  <AccordionSummary 
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                      background: alpha(theme.palette.primary.main, 0.05),
                    }}
                  >
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <WarningIcon sx={{ mr: 1.5, color: theme.palette.warning.main }} />
                      <Typography variant="subtitle1" fontWeight={600}>
                        Format Suggestions
                      </Typography>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails sx={{ p: 3 }}>
                    {tailoringData?.formatSuggestions?.length > 0 ? (
                      <List sx={{ bgcolor: alpha(theme.palette.warning.main, 0.05), borderRadius: 2, p: 2 }}>
                        {tailoringData.formatSuggestions.map((suggestion, index) => (
                          <ListItem key={index} sx={{ px: 1, py: 0.5 }}>
                            <ListItemIcon>
                              <WarningIcon color="warning" />
                            </ListItemIcon>
                            <ListItemText 
                              primary={suggestion} 
                              primaryTypographyProps={{ color: 'text.secondary' }}
                            />
                          </ListItem>
                        ))}
                      </List>
                    ) : (
                      <Alert severity="info" sx={{ borderRadius: 2 }}>
                        No format suggestions available.
                      </Alert>
                    )}
                  </AccordionDetails>
                </Accordion>
              </Grid>
              
              {/* General Advice */}
              <Grid item xs={12}>
                <Card 
                  sx={{ 
                    borderRadius: 2,
                    border: `1px solid ${theme.palette.divider}`,
                    boxShadow: 'none'
                  }}
                >
                  <CardHeader 
                    title="General Advice" 
                    avatar={<InfoIcon color="primary" />}
                    titleTypographyProps={{ fontWeight: 600 }}
                    sx={{ 
                      p: 2, 
                      pb: 1.5,
                      backgroundColor: alpha(theme.palette.primary.main, 0.05)
                    }}
                  />
                  <CardContent sx={{ p: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      {tailoringData?.generalAdvice || "No general advice available."}
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Box>
        );
      
      case 2:
        return (
          <Box sx={{ my: 2 }}>
            <Typography variant="h6" fontWeight={500} gutterBottom>
              Create Tailored Resume
            </Typography>
            
            <Typography variant="body1" paragraph color="text.secondary">
              Based on the recommendations, we'll create a tailored version of your resume 
              specifically optimized for this job. The AI will apply all the suggested improvements.
            </Typography>
            
            <Box sx={{ 
              mt: 3, 
              p: 2.5, 
              bgcolor: alpha(theme.palette.info.main, 0.1), 
              borderRadius: 2, 
              display: 'flex', 
              alignItems: 'flex-start',
              border: `1px solid ${alpha(theme.palette.info.main, 0.3)}`
            }}>
              <SmartToyIcon sx={{ mr: 2, color: theme.palette.info.main, mt: 0.5 }} />
              <Typography variant="body2" color="text.secondary">
                This will create a new resume in your collection with the AI recommended improvements applied.
                Your original resume will remain unchanged.
              </Typography>
            </Box>
            
            <Typography variant="subtitle2" fontWeight={600} color="text.secondary" sx={{ mt: 3, mb: 1 }}>
              Resume Name
            </Typography>
            <TextField
              variant="outlined"
              fullWidth
              value={versionName}
              onChange={(e) => setVersionName(e.target.value)}
              placeholder="Enter a name for your tailored resume"
              size="medium"
              sx={{ 
                mb: 3,
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2
                }
              }}
            />
            
            <Typography variant="subtitle2" fontWeight={600} color="text.secondary" sx={{ mb: 1 }}>
              Notes (Optional)
            </Typography>
            <TextField
              variant="outlined"
              fullWidth
              multiline
              rows={3}
              value={versionNotes}
              onChange={(e) => setVersionNotes(e.target.value)}
              placeholder="Add any notes about this tailored version..."
              sx={{ 
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2
                }
              }}
            />
          </Box>
        );
      
      default:
        return null;
    }
  };

  if (loading && activeStep === 0) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate(`/jobs/${jobId}`)}
            sx={{ mb: 4 }}
            variant="outlined"
          >
            Back to Job
          </Button>
          
          <Paper sx={{ p: 4, borderRadius: 3 }}>
            <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
              {steps.map((label) => (
                <Step key={label}>
                  <StepLabel>{label}</StepLabel>
                </Step>
              ))}
            </Stepper>
            
            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              <Typography variant="h6" gutterBottom fontWeight={500}>
                Analyzing Resume Match
              </Typography>
              <CircularProgress size={60} thickness={4} sx={{ my: 4 }} />
              <Typography variant="body1" color="text.secondary">
                Please wait while we analyze your resume against the job requirements...
              </Typography>
            </Box>
          </Paper>
        </Box>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate(`/jobs/${jobId}`)}
            sx={{ mb: 2 }}
            variant="outlined"
          >
            Back to Job
          </Button>
          
          <Alert severity="error" sx={{ mb: 2, borderRadius: 2 }}>
            {error}
          </Alert>
          
          <Button 
            variant="contained" 
            color="primary"
            onClick={fetchData}
          >
            Try Again
          </Button>
        </Box>
      </MainLayout>
    );
  }

  if (!job || !resume || !tailoringData) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate(`/jobs/${jobId}`)}
            sx={{ mb: 2 }}
            variant="outlined"
          >
            Back to Job
          </Button>
          
          <Alert severity="info" sx={{ borderRadius: 2 }}>
            Unable to load tailoring data. Please try again.
          </Alert>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1200px', mx: 'auto' }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate(`/jobs/${jobId}`)}
          sx={{ mb: 2 }}
          variant="outlined"
        >
          Back to Job
        </Button>
        
        <Paper sx={{ p: 4, mb: 3, borderRadius: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
            <Box>
              <Typography variant="h5" gutterBottom fontWeight={600}>
                Tailor Resume for {job.title}
              </Typography>
              <Typography variant="subtitle1" color="text.secondary">
                {job.company}
              </Typography>
            </Box>
            <Box>
              <Chip 
                label={`Match Score: ${job.matchAnalysis?.overallScore || 0}%`}
                color={getScoreColor(job.matchAnalysis?.overallScore || 0)}
                sx={{ fontWeight: 500, borderRadius: 6, height: 36 }}
              />
            </Box>
          </Box>
          
          <Stepper 
            activeStep={activeStep} 
            sx={{ 
              mb: 4,
              '& .MuiStepLabel-root': {
                '& .MuiStepLabel-iconContainer': {
                  '& .MuiStepIcon-root': {
                    '&.Mui-active': {
                      color: theme.palette.primary.main,
                    },
                    '&.Mui-completed': {
                      color: theme.palette.success.main,
                    },
                  },
                },
              },
            }}
          >
            {steps.map((label) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>
          
          {renderStepContent(activeStep)}
          
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4, pt: 2, borderTop: `1px solid ${theme.palette.divider}` }}>
            <Button
              variant="outlined"
              onClick={() => navigate(`/jobs/${jobId}`)}
              sx={{ mr: 1, borderRadius: 2 }}
            >
              Cancel
            </Button>
            
            <Box>
              {activeStep === 2 && (
                <Button
                  variant="outlined"
                  onClick={handleBack}
                  startIcon={<ArrowBackIcon />}
                  sx={{ mr: 1, borderRadius: 2 }}
                  disabled={loading || tailoringSaving}
                >
                  Back to Recommendations
                </Button>
              )}
              
              {activeStep < steps.length - 1 ? (
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handleNext}
                  disabled={loading || activeStep === 0}
                  sx={{ borderRadius: 2 }}
                >
                  Next
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handleSaveTailoredResume}
                  startIcon={tailoringSaving ? <CircularProgress size={20} color="inherit" /> : <SaveIcon />}
                  disabled={tailoringSaving}
                  sx={{ borderRadius: 2, px: 3 }}
                >
                  {tailoringSaving ? 'Creating...' : 'Create Tailored Resume'}
                </Button>
              )}
            </Box>
          </Box>
        </Paper>
      </Box>
      
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert 
          onClose={handleCloseSnackbar} 
          severity={snackbar.severity} 
          sx={{ width: '100%', borderRadius: 2 }}
          variant="filled"
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </MainLayout>
  );
};

// Helper function to get color based on score
const getScoreColor = (score) => {
  if (score >= 80) return 'success';
  if (score >= 60) return 'warning';
  return 'error';
};

export default ResumeTailoring;

================
File: frontend/src/components/jobs/tabs/AnalysisTab.js
================
// src/components/jobs/tabs/AnalysisTab.js
import React from 'react';
import {
  Grid,
  Card,
  CardHeader,
  CardContent,
  Typography,
  Button,
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Alert,
  CircularProgress,
  Stack,
  Chip,
  Tooltip,
  useTheme,
  Paper
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  SmartToy as SmartToyIcon,
  Lightbulb as LightbulbIcon,
  Code as CodeIcon,
  Speed as SpeedIcon,
  AutoAwesome as AutoAwesomeIcon,
  Analytics as AnalyticsIcon,
  TrendingUp as TrendingUpIcon
} from '@mui/icons-material';

import SkillChip from '../components/SkillChip';
import AutoJobLogo from '../../common/AutoJobLogo';

const AnalysisTab = ({ job, onTailorClick }) => {
  const theme = useTheme();

  // Safe AutoJobLogo wrapper component that handles the proper props
  const SafeAutoJobLogo = ({ iconSize = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={iconSize} 
          showTagline={false}
        />
      );
    } catch (error) {
      // Fallback to SmartToy icon if AutoJobLogo fails
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: iconSize === 'small' ? 16 : 20 }} />;
    }
  };

  const getScoreColor = (score) => {
    if (score >= 85) return 'success';
    if (score >= 70) return 'info';
    if (score >= 55) return 'warning';
    return 'error';
  };

  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  if (!job.matchAnalysis?.overallScore) {
    return (
      <Box sx={{ 
        display: 'flex', 
        flexDirection: 'column', 
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '50vh',
        textAlign: 'center',
        px: 3,
        py: 6
      }}>
        {/* Main Icon Container with Diamond */}
        <Box sx={{ 
          mb: 3,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          {/* Background Circle with Gradient */}
          <Box
            sx={{
              width: 80,
              height: 80,
              background: `linear-gradient(135deg, ${theme.palette.primary.main}15 0%, ${theme.palette.secondary.main}15 100%)`,
              borderRadius: 3, // Using theme's borderRadius
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              border: `2px solid ${theme.palette.primary.main}20`,
              position: 'relative',
              boxShadow: `0px 4px 8px ${theme.palette.primary.main}20`,
            }}
          >
            <AutoAwesomeIcon sx={{ 
              fontSize: 32, 
              color: theme.palette.primary.main
            }} />
          </Box>
        </Box>

        {/* Title with Theme Typography */}
        <Typography 
          variant="h5" 
          gutterBottom 
          fontWeight={600}
          sx={{ 
            color: theme.palette.text.primary,
            mb: 1
          }}
        >
          No Match Analysis Available
        </Typography>
        
        {/* Subtitle */}
        <Typography 
          variant="body1" 
          sx={{ 
            color: theme.palette.text.secondary,
            mb: 4,
            maxWidth: 500,
            lineHeight: 1.5
          }}
        >
          Get detailed insights by matching your resume with this job. Our enhanced AI will provide:
        </Typography>

        {/* Features List in Card */}
        <Paper 
          elevation={1}
          sx={{ 
            maxWidth: 480, 
            mb: 4,
            p: 3,
            borderRadius: 3, // Using theme's enhanced borderRadius
            bgcolor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`
          }}
        >
          <List dense sx={{ '& .MuiListItem-root': { py: 0.75 } }}>
            <ListItem sx={{ px: 0 }}>
              <ListItemIcon sx={{ minWidth: 36 }}>
                <CheckCircleIcon color="primary" fontSize="small" />
              </ListItemIcon>
              <ListItemText 
                primary="Precise skill matching with importance weighting"
                primaryTypographyProps={{ 
                  variant: 'body2', 
                  fontWeight: 500,
                  color: theme.palette.text.primary
                }}
              />
            </ListItem>
            <ListItem sx={{ px: 0 }}>
              <ListItemIcon sx={{ minWidth: 36 }}>
                <TrendingUpIcon color="primary" fontSize="small" />
              </ListItemIcon>
              <ListItemText 
                primary="Experience level compatibility analysis"
                primaryTypographyProps={{ 
                  variant: 'body2', 
                  fontWeight: 500,
                  color: theme.palette.text.primary
                }}
              />
            </ListItem>
            <ListItem sx={{ px: 0 }}>
              <ListItemIcon sx={{ minWidth: 36 }}>
                <LightbulbIcon color="primary" fontSize="small" />
              </ListItemIcon>
              <ListItemText 
                primary="Personalized recommendations for improvement"
                primaryTypographyProps={{ 
                  variant: 'body2', 
                  fontWeight: 500,
                  color: theme.palette.text.primary
                }}
              />
            </ListItem>
          </List>
        </Paper>

        {/* CTA Button with Theme Styling */}
        <Button
          variant="contained"
          size="large"
          onClick={onTailorClick}
          startIcon={<SafeAutoJobLogo iconSize="small" />}
          sx={{ 
            borderRadius: 2, // Using theme's borderRadius
            px: 4,
            py: 1.2,
            fontSize: '0.95rem',
            fontWeight: 600,
            bgcolor: theme.palette.secondary.main,
            color: theme.palette.secondary.contrastText,
            boxShadow: theme.shadows[3],
            '&:hover': {
              bgcolor: theme.palette.secondary.dark,
              boxShadow: theme.shadows[6],
              transform: 'translateY(-1px)'
            },
            transition: 'all 0.2s ease'
          }}
        >
          Start Enhanced Analysis
        </Button>

        {/* Bottom Helper Text */}
        <Typography 
          variant="caption" 
          sx={{ 
            color: theme.palette.text.disabled,
            mt: 3,
            maxWidth: 400
          }}
        >
          Our AI will analyze your resume against this job posting to provide detailed compatibility scores and improvement suggestions.
        </Typography>
      </Box>
    );
  }

  return (
    <Grid container spacing={3}>
      {/* Detailed Match Breakdown */}
      <Grid item xs={12}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Detailed Match Analysis" 
            avatar={<SpeedIcon color="primary" />}
            action={
              <Stack direction="row" spacing={1}>
                <Chip 
                  label={`Analyzed ${new Date(job.matchAnalysis.lastAnalyzed || Date.now()).toLocaleDateString()}`} 
                  size="small" 
                  color="secondary"
                  variant="outlined"
                />
              </Stack>
            }
            sx={{ 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} md={4}>
                <Box sx={{ textAlign: 'center', p: 3, border: '1px solid', borderColor: 'divider', borderRadius: 3, height: '100%' }}>
                  <Box sx={{ mb: 2 }}>
                    <CircularProgress
                      variant="determinate"
                      value={job.matchAnalysis.categoryScores?.skills || 0}
                      size={80}
                      thickness={6}
                      sx={{ 
                        color: theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.skills || 0)].main,
                        mb: 1
                      }}
                    />
                  </Box>
                  <Typography variant="h5" fontWeight={600} color={theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.skills || 0)].main}>
                    {job.matchAnalysis.categoryScores?.skills || 0}%
                  </Typography>
                  <Typography variant="subtitle1" fontWeight={500} color="primary.main">
                    Skills Match
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                    {job.matchAnalysis.matchedSkills?.filter(s => s.found).length || 0} of {job.matchAnalysis.matchedSkills?.length || 0} skills matched
                  </Typography>
                  
                  {/* Skills breakdown */}
                  {job.matchAnalysis.matchedSkills && (
                    <Box sx={{ mt: 2 }}>
                      <Stack direction="row" spacing={1} justifyContent="center">
                        <Chip 
                          label={`${job.matchAnalysis.matchedSkills.filter(s => s.found && s.matchQuality === 'exact').length} exact`}
                          size="small"
                          color="success"
                        />
                        <Chip 
                          label={`${job.matchAnalysis.matchedSkills.filter(s => s.found && s.matchQuality === 'partial').length} partial`}
                          size="small"
                          color="warning"
                        />
                      </Stack>
                    </Box>
                  )}
                </Box>
              </Grid>
              
              <Grid item xs={12} md={4}>
                <Box sx={{ textAlign: 'center', p: 3, border: '1px solid', borderColor: 'divider', borderRadius: 3, height: '100%' }}>
                  <Box sx={{ mb: 2 }}>
                    <CircularProgress
                      variant="determinate"
                      value={job.matchAnalysis.categoryScores?.experience || 0}
                      size={80}
                      thickness={6}
                      sx={{ 
                        color: theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.experience || 0)].main,
                        mb: 1
                      }}
                    />
                  </Box>
                  <Typography variant="h5" fontWeight={600} color={theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.experience || 0)].main}>
                    {job.matchAnalysis.categoryScores?.experience || 0}%
                  </Typography>
                  <Typography variant="subtitle1" fontWeight={500} color="primary.main">
                    Experience Match
                  </Typography>
                  
                  {/* Enhanced experience details */}
                  {job.matchAnalysis.experienceAnalysis ? (
                    <Box sx={{ mt: 1 }}>
                      <Typography variant="body2" color="text.secondary">
                        {job.matchAnalysis.experienceAnalysis.relevantYearsExperience || 0} years relevant
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {job.matchAnalysis.experienceAnalysis.seniorityMatch && 
                          `${job.matchAnalysis.experienceAnalysis.seniorityMatch} level`}
                      </Typography>
                    </Box>
                  ) : (
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Experience level alignment
                    </Typography>
                  )}
                </Box>
              </Grid>
              
              <Grid item xs={12} md={4}>
                <Box sx={{ textAlign: 'center', p: 3, border: '1px solid', borderColor: 'divider', borderRadius: 3, height: '100%' }}>
                  <Box sx={{ mb: 2 }}>
                    <CircularProgress
                      variant="determinate"
                      value={job.matchAnalysis.categoryScores?.education || 0}
                      size={80}
                      thickness={6}
                      sx={{ 
                        color: theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.education || 0)].main,
                        mb: 1
                      }}
                    />
                  </Box>
                  <Typography variant="h5" fontWeight={600} color={theme.palette[getScoreColor(job.matchAnalysis.categoryScores?.education || 0)].main}>
                    {job.matchAnalysis.categoryScores?.education || 0}%
                  </Typography>
                  <Typography variant="subtitle1" fontWeight={500} color="primary.main">
                    Education Match
                  </Typography>
                  
                  {/* Enhanced education details */}
                  {job.matchAnalysis.educationAnalysis ? (
                    <Box sx={{ mt: 1 }}>
                      <Typography variant="body2" color="text.secondary" sx={{ textTransform: 'capitalize' }}>
                        {job.matchAnalysis.educationAnalysis.degreeMatch} requirements
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ textTransform: 'capitalize' }}>
                        {job.matchAnalysis.educationAnalysis.fieldAlignment} field alignment
                      </Typography>
                    </Box>
                  ) : (
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                      Education requirements met
                    </Typography>
                  )}
                </Box>
              </Grid>
            </Grid>
            
            <Box sx={{ 
              mt: 3, 
              p: 2, 
              bgcolor: `${theme.palette.info.main}10`, 
              borderRadius: 2,
              border: `1px solid ${theme.palette.info.main}20`,
              display: 'flex',
              alignItems: 'flex-start'
            }}>
              <AnalyticsIcon color="info" sx={{ mr: 1.5, mt: 0.5 }} />
              <Box>
                <Typography variant="body2" paragraph>
                  Our enhanced AI matching algorithm analyzes your resume against this job using advanced NLP and semantic understanding. 
                  Scores are weighted: Skills (40%), Experience (35%), Education (25%).
                </Typography>
              </Box>
            </Box>
          </CardContent>
        </Card>
      </Grid>
      
      {/* Enhanced Skills Analysis */}
      <Grid item xs={12} md={6}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3, height: 'fit-content' }}>
          <CardHeader 
            title="Skills Analysis" 
            avatar={<CodeIcon color="primary" />}
            sx={{ 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            <Typography variant="subtitle1" fontWeight={600} gutterBottom sx={{ 
              color: theme.palette.success.main, 
              display: 'flex', 
              alignItems: 'center' 
            }}>
              <CheckCircleIcon sx={{ mr: 1 }} /> Matched Skills ({job.matchAnalysis.matchedSkills?.filter(s => s.found).length || 0})
            </Typography>
            
            {job.matchAnalysis.matchedSkills && job.matchAnalysis.matchedSkills.filter(s => s.found).length > 0 ? (
              <Box sx={{ 
                display: 'flex', 
                flexWrap: 'wrap', 
                gap: 1, 
                mb: 3,
                p: 2,
                bgcolor: `${theme.palette.success.main}08`,
                borderRadius: 2
              }}>
                {job.matchAnalysis.matchedSkills && job.matchAnalysis.matchedSkills.filter(s => s && s.found).map((skill, index) => (
                  <SkillChip
                    key={`matched-skill-${index}`}
                    skill={skill}
                    isMatched={true}
                    importance={skill && typeof skill === 'object' ? skill.importance : undefined}
                    matchQuality={skill && typeof skill === 'object' ? skill.matchQuality : undefined}
                  />
                ))}
              </Box>
            ) : (
              <Alert severity="info" sx={{ mb: 3, borderRadius: 2 }}>
                No matching skills found.
              </Alert>
            )}

            <Typography variant="subtitle1" fontWeight={600} gutterBottom sx={{ 
              color: theme.palette.warning.main, 
              display: 'flex', 
              alignItems: 'center',
              mt: 4
            }}>
              <WarningIcon sx={{ mr: 1 }} /> Missing Skills ({job.matchAnalysis.missingSkills?.length || 0})
            </Typography>
            
            {job.matchAnalysis.missingSkills && job.matchAnalysis.missingSkills.length > 0 ? (
              <Box sx={{ 
                display: 'flex', 
                flexWrap: 'wrap', 
                gap: 1,
                p: 2,
                bgcolor: `${theme.palette.warning.main}08`,
                borderRadius: 2
              }}>
                {job.matchAnalysis.missingSkills && job.matchAnalysis.missingSkills.map((skill, index) => (
                  <SkillChip
                    key={`missing-skill-${index}`}
                    skill={skill}
                    isMatched={false}
                    importance={skill && typeof skill === 'object' ? skill.importance : undefined}
                  />
                ))}
              </Box>
            ) : (
              <Alert severity="success" sx={{ borderRadius: 2 }}>
                Excellent! No missing skills identified. Your resume includes all required skills.
              </Alert>
            )}
          </CardContent>
        </Card>
      </Grid>

      {/* Enhanced Improvement Suggestions */}
      <Grid item xs={12} md={6}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3, height: 'fit-content' }}>
          <CardHeader 
            title="AI Recommendations" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            {job.matchAnalysis.improvementSuggestions && job.matchAnalysis.improvementSuggestions.length > 0 ? (
              <List sx={{ p: 0 }}>
                {job.matchAnalysis.improvementSuggestions.map((suggestion, index) => (
                  <ListItem key={index} sx={{ 
                    backgroundColor: `${theme.palette.info.main}08`, 
                    borderRadius: 2, 
                    mb: 2,
                    px: 2,
                    alignItems: 'flex-start'
                  }}>
                    <ListItemIcon>
                      <LightbulbIcon color="info" />
                    </ListItemIcon>
                    <ListItemText 
                      primary={suggestion}
                      primaryTypographyProps={{ variant: 'body2' }}
                    />
                  </ListItem>
                ))}
              </List>
            ) : (
              <Alert severity="success" sx={{ borderRadius: 2 }}>
                Great! No major improvements needed. Your resume looks excellent for this job.
              </Alert>
            )}

            <Box sx={{ mt: 3 }}>
              <Button
                variant="contained"
                color="secondary"
                startIcon={<SafeAutoJobLogo iconSize="small" />}
                onClick={onTailorClick}
                fullWidth
                sx={{ borderRadius: 2, py: 1.2 }}
              >
                Get Tailored Resume
              </Button>
            </Box>
          </CardContent>
        </Card>
      </Grid>
      
      {/* Enhanced Keywords Section */}
      <Grid item xs={12}>
        <Card elevation={2} sx={{ borderRadius: 3 }}>
          <CardHeader 
            title="Keyword Optimization" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ 
              pb: 1, 
              '& .MuiCardHeader-title': { fontWeight: 600 } 
            }}
          />
          <CardContent>
            <Typography variant="body2" color="text.secondary" paragraph>
              These keywords will boost your ATS compatibility and match score for this position:
            </Typography>
            
            <Box sx={{ 
              display: 'flex', 
              flexWrap: 'wrap', 
              gap: 1.5,
              '& .MuiChip-root': {
                transition: 'all 0.2s ease',
                '&:hover': {
                  transform: 'translateY(-2px)',
                  boxShadow: 2
                }
              }
            }}>
              {job.matchAnalysis.missingSkills && job.matchAnalysis.missingSkills.map((skill, index) => {
                // Extract skill name safely
                const skillName = skill && typeof skill === 'object' ? 
                  (skill.name || skill.skill || 'Unknown Skill') : 
                  (typeof skill === 'string' ? skill : 'Unknown Skill');
                
                const importance = skill && typeof skill === 'object' ? skill.importance : 5;
                const category = skill && typeof skill === 'object' ? (skill.category || 'required') : 'required';
                
                return (
                  <Tooltip 
                    key={`keyword-skill-${index}`}
                    title={`Importance: ${importance}/10 | ${category}`}
                  >
                    <Chip 
                      label={skillName} 
                      sx={{ 
                        bgcolor: COLORS[index % COLORS.length] + '20',
                        color: COLORS[index % COLORS.length],
                        fontWeight: 500,
                        borderRadius: 2,
                        border: `1px solid ${COLORS[index % COLORS.length]}40`,
                        '&:hover': {
                          bgcolor: COLORS[index % COLORS.length] + '30',
                        }
                      }} 
                    />
                  </Tooltip>
                );
              })}
            </Box>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
};

export default AnalysisTab;

================
File: frontend/src/components/jobs/tabs/ContentTab.js
================
// src/components/jobs/tabs/ContentTab.js
import React from 'react';
import {
  Grid,
  Card,
  CardHeader,
  CardContent,
  Typography,
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  Assignment as AssignmentIcon,
  Code as CodeIcon,
  Person as PersonIcon
} from '@mui/icons-material';

const ContentTab = ({ job }) => {
  return (
    <>
      <Card elevation={2} sx={{ borderRadius: 3, mb: 3 }}>
        <CardHeader 
          title="Full Job Description" 
          avatar={<DescriptionIcon color="primary" />}
          sx={{ 
            '& .MuiCardHeader-title': { fontWeight: 600 } 
          }}
        />
        <CardContent>
          <Typography variant="body1" component="div" sx={{ whiteSpace: 'pre-line', lineHeight: 1.7 }}>
            {job.description}
          </Typography>
        </CardContent>
      </Card>
      
      {job.parsedData && (
        <Grid container spacing={3}>
          {job.parsedData.responsibilities && job.parsedData.responsibilities.length > 0 && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title={`Key Responsibilities (${job.parsedData.responsibilities.length})`}
                  avatar={<WorkIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <List>
                    {job.parsedData.responsibilities.map((resp, index) => (
                      <ListItem key={index} sx={{ py: 0.5, alignItems: 'flex-start' }}>
                        <ListItemIcon sx={{ minWidth: 28, mt: 0.5 }}>
                          <CheckCircleIcon fontSize="small" color="primary" />
                        </ListItemIcon>
                        <ListItemText 
                          primary={resp}
                          primaryTypographyProps={{ variant: 'body2' }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Grid>
          )}
          
          {job.parsedData.requirements && job.parsedData.requirements.length > 0 && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title={`Requirements (${job.parsedData.requirements.length})`}
                  avatar={<AssignmentIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <List>
                    {job.parsedData.requirements.map((req, index) => (
                      <ListItem key={index} sx={{ py: 0.5, alignItems: 'flex-start' }}>
                        <ListItemIcon sx={{ minWidth: 28, mt: 0.5 }}>
                          <CheckCircleIcon fontSize="small" color="primary" />
                        </ListItemIcon>
                        <ListItemText 
                          primary={req}
                          primaryTypographyProps={{ variant: 'body2' }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Grid>
          )}

          {/* Enhanced Technical Details */}
          {(job.parsedData.technicalSkills || job.parsedData.toolsAndTechnologies) && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title="Technical Requirements"
                  avatar={<CodeIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  {job.parsedData.technicalSkills && job.parsedData.technicalSkills.length > 0 && (
                    <Box sx={{ mb: 2 }}>
                      <Typography variant="subtitle2" gutterBottom color="primary">
                        Technical Skills:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {job.parsedData.technicalSkills && job.parsedData.technicalSkills.map((skill, index) => {
                          // Extract skill name safely
                          const skillName = skill && typeof skill === 'object' ? 
                            (skill.name || skill.skill || 'Unknown Skill') : 
                            (typeof skill === 'string' ? skill : 'Unknown Skill');
                          
                          return (
                            <Chip 
                              key={`tech-skill-${index}`} 
                              label={skillName} 
                              size="small" 
                              color="primary"
                              variant="outlined"
                            />
                          );
                        })}
                      </Box>
                    </Box>
                  )}
                  
                  {job.parsedData.toolsAndTechnologies && job.parsedData.toolsAndTechnologies.length > 0 && (
                    <Box>
                      <Typography variant="subtitle2" gutterBottom color="secondary">
                        Tools & Technologies:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {job.parsedData.toolsAndTechnologies && job.parsedData.toolsAndTechnologies.map((tool, index) => {
                          // Extract tool name safely
                          const toolName = tool && typeof tool === 'object' ? 
                            (tool.name || tool.skill || tool.tool || 'Unknown Tool') : 
                            (typeof tool === 'string' ? tool : 'Unknown Tool');
                          
                          return (
                            <Chip 
                              key={`tool-tech-${index}`} 
                              label={toolName} 
                              size="small" 
                              color="secondary"
                              variant="outlined"
                            />
                          );
                        })}
                      </Box>
                    </Box>
                  )}
                </CardContent>
              </Card>
            </Grid>
          )}

          {/* Enhanced Soft Skills */}
          {job.parsedData.softSkills && job.parsedData.softSkills.length > 0 && (
            <Grid item xs={12} md={6}>
              <Card elevation={2} sx={{ borderRadius: 3, height: '100%' }}>
                <CardHeader 
                  title="Soft Skills & Attributes"
                  avatar={<PersonIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                    {job.parsedData.softSkills && job.parsedData.softSkills.map((skill, index) => {
                      // Extract skill name safely
                      const skillName = skill && typeof skill === 'object' ? 
                        (skill.name || skill.skill || 'Unknown Skill') : 
                        (typeof skill === 'string' ? skill : 'Unknown Skill');
                      
                      return (
                        <Chip 
                          key={`soft-skill-${index}`} 
                          label={skillName} 
                          size="small" 
                          color="info"
                          variant="outlined"
                        />
                      );
                    })}
                  </Box>
                </CardContent>
              </Card>
            </Grid>
          )}
          
          {job.parsedData.benefits && job.parsedData.benefits.length > 0 && (
            <Grid item xs={12}>
              <Card elevation={2} sx={{ borderRadius: 3 }}>
                <CardHeader 
                  title={`Benefits & Perks (${job.parsedData.benefits.length})`}
                  avatar={<WorkIcon color="primary" />}
                  sx={{ 
                    '& .MuiCardHeader-title': { fontWeight: 600 } 
                  }}
                />
                <CardContent>
                  <Grid container spacing={2}>
                    {job.parsedData.benefits.map((benefit, index) => (
                      <Grid item xs={12} md={6} key={index}>
                        <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                          <CheckCircleIcon color="success" sx={{ mt: 0.5, mr: 1.5 }} />
                          <Typography variant="body2">{benefit}</Typography>
                        </Box>
                      </Grid>
                    ))}
                  </Grid>
                </CardContent>
              </Card>
            </Grid>
          )}
        </Grid>
      )}
    </>
  );
};

export default ContentTab;

================
File: frontend/src/components/jobs/tabs/OverviewTab.js
================
// src/components/jobs/tabs/OverviewTab.js
import React from 'react';
import {
  Grid,
  Card,
  CardHeader,
  CardContent,
  Typography,
  Button,
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  useTheme,
  Chip
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  SmartToy as SmartToyIcon,
  Psychology as PsychologyIcon,
  Assignment as AssignmentIcon,
  School as SchoolIcon,
  Lightbulb as LightbulbIcon,
  Code as CodeIcon,
  Info as InfoIcon,
  Star as StarIcon
} from '@mui/icons-material';

// Import our component files
import JobDetailsCard from '../components/JobDetailsCard';
import MatchAnalysisCard from '../components/MatchAnalysisCard';
import SkillChip from '../components/SkillChip';
import AutoJobLogo from '../../common/AutoJobLogo';

const OverviewTab = ({ job, onTailorClick }) => {
  const theme = useTheme();

  // Safe AutoJobLogo wrapper component
  const SafeAutoJobLogo = ({ size = 'small' }) => {
    try {
      return (
        <AutoJobLogo 
          variant="icon-only" 
          size={size} 
          showTagline={false}
        />
      );
    } catch (error) {
      // Fallback to SmartToy icon if AutoJobLogo fails
      console.warn('AutoJobLogo failed to render:', error);
      return <SmartToyIcon sx={{ fontSize: size === 'small' ? 16 : 20 }} />;
    }
  };

  return (
    <Grid container spacing={3}>
      <Grid item xs={12} md={4}>
        {/* Job Details Card Component */}
        <JobDetailsCard job={job} />
        
        {/* Match Analysis Card Component */}
        <MatchAnalysisCard job={job} />
      </Grid>

      <Grid item xs={12} md={8}>
        {job.matchAnalysis?.overallScore ? (
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Match Insights & Recommendations" 
              avatar={<CheckCircleIcon color="primary" />}
              sx={{ 
                pb: 0, 
                '& .MuiCardHeader-title': { fontWeight: 600 } 
              }}
            />
            <CardContent>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle1" gutterBottom sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    color: theme.palette.success.main,
                    fontWeight: 600
                  }}>
                    <CheckCircleIcon sx={{ mr: 1 }} /> Your Strengths
                  </Typography>
                  
                  {/* Show strengths from new enhanced matching */}
                  {job.matchAnalysis.strengthsHighlight && job.matchAnalysis.strengthsHighlight.length > 0 ? (
                    <List dense>
                      {job.matchAnalysis.strengthsHighlight.map((strength, index) => (
                        <ListItem key={index} sx={{ 
                          backgroundColor: `${theme.palette.success.main}15`, 
                          borderRadius: 2, 
                          mb: 1,
                          px: 2
                        }}>
                          <ListItemIcon>
                            <StarIcon color="success" fontSize="small" />
                          </ListItemIcon>
                          <ListItemText primary={strength} />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    /* Fallback to matched skills */
                    <List dense>
                      {job.matchAnalysis.matchedSkills && job.matchAnalysis.matchedSkills.filter(s => s.found).length > 0 ? (
                        job.matchAnalysis.matchedSkills.filter(s => s.found).slice(0, 4).map((skill, index) => (
                          <ListItem key={index} sx={{ 
                            backgroundColor: `${theme.palette.success.main}15`, 
                            borderRadius: 2, 
                            mb: 1,
                            px: 2
                          }}>
                            <ListItemIcon>
                              <CheckCircleIcon color="success" fontSize="small" />
                            </ListItemIcon>
                            <ListItemText 
                              primary={skill.skill} 
                              secondary={skill.matchQuality ? `${skill.matchQuality} match` : null}
                            />
                          </ListItem>
                        ))
                      ) : (
                        <ListItem>
                          <ListItemText primary="No matching skills found." />
                        </ListItem>
                      )}
                    </List>
                  )}
                </Grid>

                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle1" gutterBottom sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    color: theme.palette.warning.main,
                    fontWeight: 600
                  }}>
                    <WarningIcon sx={{ mr: 1 }} /> Areas for Improvement
                  </Typography>
                  <List dense>
                    {job.matchAnalysis.improvementSuggestions && job.matchAnalysis.improvementSuggestions.length > 0 ? (
                      job.matchAnalysis.improvementSuggestions.slice(0, 4).map((suggestion, index) => (
                        <ListItem key={index} sx={{ 
                          backgroundColor: `${theme.palette.warning.main}15`, 
                          borderRadius: 2, 
                          mb: 1,
                          px: 2 
                        }}>
                          <ListItemIcon>
                            <LightbulbIcon color="warning" fontSize="small" />
                          </ListItemIcon>
                          <ListItemText primary={suggestion} />
                        </ListItem>
                      ))
                    ) : (
                      <ListItem>
                        <ListItemText primary="No improvement suggestions available." />
                      </ListItem>
                    )}
                  </List>
                </Grid>
              </Grid>
              
              <Box sx={{ mt: 3 }}>
                <Button
                  variant="contained"
                  color="secondary"
                  startIcon={<SafeAutoJobLogo size="small" />}
                  onClick={onTailorClick}
                  sx={{ borderRadius: 2, py: 1.2 }}
                >
                  Get Tailored Resume
                </Button>
              </Box>
            </CardContent>
          </Card>
        ) : (
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Tailor My Resume To This Job" 
              avatar={<PsychologyIcon color="primary" />}
              sx={{ 
                pb: 1, 
                '& .MuiCardHeader-title': { fontWeight: 600 } 
              }}
            />
            <CardContent sx={{ textAlign: 'center', py: 4 }}>
              <Box 
                sx={{ 
                  width: 100, 
                  height: 100, 
                  borderRadius: '50%', 
                  border: '3px dashed', 
                  borderColor: 'primary.main',
                  display: 'flex',
                  justifyContent: 'center',
                  alignItems: 'center',
                  mb: 3,
                  mx: 'auto'
                }}
              >
                <SafeAutoJobLogo size="medium" />
              </Box>
              <Typography variant="h5" gutterBottom fontWeight={600}>
                Tailor My Resume To This Job
              </Typography>
              <Typography variant="body1" paragraph sx={{ mb: 3, mx: 'auto', maxWidth: 600 }}>
                Get intelligent insights by matching your resume with this job. Our enhanced AI will analyze skills, experience, 
                and education to provide accurate compatibility scores and personalized recommendations.
              </Typography>
              <Button
                variant="contained"
                color="secondary"
                startIcon={<SafeAutoJobLogo size="small" />}
                onClick={onTailorClick}
                sx={{ borderRadius: 2, px: 3, py: 1.2 }}
              >
                Get Tailored Resume
              </Button>
            </CardContent>
          </Card>
        )}

        {/* Enhanced Key Requirements */}
        {job.parsedData && (
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Job Requirements Analysis" 
              avatar={<AssignmentIcon color="primary" />}
              sx={{ 
                '& .MuiCardHeader-title': { fontWeight: 600 } 
              }}
            />
            <CardContent>
              <Grid container spacing={3}>
                {job.parsedData.keySkills && job.parsedData.keySkills.length > 0 && (
                  <Grid item xs={12}>
                    <Typography variant="subtitle1" fontWeight={600} gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center' }}>
                      <CodeIcon sx={{ mr: 1 }} /> Required Skills
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                      Skills are color-coded by importance: <span style={{ color: theme.palette.error.main }}>Critical</span>, 
                      <span style={{ color: theme.palette.warning.main }}> Important</span>, 
                      <span style={{ color: theme.palette.info.main }}> Nice-to-have</span>
                    </Typography>
                    <Box sx={{ 
                      display: 'flex', 
                      flexWrap: 'wrap', 
                      gap: 1.5,
                      p: 2,
                      bgcolor: 'rgba(0,0,0,0.02)',
                      borderRadius: 2
                    }}>
                      {job.parsedData.keySkills && job.parsedData.keySkills.map((skill, index) => {
                        const skillName = skill && typeof skill === 'object' ? (skill.name || skill.skill || '') : skill;
                        const matchedSkill = job.matchAnalysis?.matchedSkills?.find(s => 
                          (s.skill === skillName) || 
                          (typeof s.skill === 'object' && s.skill.name === skillName)
                        );
                        const isMatched = matchedSkill?.found || false;
                        
                        return (
                          <SkillChip
                            key={`key-skill-${index}`}
                            skill={skill}
                            isMatched={isMatched}
                            importance={skill && typeof skill === 'object' ? skill.importance : undefined}
                            matchQuality={matchedSkill?.matchQuality}
                          />
                        );
                      })}
                    </Box>
                  </Grid>
                )}

                {job.parsedData.qualifications && (
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle1" fontWeight={600} gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center' }}>
                      <SchoolIcon sx={{ mr: 1 }} /> Qualifications
                    </Typography>
                    <Box sx={{ 
                      p: 2, 
                      bgcolor: 'rgba(0,0,0,0.02)',
                      borderRadius: 2
                    }}>
                      {job.parsedData.qualifications.required && job.parsedData.qualifications.required.length > 0 && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="subtitle2" gutterBottom sx={{ display: 'flex', alignItems: 'center', color: theme.palette.secondary.main }}>
                            Required Qualifications:
                          </Typography>
                          <List dense disablePadding>
                            {job.parsedData.qualifications.required.slice(0, 5).map((qual, index) => (
                              <ListItem key={index} sx={{ py: 0.5 }}>
                                <ListItemIcon sx={{ minWidth: 28 }}>
                                  <CheckCircleIcon fontSize="small" color="secondary" />
                                </ListItemIcon>
                                <ListItemText primary={qual} />
                              </ListItem>
                            ))}
                          </List>
                        </Box>
                      )}
                      {job.parsedData.qualifications.preferred && job.parsedData.qualifications.preferred.length > 0 && (
                        <Box>
                          <Typography variant="subtitle2" gutterBottom sx={{ display: 'flex', alignItems: 'center', color: theme.palette.info.main }}>
                            Preferred Qualifications:
                          </Typography>
                          <List dense disablePadding>
                            {job.parsedData.qualifications.preferred.slice(0, 3).map((qual, index) => (
                              <ListItem key={index} sx={{ py: 0.5 }}>
                                <ListItemIcon sx={{ minWidth: 28 }}>
                                  <CheckCircleIcon fontSize="small" color="info" />
                                </ListItemIcon>
                                <ListItemText primary={qual} />
                              </ListItem>
                            ))}
                          </List>
                        </Box>
                      )}
                    </Box>
                  </Grid>
                )}

                {/* Enhanced job metadata */}
                {(job.parsedData.industryContext || job.parsedData.roleCategory || job.parsedData.technicalComplexity) && (
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle1" fontWeight={600} gutterBottom color="primary" sx={{ display: 'flex', alignItems: 'center' }}>
                      <InfoIcon sx={{ mr: 1 }} /> Job Context
                    </Typography>
                    <Box sx={{ 
                      p: 2, 
                      bgcolor: 'rgba(0,0,0,0.02)',
                      borderRadius: 2
                    }}>
                      {job.parsedData.industryContext && (
                        <Box sx={{ mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">Industry:</Typography>
                          <Typography variant="body1" fontWeight={500} sx={{ textTransform: 'capitalize' }}>
                            {job.parsedData.industryContext}
                          </Typography>
                        </Box>
                      )}
                      {job.parsedData.roleCategory && (
                        <Box sx={{ mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">Role Category:</Typography>
                          <Typography variant="body1" fontWeight={500} sx={{ textTransform: 'capitalize' }}>
                            {job.parsedData.roleCategory.replace('-', ' ')}
                          </Typography>
                        </Box>
                      )}
                      {job.parsedData.technicalComplexity && (
                        <Box sx={{ mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">Technical Complexity:</Typography>
                          <Chip 
                            label={job.parsedData.technicalComplexity} 
                            size="small" 
                            color={
                              job.parsedData.technicalComplexity === 'high' ? 'error' :
                              job.parsedData.technicalComplexity === 'medium' ? 'warning' : 'success'
                            }
                            sx={{ textTransform: 'capitalize' }}
                          />
                        </Box>
                      )}
                    </Box>
                  </Grid>
                )}
              </Grid>
            </CardContent>
          </Card>
        )}
      </Grid>
    </Grid>
  );
};

export default OverviewTab;

================
File: frontend/src/components/jobs/utils/searchUtils.js
================
// src/components/jobs/utils/searchUtils.js
import React from 'react';
import { useTheme } from '@mui/material/styles';
import {
  PlayArrow as PlayIcon,
  Pause as PauseIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Delete as DeleteIcon,
  Psychology as PsychologyIcon,
  Business as BusinessIcon,
  Search as SearchIcon,
  CloudDownload as CloudDownloadIcon,
  Save as SaveIcon,
  Info as InfoIcon,
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

export const getStatusColor = (status) => {
  switch (status) {
    case 'running': return 'success';
    case 'paused': return 'warning';
    case 'completed': return 'info';
    case 'failed': return 'error';
    case 'cancelled': return 'default';
    default: return 'default';
  }
};

export const getStatusIcon = (status) => {
  switch (status) {
    case 'running': return <PlayIcon fontSize="small" />;
    case 'paused': return <PauseIcon fontSize="small" />;
    case 'completed': return <CheckCircleIcon fontSize="small" />;
    case 'failed': return <ErrorIcon fontSize="small" />;
    case 'cancelled': return <DeleteIcon fontSize="small" />;
    default: return null;
  }
};

export const getReasoningIcon = (phase) => {
  switch (phase) {
    case 'initialization': 
      return <AutoJobLogo variant="icon-only" size="small" sx={{ width: 18, height: 18 }} />;
    case 'career_analysis': 
      return <PsychologyIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'company_discovery': 
      return <BusinessIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'job_search': 
      return <SearchIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'content_extraction': 
      return <CloudDownloadIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'job_saving': 
      return <SaveIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'completion': 
      return <CheckCircleIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    case 'error': 
      return <ErrorIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
    default: 
      return <InfoIcon sx={{ color: 'inherit', fontSize: 'inherit' }} />;
  }
};

export const getReasoningColor = (phase, success, theme) => {
  // Success/failure states take priority
  if (success === false) return theme.palette.error.main;
  if (success === true && phase === 'completion') return theme.palette.success.main;
  
  // Phase-specific colors using your theme
  switch (phase) {
    case 'initialization': 
      return theme.palette.primary.main; // #1a73e8
    case 'career_analysis': 
      return theme.palette.secondary.main; // #00c4b4
    case 'company_discovery': 
      return theme.palette.info.main; // #4285f4
    case 'job_search': 
      return theme.palette.warning.main; // #fbbc04
    case 'content_extraction': 
      return theme.palette.success.main; // #34a853
    case 'job_saving': 
      return theme.palette.primary.dark; // #0d47a1
    case 'completion': 
      return theme.palette.success.main; // #34a853
    case 'error': 
      return theme.palette.error.main; // #ea4335
    default: 
      return theme.palette.text.secondary; // #5f6368
  }
};

export const formatDate = (date) => {
  return new Date(date).toLocaleString('en-US', {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });
};

export const formatDuration = (duration) => {
  if (!duration) return 'N/A';
  if (duration < 1000) return `${duration}ms`;
  if (duration < 60000) return `${Math.round(duration / 1000)}s`;
  return `${Math.round(duration / 60000)}m`;
};

export const getProgressPercentage = (search) => {
  if (search.dailyLimit === 0) return 0;
  return Math.round((search.jobsFoundToday / search.dailyLimit) * 100);
};

================
File: frontend/src/components/layout/Header.js
================
// src/components/layout/Header.js - UPDATED WITHOUT NOTIFICATIONS
import React, { useState } from 'react';
import {
  AppBar,
  Toolbar,
  IconButton,
  Typography,
  Menu,
  MenuItem,
  Box,
  Tooltip,
  useTheme,
  alpha,
  ListItemIcon,
  ListItemText,
} from '@mui/material';
import {
  Menu as MenuIcon,
  HelpOutline as HelpOutlineIcon,
  Quiz as QuizIcon,
  Support as SupportIcon,
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import { useNavigate } from 'react-router-dom';
import AutoJobLogo from '../common/AutoJobLogo';
import GlobalSearch from '../common/GlobalSearch';

const Header = ({ onToggleSidebar }) => {
  const theme = useTheme();
  const { logout, currentUser } = useAuth();
  const navigate = useNavigate();
  const [helpAnchorEl, setHelpAnchorEl] = useState(null);
  
  const isHelpMenuOpen = Boolean(helpAnchorEl);

  const handleHelpMenuOpen = (event) => {
    setHelpAnchorEl(event.currentTarget);
  };

  const handleMenuClose = (setState) => () => {
    setState(null);
  };

  return (
    <AppBar 
      position="static"
      color="default"
      elevation={1}
      sx={{ 
        backgroundColor: 'background.paper',
        borderBottom: '1px solid',
        borderColor: 'divider',
        width: '100%',
        boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.08)',
      }}
    >
      <Toolbar sx={{ px: { xs: 2, sm: 3 }, minHeight: '64px !important' }}>
        {/* Mobile Menu Button */}
        <IconButton
          edge="start"
          color="inherit"
          aria-label="open drawer"
          onClick={onToggleSidebar}
          sx={{ 
            mr: 2, 
            display: { sm: 'block', md: 'none' },
            color: 'text.primary'
          }}
        >
          <MenuIcon />
        </IconButton>

        {/* Global Search Component */}
        <GlobalSearch 
          sx={{
            marginRight: 2,
            marginLeft: 0,
            width: '100%',
            maxWidth: { xs: '100%', sm: 400, md: 500 },
          }}
        />

        <Box sx={{ flexGrow: 1 }} />

        {/* Action Buttons */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
          {/* Help */}
          <Tooltip title="Help & Support" arrow>
            <IconButton
              color="inherit"
              onClick={handleHelpMenuOpen}
              sx={{ 
                color: 'text.secondary',
                '&:hover': {
                  color: 'primary.main',
                  backgroundColor: alpha(theme.palette.primary.main, 0.04)
                }
              }}
            >
              <HelpOutlineIcon />
            </IconButton>
          </Tooltip>
        </Box>
      </Toolbar>

      {/* Help Menu */}
      <Menu
        anchorEl={helpAnchorEl}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        open={isHelpMenuOpen}
        onClose={handleMenuClose(setHelpAnchorEl)}
        PaperProps={{
          sx: {
            mt: 1,
            minWidth: 240,
            boxShadow: '0 4px 20px rgba(0,0,0,0.1)',
          }
        }}
      >
        <MenuItem onClick={handleMenuClose(setHelpAnchorEl)} sx={{ py: 1.5 }}>
          <ListItemIcon>
            <QuizIcon color="primary" />
          </ListItemIcon>
          <ListItemText
            primary="Getting Started Guide"
            secondary="Learn how to use auto-job.ai"
            primaryTypographyProps={{ variant: 'body2', fontWeight: 500 }}
            secondaryTypographyProps={{ variant: 'caption' }}
          />
        </MenuItem>
        <MenuItem onClick={handleMenuClose(setHelpAnchorEl)} sx={{ py: 1.5 }}>
          <ListItemIcon>
            <HelpOutlineIcon color="primary" />
          </ListItemIcon>
          <ListItemText
            primary="FAQ"
            secondary="Find answers to common questions"
            primaryTypographyProps={{ variant: 'body2', fontWeight: 500 }}
            secondaryTypographyProps={{ variant: 'caption' }}
          />
        </MenuItem>
        <MenuItem onClick={handleMenuClose(setHelpAnchorEl)} sx={{ py: 1.5 }}>
          <ListItemIcon>
            <SupportIcon color="primary" />
          </ListItemIcon>
          <ListItemText
            primary="Contact Support"
            secondary="Get help from our team"
            primaryTypographyProps={{ variant: 'body2', fontWeight: 500 }}
            secondaryTypographyProps={{ variant: 'caption' }}
          />
        </MenuItem>
      </Menu>
    </AppBar>
  );
};

export default Header;

================
File: frontend/src/components/layout/MainLayout.js
================
// src/components/layout/MainLayout.js
import React, { useState } from 'react';
import { Box, useMediaQuery, useTheme } from '@mui/material';
import Sidebar from './Sidebar';
import Header from './Header';

const MainLayout = ({ children }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [sidebarOpen, setSidebarOpen] = useState(!isMobile);

  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen);
  };

  return (
    <Box sx={{ 
      display: 'flex', 
      height: '100vh', // Fixed viewport height
      overflow: 'hidden' // Prevent any overflow on the main container
    }}>
      <Sidebar open={sidebarOpen} onClose={() => setSidebarOpen(false)} />
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          display: 'flex',
          flexDirection: 'column',
          height: '100vh', // Full viewport height
          overflow: 'hidden', // Prevent overflow on main wrapper
        }}
      >
        {/* Sticky Header */}
        <Box sx={{ 
          position: 'sticky',
          top: 0,
          zIndex: (theme) => theme.zIndex.appBar,
          flexShrink: 0 // Prevent header from shrinking
        }}>
          <Header onToggleSidebar={toggleSidebar} />
        </Box>
        
        {/* Scrollable Content Area */}
        <Box
          sx={{
            flexGrow: 1,
            overflow: 'auto', // Enable scrolling for content
            backgroundColor: 'background.default',
            p: 3,
            // Ensure proper scrollbar styling
            '&::-webkit-scrollbar': {
              width: '6px',
            },
            '&::-webkit-scrollbar-track': {
              backgroundColor: 'rgba(0, 0, 0, 0.04)',
              borderRadius: '3px',
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0, 0, 0, 0.2)',
              borderRadius: '3px',
              '&:hover': {
                backgroundColor: 'rgba(0, 0, 0, 0.3)',
              },
            },
          }}
        >
          {children}
        </Box>
      </Box>
    </Box>
  );
};

export default MainLayout;

================
File: frontend/src/components/layout/Sidebar.js
================
// src/components/layout/Sidebar.js
import React, { useContext } from 'react';
import { 
  Box, 
  Drawer, 
  List, 
  ListItem, 
  ListItemButton, 
  ListItemIcon, 
  ListItemText,
  Divider,
  Typography,
  useTheme,
  useMediaQuery,
  Avatar,
  Collapse,
  Tooltip,
} from '@mui/material';
import { Link, useLocation } from 'react-router-dom';
import {
  Dashboard as DashboardIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  People as PeopleIcon,
  Assignment as AssignmentIcon,
  Settings as SettingsIcon,
  Logout as LogoutIcon,
  SmartToy as SmartToyIcon,
  ExpandLess,
  ExpandMore,
  UploadFile as UploadFileIcon,
  FormatListBulleted as FormatListBulletedIcon,
  Add as AddIcon,
  ContentPasteSearch as ContentPasteSearchIcon,
  ManageSearch as ManageSearchIcon,
  Search as SearchIcon,
  Message as MessageIcon,
  Person as PersonIcon
} from '@mui/icons-material';
import { AuthContext } from '../../context/AuthContext';
import AutoJobLogo from '../common/AutoJobLogo';

const drawerWidth = 260;

const navItems = [
  { 
    title: 'Dashboard',
    path: '/dashboard',
    icon: <DashboardIcon />,
    color: '#1a73e8' // Primary blue
  },
  { 
    title: 'My Resumes',
    path: '/resumes',
    icon: <DescriptionIcon />,
    color: '#34a853', // Success green
  },
  { 
    title: 'Jobs Portal',
    path: '/jobs',
    icon: <WorkIcon />,
    color: '#4285f4', // Info blue
    subItems: [
      {
        title: 'All Jobs',
        path: '/jobs',
        icon: <FormatListBulletedIcon fontSize="small" />,
        color: '#4285f4'
      },
      {
        title: 'Agent Job Discovery',
        path: '/jobs/ai-searches',
        icon: <SmartToyIcon fontSize="small" />,
        color: '#4285f4'
      }
    ]
  },

  { 
    title: 'Recruiter Outreach',
    path: '/recruiters',
    icon: <PeopleIcon />,
    color: '#00c4b4', // Secondary teal

  },

];

const Sidebar = ({ open, onClose }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const location = useLocation();
  const { currentUser, logout } = useContext(AuthContext);
  const [openSubMenu, setOpenSubMenu] = React.useState('');

  // Auto-expand the submenu for the current path
  React.useEffect(() => {
    navItems.forEach(item => {
      if (item.subItems && (
        location.pathname === item.path || 
        item.subItems.some(subItem => location.pathname.startsWith(subItem.path)) ||
        // Special handling for recruiter routes
        (item.path === '/recruiters' && location.pathname.startsWith('/recruiters'))
      )) {
        setOpenSubMenu(item.title);
      }
    });
  }, [location.pathname]);

  const handleSubMenuClick = (title) => {
    setOpenSubMenu(openSubMenu === title ? '' : title);
  };

  const isPathActive = (path) => {
    // Special handling for exact path matching on main routes
    if (path === '/recruiters' && location.pathname === '/recruiters') {
      return true;
    }
    // For sub-items, check exact path
    if (path.includes('/recruiters/')) {
      return location.pathname === path;
    }
    // Default behavior for other routes
    return location.pathname === path || location.pathname.startsWith(`${path}/`);
  };

  const isSubItemActive = (subItemPath) => {
    return location.pathname === subItemPath;
  };

  // Helper function to get user display name
  const getUserDisplayName = () => {
    if (currentUser?.firstName && currentUser?.lastName) {
      return `${currentUser.firstName} ${currentUser.lastName}`;
    }
    return currentUser?.firstName || 'User';
  };

  // Helper function to get user email with proper truncation
  const getUserEmail = () => {
    return currentUser?.email || 'user@example.com';
  };

  const drawerContent = (
    <Box sx={{ 
      height: '100%', 
      display: 'flex', 
      flexDirection: 'column',
      overflow: 'hidden' // Prevent overflow on sidebar container
    }}>
      {/* Logo Section */}
      <Box sx={{ 
        px: 2.5, 
        py: 2, 
        display: 'flex', 
        alignItems: 'center',
        cursor: 'pointer',
        flexShrink: 0 // Prevent logo from shrinking
      }}>
        <AutoJobLogo 
          variant="horizontal"
          size="small"
          color="primary"
          showTagline={false}
        />
      </Box>
      
      <Box sx={{ px: 2, pt: 2, pb: 1, flexShrink: 0 }}>
        <Typography variant="overline" color="text.secondary" sx={{ fontWeight: 600 }}>
          Main Menu
        </Typography>
      </Box>
      
      {/* Scrollable Navigation Area */}
      <Box sx={{ 
        flex: 1, 
        overflow: 'auto',
        // Custom scrollbar for sidebar
        '&::-webkit-scrollbar': {
          width: '4px',
        },
        '&::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        '&::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.15)',
          borderRadius: '2px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.25)',
          },
        },
      }}>
        <List sx={{ px: 1 }}>
          {navItems.map((item) => (
            <React.Fragment key={item.path}>
              <ListItem disablePadding>
                {item.subItems ? (
                  <ListItemButton
                    onClick={() => handleSubMenuClick(item.title)}
                    selected={location.pathname.startsWith(item.path)}
                    sx={{
                      borderRadius: 1.5,
                      mb: 0.5,
                      '&.Mui-selected': {
                        backgroundColor: `${item.color}15`, // Use item color with 15% opacity
                        color: item.color,
                        '&:hover': {
                          backgroundColor: `${item.color}20`, // Slightly darker on hover
                        },
                        '& .MuiListItemIcon-root': {
                          color: item.color,
                        },
                      },
                      '&:hover': {
                        backgroundColor: `${item.color}08`, // Light hover state with item color
                      }
                    }}
                  >
                    <ListItemIcon 
                      sx={{ 
                        minWidth: 40,
                        color: item.color,
                        '& .MuiSvgIcon-root': {
                          fontSize: '1.3rem'
                        }
                      }}
                    >
                      {React.cloneElement(item.icon, { 
                        style: { color: item.color }
                      })}
                    </ListItemIcon>
                    <ListItemText 
                      primary={item.title}
                      primaryTypographyProps={{
                        fontWeight: location.pathname.startsWith(item.path) ? 600 : 500,
                        fontSize: '0.9rem',
                        color: location.pathname.startsWith(item.path) ? item.color : 'text.primary'
                      }}
                    />
                    {openSubMenu === item.title ? 
                      <ExpandLess sx={{ color: 'text.secondary' }} /> : 
                      <ExpandMore sx={{ color: 'text.secondary' }} />
                    }
                  </ListItemButton>
                ) : (
                  <ListItemButton
                    component={Link}
                    to={item.path}
                    selected={isPathActive(item.path)}
                    sx={{
                      borderRadius: 1.5,
                      mb: 0.5,
                      '&.Mui-selected': {
                        backgroundColor: `${item.color}15`, // Use item color with 15% opacity
                        color: item.color,
                        '&:hover': {
                          backgroundColor: `${item.color}20`, // Slightly darker on hover
                        },
                        '& .MuiListItemIcon-root': {
                          color: item.color,
                        },
                      },
                      '&:hover': {
                        backgroundColor: `${item.color}08`, // Light hover state with item color
                      }
                    }}
                  >
                    <ListItemIcon 
                      sx={{ 
                        minWidth: 40,
                        color: item.color,
                        '& .MuiSvgIcon-root': {
                          fontSize: '1.3rem'
                        }
                      }}
                    >
                      {React.cloneElement(item.icon, { 
                        style: { color: item.color }
                      })}
                    </ListItemIcon>
                    <ListItemText 
                      primary={item.title}
                      primaryTypographyProps={{
                        fontWeight: isPathActive(item.path) ? 600 : 500,
                        fontSize: '0.9rem',
                        color: isPathActive(item.path) ? item.color : 'text.primary'
                      }}
                    />
                  </ListItemButton>
                )}
              </ListItem>
              {item.subItems && (
                <Collapse in={openSubMenu === item.title} timeout="auto" unmountOnExit>
                  <List component="div" disablePadding>
                    {item.subItems.map((subItem) => (
                      <ListItemButton
                        key={subItem.path}
                        component={Link}
                        to={subItem.path}
                        selected={isSubItemActive(subItem.path)}
                        sx={{
                          pl: 4,
                          py: 0.75,
                          borderRadius: 1.5,
                          mb: 0.5,
                          '&.Mui-selected': {
                            backgroundColor: `${subItem.color}15`, // Use subItem color with 15% opacity
                            color: subItem.color,
                            '&:hover': {
                              backgroundColor: `${subItem.color}20`, // Slightly darker on hover
                            },
                            '& .MuiListItemIcon-root': {
                              color: subItem.color,
                            },
                          },
                          '&:hover': {
                            backgroundColor: `${subItem.color}08`, // Light hover state with subItem color
                          }
                        }}
                      >
                        <ListItemIcon 
                          sx={{ 
                            minWidth: 32,
                            color: subItem.color,
                            '& .MuiSvgIcon-root': {
                              fontSize: '1.1rem'
                            }
                          }}
                        >
                          {React.cloneElement(subItem.icon, { 
                            style: { color: subItem.color }
                          })}
                        </ListItemIcon>
                        <ListItemText 
                          primary={subItem.title}
                          primaryTypographyProps={{
                            variant: 'body2',
                            fontWeight: isSubItemActive(subItem.path) ? 600 : 500,
                            fontSize: '0.85rem',
                            color: isSubItemActive(subItem.path) ? subItem.color : 'text.primary'
                          }}
                        />
                      </ListItemButton>
                    ))}
                  </List>
                </Collapse>
              )}
            </React.Fragment>
          ))}
        </List>
      </Box>
      
      <Divider sx={{ mt: 2, flexShrink: 0 }} />
      
      {/* User Section - Fixed at bottom with improved email handling */}
      <Box sx={{ p: 2, flexShrink: 0 }}>
        <Box sx={{ 
          display: 'flex', 
          alignItems: 'center', 
          mb: 2,
          p: 1.5,
          borderRadius: 2,
          backgroundColor: 'rgba(26, 115, 232, 0.04)',
          border: '1px solid rgba(26, 115, 232, 0.1)',
          minWidth: 0, // Allow shrinking
        }}>
          <Avatar 
            sx={{ 
              width: 40, 
              height: 40,
              mr: 2,
              bgcolor: 'primary.main',
              fontSize: '1rem',
              fontWeight: 600,
              flexShrink: 0, // Prevent avatar from shrinking
            }}
          >
            {currentUser?.firstName?.[0] || 'U'}
          </Avatar>
          <Box sx={{ 
            flex: 1, 
            minWidth: 0, // Allow this box to shrink
            overflow: 'hidden' // Prevent overflow
          }}>
            <Typography 
              variant="subtitle2" 
              sx={{ 
                fontWeight: 600,
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
                lineHeight: 1.2
              }}
            >
              {getUserDisplayName()}
            </Typography>
            <Tooltip title={getUserEmail()} arrow placement="top">
              <Typography 
                variant="caption" 
                color="text.secondary" 
                sx={{
                  display: 'block',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  lineHeight: 1.2,
                  cursor: 'help', // Show that it's interactive
                  '&:hover': {
                    color: 'text.primary', // Slightly darker on hover
                  }
                }}
              >
                {getUserEmail()}
              </Typography>
            </Tooltip>
          </Box>
        </Box>
        
        <List sx={{ p: 0 }}>
          <ListItem disablePadding>
            <ListItemButton
              component={Link}
              to="/settings"
              sx={{
                borderRadius: 1.5,
                py: 1,
                '&:hover': {
                  backgroundColor: 'rgba(0, 0, 0, 0.04)'
                }
              }}
            >
              <ListItemIcon sx={{ minWidth: 36 }}>
                <SettingsIcon 
                  fontSize="small" 
                  sx={{ color: '#666' }}
                />
              </ListItemIcon>
              <ListItemText 
                primary="Settings" 
                primaryTypographyProps={{
                  fontSize: '0.9rem',
                  fontWeight: 500
                }}
              />
            </ListItemButton>
          </ListItem>
          <ListItem disablePadding>
            <ListItemButton
              onClick={logout}
              sx={{
                borderRadius: 1.5,
                py: 1,
                '&:hover': {
                  backgroundColor: 'rgba(234, 67, 53, 0.04)',
                  '& .MuiListItemIcon-root': {
                    color: 'error.main'
                  },
                  '& .MuiListItemText-primary': {
                    color: 'error.main'
                  }
                }
              }}
            >
              <ListItemIcon sx={{ minWidth: 36 }}>
                <LogoutIcon 
                  fontSize="small" 
                  sx={{ color: '#666' }}
                />
              </ListItemIcon>
              <ListItemText 
                primary="Logout" 
                primaryTypographyProps={{
                  fontSize: '0.9rem',
                  fontWeight: 500
                }}
              />
            </ListItemButton>
          </ListItem>
        </List>
      </Box>
    </Box>
  );

  return (
    <Drawer
      variant={isMobile ? 'temporary' : 'permanent'}
      open={open}
      onClose={onClose}
      sx={{
        width: drawerWidth,
        flexShrink: 0,
        '& .MuiDrawer-paper': {
          width: drawerWidth,
          boxSizing: 'border-box',
          borderRight: '1px solid',
          borderColor: 'divider',
          backgroundColor: 'background.paper',
          height: '100vh', // Full viewport height
          overflow: 'hidden' // Prevent overflow on drawer paper
        },
      }}
    >
      {drawerContent}
    </Drawer>
  );
};

export default Sidebar;

================
File: frontend/src/components/recruiters/OutreachComposer.js
================
// src/components/recruiters/OutreachComposer.js - FIXED DATA HANDLING AND ERROR RESOLUTION
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  Typography,
  Box,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  Avatar,
  Divider,
  Alert,
  LinearProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  RadioGroup,
  FormControlLabel,
  Radio,
  Autocomplete,
  Collapse,
  Paper
} from '@mui/material';
import {
  Close as CloseIcon,
  AutoFixHigh as AutoFixHighIcon,
  Send as SendIcon,
  Save as SaveIcon,
  Refresh as RefreshIcon,
  Psychology as PsychologyIcon,
  Business as BusinessIcon,
  Person as PersonIcon,
  Work as WorkIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Description as DescriptionIcon,
  Lightbulb as LightbulbIcon,
  Star as StarIcon,
  TrendingUp as TrendingUpIcon,
  School as SchoolIcon,
  Assignment as AssignmentIcon,
  Preview as PreviewIcon,
  CheckCircle as CheckCircleIcon,
  Drafts as DraftsIcon,
  Cancel as CancelIcon,
  Edit as EditIcon,
  ContentCopy as ContentCopyIcon,
  Warning as WarningIcon,
  Info as InfoIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import { useAuth } from '../../context/AuthContext';
import recruiterService from '../../utils/recruiterService';
import resumeService from '../../utils/resumeService';
import jobService from '../../utils/jobService';
import AutoJobLogo from '../common/AutoJobLogo';

const OutreachComposer = ({ 
  open, 
  onClose, 
  recruiter, 
  onSend, 
  onSave,
  defaultMessage = '',
  mode = 'create'
}) => {
  const theme = useTheme();
  const { currentUser } = useAuth();
  
  // Form state
  const [messageContent, setMessageContent] = useState(defaultMessage);
  const [messageType, setMessageType] = useState('introduction');
  const [tone, setTone] = useState('professional');
  const [sentVia, setSentVia] = useState('email');
  const [selectedResume, setSelectedResume] = useState(null);
  const [selectedJob, setSelectedJob] = useState(null);
  const [customRequirements, setCustomRequirements] = useState('');
  
  // UI state
  const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [characterCount, setCharacterCount] = useState(0);
  const [error, setError] = useState('');
  const [generationHistory, setGenerationHistory] = useState([]);
  
  // Email-specific state
  const [showEmailPreview, setShowEmailPreview] = useState(false);
  const [showStatusDialog, setShowStatusDialog] = useState(false);
  const [emailSubject, setEmailSubject] = useState('');
  const [formattedEmailBody, setFormattedEmailBody] = useState('');
  const [manualStatus, setManualStatus] = useState('sent');
  const [showClipboardFallback, setShowClipboardFallback] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);
  
  // Data state
  const [resumes, setResumes] = useState([]);
  const [jobs, setJobs] = useState([]);
  const [loadingData, setLoadingData] = useState(true);

  // Load user data on mount
  useEffect(() => {
    if (open) {
      loadUserData();
      setMessageContent(defaultMessage);
      setCharacterCount(defaultMessage.length);
    }
  }, [open, defaultMessage]);

  // Update character count when message changes
  useEffect(() => {
    setCharacterCount(messageContent.length);
  }, [messageContent]);

  const loadUserData = async () => {
    try {
      setLoadingData(true);
      const [resumesResponse, jobsResponse] = await Promise.all([
        resumeService.getUserResumes(),
        jobService.getUserJobs()
      ]);
      
      setResumes(resumesResponse || []);
      setJobs(jobsResponse || []);
    } catch (error) {
      console.error('Failed to load user data:', error);
      setError('Failed to load your resumes and jobs');
    } finally {
      setLoadingData(false);
    }
  };

  // Email utility functions
  const generateSubjectLine = (recruiter, messageType, jobTitle = null) => {
    const companyName = recruiter?.company?.name || 'your company';
    
    const templates = {
      introduction: `Exploring opportunities at ${companyName}`,
      application: `Application for ${jobTitle || 'Software Developer'} position`,
      follow_up: `Following up - ${companyName} opportunities`,
      thank_you: `Thank you for your time - ${recruiter?.firstName || 'Recruiter'}`
    };
    
    return templates[messageType] || `Professional inquiry - ${companyName}`;
  };

  const formatEmailMessage = (content, recruiterData, userData) => {
    const recruiterFirstName = recruiterData?.firstName || 'there';
    
    // Remove any subject lines from the AI content
    let cleanedContent = content.replace(/^Subject:.*$/gim, '').trim();
    
    // Check if the content already has a greeting
    const hasGreeting = cleanedContent.toLowerCase().includes('dear ') || 
                       cleanedContent.toLowerCase().includes('hello ') ||
                       cleanedContent.toLowerCase().includes('hi ');
    
    // Check if the content already has a signature/closing
    const hasSignature = cleanedContent.toLowerCase().includes('best regards') || 
                        cleanedContent.toLowerCase().includes('warm regards') ||
                        cleanedContent.toLowerCase().includes('sincerely') ||
                        cleanedContent.toLowerCase().includes('regards,');
    
    let formattedContent = cleanedContent;
    
    // Add greeting only if none exists
    if (!hasGreeting) {
      formattedContent = `Dear ${recruiterFirstName},

${cleanedContent}`;
    }
    
    // Add signature only if none exists
    if (!hasSignature && !hasGreeting) {
      const userFirstName = userData?.firstName || 'Best regards';
      formattedContent = `${formattedContent}

Best regards,
${userFirstName}`;
    }
    
    return formattedContent;
  };

  const handleGenerateMessage = async () => {
    if (!recruiter) return;
    
    try {
      setIsGenerating(true);
      setError('');
      
      const messageParams = {
        recruiterId: recruiter.id,
        resumeId: selectedResume?._id,
        jobId: selectedJob?._id,
        messageType,
        tone,
        customRequirements
      };

      console.log('🤖 Generating message with params:', messageParams);
      
      const response = await recruiterService.generatePersonalizedMessage(messageParams);
      
      // Save to generation history
      setGenerationHistory(prev => [{
        message: response.message,
        params: messageParams,
        timestamp: new Date()
      }, ...prev.slice(0, 4)]);
      
      setMessageContent(response.message);
      
    } catch (error) {
      console.error('Message generation failed:', error);
      setError('Failed to generate message. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSendViaEmail = () => {
    try {
      // Generate subject line
      const subject = generateSubjectLine(recruiter, messageType, selectedJob?.title);
      
      // Format message with signature
      const formattedMessage = formatEmailMessage(messageContent, recruiter, currentUser);
      
      setEmailSubject(subject);
      setFormattedEmailBody(formattedMessage);
      setShowEmailPreview(true);
      
    } catch (error) {
      console.error('Email preparation failed:', error);
      setError('Failed to prepare email. Please try again.');
    }
  };

  const copyToClipboard = async () => {
    try {
      const fullEmailContent = `To: ${recruiter.email}
Subject: ${emailSubject}

${formattedEmailBody}`;
      
      await navigator.clipboard.writeText(fullEmailContent);
      setCopySuccess(true);
      setTimeout(() => {
        setCopySuccess(false);
        setShowEmailPreview(false);
        setShowStatusDialog(true);
      }, 1500);
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      // Fallback for older browsers
      const fullEmailContent = `To: ${recruiter.email}
Subject: ${emailSubject}

${formattedEmailBody}`;
      
      const textArea = document.createElement('textarea');
      textArea.value = fullEmailContent;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      setCopySuccess(true);
      setTimeout(() => {
        setCopySuccess(false);
        setShowEmailPreview(false);
        setShowStatusDialog(true);
      }, 1500);
    }
  };

  // FIXED: Proper data structure for status update
  const handleStatusUpdate = async () => {
    try {
      // Validate required fields
      if (!recruiter?.id) {
        setError('Recruiter information is missing. Please try again.');
        return;
      }

      if (!messageContent?.trim()) {
        setError('Message content cannot be empty.');
        return;
      }

      console.log('📋 Status update - Recruiter:', recruiter);
      console.log('📋 Status update - Message length:', messageContent.length);
      console.log('📋 Status update - Selected status:', manualStatus);

      // FIXED: Create proper outreach data structure matching the backend expectations
      const outreachData = {
        recruiterId: recruiter.id, // Ensure this is set
        messageContent: messageContent.trim(), // Ensure this is set and trimmed
        messageTemplate: messageType,
        sentVia: 'email', // Always email for this flow
        jobId: selectedJob?._id || null,
        customizations: [],
        // Add additional fields that might be expected
        subject: emailSubject || generateSubjectLine(recruiter, messageType, selectedJob?.title),
        formattedContent: formattedEmailBody || messageContent.trim()
      };

      console.log('📤 Sending outreach data:', outreachData);

      // FIXED: Validate the data before sending
      const validation = recruiterService.validateOutreachData(outreachData);
      if (!validation.isValid) {
        console.error('❌ Validation failed:', validation.errors);
        setError(`Validation failed: ${validation.errors.join(', ')}`);
        return;
      }

      // FIXED: Handle different status outcomes
      if (manualStatus === 'sent') {
        console.log('📧 Marking as sent...');
        await onSend(outreachData);
      } else if (manualStatus === 'drafted') {
        console.log('📝 Saving as draft...');
        await onSave(outreachData);
      } else {
        // For 'cancelled' status, we still save it but mark it appropriately
        console.log('❌ Marking as cancelled...');
        const cancelledData = { ...outreachData, status: 'cancelled' };
        await onSave(cancelledData);
      }
      
      console.log('✅ Status update successful');
      setShowStatusDialog(false);
      handleClose();
      
    } catch (error) {
      console.error('❌ Status update failed:', error);
      
      // FIXED: Better error handling with specific messages
      let errorMessage = 'Failed to update status. Please try again.';
      
      if (error.response?.data?.error) {
        errorMessage = error.response.data.error;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      // Show specific error based on status
      if (error.response?.status === 400) {
        errorMessage = 'Invalid data provided. Please check your message content and try again.';
      } else if (error.response?.status === 404) {
        errorMessage = 'Recruiter not found. Please refresh the page and try again.';
      }
      
      setError(errorMessage);
      
      // Don't close the dialog on error, let user try again
      setShowStatusDialog(false);
      setShowEmailPreview(true); // Go back to email preview
    }
  };

  // FIXED: Improved send handler with better error handling
  const handleSend = async () => {
    if (sentVia === 'email') {
      handleSendViaEmail();
      return;
    }

    // Original send logic for other methods
    try {
      setIsSending(true);
      setError('');
      
      // FIXED: Ensure recruiter ID is present
      if (!recruiter?.id) {
        setError('Recruiter information is missing. Please refresh and try again.');
        return;
      }

      if (!messageContent?.trim()) {
        setError('Message content cannot be empty.');
        return;
      }
      
      const outreachData = {
        recruiterId: recruiter.id,
        messageContent: messageContent.trim(),
        messageTemplate: messageType,
        sentVia,
        jobId: selectedJob?._id || null,
        customizations: []
      };

      console.log('📤 Direct send - outreach data:', outreachData);

      // Validate the outreach data
      const validation = recruiterService.validateOutreachData(outreachData);
      if (!validation.isValid) {
        setError(validation.errors.join(', '));
        return;
      }

      await onSend(outreachData);
      handleClose();
      
    } catch (error) {
      console.error('❌ Send failed:', error);
      
      let errorMessage = 'Failed to send message. Please try again.';
      if (error.response?.data?.error) {
        errorMessage = error.response.data.error;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      setError(errorMessage);
    } finally {
      setIsSending(false);
    }
  };

  // FIXED: Improved save handler
  const handleSave = async () => {
    try {
      // FIXED: Validate required fields
      if (!recruiter?.id) {
        setError('Recruiter information is missing. Please refresh and try again.');
        return;
      }

      if (!messageContent?.trim()) {
        setError('Message content cannot be empty.');
        return;
      }

      const outreachData = {
        recruiterId: recruiter.id,
        messageContent: messageContent.trim(),
        messageTemplate: messageType,
        sentVia,
        jobId: selectedJob?._id || null,
        customizations: []
      };

      console.log('💾 Save draft - outreach data:', outreachData);

      // Validate the outreach data
      const validation = recruiterService.validateOutreachData(outreachData);
      if (!validation.isValid) {
        setError(validation.errors.join(', '));
        return;
      }

      await onSave(outreachData);
      handleClose();
      
    } catch (error) {
      console.error('❌ Save failed:', error);
      
      let errorMessage = 'Failed to save draft. Please try again.';
      if (error.response?.data?.error) {
        errorMessage = error.response.data.error;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      setError(errorMessage);
    }
  };

  const handleClose = () => {
    setMessageContent('');
    setError('');
    setGenerationHistory([]);
    setShowAdvancedOptions(false);
    setShowEmailPreview(false);
    setShowStatusDialog(false);
    setEmailSubject('');
    setFormattedEmailBody('');
    setManualStatus('sent');
    setShowClipboardFallback(false);
    setCopySuccess(false);
    onClose();
  };

  const messageTemplates = recruiterService.getMessageTemplates();
  const toneOptions = recruiterService.getToneOptions();

  const getCharacterCountColor = () => {
    if (characterCount > 2000) return 'error';
    if (characterCount > 1500) return 'warning';
    return 'primary';
  };

  const getSentViaIcon = (method) => {
    switch (method) {
      case 'email': return <EmailIcon />;
      case 'phone': return <PhoneIcon />;
      default: return <BusinessIcon />;
    }
  };

  const getTemplateIcon = (template) => {
    switch (template) {
      case 'introduction': return <PersonIcon sx={{ color: theme.palette.primary.main }} />;
      case 'follow_up': return <TrendingUpIcon sx={{ color: theme.palette.secondary.main }} />;
      case 'application': return <AssignmentIcon sx={{ color: theme.palette.success.main }} />;
      case 'thank_you': return <StarIcon sx={{ color: theme.palette.warning.main }} />;
      default: return <DescriptionIcon sx={{ color: theme.palette.info.main }} />;
    }
  };

  const getToneIcon = (toneValue) => {
    switch (toneValue) {
      case 'professional': return <BusinessIcon sx={{ color: theme.palette.primary.main }} />;
      case 'friendly': return <PersonIcon sx={{ color: theme.palette.success.main }} />;
      case 'casual': return <LightbulbIcon sx={{ color: theme.palette.warning.main }} />;
      case 'formal': return <SchoolIcon sx={{ color: theme.palette.info.main }} />;
      default: return <DescriptionIcon />;
    }
  };

  // FIXED: Add debug info for troubleshooting
  console.log('🔍 OutreachComposer Debug Info:', {
    recruiterPresent: !!recruiter,
    recruiterId: recruiter?.id,
    messageContentLength: messageContent?.length || 0,
    hasOnSend: typeof onSend === 'function',
    hasOnSave: typeof onSave === 'function'
  });

  if (!recruiter) {
    console.warn('⚠️ OutreachComposer: No recruiter provided');
    return null;
  }

  return (
    <>
      <Dialog
        open={open && !showStatusDialog}
        onClose={handleClose}
        maxWidth={false}
        fullWidth
        PaperProps={{
          sx: { 
            borderRadius: 2,
            minHeight: '600px',
            maxHeight: '85vh',
            width: '92vw',
            maxWidth: '1200px',
            margin: 'auto'
          }
        }}
      >
        {/* Enhanced Header */}
        <DialogTitle sx={{ 
          p: 0,
          background: `linear-gradient(135deg, ${theme.palette.primary.main}15, ${theme.palette.secondary.main}15)`,
          borderBottom: `1px solid ${theme.palette.divider}`
        }}>
          <Box sx={{ p: 2.5 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1.5 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                <Avatar
                  sx={{
                    bgcolor: theme.palette.primary.main,
                    width: 40,
                    height: 40,
                    fontSize: '1rem',
                    fontWeight: 'bold'
                  }}
                >
                  {recruiter.firstName?.[0]}{recruiter.lastName?.[0]}
                </Avatar>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 600, color: theme.palette.primary.main }}>
                    Compose Message
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    To {recruiter.firstName} {recruiter.lastName} at {recruiter.company?.name}
                  </Typography>
                </Box>
              </Box>
              <IconButton 
                onClick={handleClose}
                size="small"
                sx={{ 
                  bgcolor: 'background.paper',
                  '&:hover': { bgcolor: 'grey.100' }
                }}
              >
                <CloseIcon />
              </IconButton>
            </Box>

            {/* Status Chips */}
            <Box sx={{ display: 'flex', gap: 0.75, flexWrap: 'wrap' }}>
              <Chip
                icon={<WorkIcon sx={{ fontSize: '0.875rem' }} />}
                label={recruiter.title}
                size="small"
                variant="outlined"
                color="primary"
                sx={{ borderRadius: 1 }}
              />
              <Chip
                icon={<BusinessIcon sx={{ fontSize: '0.875rem' }} />}
                label={recruiter.company?.name}
                size="small"
                variant="outlined"
                color="secondary"
                sx={{ borderRadius: 1 }}
              />
              {recruiter.industry && (
                <Chip
                  label={recruiter.industry}
                  size="small"
                  variant="filled"
                  color="info"
                  sx={{ borderRadius: 1 }}
                />
              )}
            </Box>
          </Box>
        </DialogTitle>

        <DialogContent sx={{ p: 0, overflow: 'hidden' }}>
          {loadingData && (
            <Box sx={{ p: 2 }}>
              <LinearProgress sx={{ borderRadius: 1 }} />
              <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                Loading your resumes and jobs...
              </Typography>
            </Box>
          )}

          {error && (
            <Box sx={{ p: 2.5 }}>
              <Alert severity="error" sx={{ borderRadius: 2 }} onClose={() => setError('')}>
                {error}
              </Alert>
            </Box>
          )}

          <Box sx={{ p: 3, height: 'calc(85vh - 180px)', overflow: 'auto' }}>
            <Grid container spacing={3}>
              {/* Left Column - AI Generation */}
              <Grid item xs={12} lg={7.5}>
                {/* Enhanced AI Generation Controls */}
                <Card 
                  elevation={0} 
                  sx={{ 
                    mb: 3,
                    border: `1px solid ${theme.palette.primary.light}`,
                    borderRadius: 2,
                    background: `linear-gradient(135deg, ${theme.palette.primary.main}08, ${theme.palette.secondary.main}05)`
                  }}
                >
                  <CardContent sx={{ p: 2.5 }}>
                    <Typography 
                      variant="subtitle1"
                      gutterBottom 
                      sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1, 
                        color: theme.palette.primary.main,
                        fontWeight: 600,
                        mb: 2
                      }}
                    >
                      <PsychologyIcon sx={{ fontSize: '1.25rem' }} />
                      AI Message Generator
                    </Typography>

                    <Grid container spacing={2.5}>
                      <Grid item xs={12} md={6}>
                        <FormControl fullWidth size="small">
                          <InputLabel sx={{ color: theme.palette.primary.main }}>Message Type</InputLabel>
                          <Select
                            value={messageType}
                            label="Message Type"
                            onChange={(e) => setMessageType(e.target.value)}
                            sx={{ borderRadius: 2 }}
                          >
                            {Object.entries(messageTemplates).map(([key, template]) => (
                              <MenuItem key={key} value={key} sx={{ py: 1 }}>
                                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                  {getTemplateIcon(key)}
                                  <Box>
                                    <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                      {template.name}
                                    </Typography>
                                    <Typography variant="caption" color="text.secondary">
                                      {template.description}
                                    </Typography>
                                  </Box>
                                </Box>
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>

                      <Grid item xs={12} md={6}>
                        <FormControl fullWidth size="small">
                          <InputLabel sx={{ color: theme.palette.secondary.main }}>Tone</InputLabel>
                          <Select
                            value={tone}
                            label="Tone"
                            onChange={(e) => setTone(e.target.value)}
                            sx={{ borderRadius: 2 }}
                          >
                            {toneOptions.map((option) => (
                              <MenuItem key={option.value} value={option.value} sx={{ py: 1 }}>
                                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                  {getToneIcon(option.value)}
                                  <Box>
                                    <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                      {option.label}
                                    </Typography>
                                    <Typography variant="caption" color="text.secondary">
                                      {option.description}
                                    </Typography>
                                  </Box>
                                </Box>
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>

                      <Grid item xs={12}>
                        <Button
                          variant="contained"
                          startIcon={isGenerating ? <LinearProgress sx={{ width: 20 }} /> : 
                            <AutoJobLogo 
                              variant="icon-only" 
                              size="small" 
                              sx={{ width: 20, height: 20 }} 
                            />
                          }
                          onClick={handleGenerateMessage}
                          disabled={isGenerating}
                          fullWidth
                          sx={{ 
                            borderRadius: 2,
                            py: 1.25,
                            background: `linear-gradient(45deg, ${theme.palette.secondary.main}, ${theme.palette.secondary.light})`,
                            '&:hover': {
                              background: `linear-gradient(45deg, ${theme.palette.secondary.dark}, ${theme.palette.secondary.main})`
                            },
                            '&:disabled': {
                              background: theme.palette.grey[300]
                            }
                          }}
                        >
                          {isGenerating ? 'Generating Magic...' : '✨ Generate AI Message'}
                        </Button>
                      </Grid>
                    </Grid>

                    {/* Advanced Options */}
                    <Box sx={{ mt: 2.5 }}>
                      <Button
                        variant="text"
                        size="small"
                        onClick={() => setShowAdvancedOptions(!showAdvancedOptions)}
                        endIcon={showAdvancedOptions ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                        sx={{ color: theme.palette.primary.main }}
                      >
                        Advanced Options
                      </Button>
                      
                      <Collapse in={showAdvancedOptions}>
                        <Box sx={{ mt: 2 }}>
                          <Grid container spacing={2}>
                            <Grid item xs={12} sm={6}>
                              <Autocomplete
                                options={resumes}
                                getOptionLabel={(option) => option?.name || ''}
                                value={selectedResume}
                                onChange={(e, value) => setSelectedResume(value)}
                                isOptionEqualToValue={(option, value) => option?._id === value?._id}
                                renderInput={(params) => (
                                  <TextField
                                    {...params}
                                    label="Use Resume"
                                    placeholder="Select resume for context..."
                                    size="small"
                                    InputProps={{
                                      ...params.InputProps,
                                      startAdornment: <DescriptionIcon sx={{ mr: 1, color: theme.palette.success.main, fontSize: '1rem' }} />
                                    }}
                                  />
                                )}
                              />
                            </Grid>

                            <Grid item xs={12} sm={6}>
                              <Autocomplete
                                options={jobs}
                                getOptionLabel={(option) => option ? `${option.title} at ${option.company}` : ''}
                                value={selectedJob}
                                onChange={(e, value) => setSelectedJob(value)}
                                isOptionEqualToValue={(option, value) => option?._id === value?._id}
                                renderInput={(params) => (
                                  <TextField
                                    {...params}
                                    label="Target Job"
                                    placeholder="Select job if applying..."
                                    size="small"
                                    InputProps={{
                                      ...params.InputProps,
                                      startAdornment: <WorkIcon sx={{ mr: 1, color: theme.palette.warning.main, fontSize: '1rem' }} />
                                    }}
                                  />
                                )}
                              />
                            </Grid>

                            <Grid item xs={12}>
                              <TextField
                                fullWidth
                                multiline
                                rows={2}
                                label="Custom Requirements"
                                placeholder="Any specific points you want to mention..."
                                value={customRequirements}
                                onChange={(e) => setCustomRequirements(e.target.value)}
                                size="small"
                                InputProps={{
                                  startAdornment: <LightbulbIcon sx={{ mr: 1, color: theme.palette.info.main, alignSelf: 'flex-start', mt: 1, fontSize: '1rem' }} />
                                }}
                              />
                            </Grid>
                          </Grid>
                        </Box>
                      </Collapse>
                    </Box>
                  </CardContent>
                </Card>

                {/* Enhanced Message Content */}
                <Paper elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                    <Typography variant="subtitle2" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <DescriptionIcon sx={{ color: theme.palette.primary.main, fontSize: '1.125rem' }} />
                      Message Content
                    </Typography>
                  </Box>
                  <Box sx={{ p: 2.5 }}>
                    <TextField
                      fullWidth
                      multiline
                      rows={12}
                      placeholder="Write your message here or use the AI generator above..."
                      value={messageContent}
                      onChange={(e) => setMessageContent(e.target.value)}
                      error={characterCount > 2000}
                      helperText={
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <span>
                            {characterCount > 2000 && 'Message too long. '}
                            {messageTemplates[messageType]?.suggestedLength && 
                              `Suggested: ${messageTemplates[messageType].suggestedLength}`}
                          </span>
                          <span style={{ color: theme.palette[getCharacterCountColor()].main, fontWeight: 600 }}>
                            {characterCount}/2000
                          </span>
                        </Box>
                      }
                      sx={{
                        '& .MuiOutlinedInput-root': {
                          borderRadius: 2,
                          fontSize: '0.9rem',
                          lineHeight: 1.6
                        }
                      }}
                    />
                  </Box>
                </Paper>

                {/* Generation History */}
                {generationHistory.length > 0 && (
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="caption" gutterBottom sx={{ color: theme.palette.primary.main, fontWeight: 600 }}>
                      Recent Generations
                    </Typography>
                    <Box sx={{ display: 'flex', gap: 0.5, flexWrap: 'wrap' }}>
                      {generationHistory.map((generation, index) => (
                        <Chip
                          key={index}
                          label={`${generation.params.messageType} (${generation.params.tone})`}
                          size="small"
                          variant="outlined"
                          onClick={() => setMessageContent(generation.message)}
                          sx={{ 
                            cursor: 'pointer',
                            borderRadius: 1,
                            fontSize: '0.75rem',
                            '&:hover': {
                              backgroundColor: theme.palette.primary.main + '10'
                            }
                          }}
                        />
                      ))}
                    </Box>
                  </Box>
                )}
              </Grid>

              {/* Right Column - Settings and Preview */}
              <Grid item xs={12} lg={4.5}>
                {/* Enhanced Communication Method */}
                <Card elevation={0} sx={{ mb: 3, border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                    <Typography variant="subtitle2" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <SendIcon sx={{ color: theme.palette.success.main, fontSize: '1.125rem' }} />
                      Send Via
                    </Typography>
                  </Box>
                  <CardContent sx={{ p: 2.5 }}>
                    <RadioGroup
                      value={sentVia}
                      onChange={(e) => setSentVia(e.target.value)}
                    >
                      <FormControlLabel
                        value="email"
                        control={<Radio size="small" />}
                        label={
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                            <EmailIcon sx={{ color: theme.palette.primary.main, fontSize: '1rem' }} />
                            <Box>
                              <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                Email (Recommended)
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                Shows email preview with copy functionality
                              </Typography>
                            </Box>
                          </Box>
                        }
                        disabled={!recruiter.email}
                      />
                      <FormControlLabel
                        value="phone"
                        control={<Radio size="small" />}
                        label={
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, py: 0.5 }}>
                            <PhoneIcon sx={{ color: theme.palette.success.main, fontSize: '1rem' }} />
                            <Box>
                              <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                Phone Call
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                Script for phone conversation
                              </Typography>
                            </Box>
                          </Box>
                        }
                        disabled={!recruiter.phone}
                      />
                    </RadioGroup>
                  </CardContent>
                </Card>

                {/* Enhanced Recruiter Info */}
                <Card elevation={0} sx={{ mb: 3, border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                    <Typography variant="subtitle2" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <PersonIcon sx={{ color: theme.palette.secondary.main, fontSize: '1.125rem' }} />
                      Recruiter Details
                    </Typography>
                  </Box>
                  <CardContent sx={{ p: 2.5 }}>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          TITLE
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500, mt: 0.5 }}>
                          {recruiter.title}
                        </Typography>
                      </Box>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          COMPANY
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500, mt: 0.5 }}>
                          {recruiter.company?.name}
                        </Typography>
                      </Box>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          EMAIL
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500, mt: 0.5 }}>
                          {recruiter.email || 'Not available'}
                        </Typography>
                      </Box>
                      <Box>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          INDUSTRY
                        </Typography>
                        <Typography variant="body2" sx={{ fontWeight: 500, mt: 0.5 }}>
                          {recruiter.industry}
                        </Typography>
                      </Box>
                      {recruiter.experienceYears && (
                        <Box>
                          <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                            EXPERIENCE
                          </Typography>
                          <Typography variant="body2" sx={{ fontWeight: 500, mt: 0.5 }}>
                            {recruiter.experienceYears} years
                          </Typography>
                        </Box>
                      )}
                      {recruiter.specializations && (
                        <Box>
                          <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600, mb: 0.75, display: 'block' }}>
                            SPECIALIZATIONS
                          </Typography>
                          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                            {recruiter.specializations.slice(0, 3).map((spec, index) => (
                              <Chip 
                                key={index} 
                                label={spec} 
                                size="small" 
                                variant="outlined"
                                sx={{ borderRadius: 1, fontSize: '0.7rem' }}
                              />
                            ))}
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </CardContent>
                </Card>

                {/* Enhanced Template Guide */}
                {messageTemplates[messageType] && (
                  <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                    <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                      <Typography variant="subtitle2" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <LightbulbIcon sx={{ color: theme.palette.warning.main, fontSize: '1.125rem' }} />
                        Template Guide
                      </Typography>
                    </Box>
                    <CardContent sx={{ p: 2.5 }}>
                      <Typography variant="body2" color="text.secondary" paragraph sx={{ lineHeight: 1.6 }}>
                        {messageTemplates[messageType].description}
                      </Typography>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Typography variant="caption" color="text.secondary" sx={{ fontWeight: 600 }}>
                          SUGGESTED LENGTH:
                        </Typography>
                        <Chip 
                          label={messageTemplates[messageType].suggestedLength} 
                          size="small" 
                          color="info"
                          variant="outlined"
                          sx={{ borderRadius: 1 }}
                        />
                      </Box>
                    </CardContent>
                  </Card>
                )}
              </Grid>
            </Grid>
          </Box>
        </DialogContent>

        {/* Enhanced Footer Actions */}
        <DialogActions sx={{ 
          p: 2.5,
          borderTop: `1px solid ${theme.palette.divider}`,
          background: `linear-gradient(135deg, ${theme.palette.grey[50]}, ${theme.palette.grey[25]})`,
          gap: 1.5
        }}>
          <Button 
            onClick={handleClose} 
            variant="outlined"
            sx={{ 
              borderRadius: 2,
              px: 2.5,
              minWidth: 100
            }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleSave}
            variant="outlined"
            startIcon={<SaveIcon sx={{ fontSize: '1rem' }} />}
            disabled={!messageContent.trim()}
            sx={{ 
              borderRadius: 2,
              px: 2.5,
              minWidth: 120
            }}
          >
            Save Draft
          </Button>
          <Button
            onClick={handleSend}
            variant="contained"
            startIcon={isSending ? <LinearProgress sx={{ width: 16 }} /> : getSentViaIcon(sentVia)}
            disabled={!messageContent.trim() || isSending || characterCount > 2000}
            sx={{ 
              borderRadius: 2,
              px: 3,
              minWidth: 140,
              background: `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`,
              color: '#ffffff !important',
              fontWeight: 600,
              '&:hover': {
                background: `linear-gradient(45deg, ${theme.palette.success.dark}, ${theme.palette.success.main})`
              },
              '&:disabled': {
                background: theme.palette.grey[300],
                color: theme.palette.grey[500] + ' !important'
              }
            }}
          >
            {isSending ? 'Processing...' : 
             sentVia === 'email' ? 'Prepare Email' : `Send via ${sentVia}`}
          </Button>
        </DialogActions>
      </Dialog>

      {/* REDESIGNED: Email Preview Dialog - Consistent with Compose Message Style */}
      <Dialog
        open={showEmailPreview}
        onClose={() => setShowEmailPreview(false)}
        maxWidth={false}
        fullWidth
        PaperProps={{
          sx: { 
            borderRadius: 2,
            overflow: 'hidden',
            boxShadow: theme.shadows[6],
            width: '85vw',
            maxWidth: '900px'
          }
        }}
      >
        {/* REDESIGNED: Header matching compose style */}
        <DialogTitle sx={{ 
          p: 0,
          background: `linear-gradient(135deg, ${theme.palette.primary.main}15, ${theme.palette.secondary.main}15)`,
          borderBottom: `1px solid ${theme.palette.divider}`
        }}>
          <Box sx={{ p: 2.5 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, mb: 2 }}>
              <Avatar sx={{ 
                bgcolor: theme.palette.primary.main,
                width: 40,
                height: 40
              }}>
                <EmailIcon sx={{ fontSize: '1.25rem' }} />
              </Avatar>
              <Box>
                <Typography variant="h6" sx={{ fontWeight: 600, color: theme.palette.primary.main }}>
                  📧 Email Preview
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Review your email before copying to your email client
                </Typography>
              </Box>
              <Box sx={{ ml: 'auto' }}>
                <IconButton
                  onClick={() => setShowEmailPreview(false)}
                  size="small"
                  sx={{
                    bgcolor: 'background.paper',
                    '&:hover': { bgcolor: 'grey.100' }
                  }}
                >
                  <CloseIcon />
                </IconButton>
              </Box>
            </Box>
            
            {/* REDESIGNED: Email details in consistent card style */}
            <Card elevation={0} sx={{ 
              border: `1px solid ${theme.palette.divider}`,
              borderRadius: 2,
              background: 'rgba(255,255,255,0.8)'
            }}>
              <CardContent sx={{ p: 2 }}>
                <Grid container spacing={2}>
                  <Grid item xs={12} sm={6}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                      <PersonIcon sx={{ color: theme.palette.primary.main, fontSize: '1rem' }} />
                      <Typography variant="caption" sx={{ 
                        color: theme.palette.text.secondary, 
                        fontWeight: 600,
                        textTransform: 'uppercase'
                      }}>
                        To
                      </Typography>
                    </Box>
                    <Typography variant="body2" sx={{ 
                      fontWeight: 500,
                      color: theme.palette.text.primary
                    }}>
                      {recruiter.email}
                    </Typography>
                  </Grid>
                  <Grid item xs={12} sm={6}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                      <DescriptionIcon sx={{ color: theme.palette.primary.main, fontSize: '1rem' }} />
                      <Typography variant="caption" sx={{ 
                        color: theme.palette.text.secondary, 
                        fontWeight: 600,
                        textTransform: 'uppercase'
                      }}>
                        Subject
                      </Typography>
                    </Box>
                    <Typography variant="body2" sx={{ 
                      fontWeight: 500,
                      color: theme.palette.text.primary,
                      lineHeight: 1.3
                    }}>
                      {emailSubject}
                    </Typography>
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Box>
        </DialogTitle>

        <DialogContent sx={{ p: 0 }}>
          {/* REDESIGNED: Email content matching message content style */}
          <Box sx={{ p: 3 }}>
            <Paper elevation={0} sx={{ 
              border: `1px solid ${theme.palette.divider}`, 
              borderRadius: 2,
              minHeight: 300
            }}>
              <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}`, bgcolor: theme.palette.grey[50] }}>
                <Typography variant="subtitle2" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <EmailIcon sx={{ color: theme.palette.primary.main, fontSize: '1.125rem' }} />
                  Email Content
                </Typography>
              </Box>
              <Box sx={{ p: 2.5 }}>
                <Typography 
                  variant="body2" 
                  sx={{ 
                    whiteSpace: 'pre-wrap',
                    lineHeight: 1.7,
                    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
                    color: theme.palette.text.primary,
                    fontSize: '0.9rem'
                  }}
                >
                  {formattedEmailBody}
                </Typography>
              </Box>
            </Paper>
          </Box>

          {/* REDESIGNED: Info section matching component style */}
          <Box sx={{ 
            p: 3, 
            pt: 0,
            bgcolor: `linear-gradient(135deg, ${theme.palette.primary.main}05, ${theme.palette.secondary.main}03)`
          }}>
            <Alert 
              severity="info" 
              icon={<LightbulbIcon sx={{ color: theme.palette.primary.main }} />}
              sx={{ 
                borderRadius: 2,
                border: `1px solid ${theme.palette.primary.light}`,
                bgcolor: 'rgba(255,255,255,0.9)'
              }}
            >
              <Typography variant="body2" sx={{ 
                fontWeight: 600, 
                color: theme.palette.primary.main, 
                mb: 0.5
              }}>
                📋 What happens next:
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ lineHeight: 1.5, fontSize: '0.875rem' }}>
                Copy the email content below, then paste it into your preferred email client. 
                This maintains your professional reputation while leveraging AI-generated content.
              </Typography>
            </Alert>
          </Box>
        </DialogContent>

        {/* REDESIGNED: Dialog actions matching main dialog style */}
        <DialogActions sx={{ 
          p: 2.5,
          background: `linear-gradient(135deg, ${theme.palette.grey[50]}, white)`,
          borderTop: `1px solid ${theme.palette.divider}`,
          gap: 1.5
        }}>
          <Button 
            onClick={() => setShowEmailPreview(false)}
            variant="outlined"
            startIcon={<EditIcon sx={{ fontSize: '1rem' }} />}
            sx={{ 
              borderRadius: 2,
              borderColor: theme.palette.primary.main,
              color: theme.palette.primary.main,
              fontWeight: 500,
              px: 2.5,
              minWidth: 140,
              '&:hover': {
                bgcolor: theme.palette.primary.main + '08',
                borderColor: theme.palette.primary.dark
              }
            }}
          >
            Edit Message
          </Button>
          <Button
            onClick={copyToClipboard}
            variant="contained"
            startIcon={copySuccess ? <CheckCircleIcon sx={{ fontSize: '1rem' }} /> : <ContentCopyIcon sx={{ fontSize: '1rem' }} />}
            sx={{ 
              borderRadius: 2,
              px: 3,
              fontWeight: 600,
              minWidth: 160,
              background: copySuccess 
                ? `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`
                : `linear-gradient(45deg, ${theme.palette.secondary.main}, ${theme.palette.secondary.dark})`,
              color: '#ffffff !important',
              '&:hover': {
                background: copySuccess
                  ? `linear-gradient(45deg, ${theme.palette.success.dark}, ${theme.palette.success.main})`
                  : `linear-gradient(45deg, ${theme.palette.secondary.dark}, ${theme.palette.secondary.main})`,
                transform: 'translateY(-1px)'
              }
            }}
          >
            {copySuccess ? 'Email Copied!' : 'Copy Email'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* FIXED: Status Update Dialog with Better Error Handling */}
      <Dialog
        open={showStatusDialog}
        onClose={() => setShowStatusDialog(false)}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: { 
            borderRadius: 2,
            boxShadow: theme.shadows[6],
            minWidth: 500
          }
        }}
      >
        <DialogTitle sx={{ 
          p: 0,
          background: `linear-gradient(135deg, ${theme.palette.success.main}15, ${theme.palette.primary.main}15)`,
          borderBottom: `1px solid ${theme.palette.divider}`
        }}>
          <Box sx={{ p: 2.5 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
              <Avatar sx={{ 
                bgcolor: theme.palette.success.main,
                width: 40,
                height: 40
              }}>
                <CheckCircleIcon sx={{ fontSize: '1.25rem' }} />
              </Avatar>
              <Box>
                <Typography variant="h6" sx={{ 
                  fontWeight: 600, 
                  color: theme.palette.success.main
                }}>
                  Update Email Status
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Let us know what happened with your email
                </Typography>
              </Box>
            </Box>
          </Box>
        </DialogTitle>

        <DialogContent sx={{ p: 2.5 }}>
          {/* FIXED: Show error if there's an issue */}
          {error && (
            <Alert severity="error" sx={{ mb: 2, borderRadius: 2 }} onClose={() => setError('')}>
              {error}
            </Alert>
          )}

          <Typography variant="body2" color="text.secondary" sx={{ mb: 2.5, lineHeight: 1.6 }}>
            After copying the email content for <strong>{recruiter.firstName} {recruiter.lastName}</strong>, 
            please update the status below to help us track your outreach effectiveness:
          </Typography>

          <RadioGroup
            value={manualStatus}
            onChange={(e) => setManualStatus(e.target.value)}
            sx={{ gap: 0.75 }}
          >
            <FormControlLabel
              value="sent"
              control={<Radio size="small" sx={{ color: theme.palette.success.main }} />}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, py: 1 }}>
                  <CheckCircleIcon sx={{ color: theme.palette.success.main, fontSize: '1.125rem' }} />
                  <Box>
                    <Typography variant="body2" sx={{ fontWeight: 500 }}>
                      Email sent successfully
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      I copied the content and sent the email
                    </Typography>
                  </Box>
                </Box>
              }
              sx={{ 
                border: `1px solid ${theme.palette.success.light}`,
                borderRadius: 1.5,
                p: 1,
                m: 0.25,
                '&:hover': {
                  bgcolor: theme.palette.success.main + '05'
                }
              }}
            />
            <FormControlLabel
              value="drafted"
              control={<Radio size="small" sx={{ color: theme.palette.warning.main }} />}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, py: 1 }}>
                  <DraftsIcon sx={{ color: theme.palette.warning.main, fontSize: '1.125rem' }} />
                  <Box>
                    <Typography variant="body2" sx={{ fontWeight: 500 }}>
                      Saved as draft for later
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      I saved the email content to send later
                    </Typography>
                  </Box>
                </Box>
              }
              sx={{ 
                border: `1px solid ${theme.palette.warning.light}`,
                borderRadius: 1.5,
                p: 1,
                m: 0.25,
                '&:hover': {
                  bgcolor: theme.palette.warning.main + '05'
                }
              }}
            />
            <FormControlLabel
              value="cancelled"
              control={<Radio size="small" sx={{ color: theme.palette.error.main }} />}
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, py: 1 }}>
                  <CancelIcon sx={{ color: theme.palette.error.main, fontSize: '1.125rem' }} />
                  <Box>
                    <Typography variant="body2" sx={{ fontWeight: 500 }}>
                      Decided not to send
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      I chose not to send this email
                    </Typography>
                  </Box>
                </Box>
              }
              sx={{ 
                border: `1px solid ${theme.palette.error.light}`,
                borderRadius: 1.5,
                p: 1,
                m: 0.25,
                '&:hover': {
                  bgcolor: theme.palette.error.main + '05'
                }
              }}
            />
          </RadioGroup>
        </DialogContent>

        <DialogActions sx={{ 
          p: 2.5,
          borderTop: `1px solid ${theme.palette.divider}`,
          background: `linear-gradient(135deg, ${theme.palette.grey[50]}, white)`,
          gap: 1.5
        }}>
          <Button 
            onClick={() => setShowStatusDialog(false)}
            variant="outlined"
            sx={{ 
              borderRadius: 2,
              fontWeight: 500,
              px: 2.5,
              minWidth: 100
            }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleStatusUpdate}
            variant="contained"
            disabled={isSending} // FIXED: Prevent double submission
            sx={{ 
              borderRadius: 2,
              fontWeight: 600,
              px: 3,
              minWidth: 140,
              background: `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`,
              color: '#ffffff !important',
              '&:hover': {
                background: `linear-gradient(45deg, ${theme.palette.success.dark}, ${theme.palette.success.main})`
              },
              '&:disabled': {
                background: theme.palette.grey[300],
                color: theme.palette.grey[500] + ' !important'
              }
            }}
          >
            {isSending ? 'Updating...' : 'Update Status'}
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
};

export default OutreachComposer;

================
File: frontend/src/components/recruiters/OutreachTracker.js
================
// src/components/recruiters/OutreachTracker.js - UPDATED WITH BETTER ERROR HANDLING
import React, { useState } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  Chip,
  Avatar,
  Grid,
  IconButton,
  Tooltip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  ListItemSecondaryAction,
  Divider,
  Alert,
  CircularProgress,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  TextField,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Snackbar
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  Email as EmailIcon,
  LinkedIn as LinkedInIcon,
  Phone as PhoneIcon,
  Schedule as ScheduleIcon,
  Reply as ReplyIcon,
  Edit as EditIcon,
  Visibility as VisibilityIcon,
  ExpandMore as ExpandMoreIcon,
  Send as SendIcon,
  Drafts as DraftIcon,
  CheckCircle as CheckCircleIcon,
  Business as BusinessIcon,
  Delete as DeleteIcon,
  FilterList as FilterListIcon,
  Sort as SortIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';

const OutreachCard = ({ campaign, onViewRecruiter, onEditCampaign, onDeleteCampaign }) => {
  const theme = useTheme();
  const formatted = recruiterService.formatOutreachForDisplay(campaign);

  const getStatusIcon = (status) => {
    switch (status) {
      case 'drafted':
        return <DraftIcon color="action" />;
      case 'sent':
        return <SendIcon color="warning" />;
      case 'replied':
        return <ReplyIcon color="success" />;
      case 'delivered':
        return <CheckCircleIcon color="info" />;
      default:
        return <EmailIcon color="action" />;
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'drafted':
        return 'default';
      case 'sent':
        return 'warning';
      case 'replied':
        return 'success';
      case 'delivered':
        return 'info';
      default:
        return 'default';
    }
  };

  const getSentViaIcon = (sentVia) => {
    switch (sentVia) {
      case 'linkedin':
        return <LinkedInIcon fontSize="small" />;
      case 'email':
        return <EmailIcon fontSize="small" />;
      case 'phone':
        return <PhoneIcon fontSize="small" />;
      default:
        return <BusinessIcon fontSize="small" />;
    }
  };

  const handleViewRecruiter = () => {
    console.log('🔍 OutreachCard: handleViewRecruiter called');
    console.log('📋 Campaign data:', campaign);
    
    if (!onViewRecruiter) {
      console.error('❌ onViewRecruiter function not provided');
      return;
    }

    // Try different ways to get the recruiterId
    let recruiterId = campaign.recruiterId || campaign.recruiter_id || campaign.recruiter?.id;
    
    if (!recruiterId) {
      console.error('❌ No recruiterId found in campaign data:', {
        recruiterId: campaign.recruiterId,
        recruiter_id: campaign.recruiter_id,
        recruiterObject: campaign.recruiter
      });
      return;
    }

    console.log('✅ Found recruiterId:', recruiterId);
    
    // Create a recruiter object with the ID and any available recruiter data
    const recruiterData = {
      id: recruiterId,
      ...campaign.recruiter // Spread any additional recruiter data if available
    };
    
    console.log('📤 Calling onViewRecruiter with:', recruiterData);
    onViewRecruiter(recruiterData);
  };

  const handleEditCampaign = () => {
    console.log('✏️ OutreachCard: handleEditCampaign called for campaign:', campaign.id);
    if (onEditCampaign) {
      onEditCampaign(campaign);
    }
  };

  const handleDeleteCampaign = () => {
    console.log('🗑️ OutreachCard: handleDeleteCampaign called for campaign:', campaign.id);
    if (onDeleteCampaign) {
      onDeleteCampaign(campaign.id);
    } else {
      console.error('❌ onDeleteCampaign function not provided');
    }
  };

  return (
    <Card elevation={2} sx={{ mb: 2, borderLeft: `4px solid ${theme.palette[getStatusColor(campaign.status)]?.main || theme.palette.grey[400]}` }}>
      <CardContent>
        <Grid container spacing={2} alignItems="center">
          {/* Recruiter Info */}
          <Grid item xs={12} sm={6} md={4}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              <Avatar
                sx={{
                  bgcolor: theme.palette.primary.main,
                  width: 40,
                  height: 40
                }}
              >
                {formatted?.recruiterDisplay ? 
                  formatted.recruiterDisplay.split(' ').map(n => n[0]).join('').substring(0, 2) :
                  'UK'
                }
              </Avatar>
              <Box>
                <Typography variant="subtitle2" fontWeight={600}>
                  {formatted?.recruiterDisplay || campaign.recruiter?.name || 'Unknown Recruiter'}
                </Typography>
                <Typography variant="caption" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                  <BusinessIcon fontSize="small" />
                  {formatted?.companyDisplay || campaign.recruiter?.company?.name || 'Unknown Company'}
                </Typography>
              </Box>
            </Box>
          </Grid>

          {/* Status and Message Info */}
          <Grid item xs={12} sm={6} md={4}>
            <Box>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                <Chip
                  icon={getStatusIcon(campaign.status)}
                  label={formatted?.statusDisplay || campaign.status}
                  size="small"
                  color={getStatusColor(campaign.status)}
                  variant="filled"
                />
                <Chip
                  icon={getSentViaIcon(campaign.sentVia)}
                  label={campaign.sentVia || 'unknown'}
                  size="small"
                  variant="outlined"
                />
              </Box>
              <Typography variant="body2" color="text.secondary" noWrap>
                {formatted?.messagePreview || campaign.messageContent?.substring(0, 100) + '...' || 'No message preview'}
              </Typography>
            </Box>
          </Grid>

          {/* Dates and Actions */}
          <Grid item xs={12} md={4}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <Box>
                <Typography variant="caption" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                  <ScheduleIcon fontSize="small" />
                  Created: {formatted?.createdDisplay || new Date(campaign.createdAt).toLocaleDateString()}
                </Typography>
                {(formatted?.sentDisplay || campaign.sentAt) && (
                  <Typography variant="caption" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mt: 0.5 }}>
                    <SendIcon fontSize="small" />
                    Sent: {formatted?.sentDisplay || new Date(campaign.sentAt).toLocaleDateString()}
                  </Typography>
                )}
                {(formatted?.hasReplies || campaign.repliesCount > 0) && (
                  <Typography variant="caption" color="success.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mt: 0.5 }}>
                    <ReplyIcon fontSize="small" />
                    {campaign.repliesCount || 0} replies
                  </Typography>
                )}
              </Box>

              {/* Action Buttons */}
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <Tooltip title="View Recruiter">
                  <IconButton size="small" onClick={handleViewRecruiter}>
                    <VisibilityIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                
                {(formatted?.canEdit || campaign.status === 'drafted') && (
                  <Tooltip title="Edit Campaign">
                    <IconButton size="small" onClick={handleEditCampaign}>
                      <EditIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                )}
                
                <Tooltip title="Delete Campaign">
                  <IconButton 
                    size="small" 
                    onClick={handleDeleteCampaign} 
                    color="error"
                    sx={{ '&:hover': { backgroundColor: 'error.main', color: 'white' } }}
                  >
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
            </Box>
          </Grid>
        </Grid>

        {/* Expandable Message Content */}
        <Accordion elevation={0} sx={{ mt: 2, '&:before': { display: 'none' } }}>
          <AccordionSummary expandIcon={<ExpandMoreIcon />}>
            <Typography variant="body2">View Full Message</Typography>
          </AccordionSummary>
          <AccordionDetails>
            <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>
              {campaign.messageContent || 'No message content available'}
            </Typography>
          </AccordionDetails>
        </Accordion>
      </CardContent>
    </Card>
  );
};

const OutreachTracker = ({ 
  campaigns = [], 
  loading = false, 
  onRefresh, 
  onViewRecruiter, 
  onEditCampaign 
}) => {
  const theme = useTheme();
  const [statusFilter, setStatusFilter] = useState('all');
  const [sortBy, setSortBy] = useState('createdAt');
  const [sortOrder, setSortOrder] = useState('desc');
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [campaignToDelete, setCampaignToDelete] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  // Filter and sort campaigns
  const filteredAndSortedCampaigns = React.useMemo(() => {
    let filtered = campaigns;

    // Apply status filter
    if (statusFilter !== 'all') {
      filtered = filtered.filter(campaign => campaign.status === statusFilter);
    }

    // Apply sorting
    filtered.sort((a, b) => {
      let aValue, bValue;
      
      switch (sortBy) {
        case 'createdAt':
          aValue = new Date(a.createdAt);
          bValue = new Date(b.createdAt);
          break;
        case 'sentAt':
          aValue = a.sentAt ? new Date(a.sentAt) : new Date(0);
          bValue = b.sentAt ? new Date(b.sentAt) : new Date(0);
          break;
        case 'recruiterName':
          aValue = (a.recruiter?.name || '').toLowerCase();
          bValue = (b.recruiter?.name || '').toLowerCase();
          break;
        case 'company':
          aValue = (a.recruiter?.company?.name || '').toLowerCase();
          bValue = (b.recruiter?.company?.name || '').toLowerCase();
          break;
        default:
          aValue = a[sortBy];
          bValue = b[sortBy];
      }

      if (sortOrder === 'asc') {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    return filtered;
  }, [campaigns, statusFilter, sortBy, sortOrder]);

  const handleDeleteCampaign = async (campaignId) => {
    console.log('🗑️ OutreachTracker: Delete requested for campaign:', campaignId);
    
    if (!campaignId) {
      console.error('❌ No campaign ID provided for deletion');
      showNotification('Error: No campaign ID provided', 'error');
      return;
    }

    setCampaignToDelete(campaignId);
    setDeleteDialogOpen(true);
  };

  const confirmDelete = async () => {
    if (!campaignToDelete) {
      console.error('❌ No campaign selected for deletion');
      return;
    }

    try {
      setIsDeleting(true);
      console.log(`🗑️ Attempting to delete campaign: ${campaignToDelete}`);
      
      const result = await recruiterService.deleteOutreach(campaignToDelete);
      console.log('✅ Delete successful:', result);
      
      showNotification('Campaign deleted successfully!', 'success');
      
      // Close dialog
      setDeleteDialogOpen(false);
      setCampaignToDelete(null);
      
      // Refresh the list
      if (onRefresh) {
        console.log('🔄 Calling onRefresh to update the list');
        onRefresh();
      } else {
        console.warn('⚠️ onRefresh function not provided - list may not update');
      }
      
    } catch (error) {
      console.error('❌ Delete failed:', error);
      
      let errorMessage = 'Failed to delete campaign';
      if (error.response?.data?.error) {
        errorMessage = error.response.data.error;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      showNotification(errorMessage, 'error');
    } finally {
      setIsDeleting(false);
    }
  };

  const cancelDelete = () => {
    console.log('❌ Delete cancelled by user');
    setDeleteDialogOpen(false);
    setCampaignToDelete(null);
  };

  const showNotification = (message, severity = 'success') => {
    setNotification({
      open: true,
      message,
      severity
    });
  };

  const getStatusCounts = () => {
    const counts = {
      all: campaigns.length,
      drafted: 0,
      sent: 0,
      replied: 0,
      delivered: 0
    };

    campaigns.forEach(campaign => {
      if (counts.hasOwnProperty(campaign.status)) {
        counts[campaign.status]++;
      }
    });

    return counts;
  };

  const statusCounts = getStatusCounts();

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>
        <Box sx={{ textAlign: 'center' }}>
          <CircularProgress size={60} />
          <Typography variant="h6" sx={{ mt: 2, color: 'text.secondary' }}>
            Loading outreach campaigns...
          </Typography>
        </Box>
      </Box>
    );
  }

  if (campaigns.length === 0) {
    return (
      <Card elevation={1} sx={{ textAlign: 'center', py: 8 }}>
        <CardContent>
          <EmailIcon sx={{ fontSize: 64, color: 'text.disabled', mb: 2 }} />
          <Typography variant="h6" gutterBottom>
            No outreach campaigns yet
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
            Start by searching for recruiters and sending your first outreach message.
          </Typography>
          <Button variant="outlined" onClick={onRefresh}>
            Refresh
          </Button>
        </CardContent>
      </Card>
    );
  }

  return (
    <Box>
      {/* Header with Filters */}
      <Card elevation={1} sx={{ mb: 3 }}>
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <EmailIcon color="primary" />
              Outreach Campaigns ({campaigns.length})
            </Typography>
            
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={onRefresh}
              disabled={loading}
            >
              Refresh
            </Button>
          </Box>

          {/* Filters and Sorting */}
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} sm={6} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel>Status Filter</InputLabel>
                <Select
                  value={statusFilter}
                  label="Status Filter"
                  onChange={(e) => setStatusFilter(e.target.value)}
                >
                  <MenuItem value="all">All ({statusCounts.all})</MenuItem>
                  <MenuItem value="drafted">Drafted ({statusCounts.drafted})</MenuItem>
                  <MenuItem value="sent">Sent ({statusCounts.sent})</MenuItem>
                  <MenuItem value="delivered">Delivered ({statusCounts.delivered})</MenuItem>
                  <MenuItem value="replied">Replied ({statusCounts.replied})</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel>Sort By</InputLabel>
                <Select
                  value={sortBy}
                  label="Sort By"
                  onChange={(e) => setSortBy(e.target.value)}
                >
                  <MenuItem value="createdAt">Date Created</MenuItem>
                  <MenuItem value="sentAt">Date Sent</MenuItem>
                  <MenuItem value="recruiterName">Recruiter Name</MenuItem>
                  <MenuItem value="company">Company</MenuItem>
                  <MenuItem value="status">Status</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel>Order</InputLabel>
                <Select
                  value={sortOrder}
                  label="Order"
                  onChange={(e) => setSortOrder(e.target.value)}
                >
                  <MenuItem value="desc">Newest First</MenuItem>
                  <MenuItem value="asc">Oldest First</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <Typography variant="body2" color="text.secondary" textAlign="center">
                Showing {filteredAndSortedCampaigns.length} of {campaigns.length} campaigns
              </Typography>
            </Grid>
          </Grid>

          {/* Status Summary */}
          <Box sx={{ display: 'flex', gap: 1, mt: 2, flexWrap: 'wrap' }}>
            <Chip 
              label={`${statusCounts.drafted} Drafts`} 
              size="small" 
              color="default" 
              variant={statusFilter === 'drafted' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('drafted')}
              sx={{ cursor: 'pointer' }}
            />
            <Chip 
              label={`${statusCounts.sent} Sent`} 
              size="small" 
              color="warning" 
              variant={statusFilter === 'sent' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('sent')}
              sx={{ cursor: 'pointer' }}
            />
            <Chip 
              label={`${statusCounts.delivered} Delivered`} 
              size="small" 
              color="info" 
              variant={statusFilter === 'delivered' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('delivered')}
              sx={{ cursor: 'pointer' }}
            />
            <Chip 
              label={`${statusCounts.replied} Replied`} 
              size="small" 
              color="success" 
              variant={statusFilter === 'replied' ? 'filled' : 'outlined'}
              onClick={() => setStatusFilter('replied')}
              sx={{ cursor: 'pointer' }}
            />
          </Box>
        </CardContent>
      </Card>

      {/* Campaigns List */}
      {filteredAndSortedCampaigns.length === 0 ? (
        <Alert severity="info" sx={{ mb: 2 }}>
          No campaigns match the current filter criteria.
        </Alert>
      ) : (
        <Box>
          {filteredAndSortedCampaigns.map((campaign, index) => (
            <OutreachCard
              key={campaign.id || index}
              campaign={campaign}
              onViewRecruiter={onViewRecruiter}
              onEditCampaign={onEditCampaign}
              onDeleteCampaign={handleDeleteCampaign}
            />
          ))}
        </Box>
      )}

      {/* Delete Confirmation Dialog */}
      <Dialog
        open={deleteDialogOpen}
        onClose={cancelDelete}
        PaperProps={{
          sx: { borderRadius: 2 }
        }}
      >
        <DialogTitle>Confirm Delete</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete this outreach campaign? This action cannot be undone.
          </Typography>
          {campaignToDelete && (
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              Campaign ID: {campaignToDelete}
            </Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={cancelDelete} disabled={isDeleting}>
            Cancel
          </Button>
          <Button 
            onClick={confirmDelete} 
            color="error" 
            variant="contained"
            disabled={isDeleting}
            startIcon={isDeleting ? <CircularProgress size={16} color="inherit" /> : null}
          >
            {isDeleting ? 'Deleting...' : 'Delete'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Notification Snackbar */}
      <Snackbar
        open={notification.open}
        autoHideDuration={6000}
        onClose={() => setNotification({ ...notification, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setNotification({ ...notification, open: false })}
          severity={notification.severity}
          variant="filled"
          sx={{ borderRadius: 2 }}
        >
          {notification.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default OutreachTracker;

================
File: frontend/src/components/recruiters/RecruiterDetails.js
================
// src/components/recruiters/RecruiterDetails.js
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Avatar,
  Divider,
  IconButton,
  Card,
  CardContent,
  Grid,
  Chip,
  Link,
  CircularProgress,
  Alert,
  Paper
} from '@mui/material';
import {
  Close as CloseIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  LinkedIn as LinkedInIcon,
  Business as BusinessIcon,
  Work as WorkIcon,
  Language as LanguageIcon,
  CalendarToday as CalendarTodayIcon,
  Send as SendIcon,
  Star as StarIcon,
  Groups as GroupsIcon,
  Domain as DomainIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';

const RecruiterDetails = ({ open, onClose, recruiterId, onStartOutreach }) => {
  const theme = useTheme();
  const [recruiter, setRecruiter] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  // Reset state when dialog opens/closes or recruiterId changes
  useEffect(() => {
    if (open && recruiterId) {
      loadRecruiterDetails();
    } else {
      // Reset state when dialog closes or no recruiterId
      setRecruiter(null);
      setError('');
      setLoading(false);
    }
  }, [open, recruiterId]);

  const loadRecruiterDetails = async () => {
    // Don't load if no recruiterId provided
    if (!recruiterId) {
      setError('No recruiter selected');
      return;
    }

    try {
      setLoading(true);
      setError('');
      console.log('🔍 Loading recruiter details for ID:', recruiterId);
      
      const response = await recruiterService.getRecruiterDetails(recruiterId);
      
      if (response && response.recruiter) {
        setRecruiter(response.recruiter);
        console.log('✅ Recruiter details loaded:', response.recruiter.fullName);
      } else {
        setError('Recruiter data not found');
      }
    } catch (error) {
      console.error('Failed to load recruiter details:', error);
      setError('Failed to load recruiter details. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    // Reset all state when closing
    setRecruiter(null);
    setError('');
    setLoading(false);
    onClose();
  };

  const handleStartOutreach = () => {
    if (recruiter) {
      onStartOutreach(recruiter);
      handleClose();
    }
  };

  const formatCompanySize = (sizeString) => {
    if (!sizeString) return 'Not specified';
    
    // Handle formats like "10000plus" or "1000plus"
    const plusMatch = sizeString.match(/(\d+)plus/i);
    if (plusMatch) {
      const [, number] = plusMatch;
      return `${parseInt(number).toLocaleString()}+ employees`;
    }
    
    // Handle formats like "Employees.1000to4999" or "1000to4999"
    const rangeMatch = sizeString.match(/(\d+)to(\d+)/);
    if (rangeMatch) {
      const [, min, max] = rangeMatch;
      return `${parseInt(min).toLocaleString()} - ${parseInt(max).toLocaleString()} employees`;
    }
    
    // Handle other formats like "Employees.1000plus"
    if (sizeString.includes('Employees.')) {
      const cleanedSize = sizeString.replace('Employees.', '');
      
      // Check for plus format after removing "Employees."
      const plusMatch2 = cleanedSize.match(/(\d+)plus/i);
      if (plusMatch2) {
        const [, number] = plusMatch2;
        return `${parseInt(number).toLocaleString()}+ employees`;
      }
      
      // Check for range format after removing "Employees."
      const rangeMatch2 = cleanedSize.match(/(\d+)to(\d+)/);
      if (rangeMatch2) {
        const [, min, max] = rangeMatch2;
        return `${parseInt(min).toLocaleString()} - ${parseInt(max).toLocaleString()} employees`;
      }
      
      return cleanedSize.replace('to', ' - ') + ' employees';
    }
    
    return sizeString;
  };

  const getInitials = (firstName, lastName) => {
    return `${firstName?.[0] || ''}${lastName?.[0] || ''}`.toUpperCase();
  };

  const getAvatarColor = () => {
    const colors = [
      theme.palette.primary.main,
      theme.palette.secondary.main,
      theme.palette.success.main,
      theme.palette.warning.main,
      theme.palette.info.main
    ];
    // Use recruiter ID to consistently assign colors
    const colorIndex = (recruiterId || 0) % colors.length;
    return colors[colorIndex];
  };

  // Safe text rendering function
  const safeText = (value) => {
    if (value === null || value === undefined) return 'Not specified';
    if (typeof value === 'object') {
      // Handle industry object specifically
      if (value.name) return value.name;
      if (value.description) return value.description;
      return 'Not specified';
    }
    return String(value);
  };

  // Extract industry name safely
  const getIndustryName = (industry) => {
    if (!industry) return 'Not specified';
    if (typeof industry === 'string') return industry;
    if (typeof industry === 'object' && industry.name) return industry.name;
    return 'Not specified';
  };

  // Don't render dialog if not open
  if (!open) return null;

  // Show error state if no recruiterId provided
  if (!recruiterId) {
    return (
      <Dialog
        open={open}
        onClose={handleClose}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: { borderRadius: 3 }
        }}
      >
        <DialogTitle sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center',
          borderBottom: `1px solid ${theme.palette.divider}`
        }}>
          <Typography variant="h6" sx={{ color: theme.palette.error.main }}>
            Error
          </Typography>
          <IconButton onClick={handleClose}>
            <CloseIcon />
          </IconButton>
        </DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <Alert severity="error" sx={{ borderRadius: 2 }}>
            No recruiter selected. Please select a recruiter to view details.
          </Alert>
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button onClick={handleClose} variant="contained">
            Close
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: { 
          borderRadius: 3,
          minHeight: '500px'
        }
      }}
    >
      {/* Header */}
      <DialogTitle sx={{ 
        p: 0,
        background: `linear-gradient(135deg, ${theme.palette.primary.main}15, ${theme.palette.secondary.main}15)`,
        borderBottom: `1px solid ${theme.palette.divider}`
      }}>
        <Box sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center',
          p: 3
        }}>
          <Typography variant="h5" sx={{ fontWeight: 600, color: theme.palette.primary.main }}>
            Recruiter Details
          </Typography>
          <IconButton 
            onClick={handleClose}
            sx={{ 
              bgcolor: 'background.paper',
              '&:hover': { bgcolor: 'grey.100' }
            }}
          >
            <CloseIcon />
          </IconButton>
        </Box>
      </DialogTitle>

      <DialogContent sx={{ p: 0 }}>
        {loading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 400 }}>
            <Box sx={{ textAlign: 'center' }}>
              <CircularProgress size={60} sx={{ color: theme.palette.primary.main, mb: 2 }} />
              <Typography variant="h6" color="text.secondary">
                Loading recruiter details...
              </Typography>
            </Box>
          </Box>
        )}

        {error && (
          <Box sx={{ p: 3 }}>
            <Alert 
              severity="error" 
              sx={{ borderRadius: 2 }}
              action={
                <Button 
                  color="inherit" 
                  size="small" 
                  onClick={loadRecruiterDetails}
                  disabled={loading}
                >
                  Retry
                </Button>
              }
            >
              {error}
            </Alert>
          </Box>
        )}

        {recruiter && !loading && !error && (
          <Box sx={{ p: 3 }}>
            {/* Profile Header */}
            <Paper 
              elevation={0} 
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                background: `linear-gradient(135deg, ${theme.palette.primary.main}08, ${theme.palette.secondary.main}08)`,
                border: `1px solid ${theme.palette.divider}`
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 3 }}>
                <Avatar
                  sx={{
                    width: 80,
                    height: 80,
                    bgcolor: getAvatarColor(),
                    fontSize: '2rem',
                    fontWeight: 'bold',
                    border: `3px solid ${theme.palette.background.paper}`,
                    boxShadow: theme.shadows[4]
                  }}
                >
                  {getInitials(recruiter.firstName, recruiter.lastName)}
                </Avatar>
                
                <Box sx={{ flex: 1 }}>
                  <Typography variant="h4" sx={{ fontWeight: 600, mb: 1, color: theme.palette.text.primary }}>
                    {safeText(recruiter.fullName || `${recruiter.firstName || ''} ${recruiter.lastName || ''}`)}
                  </Typography>
                  
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                    <WorkIcon sx={{ color: theme.palette.primary.main, fontSize: '1.2rem' }} />
                    <Typography variant="h6" sx={{ color: theme.palette.primary.main, fontWeight: 500 }}>
                      {safeText(recruiter.title)}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <BusinessIcon sx={{ color: theme.palette.text.secondary, fontSize: '1.1rem' }} />
                    <Typography variant="body1" color="text.secondary" sx={{ fontWeight: 500 }}>
                      {safeText(recruiter.company?.name)}
                    </Typography>
                    {recruiter.rating && (
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, ml: 2 }}>
                        <StarIcon sx={{ color: theme.palette.warning.main, fontSize: '1.1rem' }} />
                        <Typography variant="body2" sx={{ fontWeight: 600 }}>
                          {Number(recruiter.rating).toFixed(1)}
                        </Typography>
                      </Box>
                    )}
                  </Box>
                </Box>
                
                {recruiter.outreach?.hasContacted && (
                  <Chip
                    label="Previously Contacted"
                    color="success"
                    variant="outlined"
                    sx={{ 
                      borderRadius: 2,
                      fontWeight: 500
                    }}
                  />
                )}
              </Box>
            </Paper>

            <Grid container spacing={3}>
              {/* Contact Information */}
              <Grid item xs={12} md={6}>
                <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <CardContent sx={{ p: 3 }}>
                    <Typography 
                      variant="h6" 
                      gutterBottom 
                      sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1, 
                        mb: 2,
                        color: theme.palette.primary.main,
                        fontWeight: 600
                      }}
                    >
                      <EmailIcon />
                      Contact Information
                    </Typography>

                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {recruiter.email && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <EmailIcon sx={{ color: theme.palette.primary.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Email
                            </Typography>
                            <Link
                              href={`mailto:${recruiter.email}`}
                              sx={{ 
                                color: theme.palette.primary.main,
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              {safeText(recruiter.email)}
                            </Link>
                          </Box>
                        </Box>
                      )}

                      {recruiter.phone && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <PhoneIcon sx={{ color: theme.palette.success.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Phone
                            </Typography>
                            <Link
                              href={`tel:${recruiter.phone}`}
                              sx={{ 
                                color: theme.palette.text.primary,
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              {safeText(recruiter.phone)}
                            </Link>
                          </Box>
                        </Box>
                      )}

                      {recruiter.linkedinUrl && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <LinkedInIcon sx={{ color: '#0077b5', fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              LinkedIn
                            </Typography>
                            <Link
                              href={recruiter.linkedinUrl}
                              target="_blank"
                              rel="noopener noreferrer"
                              sx={{ 
                                color: '#0077b5',
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              LinkedIn Profile
                            </Link>
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </CardContent>
                </Card>
              </Grid>

              {/* Company Details */}
              <Grid item xs={12} md={6}>
                <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                  <CardContent sx={{ p: 3 }}>
                    <Typography 
                      variant="h6" 
                      gutterBottom 
                      sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1, 
                        mb: 2,
                        color: theme.palette.primary.main,
                        fontWeight: 600
                      }}
                    >
                      <DomainIcon />
                      Company Details
                    </Typography>

                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {recruiter.company?.size && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <GroupsIcon sx={{ color: theme.palette.secondary.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Company Size
                            </Typography>
                            <Typography variant="body2" sx={{ fontWeight: 500 }}>
                              {formatCompanySize(recruiter.company.size)}
                            </Typography>
                          </Box>
                        </Box>
                      )}

                      {recruiter.industry && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <WorkIcon sx={{ color: theme.palette.info.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Industry
                            </Typography>
                            <Chip
                              label={getIndustryName(recruiter.industry)}
                              size="small"
                              variant="outlined"
                              color="primary"
                              sx={{ borderRadius: 1, fontWeight: 500 }}
                            />
                          </Box>
                        </Box>
                      )}

                      {recruiter.company?.foundedYear && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <CalendarTodayIcon sx={{ color: theme.palette.warning.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Founded
                            </Typography>
                            <Typography variant="body2" sx={{ fontWeight: 500 }}>
                              {safeText(recruiter.company.foundedYear)}
                            </Typography>
                          </Box>
                        </Box>
                      )}

                      {recruiter.company?.website && (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                          <LanguageIcon sx={{ color: theme.palette.success.main, fontSize: '1.2rem' }} />
                          <Box>
                            <Typography variant="caption" color="text.secondary" display="block">
                              Website
                            </Typography>
                            <Link
                              href={String(recruiter.company.website).startsWith('http') ? 
                                recruiter.company.website : 
                                `https://${recruiter.company.website}`
                              }
                              target="_blank"
                              rel="noopener noreferrer"
                              sx={{ 
                                color: theme.palette.primary.main,
                                textDecoration: 'none',
                                fontWeight: 500,
                                '&:hover': { textDecoration: 'underline' }
                              }}
                            >
                              {safeText(recruiter.company.website)}
                            </Link>
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </CardContent>
                </Card>
              </Grid>

              {/* Specializations */}
              {recruiter.specializations && Array.isArray(recruiter.specializations) && recruiter.specializations.length > 0 && (
                <Grid item xs={12}>
                  <Card elevation={0} sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
                    <CardContent sx={{ p: 3 }}>
                      <Typography 
                        variant="h6" 
                        gutterBottom 
                        sx={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          gap: 1, 
                          mb: 2,
                          color: theme.palette.primary.main,
                          fontWeight: 600
                        }}
                      >
                        <StarIcon />
                        Specializations
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {recruiter.specializations.map((spec, index) => (
                          <Chip
                            key={index}
                            label={safeText(spec)}
                            variant="outlined"
                            sx={{ 
                              borderRadius: 1,
                              fontWeight: 500,
                              '&:hover': {
                                backgroundColor: theme.palette.primary.main + '08'
                              }
                            }}
                          />
                        ))}
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>
              )}
            </Grid>
          </Box>
        )}
      </DialogContent>

      {/* Footer Actions - Only Close Button */}
      <DialogActions sx={{ 
        p: 3, 
        borderTop: `1px solid ${theme.palette.divider}`,
        background: theme.palette.grey[50]
      }}>
        <Button 
          onClick={handleClose} 
          variant="contained"
          sx={{ 
            borderRadius: 2,
            minWidth: 100
          }}
        >
          Close
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default RecruiterDetails;

================
File: frontend/src/components/recruiters/RecruiterList.js
================
// src/components/recruiters/RecruiterList.js - FIXED PAGINATION
import React, { useState } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Avatar,
  Button,
  Chip,
  Grid,
  IconButton,
  Tooltip,
  Rating,
  Divider,
  Link,
  Badge,
  CircularProgress,
  Alert,
  Pagination,
  Paper
} from '@mui/material';
import {
  Email as EmailIcon,
  Phone as PhoneIcon,
  LinkedIn as LinkedInIcon,
  Business as BusinessIcon,
  Visibility as VisibilityIcon,
  CheckCircle as CheckCircleIcon,
  Person as PersonIcon,
  Work as WorkIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';
import AutoJobLogo from '../common/AutoJobLogo';

const RecruiterCard = ({ recruiter, onViewDetails, onStartOutreach, onLoadMore }) => {
  const theme = useTheme();
  const [isLoading, setIsLoading] = useState(false);

  // Format recruiter data for display
  const formattedRecruiter = recruiterService.formatRecruiterForDisplay ? 
    recruiterService.formatRecruiterForDisplay(recruiter) : {
      displayName: `${recruiter.firstName} ${recruiter.lastName}`,
      companyDisplay: recruiter.company?.name || 'Company Not Available'
    };

  const handleStartOutreach = async () => {
    setIsLoading(true);
    try {
      await onStartOutreach(recruiter);
    } catch (error) {
      console.error('Failed to start outreach:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const getContactStatusColor = (status) => {
    switch (status) {
      case 'replied':
        return 'success';
      case 'sent':
        return 'warning';
      case 'drafted':
        return 'info';
      default:
        return 'default';
    }
  };

  const getContactStatusText = (recruiter) => {
    if (recruiter.outreach?.hasContacted) {
      switch (recruiter.outreach.status) {
        case 'replied':
          return 'Replied';
        case 'sent':
          return 'Contacted';
        case 'drafted':
          return 'Draft Saved';
        default:
          return 'Contacted';
      }
    }
    return 'Not Contacted';
  };

  // Use different theme colors for avatar
  const getAvatarColor = (index) => {
    const colors = [
      theme.palette.secondary.main, // Teal
      theme.palette.warning.main,   // Orange
      theme.palette.success.main,   // Green
      theme.palette.info.main,      // Blue
      theme.palette.error.main      // Red
    ];
    // Use recruiter ID or name to consistently assign colors
    const colorIndex = (recruiter.id || recruiter.firstName?.charCodeAt(0) || 0) % colors.length;
    return colors[colorIndex];
  };

  return (
    <Card 
      elevation={0}
      sx={{ 
        height: '100%',
        transition: 'all 0.2s ease-in-out',
        border: `1px solid ${theme.palette.divider}`,
        borderRadius: 2,
        '&:hover': {
          elevation: 2,
          transform: 'translateY(-2px)',
          boxShadow: theme.shadows[4],
          borderColor: theme.palette.primary.light
        },
        ...(recruiter.outreach?.hasContacted && {
          borderColor: theme.palette.success.light,
          backgroundColor: `${theme.palette.success.main}08`
        })
      }}
    >
      <CardContent sx={{ p: 3, height: '100%', display: 'flex', flexDirection: 'column' }}>
        {/* Header with Avatar and Basic Info */}
        <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
          <Avatar
            sx={{
              width: 48,
              height: 48,
              mr: 2,
              bgcolor: getAvatarColor(),
              fontSize: '1.1rem',
              fontWeight: 'bold'
            }}
          >
            {recruiter.firstName?.[0]}{recruiter.lastName?.[0]}
          </Avatar>
          
          <Box sx={{ flex: 1, minWidth: 0 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
              <Typography 
                variant="h6" 
                sx={{ 
                  fontWeight: 600,
                  fontSize: '1.1rem',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  color: theme.palette.text.primary
                }}
              >
                {formattedRecruiter.displayName}
              </Typography>
              
              {recruiter.outreach?.hasContacted && (
                <Tooltip title={`Status: ${getContactStatusText(recruiter)}`}>
                  <CheckCircleIcon 
                    sx={{ 
                      fontSize: 16, 
                      color: theme.palette.success.main
                    }} 
                  />
                </Tooltip>
              )}
            </Box>
            
            <Typography variant="body2" sx={{ color: theme.palette.primary.main, fontWeight: 500, mb: 0.5 }}>
              {recruiter.title}
            </Typography>
            
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
              <BusinessIcon sx={{ fontSize: 16, color: theme.palette.text.secondary }} />
              <Typography variant="body2" color="text.secondary" noWrap>
                {formattedRecruiter.companyDisplay}
              </Typography>
            </Box>
          </Box>

          {/* Rating */}
          {recruiter.rating && (
            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              <Rating
                value={recruiter.rating}
                readOnly
                size="small"
                precision={0.1}
              />
              <Typography variant="caption" color="text.secondary">
                {recruiter.rating.toFixed(1)}
              </Typography>
            </Box>
          )}
        </Box>

        {/* Company Logo and Info */}
        {recruiter.company?.logo && (
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <Avatar
              src={recruiter.company.logo}
              variant="square"
              sx={{ width: 20, height: 20, mr: 1 }}
            />
            <Typography variant="body2" color="text.secondary">
              {recruiter.company.size && `${recruiter.company.size} company`}
            </Typography>
          </Box>
        )}

        {/* Industry and Specializations */}
        {recruiter.industry && (
          <Box sx={{ mb: 2 }}>
            <Chip
              label={recruiter.industry}
              size="small"
              variant="outlined"
              color="primary"
              sx={{ mr: 1, mb: 1, borderRadius: 1 }}
            />
            {recruiter.specializations && recruiter.specializations.slice(0, 2).map((spec, index) => (
              <Chip
                key={index}
                label={spec}
                size="small"
                variant="outlined"
                sx={{ mr: 1, mb: 1, borderRadius: 1 }}
              />
            ))}
          </Box>
        )}

        {/* Contact Status */}
        <Box sx={{ mb: 2 }}>
          <Chip
            label={getContactStatusText(recruiter)}
            size="small"
            color={getContactStatusColor(recruiter.outreach?.status)}
            variant={recruiter.outreach?.hasContacted ? 'filled' : 'outlined'}
            sx={{ fontWeight: 500, borderRadius: 1 }}
          />
          
          {recruiter.outreach?.lastContactDate && (
            <Typography variant="caption" color="text.secondary" sx={{ ml: 1 }}>
              Last contact: {new Date(recruiter.outreach.lastContactDate).toLocaleDateString()}
            </Typography>
          )}
        </Box>

        {/* Contact Information */}
        <Box sx={{ mb: 2, flex: 1 }}>
          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            {recruiter.email && (
              <Tooltip title={`Email: ${recruiter.email}`}>
                <IconButton size="small" sx={{ color: theme.palette.primary.main }}>
                  <EmailIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
            
            {recruiter.phone && (
              <Tooltip title={`Phone: ${recruiter.phone}`}>
                <IconButton size="small" sx={{ color: theme.palette.primary.main }}>
                  <PhoneIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
            
            {recruiter.linkedinUrl && (
              <Tooltip title="LinkedIn Profile">
                <IconButton 
                  size="small" 
                  sx={{ color: theme.palette.primary.main }}
                  component={Link}
                  href={recruiter.linkedinUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  <LinkedInIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
          </Box>
        </Box>

        <Divider sx={{ mb: 2 }} />

        {/* Action Buttons */}
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button
            variant="outlined"
            startIcon={<VisibilityIcon />}
            onClick={() => onViewDetails(recruiter)}
            size="small"
            sx={{ flex: 1, borderRadius: 2 }}
          >
            View Details
          </Button>
          
          <Button
            variant="contained"
            startIcon={isLoading ? <CircularProgress size={16} color="inherit" /> : 
              <AutoJobLogo variant="icon-only" size="small" sx={{ width: 24, height: 24 }} />
            }
            onClick={handleStartOutreach}
            disabled={isLoading}
            size="small"
            color={recruiter.outreach?.hasContacted ? 'secondary' : 'primary'}
            sx={{ flex: 1, borderRadius: 2 }}
          >
            {isLoading ? 'Loading...' : 'Contact Recruiter'}
          </Button>
        </Box>
      </CardContent>
    </Card>
  );
};

const RecruiterList = ({ 
  searchResults, 
  loading, 
  error, 
  hasSearched,
  onViewDetails, 
  onStartOutreach,
  onLoadMore,
  onPageChange
}) => {
  const theme = useTheme();
  const [currentPage, setCurrentPage] = useState(1);

  const handlePageChange = (event, newPage) => {
    console.log(`📄 Page change requested: ${newPage}`);
    setCurrentPage(newPage);
    
    // Calculate offset for new page
    const limit = searchResults?.pagination?.limit || 20;
    const offset = (newPage - 1) * limit;
    
    // Call the page change handler with proper parameters
    if (onPageChange) {
      onPageChange(newPage, offset);
    } else if (onLoadMore) {
      // Fallback to onLoadMore if onPageChange not provided
      onLoadMore(newPage, offset);
    }
  };

  const handleLoadMore = () => {
    console.log('📄 Load more requested');
    if (onLoadMore) {
      const nextPage = currentPage + 1;
      const limit = searchResults?.pagination?.limit || 20;
      const offset = currentPage * limit; // Current page * limit for next batch
      
      setCurrentPage(nextPage);
      onLoadMore(nextPage, offset);
    }
  };

  // Show loading state
  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>
        <Box sx={{ textAlign: 'center' }}>
          <CircularProgress size={60} sx={{ color: theme.palette.primary.main }} />
          <Typography variant="h6" sx={{ mt: 2, color: 'text.secondary' }}>
            Searching recruiters...
          </Typography>
        </Box>
      </Box>
    );
  }

  // Show error state
  if (error) {
    return (
      <Alert 
        severity="error" 
        sx={{ 
          mb: 3, 
          borderRadius: 2,
          '& .MuiAlert-icon': {
            color: theme.palette.error.main
          }
        }}
      >
        {error}
      </Alert>
    );
  }

  // Show empty state only if user has searched
  if (hasSearched && (!searchResults || !searchResults.recruiters || searchResults.recruiters.length === 0)) {
    return (
      <Paper elevation={0} sx={{ textAlign: 'center', py: 8, borderRadius: 2, border: `1px solid ${theme.palette.divider}` }}>
        <PersonIcon sx={{ fontSize: 64, color: 'text.disabled', mb: 2 }} />
        <Typography variant="h6" gutterBottom>
          No recruiters found
        </Typography>
        <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
          Try adjusting your search criteria or filters to find more results.
        </Typography>
        <Button 
          variant="outlined" 
          onClick={() => window.location.reload()}
          sx={{ borderRadius: 2 }}
        >
          Reset Search
        </Button>
      </Paper>
    );
  }

  // Don't show anything if no search has been performed
  if (!hasSearched) {
    return null;
  }

  const { recruiters, pagination } = searchResults;
  const totalPages = Math.ceil(pagination.total / pagination.limit);

  console.log('🔍 RecruiterList render:', {
    recruitersCount: recruiters?.length,
    currentPage,
    totalPages,
    pagination
  });

  return (
    <Box>
      {/* Results Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <WorkIcon sx={{ color: theme.palette.primary.main }} />
          {pagination.total.toLocaleString()} Recruiters Found
        </Typography>
      </Box>

      {/* Recruiter Grid */}
      <Grid container spacing={3}>
        {recruiters.map((recruiter) => (
          <Grid item xs={12} sm={6} lg={4} key={recruiter.id}>
            <RecruiterCard
              recruiter={recruiter}
              onViewDetails={onViewDetails}
              onStartOutreach={onStartOutreach}
              onLoadMore={onLoadMore}
            />
          </Grid>
        ))}
      </Grid>

      {/* Pagination - Only show if more than one page */}
      {totalPages > 1 && (
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
          <Pagination
            count={totalPages}
            page={currentPage}
            onChange={handlePageChange}
            color="primary"
            size="large"
            showFirstButton
            showLastButton
            sx={{
              '& .MuiPaginationItem-root': {
                borderRadius: 2
              }
            }}
          />
        </Box>
      )}

      {/* Load More Button (Alternative to pagination) - REMOVED */}
      {/* This section has been removed as requested */}

      {/* Results Summary - SIMPLIFIED */}
      <Paper 
        elevation={0}
        sx={{ 
          mt: 3, 
          p: 2, 
          borderRadius: 2, 
          textAlign: 'center',
          border: `1px solid ${theme.palette.divider}`,
          bgcolor: theme.palette.grey[50]
        }}
      >
        <Typography variant="body2" color="text.secondary">
          Showing {recruiters.length} of {pagination.total.toLocaleString()} recruiters
        </Typography>
      </Paper>
    </Box>
  );
};

export default RecruiterList;

================
File: frontend/src/components/recruiters/RecruiterPage.js
================
// src/components/recruiters/RecruiterPage.js - UPDATED WITH ANALYTICS TAB REMOVED
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Container,
  Typography,
  Tabs,
  Tab,
  Alert,
  Snackbar,
  Tooltip,
  Badge
} from '@mui/material';
import {
  Search as SearchIcon,
  Message as MessageIcon,
  People as PeopleIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import MainLayout from '../layout/MainLayout';
import PageHeader from '../common/PageHeader';
import RecruiterSearch from './RecruiterSearch';
import RecruiterList from './RecruiterList';
import RecruiterDetails from './RecruiterDetails';
import OutreachComposer from './OutreachComposer';
import OutreachTracker from './OutreachTracker';
import recruiterService from '../../utils/recruiterService';

const TabPanel = ({ children, value, index, ...other }) => (
  <div
    role="tabpanel"
    hidden={value !== index}
    id={`recruiter-tabpanel-${index}`}
    aria-labelledby={`recruiter-tab-${index}`}
    {...other}
  >
    {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
  </div>
);

const RecruiterPage = () => {
  const theme = useTheme();
  
  // Tab state
  const [activeTab, setActiveTab] = useState(0);
  
  // Search state
  const [searchResults, setSearchResults] = useState(null);
  const [searchLoading, setSearchLoading] = useState(false);
  const [searchError, setSearchError] = useState('');
  const [hasSearched, setHasSearched] = useState(false);
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [currentSearchParams, setCurrentSearchParams] = useState(null);
  
  // Dialog state
  const [selectedRecruiter, setSelectedRecruiter] = useState(null);
  const [showRecruiterDetails, setShowRecruiterDetails] = useState(false);
  const [showOutreachComposer, setShowOutreachComposer] = useState(false);
  
  // Outreach state - Load immediately for badge count
  const [outreachCampaigns, setOutreachCampaigns] = useState([]);
  const [outreachLoading, setOutreachLoading] = useState(false);
  
  // Notification state
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  // Refs for component communication
  const searchRef = useRef(null);

  // Load initial data immediately when component mounts
  useEffect(() => {
    // Always load outreach campaigns for badge count
    loadOutreachCampaigns();
  }, []);

  // Search handlers
  const handleSearchResults = (results, searchParams = null) => {
    console.log('🔍 RecruiterPage: Search results received:', results);
    console.log('🔍 RecruiterPage: Search params received:', searchParams);
    
    setSearchResults(results);
    setSearchError('');
    setHasSearched(true);
    setCurrentPage(1); // Reset to page 1 for new search
    
    // Store search params for pagination (FIXED)
    if (searchParams) {
      setCurrentSearchParams(searchParams);
      console.log('✅ RecruiterPage: Stored search params:', searchParams);
    }
  };

  const handleSearchLoading = (loading) => {
    setSearchLoading(loading);
  };

  const handleSearchError = (error) => {
    setSearchError(error);
    setHasSearched(true);
    showNotification(error, 'error');
  };

  // Pagination handler - this is the key fix
  const handlePageChange = async (page, offset) => {
    console.log(`📄 RecruiterPage: Page change - Page: ${page}, Offset: ${offset}`);
    console.log(`🔍 RecruiterPage: Using stored search params:`, currentSearchParams);
    
    try {
      setSearchLoading(true);
      setCurrentPage(page);
      
      // Use the stored search parameters with pagination (FIXED)
      const searchFilters = {
        ...currentSearchParams, // This now contains the proper search filters
        limit: 20,
        offset: offset
      };
      
      console.log('🔍 RecruiterPage: Performing paginated search:', searchFilters);
      
      const response = await recruiterService.searchRecruiters(searchFilters);
      
      console.log('✅ RecruiterPage: Paginated results received:', response);
      setSearchResults(response);
      
    } catch (error) {
      console.error('❌ RecruiterPage: Pagination failed:', error);
      showNotification('Failed to load more recruiters', 'error');
    } finally {
      setSearchLoading(false);
    }
  };

  // Enhanced search results handler that stores search params
  const handleSearchResultsWithParams = (results, searchParams = null) => {
    console.log('🔍 RecruiterPage: Search results with params:', { results, searchParams });
    
    setSearchResults(results);
    setSearchError('');
    setHasSearched(true);
    setCurrentPage(1);
    
    // Store search parameters for pagination
    if (searchParams) {
      setCurrentSearchParams(searchParams);
    }
  };

  // Load more handler (alternative to pagination)
  const handleLoadMore = async (page, offset) => {
    console.log(`📄 RecruiterPage: Load more - Page: ${page}, Offset: ${offset}`);
    await handlePageChange(page, offset);
  };

  // Recruiter handlers
  const handleViewRecruiterDetails = (recruiter) => {
    setSelectedRecruiter(recruiter);
    setShowRecruiterDetails(true);
  };

  const handleStartOutreach = (recruiter) => {
    setSelectedRecruiter(recruiter);
    setShowOutreachComposer(true);
  };

  // Outreach handlers
  const handleSendOutreach = async (outreachData) => {
    try {
      const response = await recruiterService.createOutreach(outreachData);
      
      // Immediately send the outreach
      await recruiterService.sendOutreach(response.outreach.id);
      
      showNotification('Message sent successfully!', 'success');
      
      // Reload outreach campaigns to update count
      loadOutreachCampaigns();
      
    } catch (error) {
      console.error('Failed to send outreach:', error);
      showNotification('Failed to send message. Please try again.', 'error');
      throw error;
    }
  };

  const handleSaveOutreach = async (outreachData) => {
    try {
      await recruiterService.createOutreach(outreachData);
      showNotification('Draft saved successfully!', 'success');
      
      // Reload outreach campaigns to update count
      loadOutreachCampaigns();
      
    } catch (error) {
      console.error('Failed to save outreach:', error);
      showNotification('Failed to save draft. Please try again.', 'error');
      throw error;
    }
  };

  // Load outreach campaigns
  const loadOutreachCampaigns = async () => {
    try {
      setOutreachLoading(true);
      console.log('📋 Loading outreach campaigns for badge count...');
      
      const response = await recruiterService.getUserOutreach({ limit: 50 });
      const campaigns = response.outreaches || [];
      
      setOutreachCampaigns(campaigns);
      console.log(`✅ Loaded ${campaigns.length} outreach campaigns`);
      
    } catch (error) {
      console.error('Failed to load outreach campaigns:', error);
      // Don't show error notification for initial load, just log it
      if (activeTab === 1) {
        showNotification('Failed to load outreach campaigns', 'error');
      }
    } finally {
      setOutreachLoading(false);
    }
  };

  // Notification helper
  const showNotification = (message, severity = 'success') => {
    setNotification({
      open: true,
      message,
      severity
    });
  };

  // Calculate notification badges
  const getDraftCount = () => {
    return outreachCampaigns.filter(campaign => campaign.status === 'drafted').length;
  };

  const getTotalOutreachCount = () => {
    return outreachCampaigns.length;
  };

  const getUnrepliedCount = () => {
    return outreachCampaigns.filter(campaign => 
      campaign.status === 'sent' && 
      campaign.repliesCount === 0 &&
      Date.now() - new Date(campaign.sentAt).getTime() > 7 * 24 * 60 * 60 * 1000 // 7 days old
    ).length;
  };

  return (
    <MainLayout>
      <Container maxWidth="lg" sx={{ py: 3 }}>
        {/* Page Header */}
        <PageHeader
          title="Recruiter Outreach"
          subtitle="Find and connect with recruiters to accelerate your job search"
          icon={<PeopleIcon />}
        />

        {/* Main Tabs - Analytics Tab Removed */}
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
          <Tabs
            value={activeTab}
            onChange={(e, newValue) => setActiveTab(newValue)}
            variant="scrollable"
            scrollButtons="auto"
            sx={{
              '& .MuiTab-root': {
                minHeight: 48,
                fontSize: '0.875rem',
                fontWeight: 500,
                textTransform: 'none',
                color: theme.palette.text.secondary,
                '&.Mui-selected': {
                  color: theme.palette.primary.main,
                  fontWeight: 600
                }
              },
              '& .MuiTabs-indicator': {
                height: 2,
                backgroundColor: theme.palette.primary.main
              }
            }}
          >
            <Tab
              label="Find Recruiters"
              icon={<SearchIcon />}
              iconPosition="start"
              sx={{ 
                display: 'flex',
                flexDirection: 'row',
                gap: 1
              }}
            />
            <Tab
              label={
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <MessageIcon />
                  Outreach Campaigns
                  {getTotalOutreachCount() > 0 && (
                    <Badge 
                      badgeContent={getTotalOutreachCount()} 
                      color="warning" 
                      max={99}
                      sx={{ 
                        ml: 0.5,
                        '& .MuiBadge-badge': {
                          fontSize: '0.75rem',
                          height: 18,
                          minWidth: 18,
                          borderRadius: '9px'
                        }
                      }}
                    />
                  )}
                </Box>
              }
            />
          </Tabs>
        </Box>

        {/* Tab Content */}
        <TabPanel value={activeTab} index={0}>
          {/* Search Tab */}
          <Box>
            <RecruiterSearch
              ref={searchRef}
              onSearchResults={handleSearchResults}
              onLoading={handleSearchLoading}
              onError={handleSearchError}
              onSearchStateChange={setHasSearched}
            />
            
            <RecruiterList
              searchResults={searchResults}
              loading={searchLoading}
              error={searchError}
              hasSearched={hasSearched}
              onViewDetails={handleViewRecruiterDetails}
              onStartOutreach={handleStartOutreach}
              onLoadMore={handleLoadMore}
              onPageChange={handlePageChange}
            />
          </Box>
        </TabPanel>

        <TabPanel value={activeTab} index={1}>
          {/* Outreach Tab */}
          <OutreachTracker
            campaigns={outreachCampaigns}
            loading={outreachLoading}
            onRefresh={loadOutreachCampaigns}
            onViewRecruiter={handleViewRecruiterDetails}
            onEditCampaign={(campaign) => {
              // Handle editing existing campaign
              setSelectedRecruiter(campaign.recruiter);
              setShowOutreachComposer(true);
            }}
          />
        </TabPanel>

        {/* Dialogs */}
        <RecruiterDetails
          open={showRecruiterDetails}
          onClose={() => {
            setShowRecruiterDetails(false);
            setSelectedRecruiter(null);
          }}
          recruiterId={selectedRecruiter?.id}
          onStartOutreach={handleStartOutreach}
        />

        <OutreachComposer
          open={showOutreachComposer}
          onClose={() => {
            setShowOutreachComposer(false);
            setSelectedRecruiter(null);
          }}
          recruiter={selectedRecruiter}
          onSend={handleSendOutreach}
          onSave={handleSaveOutreach}
        />

        {/* Notifications */}
        <Snackbar
          open={notification.open}
          autoHideDuration={6000}
          onClose={() => setNotification({ ...notification, open: false })}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert
            onClose={() => setNotification({ ...notification, open: false })}
            severity={notification.severity}
            variant="filled"
            sx={{ borderRadius: 2 }}
          >
            {notification.message}
          </Alert>
        </Snackbar>

        {/* Removed Floating Action Button - conflicts with AI Assistant widget */}
      </Container>
    </MainLayout>
  );
};

export default RecruiterPage;

================
File: frontend/src/components/recruiters/RecruiterSearch.js
================
// src/components/recruiters/RecruiterSearch.js - FIXED WITH PAGINATION SUPPORT
import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Grid,
  Typography,
  Autocomplete,
  Chip,
  Paper,
  Collapse,
  IconButton,
  Divider,
  Alert,
  CircularProgress,
  Badge
} from '@mui/material';
import {
  Search as SearchIcon,
  FilterList as FilterIcon,
  Clear as ClearIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Work as WorkIcon,
  Business as BusinessIcon,
  Person as PersonIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import recruiterService from '../../utils/recruiterService';

const RecruiterSearch = ({ onSearchResults, onLoading, onError, onSearchStateChange }) => {
  const theme = useTheme();
  
  // Search state - NO LOCATION FILTER
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState({
    company: null,
    industry: null,
    title: ''
  });
  
  // UI state
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const [isSearching, setIsSearching] = useState(false);
  const [searchCount, setSearchCount] = useState(0);
  
  // Store current search parameters for pagination
  const [currentSearchParams, setCurrentSearchParams] = useState(null);
  
  // Filter options - NO LOCATIONS
  const [filterOptions, setFilterOptions] = useState({
    companies: [],
    industries: []
  });
  const [filterOptionsLoading, setFilterOptionsLoading] = useState(true);

  // Load filter options on component mount
  useEffect(() => {
    loadFilterOptions();
  }, []);

  const loadFilterOptions = async () => {
    try {
      setFilterOptionsLoading(true);
      const response = await recruiterService.getFilterOptions();
      setFilterOptions(response.filterOptions);
    } catch (error) {
      console.error('Failed to load filter options:', error);
      onError?.('Failed to load search filters');
    } finally {
      setFilterOptionsLoading(false);
    }
  };

  // Debounced search function with pagination support
  const performSearch = useCallback(async (searchParams = {}, page = 1, offset = 0) => {
    try {
      setIsSearching(true);
      onLoading?.(true);
      onSearchStateChange?.(true);
      
      const searchFilters = {
        query: searchQuery,
        company: filters.company?.name || '',
        industry: filters.industry?.name || '',
        title: filters.title || '',
        ...searchParams, // This should override the above if provided
        limit: 20,
        offset: offset
      };

      console.log('🔍 Performing search with filters:', searchFilters);
      console.log(`📄 Page: ${page}, Offset: ${offset}`);
      
      // Store current search params for pagination (FIXED)
      const paramsToStore = {
        query: searchFilters.query,
        company: searchFilters.company,
        industry: searchFilters.industry,
        title: searchFilters.title
      };
      setCurrentSearchParams(paramsToStore);
      
      const response = await recruiterService.searchRecruiters(searchFilters);
      
      setSearchCount(response.pagination.total);
      
      // Pass search parameters along with results (FIXED)
      if (onSearchResults) {
        // Add the search parameters to the callback
        onSearchResults(response, paramsToStore);
      }
      
    } catch (error) {
      console.error('Search failed:', error);
      onError?.('Search failed. Please try again.');
    } finally {
      setIsSearching(false);
      onLoading?.(false);
    }
  }, [searchQuery, filters, onSearchResults, onLoading, onError, onSearchStateChange]);

  // Handle search button click
  const handleSearch = () => {
    performSearch({}, 1, 0); // Reset to page 1
  };

  // Handle pagination from RecruiterList
  const handlePageChange = useCallback((page, offset) => {
    console.log(`🔄 RecruiterSearch: Page change requested - Page: ${page}, Offset: ${offset}`);
    
    if (currentSearchParams) {
      // Use stored search parameters for pagination
      performSearch(currentSearchParams, page, offset);
    } else {
      // Fallback: perform new search with current filters
      performSearch({}, page, offset);
    }
  }, [currentSearchParams, performSearch]);

  // Expose pagination handler to parent component
  React.useImperativeHandle(React.forwardRef(() => null), () => ({
    handlePageChange
  }));

  // Make pagination handler available to parent
  React.useEffect(() => {
    if (onSearchResults && typeof onSearchResults === 'function') {
      // Add pagination handler as a property to the callback
      onSearchResults.handlePageChange = handlePageChange;
    }
  }, [handlePageChange, onSearchResults]);

  // Handle filter changes with proper null handling
  const handleFilterChange = (filterName, value) => {
    setFilters(prev => ({
      ...prev,
      [filterName]: value
    }));
  };

  // Reset entire search state
  const resetSearchState = () => {
    setSearchQuery('');
    setFilters({
      company: null,
      industry: null,
      title: ''
    });
    setSearchCount(0);
    setShowAdvancedFilters(false);
    setCurrentSearchParams(null);
    onSearchStateChange?.(false);
    onSearchResults?.(null);
  };

  // Clear search query (X button)
  const clearSearchQuery = () => {
    setSearchQuery('');
    // If there are no other filters, reset everything
    if (!hasActiveFiltersExceptQuery()) {
      resetSearchState();
    }
  };

  // Refresh search with current parameters
  const refreshSearch = () => {
    performSearch({}, 1, 0); // Reset to page 1
  };

  // Check if any filters are applied (excluding search query)
  const hasActiveFiltersExceptQuery = () => {
    return filters.company || 
           filters.industry || 
           filters.title;
  };

  // Check if any filters are applied (including search query)
  const hasActiveFilters = () => {
    return searchQuery || hasActiveFiltersExceptQuery();
  };

  // Expose the pagination handler to parent components
  React.useEffect(() => {
    // Create a custom property on the component to expose pagination
    if (typeof window !== 'undefined') {
      window.recruiterSearchPagination = handlePageChange;
    }
    
    return () => {
      if (typeof window !== 'undefined') {
        delete window.recruiterSearchPagination;
      }
    };
  }, [handlePageChange]);

  return (
    <Paper elevation={0} sx={{ mb: 3, border: `1px solid ${theme.palette.divider}`, borderRadius: 2 }}>
      <CardContent sx={{ p: 3 }}>
        {/* Main Search Bar */}
        <Box sx={{ mb: 3 }}>
          <Typography variant="h5" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
            <SearchIcon sx={{ color: theme.palette.primary.main }} />
            Find Recruiters
            {searchCount > 0 && (
              <Chip 
                label={`${searchCount.toLocaleString()} found`} 
                size="small" 
                color="primary" 
                variant="outlined"
                sx={{ borderRadius: 1 }}
              />
            )}
          </Typography>
          
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} md={8}>
              <TextField
                fullWidth
                variant="outlined"
                placeholder="Search by name, company, title, or keywords..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
                InputProps={{
                  startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                  endAdornment: searchQuery && (
                    <IconButton size="small" onClick={clearSearchQuery}>
                      <ClearIcon />
                    </IconButton>
                  )
                }}
                sx={{ 
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2
                  }
                }}
              />
            </Grid>
            
            <Grid item xs={12} md={4}>
              <Box sx={{ display: 'flex', gap: 1 }}>
                <Button
                  variant="contained"
                  onClick={handleSearch}
                  disabled={isSearching}
                  startIcon={isSearching ? <CircularProgress size={16} color="inherit" /> : <SearchIcon />}
                  sx={{ borderRadius: 2, minWidth: 120 }}
                >
                  {isSearching ? 'Searching...' : 'Search'}
                </Button>
                
                <Badge 
                  badgeContent={hasActiveFilters() ? '●' : 0} 
                  color="secondary"
                  variant="dot"
                >
                  <Button
                    variant="outlined"
                    onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
                    startIcon={<FilterIcon />}
                    endIcon={showAdvancedFilters ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                    sx={{ borderRadius: 2 }}
                  >
                    Filters
                  </Button>
                </Badge>
              </Box>
            </Grid>
          </Grid>
        </Box>

        {/* Advanced Filters */}
        <Collapse in={showAdvancedFilters}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              bgcolor: theme.palette.grey[50],
              border: `1px solid ${theme.palette.divider}`
            }}
          >
            <Typography variant="subtitle1" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
              <FilterIcon sx={{ color: theme.palette.primary.main }} />
              Advanced Filters
            </Typography>
            
            <Grid container spacing={3}>
              {/* Company Filter */}
              <Grid item xs={12} md={6} lg={4}>
                <Autocomplete
                  options={filterOptions.companies}
                  getOptionLabel={(option) => option?.name || ''}
                  value={filters.company}
                  onChange={(e, value) => handleFilterChange('company', value)}
                  loading={filterOptionsLoading}
                  isOptionEqualToValue={(option, value) => option?.name === value?.name}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="Company"
                      placeholder="Select company..."
                      size="small"
                      InputProps={{
                        ...params.InputProps,
                        startAdornment: <BusinessIcon sx={{ mr: 1, color: 'text.secondary', fontSize: '1.2rem' }} />
                      }}
                    />
                  )}
                  renderOption={(props, option) => (
                    <Box component="li" {...props} key={option.name}>
                      <Box>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>{option.name}</Typography>
                        <Typography variant="caption" color="text.secondary">
                          {option.count} recruiters
                        </Typography>
                      </Box>
                    </Box>
                  )}
                />
              </Grid>

              {/* Industry Filter */}
              <Grid item xs={12} md={6} lg={4}>
                <Autocomplete
                  options={filterOptions.industries}
                  getOptionLabel={(option) => option?.name || ''}
                  value={filters.industry}
                  onChange={(e, value) => handleFilterChange('industry', value)}
                  loading={filterOptionsLoading}
                  isOptionEqualToValue={(option, value) => option?.name === value?.name}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="Industry"
                      placeholder="Select industry..."
                      size="small"
                      InputProps={{
                        ...params.InputProps,
                        startAdornment: <WorkIcon sx={{ mr: 1, color: 'text.secondary', fontSize: '1.2rem' }} />
                      }}
                    />
                  )}
                  renderOption={(props, option) => (
                    <Box component="li" {...props} key={option.name}>
                      <Box>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>{option.name}</Typography>
                        <Typography variant="caption" color="text.secondary">
                          {option.count} recruiters
                        </Typography>
                      </Box>
                    </Box>
                  )}
                />
              </Grid>

              {/* Title Filter */}
              <Grid item xs={12} md={6} lg={4}>
                <TextField
                  fullWidth
                  size="small"
                  label="Job Title"
                  placeholder="e.g., Technical Recruiter"
                  value={filters.title}
                  onChange={(e) => handleFilterChange('title', e.target.value)}
                  InputProps={{
                    startAdornment: <PersonIcon sx={{ mr: 1, color: 'text.secondary', fontSize: '1.2rem' }} />
                  }}
                />
              </Grid>
            </Grid>

            <Divider sx={{ my: 2 }} />

            {/* Filter Actions */}
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <Box sx={{ display: 'flex', gap: 1 }}>
                {hasActiveFilters() && (
                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={resetSearchState}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Reset All
                  </Button>
                )}
              </Box>
              
              <Button
                variant="contained"
                onClick={handleSearch}
                disabled={isSearching}
                startIcon={isSearching ? <CircularProgress size={16} color="inherit" /> : <SearchIcon />}
                sx={{ borderRadius: 2 }}
              >
                Apply Filters
              </Button>
            </Box>

            {/* Active Filters Display */}
            {hasActiveFilters() && (
              <Box sx={{ mt: 2 }}>
                <Typography variant="caption" color="text.secondary" gutterBottom display="block" sx={{ mb: 1 }}>
                  Active Filters:
                </Typography>
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {searchQuery && (
                    <Chip
                      label={`Search: "${searchQuery}"`}
                      size="small"
                      onDelete={() => setSearchQuery('')}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                  {filters.company && (
                    <Chip
                      label={`Company: ${filters.company.name}`}
                      size="small"
                      onDelete={() => handleFilterChange('company', null)}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                  {filters.industry && (
                    <Chip
                      label={`Industry: ${filters.industry.name}`}
                      size="small"
                      onDelete={() => handleFilterChange('industry', null)}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                  {filters.title && (
                    <Chip
                      label={`Title: ${filters.title}`}
                      size="small"
                      onDelete={() => handleFilterChange('title', '')}
                      color="primary"
                      sx={{ borderRadius: 1 }}
                    />
                  )}
                </Box>
              </Box>
            )}
          </Paper>
        </Collapse>

        {/* Search Tips */}
        {!hasActiveFilters() && (
          <Alert 
            severity="info" 
            sx={{ 
              mt: 2,
              borderRadius: 2,
              '& .MuiAlert-icon': {
                color: theme.palette.info.main
              }
            }}
          >
            <Typography variant="body2">
              💡 <strong>Search Tips:</strong> Use specific keywords like "Technical Recruiter", company names, or job titles. 
              Try filtering by industry for better results.
            </Typography>
          </Alert>
        )}
      </CardContent>
      
      {/* Export pagination handler for parent component */}
      <div style={{ display: 'none' }} data-pagination-handler={handlePageChange} />
    </Paper>
  );
};

// Add pagination handler as a static method
RecruiterSearch.handlePageChange = null;

export default RecruiterSearch;

================
File: frontend/src/components/resumes/components/AiEditingToolbar.js
================
// src/components/resumes/components/AiEditingToolbar.js - FIXED PROGRESS DISPLAY
import React from 'react';
import {
  Box,
  Typography,
  Paper,
  Button,
  ButtonGroup,
  Chip,
  Grid,
  LinearProgress,
  useTheme
} from '@mui/material';
import {
  Chat as ChatIcon,
  AutoFixHigh as AutoFixHighIcon
} from '@mui/icons-material';
import AutoJobLogo from '../../common/AutoJobLogo';

/**
 * AI editing toolbar component with enhanced progress tracking
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {function} props.onQuickAction - Quick action handler
 * @param {function} props.onOpenChat - Open chat handler
 * @param {boolean} props.aiProcessing - AI processing state
 * @param {string} props.progressStage - Current progress stage message
 * @param {number} props.progressPercentage - Progress percentage (0-100)
 * @returns {JSX.Element} AI editing toolbar component
 */
const AiEditingToolbar = ({ 
  resume, 
  onQuickAction, 
  onOpenChat, 
  aiProcessing, 
  progressStage, 
  progressPercentage 
}) => {
  const theme = useTheme();
  
  // Ensure progress percentage is valid for MUI LinearProgress
  const validProgressPercentage = Math.max(0, Math.min(100, progressPercentage || 0));

  return (
    <Paper 
      elevation={3} 
      sx={{ 
        p: 2, 
        mb: 3, 
        borderRadius: 3,
        background: `linear-gradient(135deg, ${theme.palette.primary.main}10 0%, ${theme.palette.secondary.main}10 100%)`,
        border: `1px solid ${theme.palette.primary.main}30`
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <AutoJobLogo variant="icon-only" size="small" />
        <Typography variant="h6" sx={{ ml: 1, fontWeight: 600 }}>
          AI Job Assistant
        </Typography>
        <Chip 
          label="Powered by AJ" 
          size="small" 
          color="primary" 
          sx={{ ml: 2 }}
        />
      </Box>

      {aiProcessing && (
        <Box sx={{ mb: 2 }}>
          <LinearProgress 
            variant="determinate" 
            value={validProgressPercentage} 
            sx={{ 
              borderRadius: 1,
              height: 8,
              '& .MuiLinearProgress-bar': {
                borderRadius: 1,
                background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.secondary.main} 100%)`
              }
            }} 
          />
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mt: 1 }}>
            <Typography 
              variant="caption" 
              color="text.secondary"
              sx={{ 
                fontWeight: 500,
                maxWidth: '75%',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
              }}
            >
              {progressStage || 'AJ is improving your resume...'}
            </Typography>
            <Typography variant="caption" color="primary" fontWeight="medium">
              {Math.round(validProgressPercentage)}%
            </Typography>
          </Box>
        </Box>
      )}

      <Grid container spacing={2} alignItems="center">
        <Grid item xs={12} md={8}>
          <Typography variant="body2" color="text.secondary">
            Let AJ analyze and optimize your resume for better ATS compatibility and job matching.
          </Typography>
        </Grid>
        
        <Grid item xs={12} md={4}>
          <ButtonGroup variant="contained" fullWidth>
            <Button
              startIcon={<ChatIcon />}
              onClick={onOpenChat}
              disabled={aiProcessing}
              sx={{ flexGrow: 1 }}
            >
              Edit with AJ
            </Button>
            <Button
              startIcon={<AutoFixHighIcon />}
              onClick={() => onQuickAction('Auto-Fix for ATS')}
              disabled={aiProcessing}
              color="secondary"
            >
              Auto-Fix for ATS
            </Button>
          </ButtonGroup>
        </Grid>
      </Grid>
    </Paper>
  );
};

export default AiEditingToolbar;

================
File: frontend/src/components/resumes/components/BeforeAfterComparison.js
================
// src/components/resumes/components/BeforeAfterComparison.js - FIXED READABILITY
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Card,
  CardContent,
  Grid,
  Chip,
  IconButton,
  Tabs,
  Tab,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Alert
} from '@mui/material';
import {
  Close as CloseIcon,
  TrendingUp as TrendingUpIcon,
  CheckCircle as CheckCircleIcon,
  ArrowForward as ArrowForwardIcon,
  Timeline as TimelineIcon,
  Work as WorkIcon,
  Code as CodeIcon
} from '@mui/icons-material';

/**
 * Before/After Comparison Dialog Component - FIXED UI READABILITY
 * @param {object} props - Component props
 * @param {boolean} props.open - Dialog open state
 * @param {function} props.onClose - Close dialog handler
 * @param {object} props.comparisonData - Comparison data from backend
 * @returns {JSX.Element} Before/After comparison dialog
 */
const BeforeAfterComparison = ({ open, onClose, comparisonData }) => {
  const [tabValue, setTabValue] = useState(0);

  if (!comparisonData) return null;

  const { scores, changes, summary, summaryText } = comparisonData;

  const TabPanel = ({ children, value, index }) => (
    <div hidden={value !== index}>
      {value === index && <Box sx={{ pt: 2 }}>{children}</Box>}
    </div>
  );

  const renderScoreComparison = () => (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Alert severity="success" sx={{ mb: 3 }}>
          <Typography variant="h6" gutterBottom>
            🎉 Optimization Results
          </Typography>
          <Typography variant="body1">
            {summaryText}
          </Typography>
        </Alert>
      </Grid>
      
      <Grid item xs={12} md={6}>
        <Card variant="outlined" sx={{ textAlign: 'center', p: 2 }}>
          <Typography variant="h6" color="text.secondary" gutterBottom>
            Before Optimization
          </Typography>
          <Box sx={{ display: 'flex', justifyContent: 'space-around', mt: 2 }}>
            <Box>
              <Typography variant="h4" color="warning.main" fontWeight="bold">
                {scores.before.overallScore}
              </Typography>
              <Typography variant="caption" color="text.secondary">
                Overall Score
              </Typography>
            </Box>
            <Box>
              <Typography variant="h4" color="warning.main" fontWeight="bold">
                {scores.before.atsCompatibility}%
              </Typography>
              <Typography variant="caption" color="text.secondary">
                ATS Score
              </Typography>
            </Box>
          </Box>
        </Card>
      </Grid>

      <Grid item xs={12} md={6}>
        <Card variant="outlined" sx={{ 
          textAlign: 'center', 
          p: 2, 
          bgcolor: 'success.light', 
          border: '2px solid',
          borderColor: 'success.main'
        }}>
          <Typography variant="h6" gutterBottom sx={{ color: 'success.dark', fontWeight: 600 }}>
            After Optimization
          </Typography>
          <Box sx={{ display: 'flex', justifyContent: 'space-around', mt: 2 }}>
            <Box>
              <Typography variant="h4" sx={{ color: 'success.dark', fontWeight: 'bold' }}>
                {scores.after.overallScore}
              </Typography>
              <Typography variant="caption" sx={{ color: 'success.dark', fontWeight: 500 }}>
                Overall Score
              </Typography>
            </Box>
            <Box>
              <Typography variant="h4" sx={{ color: 'success.dark', fontWeight: 'bold' }}>
                {scores.after.atsCompatibility}%
              </Typography>
              <Typography variant="caption" sx={{ color: 'success.dark', fontWeight: 500 }}>
                ATS Score
              </Typography>
            </Box>
          </Box>
          {(scores.after.atsCompatibility - scores.before.atsCompatibility) > 0 && (
            <Chip 
              icon={<TrendingUpIcon />}
              label={`+${scores.after.atsCompatibility - scores.before.atsCompatibility}% improvement`}
              color="success"
              variant="outlined"
              sx={{ 
                mt: 2,
                bgcolor: 'white',
                color: 'success.dark',
                fontWeight: 600,
                '& .MuiChip-icon': {
                  color: 'success.main'
                }
              }}
            />
          )}
        </Card>
      </Grid>

      <Grid item xs={12}>
        <Card variant="outlined" sx={{ p: 2 }}>
          <Typography variant="h6" gutterBottom>
            📊 Summary Statistics
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h5" color="primary" fontWeight="bold">
                  {summary.sectionsModified}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Sections Enhanced
                </Typography>
              </Box>
            </Grid>
            <Grid item xs={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h5" color="primary" fontWeight="bold">
                  {summary.improvementsCount}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Improvements Made
                </Typography>
              </Box>
            </Grid>
            <Grid item xs={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h5" color="primary" fontWeight="bold">
                  {summary.keywordsAdded}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Keywords Added
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </Card>
      </Grid>
    </Grid>
  );

  const renderDetailedChanges = () => (
    <Box>
      {changes.map((change, index) => (
        <Card key={index} variant="outlined" sx={{ mb: 3 }}>
          <CardContent>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
              {change.section === 'experience' ? <WorkIcon color="primary" /> : <CodeIcon color="primary" />}
              <Box sx={{ ml: 1 }}>
                <Typography variant="h6" color="primary">
                  {change.section === 'experience' ? 'Work Experience' : 'Skills'} Enhancement
                </Typography>
                {change.jobTitle && (
                  <Typography variant="body2" color="text.secondary">
                    {change.jobTitle} at {change.company}
                  </Typography>
                )}
              </Box>
              <Box sx={{ ml: 'auto' }}>
                <Chip 
                  label={change.changeType} 
                  color="primary" 
                  size="small"
                  sx={{ textTransform: 'capitalize' }}
                />
              </Box>
            </Box>

            <Typography variant="body2" color="text.secondary" gutterBottom>
              {change.impact}
            </Typography>

            <Divider sx={{ my: 2 }} />

            {change.field === 'highlights' ? (
              <Box>
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" color="error.main" gutterBottom>
                      Before:
                    </Typography>
                    <List dense>
                      {change.before.map((item, idx) => (
                        <ListItem key={idx} sx={{ pl: 0, py: 0.5 }}>
                          <ListItemText 
                            primary={item}
                            sx={{ 
                              '& .MuiListItemText-primary': { 
                                fontSize: '0.875rem',
                                bgcolor: 'rgba(255, 0, 0, 0.05)',
                                p: 1,
                                borderRadius: 1,
                                border: '1px solid rgba(255, 0, 0, 0.2)'
                              }
                            }}
                          />
                        </ListItem>
                      ))}
                    </List>
                  </Grid>
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" color="success.main" gutterBottom>
                      After:
                    </Typography>
                    <List dense>
                      {change.after.map((item, idx) => (
                        <ListItem key={idx} sx={{ pl: 0, py: 0.5 }}>
                          <ListItemIcon sx={{ minWidth: 32 }}>
                            <CheckCircleIcon fontSize="small" color="success" />
                          </ListItemIcon>
                          <ListItemText 
                            primary={item}
                            sx={{ 
                              '& .MuiListItemText-primary': { 
                                fontSize: '0.875rem',
                                bgcolor: 'rgba(0, 255, 0, 0.05)',
                                p: 1,
                                borderRadius: 1,
                                border: '1px solid rgba(0, 255, 0, 0.2)'
                              }
                            }}
                          />
                        </ListItem>
                      ))}
                    </List>
                  </Grid>
                </Grid>
              </Box>
            ) : (
              <Box>
                <Typography variant="subtitle2" color="error.main" gutterBottom>
                  Before:
                </Typography>
                <Typography variant="body2" sx={{ 
                  bgcolor: 'rgba(255, 0, 0, 0.05)', 
                  p: 2, 
                  borderRadius: 1,
                  border: '1px solid rgba(255, 0, 0, 0.2)',
                  mb: 2
                }}>
                  {change.before}
                </Typography>
                
                <Typography variant="subtitle2" color="success.main" gutterBottom>
                  After:
                </Typography>
                <Typography variant="body2" sx={{ 
                  bgcolor: 'rgba(0, 255, 0, 0.05)', 
                  p: 2, 
                  borderRadius: 1,
                  border: '1px solid rgba(0, 255, 0, 0.2)'
                }}>
                  {change.after}
                </Typography>
              </Box>
            )}
          </CardContent>
        </Card>
      ))}

      {changes.length === 0 && (
        <Alert severity="info">
          <Typography variant="body1">
            No detailed changes to display. The optimization focused on overall improvements and keyword enhancements.
          </Typography>
        </Alert>
      )}
    </Box>
  );

  return (
    <Dialog 
      open={open} 
      onClose={onClose} 
      maxWidth="lg" 
      fullWidth
      PaperProps={{
        sx: { borderRadius: 3, maxHeight: '90vh' }
      }}
    >
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <TimelineIcon color="primary" sx={{ mr: 1 }} />
          <Typography variant="h5" fontWeight="bold">
            ATS Optimization Results
          </Typography>
        </Box>
        <IconButton onClick={onClose} size="small">
          <CloseIcon />
        </IconButton>
      </DialogTitle>

      <DialogContent>
        <Tabs 
          value={tabValue} 
          onChange={(e, newValue) => setTabValue(newValue)}
          sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}
        >
          <Tab 
            label="Score Comparison" 
            icon={<TrendingUpIcon />} 
            iconPosition="start"
          />
          <Tab 
            label="Detailed Changes" 
            icon={<CheckCircleIcon />} 
            iconPosition="start"
          />
        </Tabs>

        <TabPanel value={tabValue} index={0}>
          {renderScoreComparison()}
        </TabPanel>

        <TabPanel value={tabValue} index={1}>
          {renderDetailedChanges()}
        </TabPanel>
      </DialogContent>

      <DialogActions sx={{ p: 3 }}>
        <Button 
          onClick={onClose} 
          variant="contained" 
          startIcon={<CheckCircleIcon />}
          size="large"
        >
          Got it!
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default BeforeAfterComparison;

================
File: frontend/src/components/resumes/components/ProcessingView.js
================
// src/components/resumes/components/ProcessingView.js
import React from 'react';
import {
  Box,
  Typography,
  Button,
  Card,
  CardContent,
  CircularProgress,
  Divider
} from '@mui/material';
import { ArrowBack as ArrowBackIcon } from '@mui/icons-material';
import MainLayout from '../../layout/MainLayout';

/**
 * Processing view component shown while resume is being analyzed
 * @param {object} props - Component props
 * @param {function} props.navigate - Navigation function
 * @returns {JSX.Element} Processing view component
 */
const ProcessingView = ({ navigate }) => {
  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/resumes')}
          sx={{ mb: 3 }}
        >
          Back to Resumes
        </Button>
        
        <Card sx={{ maxWidth: 700, mx: 'auto', borderRadius: 3 }}>
          <CardContent sx={{ textAlign: 'center', py: 5 }}>
            <CircularProgress size={80} thickness={4} sx={{ mb: 3 }} />
            <Typography variant="h5" gutterBottom fontWeight={500}>
              Processing Your Resume
            </Typography>
            <Typography variant="body1" sx={{ mb: 4, color: 'text.secondary' }}>
              Our AI is currently analyzing your resume. This process may take a few minutes.
            </Typography>
            <Divider sx={{ my: 2 }} />
            <Typography variant="body2" color="primary">
              This page will automatically update when processing is complete.
            </Typography>
          </CardContent>
        </Card>
      </Box>
    </MainLayout>
  );
};

export default ProcessingView;

================
File: frontend/src/components/resumes/components/ScoreDisplay.js
================
// src/components/resumes/components/ScoreDisplay.js
import React from 'react';
import {
  Box,
  Typography,
  CircularProgress,
  useTheme
} from '@mui/material';
import { getScoreColor } from '../utils/resumeHelpers';

/**
 * Circular progress score display component
 * @param {object} props - Component props
 * @param {number} props.value - Score value (0-100)
 * @param {string} props.label - Score label
 * @param {number} props.size - Circle size in pixels
 * @returns {JSX.Element} Score display component
 */
const ScoreDisplay = ({ value, label, size = 100 }) => {
  const theme = useTheme();
  const color = getScoreColor(value, theme);

  return (
    <Box sx={{ position: 'relative', display: 'inline-flex' }}>
      <CircularProgress
        variant="determinate"
        size={size}
        thickness={5}
        value={100}
        sx={{ color: color, opacity: 0.2, position: 'absolute' }}
      />
      <CircularProgress
        variant="determinate"
        size={size}
        thickness={5}
        value={value}
        sx={{ color: color }}
      />
      <Box
        sx={{
          position: 'absolute',
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column'
        }}
      >
        <Typography variant="h4" fontWeight="bold" color={color}>
          {Math.round(value)}
        </Typography>
        <Typography variant="caption" color="text.secondary">
          {label}
        </Typography>
      </Box>
    </Box>
  );
};

export default ScoreDisplay;

================
File: frontend/src/components/resumes/components/TabPanel.js
================
// src/components/resumes/components/TabPanel.js
import React from 'react';
import { Box } from '@mui/material';

/**
 * Generic tab panel wrapper component
 * @param {object} props - Component props
 * @param {React.ReactNode} props.children - Tab content
 * @param {number} props.value - Current tab value
 * @param {number} props.index - Tab index
 * @returns {JSX.Element} Tab panel component
 */
const TabPanel = ({ children, value, index, ...other }) => (
  <div
    role="tabpanel"
    hidden={value !== index}
    id={`resume-tabpanel-${index}`}
    aria-labelledby={`resume-tab-${index}`}
    {...other}
  >
    {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
  </div>
);

export default TabPanel;

================
File: frontend/src/components/resumes/hooks/useAiIntegration.js
================
// src/components/resumes/hooks/useAiIntegration.js - COMPLETE FIXED VERSION WITH PROPER BACKEND URL
import { useState, useEffect, useCallback, useRef } from 'react';
import { useAiAssistant } from '../../../context/AiAssistantContext';
import axios from '../../../utils/axios';

/**
 * Custom hook for AI integration functionality with REAL SSE progress tracking and ANALYSIS REFRESH
 * @param {object} resume - Resume data object
 * @param {function} fetchResumeDetails - Function to refresh resume data
 * @returns {object} AI processing states and functions
 */
export const useAiIntegration = (resume, fetchResumeDetails) => {
  const [aiProcessing, setAiProcessing] = useState(false);
  const [aiSuccess, setAiSuccess] = useState('');
  const [progressPercentage, setProgressPercentage] = useState(0);
  const [progressStage, setProgressStage] = useState('');
  const [comparisonData, setComparisonData] = useState(null);
  
  // SSE connection ref
  const eventSourceRef = useRef(null);
  
  // Safely get AI assistant functions
  let setAiOpen = () => {};
  let updateContextFromLocation = () => {};
  
  try {
    const aiAssistant = useAiAssistant();
    setAiOpen = aiAssistant?.setIsOpen || (() => {});
    updateContextFromLocation = aiAssistant?.updateContextFromLocation || (() => {});
    
    // Log available functions for debugging
    console.log('Available AI functions:', Object.keys(aiAssistant));
  } catch (error) {
    console.warn('AI Assistant not available:', error);
  }

  // Cleanup SSE connection on unmount
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        console.log('🧹 Cleaning up SSE connection on unmount');
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
    };
  }, []);

  // Trigger context update when resume changes
  useEffect(() => {
    if (resume && updateContextFromLocation) {
      // Use the existing context update function
      updateContextFromLocation();
      console.log('Updated AI context for resume:', resume.name);
    }
  }, [resume, updateContextFromLocation]);

  // 🔥 CRITICAL FIX: Listen for AI resume updates AND refresh analysis
  useEffect(() => {
    const handleResumeUpdate = async (event) => {
      if (event.detail?.resumeId === resume?.id) {
        console.log('🔄 Resume update event received, refreshing analysis data...');
        
        // Force a complete refresh of resume data including analysis
        await fetchResumeDetails();
        
        // Show success message
        setAiSuccess(event.detail.message || '✅ AJ updated your resume!');
        
        // 🔥 ENHANCED: If the event includes new analysis data, use it
        if (event.detail.newAnalysis) {
          console.log('📊 New analysis data received:', event.detail.newAnalysis);
          setAiSuccess(prev => prev + `\n📊 New Scores: Overall ${event.detail.newAnalysis.overallScore}%, ATS ${event.detail.newAnalysis.atsCompatibility}%`);
        }
        
        setTimeout(() => setAiSuccess(''), 8000); // Longer timeout for detailed messages
      }
    };

    window.addEventListener('resumeUpdated', handleResumeUpdate);
    return () => window.removeEventListener('resumeUpdated', handleResumeUpdate);
  }, [resume?.id, fetchResumeDetails]);

  /**
   * Start real-time progress tracking via SSE - FIXED VERSION WITH CORRECT BACKEND URL
   */
  const startProgressTracking = useCallback((resumeId) => {
    console.log('🚀 Starting real-time progress tracking via SSE for resume:', resumeId);
    
    // Close existing connection if any
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }

    try {
      // Get auth token for SSE request
      const token = localStorage.getItem('token');
      if (!token) {
        console.error('❌ No auth token available for SSE connection');
        setProgressStage('Authentication required');
        return;
      }

      // 🔧 CRITICAL FIX: Use BACKEND URL not frontend URL
      const backendUrl = process.env.NODE_ENV === 'development' 
        ? 'http://localhost:5000' 
        : 'https://auto-job-backend-production.up.railway.app'; // FIXED: Use backend URL
      
      const sseUrl = `${backendUrl}/api/resumes/${resumeId}/optimization-progress?token=${encodeURIComponent(token)}`;
      console.log('📡 Connecting to SSE URL:', sseUrl);
      
      // 🔧 FIX: Add a small delay to ensure backend is ready
      setTimeout(() => {
        try {
          // Create EventSource connection
          eventSourceRef.current = new EventSource(sseUrl);
          
          eventSourceRef.current.onopen = (event) => {
            console.log('📡 SSE connection opened successfully', event);
            setProgressStage('Connected to progress stream');
          };
          
          eventSourceRef.current.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              console.log('📡 Parsed SSE update:', data);
              
              if (data.type === 'progress') {
                console.log(`📊 Real Progress Update: ${data.percentage}% - ${data.message}`);
                setProgressPercentage(data.percentage);
                setProgressStage(data.message);
                
                // If optimization is complete, we'll handle it in the main API response
                if (data.percentage >= 100) {
                  console.log('✅ SSE Progress Complete - awaiting final API response');
                  setProgressStage('Optimization complete - finalizing...');
                }
              } else if (data.type === 'connected') {
                console.log('📡 SSE Connection confirmed:', data.message);
                setProgressStage('Progress tracking connected');
              } else if (data.type === 'complete') {
                console.log('🎉 SSE Optimization complete signal received');
                setProgressPercentage(100);
                setProgressStage(data.message);
              } else if (data.type === 'error') {
                console.error('❌ SSE Error received:', data.message);
                setProgressStage(`Error: ${data.message}`);
              } else if (data.type === 'heartbeat') {
                // Ignore heartbeat messages, just log them
                console.log('💓 SSE Heartbeat received');
              }
            } catch (parseError) {
              console.error('❌ Error parsing SSE data:', parseError, 'Raw data:', event.data);
            }
          };
          
          eventSourceRef.current.onerror = (error) => {
            console.error('❌ SSE Connection Error:', error);
            console.error('❌ SSE ReadyState:', eventSourceRef.current?.readyState);
            console.error('❌ SSE URL was:', sseUrl);
            
            // 🔧 FIX: Better error handling with specific messages
            const readyState = eventSourceRef.current?.readyState;
            let errorMessage = 'Connection error';
            
            if (readyState === 0) {
              errorMessage = 'Connecting to progress stream...';
            } else if (readyState === 2) {
              errorMessage = 'Connection closed - continuing without live updates';
            } else {
              errorMessage = 'Connection failed - continuing without live updates';
            }
            
            setProgressStage(errorMessage);
            
            // Close and cleanup on error
            if (eventSourceRef.current) {
              eventSourceRef.current.close();
              eventSourceRef.current = null;
            }
          };

          console.log('📡 SSE Connection setup complete');
          
        } catch (connectionError) {
          console.error('❌ Failed to create SSE connection:', connectionError);
          setProgressStage('Failed to connect - continuing without live updates');
        }
      }, 100); // Small delay to ensure everything is ready
      
    } catch (error) {
      console.error('❌ Failed to establish SSE connection:', error);
      setProgressStage('Failed to connect - continuing without live updates');
    }
  }, []);

  /**
   * Stop progress tracking and cleanup SSE connection
   */
  const stopProgressTracking = useCallback(() => {
    console.log('🛑 Stopping progress tracking and closing SSE connection');
    
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
      console.log('📡 SSE connection closed');
    }
  }, []);

  const openAiChat = useCallback(() => {
    try {
      setAiOpen(true);
    } catch (error) {
      console.warn('Cannot open AI chat:', error);
      setAiSuccess('AI Assistant not available. Please check your setup.');
      setTimeout(() => setAiSuccess(''), 3000);
    }
  }, [setAiOpen]);

  const handleQuickAction = useCallback(async (action) => {
    if (!resume) return;
    
    console.log(`🤖 AJ: Starting ${action} with real progress tracking...`);
    
    setAiProcessing(true);
    setProgressPercentage(0);
    setProgressStage('Initializing...');
    setComparisonData(null);
    
    try {
      if (action === 'Auto-Fix for ATS') {
        console.log('🤖 AJ: Starting ATS optimization with real progress...');
        
        // 🔧 FIX: Only start SSE if we're in a development environment or if backend supports it
        // In production, we'll rely on the API response for now
        if (process.env.NODE_ENV === 'development') {
          startProgressTracking(resume.id);
          setProgressStage('Connecting to progress stream...');
          await new Promise(resolve => setTimeout(resolve, 1500));
        } else {
          // Production fallback - show manual progress updates
          setProgressStage('Starting ATS optimization...');
          
          // Simulate progress updates for better UX
          const progressSteps = [
            { percentage: 10, message: 'Analyzing resume for ATS optimizations...' },
            { percentage: 30, message: 'Generating enhancement suggestions...' },
            { percentage: 50, message: 'Applying optimizations to resume...' },
            { percentage: 70, message: 'Re-analyzing optimized resume...' },
            { percentage: 90, message: 'Generating before/after comparison...' }
          ];
          
          // Update progress every 2 seconds
          let stepIndex = 0;
          const progressInterval = setInterval(() => {
            if (stepIndex < progressSteps.length) {
              const step = progressSteps[stepIndex];
              setProgressPercentage(step.percentage);
              setProgressStage(step.message);
              stepIndex++;
            }
          }, 2000);
          
          // Clear interval when done (will be handled in finally block)
          setTimeout(() => clearInterval(progressInterval), 10000);
        }
        
        setProgressStage('Starting ATS optimization...');
        
        // Call the real backend API for ATS optimization
        const response = await axios.post(`/resumes/${resume.id}/optimize-ats`, {
          targetJob: null // Could be enhanced to include specific job targeting
        });
        
        console.log('✅ AJ: ATS optimization response:', response.data);
       
        if (response.data.success) {
          const { data } = response.data;
          
          // Store comparison data for before/after dialog
          if (data.comparison) {
            console.log('📊 Setting comparison data for before/after view');
            setComparisonData(data.comparison);
          }
          
          // Show detailed success message with improvement metrics
          const improvementMessage = `✅ ATS Optimization Complete! 
📈 ATS Score: ${data.previousATSScore}% → ${data.newATSScore}% 
🚀 Improvement: +${data.improvementGain}%`;
          
          setAiSuccess(improvementMessage);
          setProgressPercentage(100);
          setProgressStage('Optimization completed successfully!');
          
          // 🔥 CRITICAL FIX: Force complete resume refresh with analysis
          console.log('🔄 Forcing complete resume data refresh with new analysis...');
          await fetchResumeDetails();
          
          // 🔥 ENHANCED: Wait a moment then force another refresh to ensure analysis is updated
          setTimeout(async () => {
            console.log('🔄 Secondary refresh to ensure analysis scores are updated...');
            await fetchResumeDetails();
          }, 2000);
          
          // Dispatch update event with detailed info
          window.dispatchEvent(new CustomEvent('resumeUpdated', {
            detail: { 
              resumeId: resume.id, 
              message: `ATS optimization complete: ${data.newATSScore}% compatibility`,
              atsScore: data.newATSScore,
              improvement: data.improvementGain,
              // 🔥 CRITICAL: Include new analysis data for UI refresh
              newAnalysis: {
                overallScore: data.newATSScore,
                atsCompatibility: data.newATSScore
              }
            }
          }));
          
        } else {
          throw new Error(response.data.message || 'ATS optimization failed');
        }
        
      } else {
        // Handle other actions (if any in the future)
        console.log(`🤖 AJ: Processing action: ${action}`);
        
        // Simulate other actions for now
        setProgressStage('Processing...');
        setProgressPercentage(50);
        await new Promise(resolve => setTimeout(resolve, 2000));
        setProgressPercentage(100);
        setProgressStage('Complete!');
        
        setAiSuccess(`✅ ${action} completed successfully!`);
        
        // 🔥 CRITICAL FIX: Force complete resume refresh for all actions
        await fetchResumeDetails();
        
        window.dispatchEvent(new CustomEvent('resumeUpdated', {
          detail: { resumeId: resume.id, message: `AI completed: ${action}` }
        }));
      }
      
    } catch (error) {
      console.error('❌ AI action failed:', error);
      
      // Enhanced error handling with specific messages
      let errorMessage = '❌ AI action failed. Please try again.';
      
      if (error.response?.status === 401) {
        errorMessage = '❌ Authentication error. Please log in again.';
      } else if (error.response?.status === 404) {
        errorMessage = '❌ Resume not found. Please refresh and try again.';
      } else if (error.response?.status === 500) {
        errorMessage = '❌ Server error. Our AI is temporarily unavailable.';
      } else if (error.response?.data?.message) {
        errorMessage = `❌ ${error.response.data.message}`;
      }
      
      setAiSuccess(errorMessage);
      setProgressStage(errorMessage);
      
    } finally {
      // Always cleanup SSE connection when done
      stopProgressTracking();
      
      setAiProcessing(false);
      setTimeout(() => {
        setAiSuccess('');
        setProgressStage('');
        setProgressPercentage(0);
      }, 8000); // Longer timeout for detailed messages
    }
  }, [resume, fetchResumeDetails, startProgressTracking, stopProgressTracking]);

  return { 
    aiProcessing, 
    aiSuccess, 
    openAiChat, 
    handleQuickAction,
    progressPercentage,
    progressStage,
    comparisonData
  };
};

================
File: frontend/src/components/resumes/hooks/useResumeData.js
================
// src/components/resumes/hooks/useResumeData.js - ENHANCED WITH FORCE REFRESH
import { useState, useCallback } from 'react';
import axios from '../../../utils/axios';

/**
 * Custom hook for managing resume data, loading states, and API calls
 * @param {string} id - Resume ID
 * @returns {object} Resume data, loading states, and fetch function
 */
export const useResumeData = (id) => {
  const [resume, setResume] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [processingStatus, setProcessingStatus] = useState('complete');

  const fetchResumeDetails = useCallback(async (isPolling = false, forceRefresh = false) => {
    try {
      if (!isPolling && !forceRefresh) setLoading(true);
      
      console.log(`🔄 Fetching resume details: ${id} (polling: ${isPolling}, force: ${forceRefresh})`);
      
      // 🔥 CRITICAL FIX: Add cache-busting parameter for force refresh
      const url = forceRefresh 
        ? `/resumes/${id}?_t=${Date.now()}` 
        : `/resumes/${id}`;
      
      const response = await axios.get(url);
      const resumeData = response.data.resume || response.data;
      
      console.log('📊 Resume data received:', {
        id: resumeData.id,
        name: resumeData.name,
        hasAnalysis: !!resumeData.analysis,
        overallScore: resumeData.analysis?.overallScore,
        atsCompatibility: resumeData.analysis?.atsCompatibility,
        analysisKeys: resumeData.analysis ? Object.keys(resumeData.analysis) : []
      });
      
      setResume(resumeData);
      
      // Check processing status
      if (resumeData.parsedData?.contactInfo?.name === 'Parsing Error') {
        setProcessingStatus('in-progress');
      } else {
        setProcessingStatus('complete');
      }
      
      setError('');
      
      console.log('✅ Resume data updated in state');
      
    } catch (error) {
      console.error('Error fetching resume details:', error);
      setError('Failed to load resume details. Please try again.');
    } finally {
      if (!isPolling && !forceRefresh) setLoading(false);
    }
  }, [id]);

  // 🔥 NEW: Force refresh function that bypasses cache
  const forceRefreshResume = useCallback(async () => {
    console.log('🔄 Force refreshing resume data...');
    setLoading(true);
    await fetchResumeDetails(false, true);
    setLoading(false);
  }, [fetchResumeDetails]);

  return { 
    resume, 
    loading, 
    error, 
    processingStatus, 
    fetchResumeDetails, 
    forceRefreshResume, // 🔥 NEW: Expose force refresh function
    setResume 
  };
};

================
File: frontend/src/components/resumes/ResumeDetail.js
================
// src/components/resumes/ResumeDetail.js - ENHANCED WITH ANALYSIS REFRESH
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  Tabs,
  Tab,
  CircularProgress,
  Alert,
  Snackbar,
  useTheme,
  ButtonGroup,
  Fade,
  Chip
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  Description as DescriptionIcon,
  Lightbulb as LightbulbIcon,
  Person as PersonIcon,
  CloudDownload as CloudDownloadIcon,
  Refresh as RefreshIcon,
  Visibility as VisibilityIcon
} from '@mui/icons-material';
import MainLayout from '../layout/MainLayout';

// Import custom hooks
import { useResumeData } from './hooks/useResumeData';
import { useAiIntegration } from './hooks/useAiIntegration';

// Import components
import TabPanel from './components/TabPanel';
import ProcessingView from './components/ProcessingView';
import AiEditingToolbar from './components/AiEditingToolbar';
import BeforeAfterComparison from './components/BeforeAfterComparison';

// Import tab content components
import OverviewTab from './tabs/OverviewTab';
import AnalysisTab from './tabs/AnalysisTab';
import ContentTab from './tabs/ContentTab';

/**
 * Main ResumeDetail component - now modular and streamlined with progress tracking and ANALYSIS REFRESH
 * Orchestrates all the individual components and manages state
 */
const ResumeDetail = () => {
  const theme = useTheme();
  const { id } = useParams();
  const navigate = useNavigate();
  const [tabValue, setTabValue] = useState(0);
  const [alert, setAlert] = useState({ open: false, message: '', severity: 'success' });
  const [showComparison, setShowComparison] = useState(false);

  // Custom hooks for data and AI integration
  const { 
    resume, 
    loading, 
    error, 
    processingStatus, 
    fetchResumeDetails, 
    forceRefreshResume // 🔥 NEW: Use force refresh function
  } = useResumeData(id);
  
  const { 
    aiProcessing, 
    aiSuccess, 
    openAiChat, 
    handleQuickAction,
    progressStage,
    progressPercentage,
    comparisonData
  } = useAiIntegration(resume, forceRefreshResume); // 🔥 FIXED: Use force refresh

  // Show comparison dialog when optimization completes
  useEffect(() => {
    if (comparisonData && !aiProcessing) {
      setShowComparison(true);
    }
  }, [comparisonData, aiProcessing]);

  // Polling for processing status
  useEffect(() => {
    if (processingStatus === 'in-progress') {
      const pollInterval = setInterval(() => fetchResumeDetails(true), 10000);
      return () => clearInterval(pollInterval);
    }
  }, [processingStatus, fetchResumeDetails]);

  // Initial load
  useEffect(() => {
    fetchResumeDetails();
  }, [fetchResumeDetails]);

  // 🔥 CRITICAL FIX: Enhanced resume update event listener with analysis refresh
  useEffect(() => {
    const handleResumeUpdate = async (event) => {
      if (event.detail?.resumeId === id) {
        console.log('🔄 ResumeDetail: Resume update event received, force refreshing...');
        
        // Force refresh the resume data to get new analysis scores
        await forceRefreshResume();
        
        // Show success alert with new scores if available
        let message = event.detail.message || '✅ Resume updated successfully!';
        
        if (event.detail.newAnalysis) {
          message += `\n📊 New Scores: Overall ${event.detail.newAnalysis.overallScore}%, ATS ${event.detail.newAnalysis.atsCompatibility}%`;
        }
        
        setAlert({
          open: true,
          message: message,
          severity: 'success'
        });
        
        // Auto-hide alert after longer duration for detailed messages
        setTimeout(() => {
          setAlert({ open: false, message: '', severity: 'success' });
        }, 8000);
      }
    };

    window.addEventListener('resumeUpdated', handleResumeUpdate);
    return () => window.removeEventListener('resumeUpdated', handleResumeUpdate);
  }, [id, forceRefreshResume]);

  const handleDownload = async () => {
    try {
      // Get the latest version or fall back to original
      let downloadUrl;
      
      if (resume.versions && resume.versions.length > 0) {
        // Get the most recent version
        const latestVersion = resume.versions[resume.versions.length - 1];
        downloadUrl = latestVersion.downloadUrl;
        console.log('📥 Downloading latest version:', latestVersion.versionNumber, latestVersion.createdAt);
      } else {
        // Fall back to original file
        downloadUrl = resume.downloadUrl;
        console.log('📥 Downloading original file');
      }
      
      if (downloadUrl) {
        // Open in new tab to trigger download
        window.open(downloadUrl, '_blank');
      } else {
        throw new Error('No download URL available');
      }
      
    } catch (error) {
      console.error('Download error:', error);
      setAlert({
        open: true,
        message: 'Failed to download the resume. Please try again.',
        severity: 'error'
      });
    }
  };

  // 🔥 ENHANCED: Force refresh function for manual refresh button
  const handleManualRefresh = async () => {
    console.log('🔄 Manual refresh triggered');
    setAlert({
      open: true,
      message: 'Refreshing resume data...',
      severity: 'info'
    });
    
    try {
      await forceRefreshResume();
      setAlert({
        open: true,
        message: '✅ Resume data refreshed successfully!',
        severity: 'success'
      });
    } catch (error) {
      setAlert({
        open: true,
        message: '❌ Failed to refresh resume data.',
        severity: 'error'
      });
    }
  };

  // Loading state
  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
          <CircularProgress size={60} thickness={4} />
          <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
            Loading your resume details...
          </Typography>
        </Box>
      </MainLayout>
    );
  }

  // Error state
  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="error">{error}</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/resumes')}
            sx={{ mt: 2 }}
          >
            Back to Resumes
          </Button>
        </Box>
      </MainLayout>
    );
  }

  // Processing state
  if (processingStatus === 'in-progress') {
    return <ProcessingView navigate={navigate} />;
  }

  if (!resume) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="info">Resume not found.</Alert>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate('/resumes')}
            sx={{ mt: 2 }}
          >
            Back to Resumes
          </Button>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1200px', mx: 'auto' }}>
        {/* Navigation */}
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/resumes')}
          variant="outlined"
          sx={{ mb: 3 }}
        >
          Back to Resumes
        </Button>

        {/* AI Success Message */}
        {aiSuccess && (
          <Fade in={!!aiSuccess}>
            <Alert 
              severity="success" 
              sx={{ 
                mb: 3,
                '& .MuiAlert-message': {
                  whiteSpace: 'pre-line' // Allow line breaks in success messages
                }
              }}
              action={
                comparisonData && (
                  <Button 
                    color="inherit" 
                    size="small"
                    startIcon={<VisibilityIcon />}
                    onClick={() => setShowComparison(true)}
                  >
                    View Changes
                  </Button>
                )
              }
            >
              {aiSuccess}
            </Alert>
          </Fade>
        )}

        {/* Header */}
        <Paper 
          elevation={2} 
          sx={{ 
            p: 3, 
            mb: 3, 
            borderRadius: 3,
            backgroundImage: `linear-gradient(135deg, ${theme.palette.background.paper} 0%, ${theme.palette.primary.light}15 100%)` 
          }}
        >
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap' }}>
            <Box sx={{ maxWidth: { xs: '80%', sm: '70%', md: '75%' } }}>
              <Typography 
                variant="h4" 
                component="h1" 
                fontWeight={700} 
                color="primary"
                sx={{ 
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  mb: 0.5
                }}
              >
                {resume.name}
              </Typography>
              <Box sx={{ display: 'flex', alignItems: 'center', mt: 1, flexWrap: 'wrap' }}>
                <Chip 
                  icon={<DescriptionIcon />} 
                  label={resume.fileType} 
                  size="small" 
                  sx={{ mr: 1, mb: 0.5 }} 
                />
                <Typography variant="body2" color="text.secondary">
                  Last updated: {new Date(resume.updatedAt).toLocaleDateString()}
                </Typography>
                {/* 🔥 ENHANCED: Show analysis scores in header */}
                {resume.analysis && (
                  <Box sx={{ ml: 2, display: 'flex', gap: 1 }}>
                    <Chip 
                      label={`Score: ${resume.analysis.overallScore || 0}%`}
                      size="small"
                      color={resume.analysis.overallScore >= 80 ? 'success' : resume.analysis.overallScore >= 60 ? 'warning' : 'error'}
                    />
                    <Chip 
                      label={`ATS: ${resume.analysis.atsCompatibility || 0}%`}
                      size="small"
                      color={resume.analysis.atsCompatibility >= 80 ? 'success' : resume.analysis.atsCompatibility >= 60 ? 'warning' : 'error'}
                    />
                  </Box>
                )}
              </Box>
            </Box>
            
            <ButtonGroup>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={handleManualRefresh} // 🔥 FIXED: Use force refresh
                size="small"
              >
                Refresh
              </Button>
              <Button
                variant="contained"
                startIcon={<CloudDownloadIcon />}
                onClick={handleDownload}
              >
                Download
              </Button>
            </ButtonGroup>
          </Box>
        </Paper>

        {/* AI Editing Toolbar */}
        <AiEditingToolbar
          resume={resume}
          onQuickAction={handleQuickAction}
          onOpenChat={openAiChat}
          aiProcessing={aiProcessing}
          progressStage={progressStage}
          progressPercentage={progressPercentage}
        />

        {/* Main Content Tabs */}
        <Box>
          <Paper sx={{ borderRadius: 3, overflow: 'hidden', mb: 3 }}>
            <Tabs
              value={tabValue}
              onChange={(e, newValue) => setTabValue(newValue)}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ 
                borderBottom: 1, 
                borderColor: 'divider',
                bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.02)',
              }}
            >
              <Tab label="Overview" icon={<DescriptionIcon />} iconPosition="start" />
              <Tab label="Analysis" icon={<LightbulbIcon />} iconPosition="start" />
              <Tab label="Content" icon={<PersonIcon />} iconPosition="start" />
            </Tabs>
          </Paper>

          <TabPanel value={tabValue} index={0}>
            <OverviewTab resume={resume} theme={theme} />
          </TabPanel>

          <TabPanel value={tabValue} index={1}>
            <AnalysisTab resume={resume} theme={theme} />
          </TabPanel>

          <TabPanel value={tabValue} index={2}>
            <ContentTab resume={resume} theme={theme} />
          </TabPanel>
        </Box>

        {/* Alert Snackbar */}
        <Snackbar 
          open={alert.open} 
          autoHideDuration={6000} 
          onClose={() => setAlert({ ...alert, open: false })}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert onClose={() => setAlert({ ...alert, open: false })} severity={alert.severity}>
            {alert.message}
          </Alert>
        </Snackbar>

        {/* Before/After Comparison Dialog */}
        <BeforeAfterComparison
          open={showComparison}
          onClose={() => setShowComparison(false)}
          comparisonData={comparisonData}
        />
      </Box>
    </MainLayout>
  );
};

export default ResumeDetail;

================
File: frontend/src/components/resumes/ResumesPage.js
================
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Grid, 
  Card, 
  CardContent, 
  CardActions, 
  Divider, 
  Chip, 
  CircularProgress, 
  LinearProgress,
  IconButton,
  Menu,
  MenuItem,
  Tooltip
} from '@mui/material';
import { 
  Add as AddIcon, 
  Description as DescriptionIcon,
  Refresh as RefreshIcon,
  ErrorOutline as ErrorOutlineIcon,
  MoreVert as MoreVertIcon,
  TrendingUp as TrendingUpIcon,
  LightbulbOutlined as LightbulbIcon,
  Download as DownloadIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  SmartToy as SmartToyIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import axios from '../../utils/axios';
import MainLayout from '../layout/MainLayout';
import ResumeUploadDialog from './ResumeUploadDialog';

const ResumesPage = () => {
  const navigate = useNavigate();
  const [resumes, setResumes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [openUploadDialog, setOpenUploadDialog] = useState(false);
  const [anchorEl, setAnchorEl] = useState(null);
  const [selectedResumeId, setSelectedResumeId] = useState(null);

  useEffect(() => {
    fetchResumes();
  }, []);

  const fetchResumes = async () => {
    try {
      setLoading(true);
      setError('');
      console.log('Fetching resumes...');
      const response = await axios.get('/resumes');
      console.log('Resume response:', response);
      setResumes(response.data.resumes || []);
    } catch (err) {
      console.error('Error fetching resumes:', err);
      setError(err.response?.data?.message || 'Failed to load resumes. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleOpenUploadDialog = () => {
    setOpenUploadDialog(true);
  };

  const handleCloseUploadDialog = () => {
    setOpenUploadDialog(false);
  };

  const handleResumeUploaded = (resumeId) => {
    fetchResumes();
    handleCloseUploadDialog();
    
    // If a resumeId is provided, navigate to the resume detail page
    if (resumeId) {
      navigate(`/resumes/${resumeId}`);
    }
  };

  const handleMenuOpen = (event, resumeId) => {
    setAnchorEl(event.currentTarget);
    setSelectedResumeId(resumeId);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
    setSelectedResumeId(null);
  };

  const handleDeleteResume = async () => {
    if (!selectedResumeId) return;
    
    try {
      await axios.delete(`/resumes/${selectedResumeId}`);
      setResumes(prevResumes => prevResumes.filter(resume => resume._id !== selectedResumeId));
      handleMenuClose();
    } catch (err) {
      console.error('Error deleting resume:', err);
    }
  };

  const getScoreColor = (score) => {
    if (score >= 80) return 'success.main';
    if (score >= 60) return 'warning.main';
    return 'error.main';
  };

  const renderEmptyState = () => (
    <Box sx={{ mt: 2 }}>
      <Paper 
        elevation={1} 
        sx={{ 
          p: 3, 
          textAlign: 'center', 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center',
          backgroundColor: theme => theme.palette.background.paper,
          border: `1px solid`,
          borderColor: 'divider',
          borderRadius: 3,
          mb: 3
        }}
      >
        <DescriptionIcon sx={{ fontSize: 48, color: 'primary.main', mb: 2, opacity: 0.8 }} />
        <Typography variant="h5" gutterBottom fontWeight={600}>
          Let's Supercharge Your Job Search
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 3, maxWidth: 560, lineHeight: 1.5 }}>
          Upload your resume to unlock AI-powered analysis, optimization, and job matching. 
          Our platform will help you create the perfect resume, match with relevant job opportunities, 
          and significantly increase your chances of landing interviews.
        </Typography>
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<AddIcon />} 
          onClick={handleOpenUploadDialog}
          sx={{ 
            py: 1, 
            px: 3, 
            fontSize: '0.9rem', 
            fontWeight: 500,
            borderRadius: 2
          }}
        >
          Upload Your First Resume
        </Button>
      </Paper>

      <Typography variant="h6" sx={{ mb: 2.5, fontWeight: 600 }}>
        How Our Resume Manager Works
      </Typography>

      <Grid container spacing={2.5} sx={{ mb: 3 }}>
        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #4caf50',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              1. AI Resume Analysis
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <DescriptionIcon sx={{ fontSize: 56, color: '#4caf50', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Our AI scans your resume and provides detailed insights about strengths, weaknesses, 
              and specific improvement suggestions.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #2196f3',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              2. ATS Optimization
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <TrendingUpIcon sx={{ fontSize: 56, color: '#2196f3', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Beat the automated screening systems with compatibility scoring and keyword 
              optimization suggestions.
            </Typography>
          </Paper>
        </Grid>

        <Grid item xs={12} md={4}>
          <Paper elevation={1} sx={{ 
            p: 2.5, 
            borderRadius: 2, 
            borderLeft: '3px solid #ff9800',
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
          }}>
            <Typography variant="subtitle1" gutterBottom fontWeight={600}>
              3. Job-Resume Matching
            </Typography>
            <Box sx={{ 
                height: 100, 
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                my: 1.5
              }}
            >
              <LightbulbIcon sx={{ fontSize: 56, color: '#ff9800', opacity: 0.8 }} />
            </Box>
            <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.4 }}>
              Find the perfect match between your resume and job opportunities with skills gap 
              analysis and tailored recommendations.
            </Typography>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );

  const renderErrorState = () => (
    <Paper 
      elevation={1} 
      sx={{ 
        p: 3, 
        mt: 2,
        borderRadius: 2,
        border: `1px solid`,
        borderColor: 'error.light',
        bgcolor: theme => `${theme.palette.error.main}08`
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
        <ErrorOutlineIcon color="error" sx={{ mr: 1.5, mt: 0.5 }} />
        <Box>
          <Typography variant="subtitle1" color="error" gutterBottom fontWeight={600}>
            Error Loading Resumes
          </Typography>
          <Typography variant="body2" sx={{ mb: 2.5 }}>
            Failed to load resumes. Please try again.
          </Typography>
        </Box>
      </Box>
      <Box sx={{ display: 'flex', gap: 1.5 }}>
        <Button 
          variant="outlined" 
          color="primary" 
          startIcon={<RefreshIcon />} 
          onClick={fetchResumes}
          size="small"
          sx={{ borderRadius: 2 }}
        >
          Try Again
        </Button>
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<AddIcon />} 
          onClick={handleOpenUploadDialog}
          size="small"
          sx={{ borderRadius: 2 }}
        >
          Upload New Resume
        </Button>
      </Box>
    </Paper>
  );

  const renderResumeGrid = () => (
    <Grid container spacing={3} sx={{ mt: 1 }}>
      {resumes.map((resume) => (
        <Grid item xs={12} sm={6} md={4} key={resume._id}>
          <Card sx={{ 
            height: '100%', 
            display: 'flex', 
            flexDirection: 'column',
            position: 'relative',
            transition: 'transform 0.2s, box-shadow 0.2s',
            '&:hover': {
              transform: 'translateY(-4px)',
              boxShadow: '0 8px 24px rgba(0,0,0,0.12)'
            }
          }}>
            <CardContent sx={{ flexGrow: 1, pt: 3 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                {resume.isTailored && (
                  <SmartToyIcon color="secondary" sx={{ mr: 1 }} />
                )}
                <Typography variant="h6" gutterBottom noWrap fontWeight={500}>
                  {resume.name}
                </Typography>
              </Box>
              <Typography variant="body2" color="text.secondary" gutterBottom>
                Updated {new Date(resume.updatedAt || resume.createdAt).toLocaleDateString()}
              </Typography>
              {resume.isTailored && resume.tailoredForJob && (
                <Typography variant="body2" color="secondary.main" sx={{ fontStyle: 'italic', mb: 1 }}>
                  Tailored for {resume.tailoredForJob.jobTitle} at {resume.tailoredForJob.company}
                </Typography>
              )}
              <Divider sx={{ my: 2 }} />
              
              {resume.analysis && resume.analysis.overallScore && (
                <Box sx={{ mt: 2, mb: 3 }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                    <Typography variant="subtitle2" fontWeight={500}>
                      Resume Score
                    </Typography>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Typography variant="h6" fontWeight={600} color={getScoreColor(resume.analysis.overallScore)}>
                        {resume.analysis.overallScore}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ ml: 0.5 }}>
                        /100
                      </Typography>
                    </Box>
                  </Box>
                  <LinearProgress 
                    variant="determinate" 
                    value={resume.analysis.overallScore} 
                    sx={{ 
                      height: 8, 
                      borderRadius: 2,
                      backgroundColor: 'rgba(0,0,0,0.05)',
                      '& .MuiLinearProgress-bar': {
                        backgroundColor: getScoreColor(resume.analysis.overallScore)
                      }
                    }}
                  />
                </Box>
              )}
              
              {resume.analysis && resume.analysis.atsCompatibility && (
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                  <Typography variant="body2" color="text.secondary">
                    ATS Compatibility
                  </Typography>
                  <Typography variant="body2" fontWeight={500}>
                    {resume.analysis.atsCompatibility}%
                  </Typography>
                </Box>
              )}
              
              {resume.matchAnalysis && resume.matchAnalysis.overallScore && (
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <TrendingUpIcon fontSize="small" color="success" sx={{ mr: 0.5 }} />
                    <Typography variant="body2" color="text.secondary">
                      Match Rate
                    </Typography>
                  </Box>
                  <Typography variant="body2" fontWeight={500}>
                    {resume.matchAnalysis.overallScore}%
                  </Typography>
                </Box>
              )}
              
              <Box sx={{ mt: 2, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                <Chip 
                  label={resume.fileType ? resume.fileType.toUpperCase() : 'PDF'} 
                  size="small" 
                  variant="outlined" 
                />
                {resume.versions && resume.versions.length > 0 && (
                  <Chip 
                    label={`${resume.versions.length + 1} Versions`} 
                    size="small" 
                    variant="outlined" 
                  />
                )}
                {resume.isTailored && (
                  <Chip 
                    icon={<SmartToyIcon />}
                    label="AI Tailored" 
                    size="small" 
                    variant="outlined"
                    color="secondary"
                  />
                )}
              </Box>
              
              {resume.analysis && resume.analysis.improvementAreas && resume.analysis.improvementAreas.length > 0 && (
                <Box sx={{ mt: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, mb: 1 }}>
                    <LightbulbIcon fontSize="small" sx={{ color: 'warning.main' }} />
                    <Typography variant="body2" fontWeight={500}>
                      Improvement Areas
                    </Typography>
                  </Box>
                  {resume.analysis.improvementAreas.slice(0, 2).map((area, index) => (
                    <Typography key={index} variant="body2" color="text.secondary" sx={{ 
                      display: 'flex', 
                      alignItems: 'center',
                      fontSize: '0.75rem',
                      '&:before': {
                        content: '""',
                        display: 'inline-block',
                        width: '4px',
                        height: '4px',
                        borderRadius: '50%',
                        backgroundColor: 'text.secondary',
                        mr: 1
                      }
                    }}>
                      {area.section}: {area.suggestions[0]}
                    </Typography>
                  ))}
                </Box>
              )}
            </CardContent>
            <CardActions sx={{ justifyContent: 'space-between', p: 2 }}>
              <Button 
                size="small" 
                color="primary" 
                onClick={() => navigate(`/resumes/${resume._id}`)}
                variant="contained"
              >
                View Details
              </Button>
              <Box>
                <Tooltip title="Download">
                  <IconButton 
                    size="small" 
                    onClick={() => window.open(resume.downloadUrl || resume.fileUrl, '_blank')}
                    sx={{ mr: 1 }}
                  >
                    <DownloadIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
                <IconButton 
                  size="small"
                  aria-controls={`resume-menu-${resume._id}`}
                  aria-haspopup="true"
                  onClick={(e) => handleMenuOpen(e, resume._id)}
                >
                  <MoreVertIcon fontSize="small" />
                </IconButton>
              </Box>
            </CardActions>
          </Card>
        </Grid>
      ))}
      <Grid item xs={12} sm={6} md={4}>
        <Card 
          sx={{ 
            height: '100%', 
            minHeight: 200,
            display: 'flex', 
            flexDirection: 'column', 
            justifyContent: 'center', 
            alignItems: 'center',
            p: 3,
            backgroundColor: 'rgba(0, 0, 0, 0.02)',
            border: '2px dashed',
            borderColor: 'divider',
            cursor: 'pointer',
            transition: 'all 0.2s ease-in-out',
            '&:hover': {
              borderColor: 'primary.main',
              backgroundColor: 'rgba(63, 81, 181, 0.04)'
            }
          }}
          onClick={handleOpenUploadDialog}
        >
          <AddIcon sx={{ fontSize: 40, color: 'primary.main', mb: 2 }} />
          <Typography variant="h6" align="center" fontWeight={500}>
            Upload New Resume
          </Typography>
          <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 1 }}>
            Add another resume to your collection
          </Typography>
        </Card>
      </Grid>
    </Grid>
  );

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h4" component="h1" fontWeight={500}>
            Resume Manager
          </Typography>
          {!loading && !error && resumes.length > 0 && (
            <Button 
              variant="contained" 
              color="primary" 
              startIcon={<AddIcon />} 
              onClick={handleOpenUploadDialog}
              sx={{ textTransform: 'none' }}
            >
              Upload New Resume
            </Button>
          )}
        </Box>

        {loading ? (
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '300px' }}>
            <CircularProgress size={60} thickness={4} color="primary" />
            <Typography variant="h6" sx={{ mt: 3, color: 'text.secondary' }}>
              Loading your resumes...
            </Typography>
          </Box>
        ) : error ? (
          renderErrorState()
        ) : resumes.length === 0 ? (
          renderEmptyState()
        ) : (
          renderResumeGrid()
        )}
      </Box>

      <ResumeUploadDialog 
        open={openUploadDialog}
        onClose={handleCloseUploadDialog}
        onResumeUploaded={handleResumeUploaded}
      />
      
      <Menu
        id="resume-menu"
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >

        <MenuItem onClick={handleDeleteResume} sx={{ color: 'error.main' }}>
          <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
          Delete Resume
        </MenuItem>
      </Menu>
    </MainLayout>
  );
};

export default ResumesPage;

================
File: frontend/src/components/resumes/ResumeUploadDialog.js
================
import React, { useState, useEffect } from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Button, 
  TextField, 
  Box, 
  Typography,
  Alert,
  Stepper,
  Step,
  StepLabel,
  IconButton,
  LinearProgress,
  StepContent
} from '@mui/material';
import { 
  CloudUpload as CloudUploadIcon,
  Close as CloseIcon,
  PictureAsPdf as PdfIcon,
  Description as DescriptionIcon,
  CheckCircle as CheckCircleIcon,
  Info as InfoIcon,
  Psychology as PsychologyIcon,
  DataObject as DataObjectIcon,
  Memory as MemoryIcon,
  Error as ErrorIcon
} from '@mui/icons-material';
import resumeService from '../../utils/resumeService';

const ResumeUploadDialog = ({ open, onClose, onResumeUploaded }) => {
  const [activeStep, setActiveStep] = useState(0);
  const [file, setFile] = useState(null);
  const [name, setName] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [dragActive, setDragActive] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [processingStage, setProcessingStage] = useState('uploading'); // 'uploading', 'parsing', 'analyzing', 'completed', 'error'
  const [uploadComplete, setUploadComplete] = useState(false);
  const [resumeId, setResumeId] = useState(null);
  const [processingTimeout, setProcessingTimeout] = useState(false);
  const [canClose, setCanClose] = useState(true);

  // Clear any intervals when the component unmounts
  useEffect(() => {
    return () => {
      // Cleanup function
    };
  }, []);

  const steps = [
    { label: 'Select Resume', icon: <DescriptionIcon /> },
    { label: 'Add Details', icon: <DataObjectIcon /> },
    { label: 'Processing', icon: <MemoryIcon /> }
  ];

  const processingSteps = [
    { label: 'Uploading', value: 10, icon: <CloudUploadIcon color="primary" /> },
    { label: 'Parsing', value: 30, icon: <DataObjectIcon color="info" /> },
    { label: 'AI Analyzing', value: 75, icon: <PsychologyIcon color="secondary" /> },
    { label: 'Complete', value: 100, icon: <CheckCircleIcon color="success" /> }
  ];

  const getProcessingStepIndex = () => {
    switch (processingStage) {
      case 'uploading': return 0;
      case 'parsing': return 1;
      case 'analyzing': return 2;
      case 'completed': return 3;
      default: return 0;
    }
  };

  const resetForm = () => {
    setFile(null);
    setName('');
    setError('');
    setActiveStep(0);
    setUploadProgress(0);
    setProcessingStage('uploading');
    setUploadComplete(false);
    setResumeId(null);
    setProcessingTimeout(false);
    setCanClose(true);
  };

  const handleClose = () => {
    if (canClose) {
      resetForm();
      onClose();
    }
  };

  const handleFileDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const droppedFile = e.dataTransfer.files[0];
      validateAndSetFile(droppedFile);
    }
  };

  const handleFileChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      const selectedFile = e.target.files[0];
      validateAndSetFile(selectedFile);
    }
  };

  const validateAndSetFile = (file) => {
    const validTypes = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
    const maxSize = 10 * 1024 * 1024; // 10MB
    
    setError('');
    
    if (!validTypes.includes(file.type)) {
      setError('Please upload a PDF or DOCX file');
      return;
    }
    
    if (file.size > maxSize) {
      setError('File size must be less than 10MB');
      return;
    }
    
    setFile(file);
    if (!name) {
      // Set the name field to file name without extension
      const fileName = file.name.replace(/\.[^/.]+$/, "");
      setName(fileName);
    }
    
    setActiveStep(1);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(true);
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
  };

  const handleProgressUpdate = (status) => {
    if (!status) return;
    
    console.log('Status update:', status); // Log the status for debugging
    
    // Update processing stage based on status
    const stage = status.stage || status.status || 'uploading';
    setProcessingStage(stage);
    
    // Update progress percentage
    if (status.percentage) {
      setUploadProgress(status.percentage);
    } else {
      // If no percentage is provided, use default values based on stage
      switch (stage) {
        case 'uploading':
          setUploadProgress(10);
          break;
        case 'parsing':
          setUploadProgress(30);
          break;
        case 'analyzing':
          setUploadProgress(75);
          break;
        case 'completed':
          setUploadProgress(100);
          setUploadComplete(true);
          setCanClose(true);
          break;
        case 'error':
          setError(status.error || status.message || 'An error occurred during processing');
          setCanClose(true);
          break;
        default:
          break;
      }
    }
  };

  const handleSubmit = async () => {
    if (!file) {
      setError('Please select a file to upload');
      return;
    }
    
    if (!name.trim()) {
      setError('Please enter a name for your resume');
      return;
    }

    try {
      setLoading(true);
      setActiveStep(2);
      setProcessingStage('uploading');
      setUploadProgress(10);
      setCanClose(false); // Prevent closing during upload
      setError('');
      
      const formData = new FormData();
      formData.append('file', file);
      formData.append('name', name);
      
      // Upload the resume
      const response = await resumeService.uploadResume(formData);
      
      console.log('Upload response:', response); // Log the response structure
      
      // Extract resume ID from the response (handle different response structures)
      let resumeId = null;
      
      if (response && response.resume && response.resume._id) {
        // Standard structure
        resumeId = response.resume._id;
      } else if (response && response._id) {
        // Alternative structure where resume is the root object
        resumeId = response._id;
      } else if (response && response.id) {
        // Alternative structure with 'id' instead of '_id'
        resumeId = response.id;
      } else if (response && response.resume && response.resume.id) {
        // Alternative structure with 'id' instead of '_id'
        resumeId = response.resume.id;
      } else if (response && response.data && response.data.resume && response.data.resume._id) {
        // Structure with data wrapper
        resumeId = response.data.resume._id;
      } else if (response && response.data && response.data._id) {
        // Structure with data wrapper
        resumeId = response.data._id;
      }
      
      if (resumeId) {
        setResumeId(resumeId);
        
        try {
          // Start polling for status updates
          await resumeService.pollResumeStatus(resumeId, handleProgressUpdate, 300000);
        } catch (pollError) {
          console.error('Error polling resume status:', pollError);
          
          if (pollError.message && pollError.message.includes('timed out')) {
            setProcessingTimeout(true);
            setError('Processing is taking longer than expected. You can close this dialog and check back later.');
          } else {
            setError(pollError.message || 'An error occurred while processing your resume');
          }
          
          setCanClose(true);
        }
      } else {
        console.error('Could not extract resume ID from response:', response);
        throw new Error('Invalid response from server - could not find resume ID');
      }
    } catch (err) {
      console.error('Error uploading resume:', err);
      setError(err.response?.data?.message || 'Failed to upload resume. Please try again.');
      setCanClose(true);
    } finally {
      setLoading(false);
    }
  };

  const getFileIcon = () => {
    if (!file) return null;
    
    return file.type === 'application/pdf' 
      ? <PdfIcon color="error" fontSize="large" />
      : <DescriptionIcon color="primary" fontSize="large" />;
  };

  const getProcessingStageIcon = () => {
    switch (processingStage) {
      case 'uploading':
        return <CloudUploadIcon sx={{ fontSize: 64, color: 'primary.main' }} />;
      case 'parsing':
        return <DataObjectIcon sx={{ fontSize: 64, color: 'info.main' }} />;
      case 'analyzing':
        return <PsychologyIcon sx={{ fontSize: 64, color: 'secondary.main' }} />;
      case 'completed':
        return <CheckCircleIcon sx={{ fontSize: 64, color: 'success.main' }} />;
      case 'error':
        return <ErrorIcon sx={{ fontSize: 64, color: 'error.main' }} />;
      default:
        return <MemoryIcon sx={{ fontSize: 64, color: 'primary.main' }} />;
    }
  };

  const getProcessingStageText = () => {
    switch (processingStage) {
      case 'uploading':
        return {
          title: 'Uploading your resume...',
          description: 'Your file is being securely uploaded to our servers.'
        };
      case 'parsing':
        return {
          title: 'Parsing your resume...',
          description: 'Our AI is extracting information from your resume, identifying your experience, skills, and qualifications.'
        };
      case 'analyzing':
        return {
          title: 'Analyzing your resume...',
          description: 'We\'re now analyzing your resume to provide personalized recommendations, identify strengths and weaknesses, and prepare improvement suggestions.'
        };
      case 'completed':
        return {
          title: 'Processing complete!',
          description: 'Your resume has been successfully processed and analyzed.'
        };
      case 'error':
        return {
          title: 'Processing error',
          description: 'There was an error processing your resume. Please try again.'
        };
      default:
        return {
          title: 'Processing your resume...',
          description: 'This may take a moment.'
        };
    }
  };

  const renderStepContent = () => {
    switch (activeStep) {
      case 0:
        return (
          <Box 
            sx={{ 
              mt: 2, 
              border: '2px dashed',
              borderColor: dragActive ? 'primary.main' : 'divider',
              borderRadius: 2,
              p: 4,
              textAlign: 'center',
              cursor: 'pointer',
              backgroundColor: dragActive ? 'action.hover' : 'background.paper',
              transition: 'all 0.2s ease'
            }}
            onDrop={handleFileDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onClick={() => document.getElementById('resume-file-upload').click()}
          >
            <input
              id="resume-file-upload"
              type="file"
              accept=".pdf,.docx"
              onChange={handleFileChange}
              style={{ display: 'none' }}
            />
            
            <CloudUploadIcon sx={{ fontSize: 64, color: 'primary.main', mb: 2 }} />
            
            <Typography variant="h6" gutterBottom fontWeight={500}>
              Drag & drop your resume here
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              or click to browse your files
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Supported formats: PDF, DOCX (Max size: 10MB)
            </Typography>
          </Box>
        );
      case 1:
        return (
          <Box sx={{ mt: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
              {getFileIcon()}
              <Box sx={{ ml: 2, flexGrow: 1 }}>
                <Typography variant="body1" fontWeight="medium">
                  {file?.name}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {(file?.size / 1024 / 1024).toFixed(2)} MB
                </Typography>
              </Box>
            </Box>
            
            <TextField
              label="Resume Name"
              fullWidth
              value={name}
              onChange={(e) => setName(e.target.value)}
              margin="normal"
              required
              placeholder="e.g., Software Developer Resume"
              helperText="Give your resume a descriptive name to easily identify it later"
            />
            
            <Box sx={{ display: 'flex', alignItems: 'center', mt: 3, p: 2, bgcolor: 'info.light', borderRadius: 2 }}>
              <InfoIcon color="info" sx={{ mr: 1.5, alignSelf: 'flex-start' }} />
              <Typography variant="body2">
                Your resume will be analyzed with AI to provide personalized insights, skills assessment, and improvement suggestions. This process may take a few minutes to complete.
              </Typography>
            </Box>
          </Box>
        );
      case 2:
        const stageText = getProcessingStageText();
        const processingStepIndex = getProcessingStepIndex();
        
        return (
          <Box sx={{ mt: 2 }}>
            {/* Processing steps stepper */}
            <Stepper activeStep={processingStepIndex} orientation="vertical" sx={{ mb: 3 }}>
              {processingSteps.map((step, index) => (
                <Step key={step.label} completed={index < processingStepIndex}>
                  <StepLabel 
                    StepIconComponent={() => step.icon}
                    sx={{ 
                      '& .MuiStepLabel-label': { 
                        fontWeight: index === processingStepIndex ? 600 : 400 
                      }
                    }}
                  >
                    {step.label}
                  </StepLabel>
                  <StepContent>
                    <Typography variant="body2" color="text.secondary">
                      {index === 0 && 'Uploading your file to our secure servers'}
                      {index === 1 && 'Extracting information from your resume'}
                      {index === 2 && 'Our AI is analyzing your resume for insights and recommendations'}
                      {index === 3 && 'All done! Your resume has been processed successfully'}
                    </Typography>
                  </StepContent>
                </Step>
              ))}
            </Stepper>
            
            {/* Progress visualization */}
            <Box sx={{ textAlign: 'center', px: 2, mb: 3 }}>
              {getProcessingStageIcon()}
              <Typography variant="h6" gutterBottom sx={{ mt: 2 }}>
                {stageText.title}
              </Typography>
              <Typography variant="body2" color="text.secondary" gutterBottom sx={{ mb: 3, mx: 'auto', maxWidth: 400 }}>
                {stageText.description}
              </Typography>
              <LinearProgress 
                variant="determinate" 
                value={uploadProgress} 
                sx={{ height: 8, borderRadius: 4, mb: 1 }} 
              />
              <Typography variant="body2" color="text.secondary">
                {Math.round(uploadProgress)}% Complete
              </Typography>
            </Box>
            
            {/* Warning message */}
            {!uploadComplete && !processingTimeout && (
              <Alert severity="warning" sx={{ mt: 2 }}>
                <Typography variant="body2" fontWeight={500}>
                  Please don't close this window
                </Typography>
                <Typography variant="body2">
                  Closing this dialog before processing is complete may result in incomplete analysis.
                </Typography>
              </Alert>
            )}
            
            {/* Timeout message */}
            {processingTimeout && (
              <Alert severity="info" sx={{ mt: 2 }}>
                <Typography variant="body2" fontWeight={500}>
                  Processing is taking longer than expected
                </Typography>
                <Typography variant="body2">
                  You can close this dialog and check back later. Your resume will continue processing in the background.
                </Typography>
              </Alert>
            )}
            
            {/* Success message */}
            {uploadComplete && (
              <Alert severity="success" sx={{ mt: 2 }}>
                <Typography variant="body2" fontWeight={500}>
                  Resume processing complete!
                </Typography>
                <Typography variant="body2">
                  Your resume has been successfully processed and analyzed. You can now view your analysis and improvement suggestions.
                </Typography>
              </Alert>
            )}
          </Box>
        );
      default:
        return null;
    }
  };

  return (
    <Dialog 
      open={open} 
      onClose={canClose ? handleClose : undefined} 
      maxWidth="sm" 
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2
        }
      }}
    >
      <DialogTitle>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Typography variant="h6" fontWeight={600}>Upload Resume</Typography>
          {canClose && (
            <IconButton onClick={handleClose} size="small">
              <CloseIcon />
            </IconButton>
          )}
        </Box>
      </DialogTitle>
      
      <DialogContent>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        
        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
          {steps.map((step) => (
            <Step key={step.label}>
              <StepLabel StepIconComponent={() => step.icon}>{step.label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {renderStepContent()}
      </DialogContent>
      
      <DialogActions sx={{ px: 3, pb: 3 }}>
        {activeStep === 0 && (
          <Button onClick={handleClose} disabled={!canClose}>
            Cancel
          </Button>
        )}
        
        {activeStep === 1 && (
          <>
            <Button onClick={() => setActiveStep(0)} disabled={loading}>
              Back
            </Button>
            <Button 
              onClick={handleSubmit} 
              variant="contained" 
              color="primary"
              disabled={!file || !name.trim() || loading}
            >
              Upload
            </Button>
          </>
        )}
        
        {activeStep === 2 && (
          <>
            {(processingTimeout || uploadComplete || processingStage === 'error') && (
              <Button 
                onClick={() => {
                  handleClose();
                  if (uploadComplete) {
                    onResumeUploaded(resumeId);
                  }
                }} 
                variant="contained" 
                color="primary"
              >
                {uploadComplete ? 'View Resume' : 'Close'}
              </Button>
            )}
            
            {!uploadComplete && !processingTimeout && processingStage !== 'error' && (
              <Button 
                disabled={!canClose}
                variant="outlined"
                color="primary"
              >
                Processing...
              </Button>
            )}
          </>
        )}
      </DialogActions>
    </Dialog>
  );
};

export default ResumeUploadDialog;

================
File: frontend/src/components/resumes/ResumeWithAssistant.js
================
// src/components/resumes/ResumeWithAssistant.js
import React, { useState, useEffect } from 'react';
import {
  Box,
  Grid,
  Paper,
  Typography,
  Button,
  Fab,
  Tooltip,
  Chip,
  Alert,
  Zoom,
  useTheme,
  alpha
} from '@mui/material';
import {
  SmartToy as RobotIcon,
  AutoFixHigh as SuggestionIcon,
  Visibility as PreviewIcon,
  Edit as EditIcon,
  Chat as ChatIcon
} from '@mui/icons-material';
import { useParams } from 'react-router-dom';
import AiAssistantWidget from '../assistant/AiAssistantWidget';
import resumeService from '../../utils/resumeService';
import assistantService from '../../utils/assistantService';
import MainLayout from '../layout/MainLayout';

const ResumeWithAssistant = () => {
  const theme = useTheme();
  const { id: resumeId } = useParams();
  const [resume, setResume] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [assistantActive, setAssistantActive] = useState(false);
  const [pendingSuggestions, setPendingSuggestions] = useState([]);
  const [showAssistant, setShowAssistant] = useState(false);

  useEffect(() => {
    if (resumeId) {
      fetchResume();
    }
  }, [resumeId]);

  const fetchResume = async () => {
    try {
      setLoading(true);
      const resumeData = await resumeService.getResumeById(resumeId);
      setResume(resumeData);
    } catch (err) {
      console.error('Error fetching resume:', err);
      setError('Failed to load resume');
    } finally {
      setLoading(false);
    }
  };

  const handleResumeUpdate = async (changes) => {
    try {
      // Apply changes to resume
      const updatedResume = await assistantService.applyResumeChanges(resumeId, changes);
      setResume(updatedResume.resume);
      
      // Show success feedback
      setPendingSuggestions(prev => prev.filter(s => s.id !== changes.id));
      
    } catch (error) {
      console.error('Error applying resume changes:', error);
    }
  };

  const handleAssistantToggle = () => {
    setShowAssistant(!showAssistant);
  };

  const ResumePreview = () => (
    <Paper 
      elevation={2} 
      sx={{ 
        p: 3, 
        height: 'fit-content',
        borderRadius: 2,
        border: `1px solid ${alpha(theme.palette.primary.main, 0.1)}`
      }}
    >
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h5" fontWeight={600}>
          {resume?.name || 'Resume Preview'}
        </Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Tooltip title="Edit Resume">
            <Button
              variant="outlined"
              size="small"
              startIcon={<EditIcon />}
              onClick={() => {/* Navigate to edit */}}
            >
              Edit
            </Button>
          </Tooltip>
          <Tooltip title="Preview Resume">
            <Button
              variant="outlined"
              size="small"
              startIcon={<PreviewIcon />}
              onClick={() => {/* Open preview */}}
            >
              Preview
            </Button>
          </Tooltip>
        </Box>
      </Box>

      {/* Resume Sections */}
      {resume?.parsedData && (
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
          {/* Contact Info */}
          {resume.parsedData.contactInfo && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 1, color: theme.palette.primary.main }}>
                Contact Information
              </Typography>
              <Typography variant="body1" fontWeight={500}>
                {resume.parsedData.contactInfo.name}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {resume.parsedData.contactInfo.email} | {resume.parsedData.contactInfo.phone}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {resume.parsedData.contactInfo.location}
              </Typography>
            </Box>
          )}

          {/* Summary */}
          {resume.parsedData.summary && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 1, color: theme.palette.primary.main }}>
                Professional Summary
              </Typography>
              <Typography variant="body2" sx={{ lineHeight: 1.6 }}>
                {resume.parsedData.summary}
              </Typography>
            </Box>
          )}

          {/* Experience */}
          {resume.parsedData.experience?.length > 0 && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 2, color: theme.palette.primary.main }}>
                Experience
              </Typography>
              {resume.parsedData.experience.slice(0, 3).map((exp, index) => (
                <Box key={index} sx={{ mb: 2, pb: 2, borderBottom: index < 2 ? `1px solid ${theme.palette.divider}` : 'none' }}>
                  <Typography variant="subtitle1" fontWeight={500}>
                    {exp.title} at {exp.company}
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                    {exp.startDate} - {exp.endDate || 'Present'} | {exp.location}
                  </Typography>
                  <Typography variant="body2" sx={{ mb: 1 }}>
                    {exp.description}
                  </Typography>
                  {exp.highlights?.length > 0 && (
                    <Box component="ul" sx={{ mt: 1, pl: 2 }}>
                      {exp.highlights.slice(0, 3).map((highlight, i) => (
                        <Typography component="li" variant="body2" key={i} sx={{ mb: 0.5 }}>
                          {highlight}
                        </Typography>
                      ))}
                    </Box>
                  )}
                </Box>
              ))}
            </Box>
          )}

          {/* Skills */}
          {resume.parsedData.skills?.length > 0 && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 2, color: theme.palette.primary.main }}>
                Skills
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {resume.parsedData.skills.slice(0, 12).map((skill, index) => (
                  <Chip
                    key={index}
                    label={typeof skill === 'string' ? skill : skill.name}
                    size="small"
                    variant="outlined"
                    sx={{ borderColor: alpha(theme.palette.primary.main, 0.3) }}
                  />
                ))}
                {resume.parsedData.skills.length > 12 && (
                  <Chip
                    label={`+${resume.parsedData.skills.length - 12} more`}
                    size="small"
                    color="primary"
                    variant="outlined"
                  />
                )}
              </Box>
            </Box>
          )}

          {/* Education */}
          {resume.parsedData.education?.length > 0 && (
            <Box>
              <Typography variant="h6" fontWeight={500} sx={{ mb: 2, color: theme.palette.primary.main }}>
                Education
              </Typography>
              {resume.parsedData.education.map((edu, index) => (
                <Box key={index} sx={{ mb: 1 }}>
                  <Typography variant="subtitle1" fontWeight={500}>
                    {edu.degree} in {edu.field}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {edu.institution} | {edu.endDate}
                  </Typography>
                </Box>
              ))}
            </Box>
          )}
        </Box>
      )}
    </Paper>
  );

  const AssistantPanel = () => (
    <Box sx={{ position: 'sticky', top: 24 }}>
      {/* AI Suggestions Banner */}
      {pendingSuggestions.length > 0 && (
        <Alert 
          severity="info" 
          icon={<SuggestionIcon />}
          sx={{ 
            mb: 2,
            border: `1px solid ${alpha(theme.palette.info.main, 0.3)}`,
            borderRadius: 2
          }}
          action={
            <Button 
              size="small" 
              onClick={handleAssistantToggle}
              sx={{ color: theme.palette.info.main }}
            >
              Review
            </Button>
          }
        >
          AJ has {pendingSuggestions.length} suggestion{pendingSuggestions.length > 1 ? 's' : ''} for your resume
        </Alert>
      )}

      {/* Assistant Status */}
      <Paper 
        elevation={1} 
        sx={{ 
          p: 2, 
          borderRadius: 2,
          background: `linear-gradient(45deg, ${alpha(theme.palette.secondary.main, 0.05)} 30%, ${alpha(theme.palette.secondary.light, 0.05)} 90%)`,
          border: `1px solid ${alpha(theme.palette.secondary.main, 0.2)}`
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <RobotIcon sx={{ color: theme.palette.secondary.main, mr: 1 }} />
          <Typography variant="h6" fontWeight={500}>
            AJ Assistant
          </Typography>
          {assistantActive && (
            <Chip 
              label="Active" 
              size="small" 
              color="success" 
              sx={{ ml: 'auto' }}
            />
          )}
        </Box>
        
        <Typography variant="body2" color="text.secondary" paragraph>
          Your AI career assistant is ready to help optimize your resume and provide career guidance.
        </Typography>

        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button
            variant="contained"
            color="secondary"
            startIcon={<ChatIcon />}
            onClick={handleAssistantToggle}
            size="small"
            fullWidth
          >
            Chat with AJ
          </Button>
        </Box>

        <Box sx={{ mt: 2, pt: 2, borderTop: `1px solid ${theme.palette.divider}` }}>
          <Typography variant="caption" color="text.secondary">
            Quick Actions:
          </Typography>
          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 1 }}>
            <Chip 
              label="Analyze Resume" 
              size="small" 
              variant="outlined" 
              clickable
              onClick={() => {/* Handle quick action */}}
            />
            <Chip 
              label="Improve Summary" 
              size="small" 
              variant="outlined" 
              clickable
            />
            <Chip 
              label="Enhance Skills" 
              size="small" 
              variant="outlined" 
              clickable
            />
          </Box>
        </Box>
      </Paper>
    </Box>
  );

  if (loading) {
    return (
      <MainLayout>
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '60vh' }}>
          <Typography>Loading resume...</Typography>
        </Box>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <Box sx={{ p: 3 }}>
          <Alert severity="error">{error}</Alert>
        </Box>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <Box sx={{ p: 3, maxWidth: '1400px', mx: 'auto' }}>
        <Grid container spacing={3}>
          {/* Main Resume Content */}
          <Grid item xs={12} md={8}>
            <ResumePreview />
          </Grid>

          {/* AI Assistant Panel */}
          <Grid item xs={12} md={4}>
            <AssistantPanel />
          </Grid>
        </Grid>

        {/* AI Assistant Widget */}
        {showAssistant && (
          <Zoom in={showAssistant}>
            <Box>
              <AiAssistantWidget
                resumeId={resumeId}
                resumeData={resume?.parsedData}
                onResumeUpdate={handleResumeUpdate}
                position={{ bottom: 100, right: 24 }}
              />
            </Box>
          </Zoom>
        )}

        {/* Floating Assistant Button (when not shown in panel) */}
        {!showAssistant && (
          <Zoom in={!showAssistant}>
            <Fab
              color="secondary"
              onClick={handleAssistantToggle}
              sx={{
                position: 'fixed',
                bottom: 24,
                right: 24,
                zIndex: 1000,
                background: `linear-gradient(45deg, ${theme.palette.secondary.main} 30%, ${theme.palette.secondary.light} 90%)`,
                boxShadow: '0 8px 24px rgba(0, 196, 180, 0.3)',
                '&:hover': {
// Continuation of ResumeWithAssistant.js

                  background: `linear-gradient(45deg, ${theme.palette.secondary.dark} 30%, ${theme.palette.secondary.main} 90%)`,
                  transform: 'scale(1.05)',
                },
                transition: 'all 0.2s ease-in-out'
              }}
            >
              <RobotIcon sx={{ fontSize: 28 }} />
            </Fab>
          </Zoom>
        )}
      </Box>
    </MainLayout>
  );
};

export default ResumeWithAssistant;

================
File: frontend/src/components/resumes/tabs/AnalysisTab.js
================
// src/components/resumes/tabs/AnalysisTab.js
import React from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Divider
} from '@mui/material';
import {
  ArrowUpward as ArrowUpwardIcon,
  Lightbulb as LightbulbIcon,
  Timeline as TimelineIcon,
  CheckCircle as CheckCircleIcon,
  ExpandMore as ExpandMoreIcon
} from '@mui/icons-material';
import { renderImprovedSnippet } from '../utils/resumeHelpers';

/**
 * Analysis tab component showing detailed improvement areas and recommendations
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {object} props.theme - MUI theme object
 * @returns {JSX.Element} Analysis tab content
 */
const AnalysisTab = ({ resume, theme }) => {
  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  return (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Card elevation={2} sx={{ borderRadius: 3, mb: 3 }}>
          <CardHeader 
            title="Detailed Improvement Areas" 
            avatar={<ArrowUpwardIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent sx={{ pb: 1 }}>
            {(resume.analysis?.improvementAreas || []).map((area, index) => (
              <Accordion 
                key={index} 
                defaultExpanded={index === 0}
                sx={{ 
                  mb: 2, 
                  borderRadius: '8px !important', 
                  overflow: 'hidden',
                  '&:before': { display: 'none' },
                  boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
                }}
              >
                <AccordionSummary
                  expandIcon={<ExpandMoreIcon />}
                  sx={{ 
                    bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.02)' 
                  }}
                >
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <Box sx={{ 
                      width: 32, 
                      height: 32, 
                      borderRadius: '50%', 
                      bgcolor: theme.palette.primary.main,
                      color: 'white',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      mr: 2,
                      flexShrink: 0
                    }}>
                      {index + 1}
                    </Box>
                    <Typography variant="subtitle1" fontWeight="bold" sx={{ textTransform: 'capitalize' }}>
                      {area.section}
                    </Typography>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {(area.suggestions || []).map((suggestion, idx) => (
                      <ListItem key={idx} sx={{ px: 0 }}>
                        <ListItemIcon>
                          <LightbulbIcon fontSize="small" color="warning" />
                        </ListItemIcon>
                        <ListItemText primary={suggestion} />
                      </ListItem>
                    ))}
                  </List>
                  
                  {area.improvedSnippets && area.improvedSnippets.length > 0 ? (
                    <Box sx={{ mt: 2 }}>
                      <Typography variant="subtitle2" gutterBottom sx={{ 
                        color: theme.palette.primary.main,
                        fontWeight: 600,
                        display: 'flex',
                        alignItems: 'center'
                      }}>
                        AI-Enhanced Examples
                      </Typography>
                      {area.improvedSnippets.map((snippet) => (
                        renderImprovedSnippet(snippet, theme)
                      ))}
                    </Box>
                  ) : (
                    <Box sx={{ mt: 2 }}>
                      <Typography variant="subtitle2" gutterBottom sx={{ 
                        color: theme.palette.primary.main,
                        fontWeight: 600
                      }}>
                        No examples available for this section
                      </Typography>
                    </Box>
                  )}
                </AccordionDetails>
              </Accordion>
            ))}
          </CardContent>
        </Card>
      </Grid>

      <Grid item xs={12}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Keyword Recommendations" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>
            <Typography variant="body2" color="text.secondary" paragraph>
              Including these keywords will boost your resume's ATS compatibility and relevance for your target roles:
            </Typography>
            
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 3 }}>
              {(resume.analysis?.keywordsSuggestions || []).map((keyword, index) => (
                <Chip 
                  key={index} 
                  label={keyword} 
                  sx={{ 
                    bgcolor: COLORS[index % COLORS.length] + '20',
                    color: COLORS[index % COLORS.length],
                    fontWeight: 500,
                    borderRadius: 2
                  }} 
                />
              ))}
            </Box>
            
            <Box sx={{ 
              p: 2, 
              bgcolor: 'rgba(33, 150, 243, 0.1)', 
              borderRadius: 2,
              border: '1px solid rgba(33, 150, 243, 0.2)',
              display: 'flex',
              alignItems: 'flex-start'
            }}>
              <CheckCircleIcon color="info" sx={{ mr: 1.5, mt: 0.5 }} />
              <Typography variant="body2">
                Using these keywords strategically throughout your resume helps you pass through Applicant Tracking Systems (ATS) and catch the attention of recruiters looking for these specific skills and qualifications.
              </Typography>
            </Box>
          </CardContent>
        </Card>
      </Grid>

      {resume.analysis?.profileSummary && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Career Path Analysis" 
              avatar={<TimelineIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <Box sx={{ mb: 3 }}>
                    <Typography variant="subtitle1" gutterBottom fontWeight={600} color="primary">
                      Current Profile
                    </Typography>
                    <Box sx={{ p: 2, bgcolor: 'rgba(0,0,0,0.02)', borderRadius: 2 }}>
                      <Typography variant="body1" fontWeight={500} paragraph>
                        {resume.analysis.profileSummary.currentRole || 'Product Manager'}
                      </Typography>
                      <Typography variant="body2" paragraph>
                        Career Level: {resume.analysis.profileSummary.careerLevel || 'Mid-Senior'}
                      </Typography>
                      <Typography variant="body2" sx={{ mb: 1 }}>
                        Industry Experience:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                        {(resume.analysis.profileSummary.industries || ['Software', 'SaaS', 'Enterprise']).map((industry, index) => (
                          <Chip 
                            key={index} 
                            label={industry} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.primary.main}20`,
                              color: theme.palette.primary.main 
                            }} 
                          />
                        ))}
                      </Box>
                    </Box>
                  </Box>
                </Grid>
                
                <Grid item xs={12} md={6}>
                  <Box sx={{ mb: 3 }}>
                    <Typography variant="subtitle1" gutterBottom fontWeight={600} color="primary">
                      Career Progression Opportunities
                    </Typography>
                    <Box sx={{ p: 2, bgcolor: 'rgba(0,0,0,0.02)', borderRadius: 2 }}>
                      <Typography variant="body2" sx={{ mb: 1 }}>
                        Suggested Job Titles:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mb: 2 }}>
                        {(resume.analysis.profileSummary.suggestedJobTitles || ['Senior Product Manager', 'Product Lead', 'Director of Product']).map((title, index) => (
                          <Chip 
                            key={index} 
                            label={title} 
                            size="small" 
                            variant="outlined" 
                            color="primary" 
                          />
                        ))}
                      </Box>
                      
                      <Typography variant="body2" sx={{ mb: 1 }}>
                        Recommended Industries:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                        {(resume.analysis.profileSummary.suggestedIndustries || ['AI/ML', 'FinTech', 'Enterprise SaaS']).map((industry, index) => (
                          <Chip 
                            key={index} 
                            label={industry} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.secondary.main}20`,
                              color: theme.palette.secondary.main
                            }} 
                          />
                        ))}
                      </Box>
                    </Box>
                  </Box>
                </Grid>
                
                <Grid item xs={12}>
                  <Divider sx={{ my: 1 }} />
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="subtitle1" gutterBottom fontWeight={600} color="primary">
                      Career Growth Recommendations
                    </Typography>
                    <List dense>
                      <ListItem sx={{ px: 0 }}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" />
                        </ListItemIcon>
                        <ListItemText 
                          primary="Highlight quantifiable achievements in product launches and user metrics" 
                          secondary="Add specific numbers to demonstrate your impact on business outcomes"
                        />
                      </ListItem>
                      <ListItem sx={{ px: 0 }}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" />
                        </ListItemIcon>
                        <ListItemText 
                          primary="Showcase strategic thinking and leadership experience" 
                          secondary="Emphasize instances where you've led cross-functional teams or influenced product strategy"
                        />
                      </ListItem>
                      <ListItem sx={{ px: 0 }}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" />
                        </ListItemIcon>
                        <ListItemText 
                          primary="Emphasize technical skills alongside product management expertise" 
                          secondary="Highlight your understanding of technical concepts, data analysis capabilities, and technical tools"
                        />
                      </ListItem>
                    </List>
                  </Box>
                </Grid>
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}
    </Grid>
  );
};

export default AnalysisTab;

================
File: frontend/src/components/resumes/tabs/ContentTab.js
================
// src/components/resumes/tabs/ContentTab.js
import React from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip
} from '@mui/material';
import {
  Person as PersonIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  LocationOn as LocationOnIcon,
  Description as DescriptionIcon,
  Work as WorkIcon,
  School as SchoolIcon,
  Code as CodeIcon,
  CheckCircle as CheckCircleIcon,
  BusinessCenter as BusinessCenterIcon,
  Timeline as TimelineIcon
} from '@mui/icons-material';
import { formatDateRange } from '../utils/resumeHelpers';

/**
 * Content tab component showing full resume content in structured format
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {object} props.theme - MUI theme object
 * @returns {JSX.Element} Content tab content
 */
const ContentTab = ({ resume, theme }) => {
  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  return (
    <Grid container spacing={3}>
      {/* Contact Information */}
      <Grid item xs={12}>
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Contact Information" 
            avatar={<PersonIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <PersonIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Name</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.name || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <EmailIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Email</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.email || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <PhoneIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Phone</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.phone || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
                  <LocationOnIcon fontSize="small" sx={{ mt: 0.5, mr: 1, color: theme.palette.primary.main }} />
                  <Box>
                    <Typography variant="body2" color="text.secondary">Location</Typography>
                    <Typography variant="body1" fontWeight="medium">{resume.parsedData?.contactInfo?.location || 'Not specified'}</Typography>
                  </Box>
                </Box>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
      </Grid>

      {/* Summary */}
      {resume.parsedData?.summary && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Professional Summary" 
              avatar={<DescriptionIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Typography variant="body1" sx={{ lineHeight: 1.7 }}>
                {resume.parsedData.summary}
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Experience */}
      {resume.parsedData?.experience && resume.parsedData.experience.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Work Experience" 
              avatar={<WorkIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              {resume.parsedData.experience.map((exp, index) => (
                <Box key={index} sx={{ 
                  mb: 3, 
                  pb: 3, 
                  borderBottom: index < resume.parsedData.experience.length - 1 ? '1px solid' : 'none', 
                  borderColor: 'divider' 
                }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap' }}>
                    <Box>
                      <Typography variant="h6" fontWeight={600} color="primary">
                        {exp.title}
                      </Typography>
                      <Typography variant="subtitle1" sx={{ display: 'flex', alignItems: 'center' }}>
                        <BusinessCenterIcon fontSize="small" sx={{ mr: 1, color: theme.palette.secondary.main }} />
                        {exp.company}
                      </Typography>
                    </Box>
                    
                    <Box sx={{ 
                      bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)', 
                      px: 1.5, 
                      py: 0.5, 
                      borderRadius: 2,
                      display: 'flex',
                      alignItems: 'center',
                      alignSelf: 'flex-start'
                    }}>
                      <TimelineIcon fontSize="small" sx={{ mr: 0.5, color: theme.palette.primary.main }} />
                      <Typography variant="body2" color="text.secondary">
                        {formatDateRange(exp.startDate, exp.endDate)}
                      </Typography>
                    </Box>
                  </Box>
                  
                  {exp.location && (
                    <Typography variant="body2" color="text.secondary" sx={{ 
                      display: 'flex', 
                      alignItems: 'center', 
                      mt: 0.5 
                    }}>
                      <LocationOnIcon fontSize="small" sx={{ mr: 0.5 }} /> {exp.location}
                    </Typography>
                  )}
                  
                  {exp.description && (
                    <Typography variant="body2" sx={{ whiteSpace: 'pre-line', my: 1.5 }}>
                      {exp.description}
                    </Typography>
                  )}
                  
                  {exp.highlights && exp.highlights.length > 0 && (
                    <Box sx={{ mt: 1.5 }}>
                      <Typography variant="body2" fontWeight="bold" color="primary">
                        Key Achievements:
                      </Typography>
                      <List dense sx={{ pl: 2 }}>
                        {exp.highlights.map((highlight, idx) => (
                          <ListItem key={idx} sx={{ px: 0, py: 0.5 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}>
                              <CheckCircleIcon fontSize="small" color="success" />
                            </ListItemIcon>
                            <ListItemText primary={highlight} />
                          </ListItem>
                        ))}
                      </List>
                    </Box>
                  )}
                  
                  {exp.skills && exp.skills.length > 0 && (
                    <Box sx={{ mt: 1.5 }}>
                      <Typography variant="body2" fontWeight="bold" color="primary">
                        Skills Used:
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 0.5 }}>
                        {exp.skills.map((skill, idx) => (
                          <Chip 
                            key={idx} 
                            label={skill} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.primary.main}15`,
                              color: theme.palette.primary.main 
                            }} 
                          />
                        ))}
                      </Box>
                    </Box>
                  )}
                </Box>
              ))}
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Education */}
      {resume.parsedData?.education && resume.parsedData.education.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Education" 
              avatar={<SchoolIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              {resume.parsedData.education.map((edu, index) => (
                <Box key={index} sx={{ 
                  mb: 3, 
                  pb: 3, 
                  borderBottom: index < resume.parsedData.education.length - 1 ? '1px solid' : 'none', 
                  borderColor: 'divider' 
                }}>
                  <Typography variant="h6" fontWeight={600} color="primary">
                    {edu.degree} {edu.field ? `in ${edu.field}` : ''}
                  </Typography>
                  <Typography variant="subtitle1" sx={{ display: 'flex', alignItems: 'center' }}>
                    <SchoolIcon fontSize="small" sx={{ mr: 1, color: theme.palette.secondary.main }} />
                    {edu.institution}
                  </Typography>
                  <Box sx={{ 
                    bgcolor: theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)', 
                    px: 1.5, 
                    py: 0.5, 
                    borderRadius: 2,
                    display: 'inline-flex',
                    alignItems: 'center',
                    mt: 1
                  }}>
                    <TimelineIcon fontSize="small" sx={{ mr: 0.5, color: theme.palette.primary.main }} />
                    <Typography variant="body2" color="text.secondary">
                      {formatDateRange(edu.startDate, edu.endDate)}
                    </Typography>
                  </Box>
                  
                  {edu.gpa && (
                    <Typography variant="body2" sx={{ mt: 1.5 }}>
                      <b>GPA:</b> {edu.gpa}
                    </Typography>
                  )}
                  
                  {edu.highlights && edu.highlights.length > 0 && (
                    <Box sx={{ mt: 1.5 }}>
                      <Typography variant="body2" fontWeight="bold" color="primary">
                        Highlights:
                      </Typography>
                      <List dense sx={{ pl: 2 }}>
                        {edu.highlights.map((highlight, idx) => (
                          <ListItem key={idx} sx={{ px: 0, py: 0.5 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}>
                              <CheckCircleIcon fontSize="small" color="success" />
                            </ListItemIcon>
                            <ListItemText primary={highlight} />
                          </ListItem>
                        ))}
                      </List>
                    </Box>
                  )}
                </Box>
              ))}
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Certifications */}
      {resume.parsedData?.certifications && resume.parsedData.certifications.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Certifications" 
              avatar={<CheckCircleIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={2}>
                {resume.parsedData.certifications.map((cert, index) => (
                  <Grid item xs={12} sm={6} lg={4} key={index}>
                    <Box sx={{ 
                      p: 2, 
                      borderRadius: 2, 
                      border: '1px solid',
                      borderColor: theme.palette.divider,
                      height: '100%',
                      display: 'flex',
                      flexDirection: 'column',
                      transition: 'all 0.2s ease',
                      '&:hover': {
                        boxShadow: '0 4px 12px rgba(0,0,0,0.08)',
                        borderColor: theme.palette.primary.light
                      }
                    }}>
                      <Typography variant="h6" fontWeight={600} color="primary" gutterBottom>
                        {cert.name}
                      </Typography>
                      <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        <BusinessCenterIcon fontSize="small" sx={{ mr: 0.5, color: theme.palette.secondary.main }} />
                        {cert.issuer}
                      </Typography>
                      {cert.dateObtained && (
                        <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', color: 'text.secondary' }}>
                          <TimelineIcon fontSize="small" sx={{ mr: 0.5 }} />
                          {new Date(cert.dateObtained).toLocaleDateString()}
                          {cert.validUntil && ` - ${new Date(cert.validUntil).toLocaleDateString()}`}
                        </Typography>
                      )}
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Skills */}
      {resume.parsedData?.skills && resume.parsedData.skills.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Skills" 
              avatar={<CodeIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {resume.parsedData.skills.map((skill, index) => {
                  let color;
                  if (typeof skill === 'object' && skill.level) {
                    color = skill.level === 'Expert' ? theme.palette.success.main : 
                            skill.level === 'Advanced' ? theme.palette.info.main : 
                            skill.level === 'Intermediate' ? theme.palette.warning.main : 
                            theme.palette.grey[600];
                  } else {
                    color = COLORS[index % COLORS.length];
                  }
                  
                  return (
                    <Chip 
                      key={index} 
                      label={
                        typeof skill === 'object' ? 
                          skill.level ? 
                            `${skill.name} (${skill.level})` : 
                            skill.name : 
                          skill
                      } 
                      sx={{ 
                        bgcolor: `${color}15`, 
                        color: color,
                        fontWeight: 500,
                        borderRadius: 2,
                        py: 2
                      }} 
                    />
                  );
                })}
              </Box>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Languages */}
      {resume.parsedData?.languages && resume.parsedData.languages.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
            <CardHeader 
              title="Languages" 
              avatar={<PersonIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={2}>
                {resume.parsedData.languages.map((lang, index) => (
                  <Grid item xs={12} sm={6} md={4} lg={3} key={index}>
                    <Box sx={{ 
                      p: 2,
                      borderRadius: 2,
                      border: '1px solid',
                      borderColor: theme.palette.divider,
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center'
                    }}>
                      <Box>
                        <Typography variant="body1" fontWeight="medium">{lang.language}</Typography>
                        {lang.proficiency && (
                          <Typography variant="body2" color="text.secondary">{lang.proficiency}</Typography>
                        )}
                      </Box>
                      {lang.proficiency && (
                        <Chip 
                          label={lang.proficiency} 
                          size="small" 
                          sx={{ 
                            bgcolor: theme.palette.primary.main + '20',
                            color: theme.palette.primary.main,
                            fontWeight: 500 
                          }} 
                        />
                      )}
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}

      {/* Projects */}
      {resume.parsedData?.projects && resume.parsedData.projects.length > 0 && (
        <Grid item xs={12}>
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Projects" 
              avatar={<WorkIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <Grid container spacing={3}>
                {resume.parsedData.projects.map((project, index) => (
                  <Grid item xs={12} md={6} key={index}>
                    <Box sx={{ 
                      p: 2,
                      borderRadius: 3,
                      border: '1px solid',
                      borderColor: theme.palette.divider,
                      height: '100%',
                      transition: 'all 0.2s ease',
                      '&:hover': {
                        boxShadow: '0 4px 20px rgba(0,0,0,0.08)',
                        borderColor: theme.palette.primary.light
                      }
                    }}>
                      <Typography variant="h6" fontWeight={600} color="primary">
                        {project.name}
                      </Typography>
                      
                      {project.url && (
                        <Typography variant="body2" color="primary" component="a" href={project.url} target="_blank" sx={{ 
                          display: 'block', 
                          mb: 1,
                          textDecoration: 'none',
                          '&:hover': { textDecoration: 'underline' }
                        }}>
                          {project.url}
                        </Typography>
                      )}
                      
                      {(project.startDate || project.endDate) && (
                        <Typography variant="body2" color="text.secondary" sx={{ 
                          mb: 1.5,
                          display: 'flex',
                          alignItems: 'center' 
                        }}>
                          <TimelineIcon fontSize="small" sx={{ mr: 0.5 }} />
                          {formatDateRange(project.startDate, project.endDate)}
                        </Typography>
                      )}
                      
                      {project.description && (
                        <Typography variant="body2" sx={{ mb: 1.5 }}>
                          {project.description}
                        </Typography>
                      )}
                      
                      {project.skills && project.skills.length > 0 && (
                        <Box sx={{ mt: 1.5 }}>
                          <Typography variant="body2" fontWeight="bold" color="text.secondary">
                            Technologies Used:
                          </Typography>
                          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 1 }}>
                            {project.skills.map((skill, idx) => (
                              <Chip 
                                key={idx} 
                                label={skill} 
                                size="small" 
                                sx={{ 
                                  bgcolor: `${theme.palette.secondary.main}15`,
                                  color: theme.palette.secondary.main 
                                }} 
                              />
                            ))}
                          </Box>
                        </Box>
                      )}
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </CardContent>
          </Card>
        </Grid>
      )}
    </Grid>
  );
};

export default ContentTab;

================
File: frontend/src/components/resumes/tabs/OverviewTab.js
================
// src/components/resumes/tabs/OverviewTab.js
import React from 'react';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  LinearProgress
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Warning as WarningIcon,
  Person as PersonIcon,
  BusinessCenter as BusinessCenterIcon,
  Timeline as TimelineIcon,
  Lightbulb as LightbulbIcon
} from '@mui/icons-material';
import ScoreDisplay from '../components/ScoreDisplay';

/**
 * Overview tab component showing resume scores, strengths, and profile summary
 * @param {object} props - Component props
 * @param {object} props.resume - Resume data
 * @param {object} props.theme - MUI theme object
 * @returns {JSX.Element} Overview tab content
 */
const OverviewTab = ({ resume, theme }) => {
  const COLORS = [
    theme.palette.primary.main, 
    theme.palette.secondary.main, 
    theme.palette.success.main, 
    theme.palette.warning.main, 
    theme.palette.error.main,
    theme.palette.info.main
  ];

  return (
    <Grid container spacing={3}>
      <Grid item xs={12} md={4}>
        {/* Resume Scores Card */}
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Resume Scores" 
            avatar={<CheckCircleIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent sx={{ display: 'flex', justifyContent: 'center', flexDirection: 'column', alignItems: 'center' }}>
            <ScoreDisplay 
              value={resume.analysis?.overallScore || 0} 
              label="Overall Score"
            />
            
            <Box sx={{ width: '100%', mt: 3 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body1">ATS Compatibility</Typography>
                <Typography variant="h6" fontWeight="medium">
                  {resume.analysis?.atsCompatibility || 0}%
                </Typography>
              </Box>
              <LinearProgress 
                variant="determinate" 
                value={resume.analysis?.atsCompatibility || 0}
                sx={{ height: 8, borderRadius: 4 }}
              />
            </Box>
          </CardContent>
        </Card>

        {/* Profile Summary Card */}
        {resume.analysis?.profileSummary && (
          <Card elevation={2} sx={{ borderRadius: 3 }}>
            <CardHeader 
              title="Professional Profile" 
              avatar={<PersonIcon color="primary" />}
              sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
            />
            <CardContent>
              <List disablePadding>
                <ListItem disableGutters sx={{ px: 0, py: 1 }}>
                  <ListItemIcon sx={{ minWidth: 40 }}>
                    <BusinessCenterIcon fontSize="small" color="primary" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Current Role" 
                    secondary={resume.analysis.profileSummary.currentRole || 'Not specified'}
                  />
                </ListItem>
                
                <ListItem disableGutters sx={{ px: 0, py: 1 }}>
                  <ListItemIcon sx={{ minWidth: 40 }}>
                    <TimelineIcon fontSize="small" color="primary" />
                  </ListItemIcon>
                  <ListItemText 
                    primary="Career Level" 
                    secondary={resume.analysis.profileSummary.careerLevel || 'Mid-level'}
                  />
                </ListItem>
              </List>
              
              {resume.analysis.profileSummary.suggestedJobTitles?.length > 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography variant="subtitle2" gutterBottom color="text.secondary">
                    Suggested Job Titles
                  </Typography>
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                    {resume.analysis.profileSummary.suggestedJobTitles.map((title, index) => (
                      <Chip 
                        key={index} 
                        label={title} 
                        size="small" 
                        variant="outlined" 
                        color="primary" 
                      />
                    ))}
                  </Box>
                </Box>
              )}
            </CardContent>
          </Card>
        )}
      </Grid>

      <Grid item xs={12} md={8}>
        {/* Strengths & Weaknesses */}
        <Card elevation={2} sx={{ mb: 3, borderRadius: 3 }}>
          <CardHeader 
            title="Strengths & Improvement Areas" 
            avatar={<CheckCircleIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle1" gutterBottom color="success.main" fontWeight={600}>
                  <CheckCircleIcon sx={{ mr: 1, verticalAlign: 'middle' }} /> Strengths
                </Typography>
                <List dense>
                  {(resume.analysis?.strengths || []).map((strength, index) => (
                    <ListItem key={index} sx={{ 
                      backgroundColor: `${theme.palette.success.main}10`, 
                      borderRadius: 2, 
                      mb: 1,
                      px: 2
                    }}>
                      <ListItemText primary={strength} />
                    </ListItem>
                  ))}
                </List>
              </Grid>

              <Grid item xs={12} md={6}>
                <Typography variant="subtitle1" gutterBottom color="warning.main" fontWeight={600}>
                  <WarningIcon sx={{ mr: 1, verticalAlign: 'middle' }} /> Improvement Areas
                </Typography>
                <List dense>
                  {(resume.analysis?.weaknesses || []).map((weakness, index) => (
                    <ListItem key={index} sx={{ 
                      backgroundColor: `${theme.palette.warning.main}10`, 
                      borderRadius: 2, 
                      mb: 1,
                      px: 2 
                    }}>
                      <ListItemText primary={weakness} />
                    </ListItem>
                  ))}
                </List>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
        
        {/* Keywords */}
        <Card elevation={2} sx={{ borderRadius: 3 }}>
          <CardHeader 
            title="Keyword Recommendations" 
            avatar={<LightbulbIcon color="primary" />}
            sx={{ '& .MuiCardHeader-title': { fontWeight: 600 } }}
          />
          <CardContent>                    
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
              {(resume.analysis?.keywordsSuggestions || []).map((keyword, index) => (
                <Chip 
                  key={index} 
                  label={keyword} 
                  sx={{ 
                    bgcolor: COLORS[index % COLORS.length] + '20',
                    color: COLORS[index % COLORS.length],
                    fontWeight: 500,
                    borderRadius: 2
                  }} 
                />
              ))}
            </Box>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
};

export default OverviewTab;

================
File: frontend/src/components/resumes/utils/resumeHelpers.js
================
// src/components/resumes/utils/resumeHelpers.js
import React from 'react';
import {
  Box,
  Typography,
  Card,
  CardContent,
  Avatar,
} from '@mui/material';
import { ArrowUpward as ArrowUpwardIcon } from '@mui/icons-material';

/**
 * Renders an improved snippet component showing before/after text
 * @param {object} snippet - Snippet object with original and improved text
 * @param {object} theme - MUI theme object
 * @returns {JSX.Element} Rendered snippet card
 */
export const renderImprovedSnippet = (snippet, theme) => {
  return (
    <Card variant="outlined" sx={{ mb: 2, overflow: 'visible', borderRadius: 2 }} key={snippet.original}>
      <CardContent sx={{ p: 2 }}>
        <Box sx={{ position: 'relative', mb: 2 }}>
          <Box sx={{ 
            backgroundColor: 'rgba(239, 83, 80, 0.1)', 
            color: 'text.primary', 
            p: 2, 
            borderRadius: 2,
            position: 'relative',
            border: '1px solid rgba(239, 83, 80, 0.3)'
          }}>
            <Typography variant="body2" sx={{ fontFamily: 'monospace' }}>
              {snippet.original}
            </Typography>
          </Box>
          <Box sx={{ 
            display: 'flex', 
            justifyContent: 'center', 
            py: 1 
          }}>
            <Avatar sx={{ bgcolor: theme.palette.primary.main }}>
              <ArrowUpwardIcon />
            </Avatar>
          </Box>
          <Box sx={{ 
            backgroundColor: 'rgba(76, 175, 80, 0.1)', 
            color: 'text.primary', 
            p: 2, 
            borderRadius: 2,
            border: '1px solid rgba(76, 175, 80, 0.3)'
          }}>
            <Typography variant="body2" sx={{ fontFamily: 'monospace' }}>
              {snippet.improved}
            </Typography>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};

/**
 * Gets color based on score value
 * @param {number} value - Score value (0-100)
 * @param {object} theme - MUI theme object
 * @returns {string} Color value
 */
export const getScoreColor = (value, theme) => {
  if (value >= 80) return theme.palette.success.main;
  if (value >= 60) return theme.palette.warning.main;
  return theme.palette.error.main;
};

/**
 * Formats date range for display
 * @param {string|Date} startDate - Start date
 * @param {string|Date} endDate - End date
 * @returns {string} Formatted date range
 */
export const formatDateRange = (startDate, endDate) => {
  if (startDate && endDate) {
    return `${new Date(startDate).toLocaleDateString()} - ${endDate ? new Date(endDate).toLocaleDateString() : 'Present'}`;
  } else if (startDate) {
    return `From ${new Date(startDate).toLocaleDateString()}`;
  } else if (endDate) {
    return `Until ${new Date(endDate).toLocaleDateString()}`;
  }
  return 'Date not specified';
};

================
File: frontend/src/components/search/SearchPage.js
================
// src/components/search/SearchPage.js
import React, { useState, useEffect } from 'react';
import {
  Box,
  Container,
  Typography,
  Paper,
  Grid,
  Card,
  CardContent,
  TextField,
  InputAdornment,
  IconButton,
  Chip,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Tabs,
  Tab,
  CircularProgress,
  Alert,
  useTheme,
  alpha,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Checkbox,
  FormControlLabel,
  Slider,
  Badge
} from '@mui/material';
import {
  Search as SearchIcon,
  Clear as ClearIcon,
  FilterList as FilterListIcon,
  Sort as SortIcon,
  Work as WorkIcon,
  Description as DescriptionIcon,
  Person as PersonIcon,
  ExpandMore as ExpandMoreIcon,
  History as HistoryIcon,
  TrendingUp as TrendingUpIcon,
  Bookmark as BookmarkIcon,
  Share as ShareIcon,
  Download as DownloadIcon
} from '@mui/icons-material';
import { useLocation, useNavigate } from 'react-router-dom';
import MainLayout from '../layout/MainLayout';
import useSearch from '../../hooks/useSearch';
import searchService from '../../utils/searchService';

const SearchPage = () => {
  const theme = useTheme();
  const location = useLocation();
  const navigate = useNavigate();
  
  // Initialize search with URL params
  const searchParams = new URLSearchParams(location.search);
  const initialQuery = searchParams.get('q') || '';
  const initialCategory = searchParams.get('category') || 'all';

  const {
    query,
    category,
    results,
    suggestions,
    isLoading,
    error,
    recentSearches,
    setQuery,
    setCategory,
    search,
    clearAll,
    getResultsForCategory,
    getTotalResults,
    hasResults,
    categories
  } = useSearch({
    initialQuery,
    initialCategory,
    autoSearch: true,
    onSearchComplete: (results, searchQuery) => {
      // Update URL with search params
      const newSearchParams = new URLSearchParams();
      newSearchParams.set('q', searchQuery);
      if (category !== 'all') {
        newSearchParams.set('category', category);
      }
      navigate(`/search?${newSearchParams}`, { replace: true });
    }
  });

  // Advanced filters state
  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);
  const [filters, setFilters] = useState({
    dateRange: 'all',
    matchScore: [0, 100],
    location: '',
    company: '',
    experienceLevel: '',
    skills: [],
    sortBy: 'relevance',
    sortOrder: 'desc'
  });

  // Popular searches and categories
  const [popularSearches, setPopularSearches] = useState([]);

  useEffect(() => {
    loadPopularSearches();
  }, []);

  const loadPopularSearches = async () => {
    try {
      const popular = await searchService.getPopularSearches();
      setPopularSearches(popular.searches || []);
    } catch (error) {
      console.error('Error loading popular searches:', error);
    }
  };

  const handleSearchSubmit = (event) => {
    event.preventDefault();
    if (query.trim()) {
      search(query, category);
    }
  };

  const handleCategoryChange = (event, newCategory) => {
    setCategory(newCategory);
  };

  const handleFilterChange = (filterName, value) => {
    setFilters(prev => ({
      ...prev,
      [filterName]: value
    }));
  };

  const handleClearFilters = () => {
    setFilters({
      dateRange: 'all',
      matchScore: [0, 100],
      location: '',
      company: '',
      experienceLevel: '',
      skills: [],
      sortBy: 'relevance',
      sortOrder: 'desc'
    });
  };

  const handleResultClick = (result) => {
    navigate(result.url);
  };

  const renderSearchInput = () => (
    <Paper elevation={2} sx={{ p: 3, mb: 3 }}>
      <Box component="form" onSubmit={handleSearchSubmit}>
        <TextField
          fullWidth
          variant="outlined"
          placeholder="Search jobs, resumes, recruiters, companies, skills..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon color="action" />
              </InputAdornment>
            ),
            endAdornment: (
              <InputAdornment position="end">
                {query && (
                  <IconButton onClick={() => setQuery('')} edge="end">
                    <ClearIcon />
                  </IconButton>
                )}
                <Button
                  type="submit"
                  variant="contained"
                  sx={{ ml: 1 }}
                  disabled={!query.trim()}
                >
                  Search
                </Button>
              </InputAdornment>
            )
          }}
          sx={{
            '& .MuiOutlinedInput-root': {
              fontSize: '1.1rem',
              '& fieldset': {
                borderColor: alpha(theme.palette.primary.main, 0.3),
              },
              '&:hover fieldset': {
                borderColor: theme.palette.primary.main,
              },
              '&.Mui-focused fieldset': {
                borderColor: theme.palette.primary.main,
              },
            }
          }}
        />
      </Box>

      {/* Recent and Popular Searches */}
      {!query && (
        <Box sx={{ mt: 2 }}>
          {recentSearches.length > 0 && (
            <Box sx={{ mb: 2 }}>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <HistoryIcon fontSize="small" sx={{ mr: 1 }} />
                Recent Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {recentSearches.slice(0, 5).map((search, index) => (
                  <Chip
                    key={index}
                    label={search.query}
                    onClick={() => setQuery(search.query)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}

          {popularSearches.length > 0 && (
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1, display: 'flex', alignItems: 'center' }}>
                <TrendingUpIcon fontSize="small" sx={{ mr: 1 }} />
                Popular Searches
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                {popularSearches.slice(0, 8).map((search, index) => (
                  <Chip
                    key={index}
                    label={search}
                    variant="outlined"
                    onClick={() => setQuery(search)}
                    sx={{ cursor: 'pointer' }}
                  />
                ))}
              </Box>
            </Box>
          )}
        </Box>
      )}
    </Paper>
  );

  const renderFilters = () => (
    <Card sx={{ mb: 3 }}>
      <CardContent>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
          <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center' }}>
            <FilterListIcon sx={{ mr: 1 }} />
            Filters
          </Typography>
          <Box>
            <Button
              variant="outlined"
              size="small"
              onClick={() => setShowAdvancedFilters(!showAdvancedFilters)}
              sx={{ mr: 1 }}
            >
              Advanced
            </Button>
            <Button
              variant="text"
              size="small"
              onClick={handleClearFilters}
            >
              Clear All
            </Button>
          </Box>
        </Box>

        <Grid container spacing={2}>
          <Grid item xs={12} sm={6} md={3}>
            <FormControl fullWidth size="small">
              <InputLabel>Date Range</InputLabel>
              <Select
                value={filters.dateRange}
                onChange={(e) => handleFilterChange('dateRange', e.target.value)}
                label="Date Range"
              >
                <MenuItem value="all">All Time</MenuItem>
                <MenuItem value="today">Today</MenuItem>
                <MenuItem value="week">This Week</MenuItem>
                <MenuItem value="month">This Month</MenuItem>
                <MenuItem value="quarter">This Quarter</MenuItem>
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <FormControl fullWidth size="small">
              <InputLabel>Sort By</InputLabel>
              <Select
                value={filters.sortBy}
                onChange={(e) => handleFilterChange('sortBy', e.target.value)}
                label="Sort By"
              >
                <MenuItem value="relevance">Relevance</MenuItem>
                <MenuItem value="date">Date</MenuItem>
                <MenuItem value="match_score">Match Score</MenuItem>
                <MenuItem value="alphabetical">Alphabetical</MenuItem>
              </Select>
            </FormControl>
          </Grid>

          {category === 'jobs' && (
            <>
              <Grid item xs={12} sm={6} md={3}>
                <TextField
                  fullWidth
                  size="small"
                  label="Location"
                  value={filters.location}
                  onChange={(e) => handleFilterChange('location', e.target.value)}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <TextField
                  fullWidth
                  size="small"
                  label="Company"
                  value={filters.company}
                  onChange={(e) => handleFilterChange('company', e.target.value)}
                />
              </Grid>
            </>
          )}
        </Grid>

        {/* Advanced Filters */}
        {showAdvancedFilters && (
          <Accordion sx={{ mt: 2 }}>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography>Advanced Filters</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" gutterBottom>
                    Match Score Range
                  </Typography>
                  <Slider
                    value={filters.matchScore}
                    onChange={(e, value) => handleFilterChange('matchScore', value)}
                    valueLabelDisplay="auto"
                    marks={[
                      { value: 0, label: '0%' },
                      { value: 50, label: '50%' },
                      { value: 100, label: '100%' }
                    ]}
                  />
                </Grid>
                
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" gutterBottom>
                    Experience Level
                  </Typography>
                  <Box sx={{ display: 'flex', flexDirection: 'column' }}>
                    {['Entry Level', 'Mid Level', 'Senior Level', 'Executive'].map((level) => (
                      <FormControlLabel
                        key={level}
                        control={<Checkbox size="small" />}
                        label={level}
                      />
                    ))}
                  </Box>
                </Grid>
              </Grid>
            </AccordionDetails>
          </Accordion>
        )}
      </CardContent>
    </Card>
  );

  const renderCategoryTabs = () => (
    <Paper sx={{ mb: 3 }}>
      <Tabs
        value={category}
        onChange={handleCategoryChange}
        variant="scrollable"
        scrollButtons="auto"
        sx={{ borderBottom: 1, borderColor: 'divider' }}
      >
        {categories.map((cat) => (
          <Tab
            key={cat.value}
            value={cat.value}
            label={
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                {cat.label}
                {results && getResultsForCategory(cat.value).length > 0 && (
                  <Badge
                    badgeContent={getResultsForCategory(cat.value).length}
                    color="primary"
                    sx={{
                      '& .MuiBadge-badge': {
                        fontSize: '0.7rem',
                        height: 16,
                        minWidth: 16
                      }
                    }}
                  />
                )}
              </Box>
            }
          />
        ))}
      </Tabs>
    </Paper>
  );

  const renderResults = () => {
    if (isLoading) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
          <CircularProgress />
        </Box>
      );
    }

    if (error) {
      return (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      );
    }

    if (!hasResults() && query) {
      return (
        <Paper sx={{ p: 4, textAlign: 'center' }}>
          <SearchIcon sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
          <Typography variant="h6" gutterBottom>
            No results found for "{query}"
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
            Try adjusting your search terms or filters
          </Typography>
          <Button onClick={clearAll}>Clear Search</Button>
        </Paper>
      );
    }

    if (!hasResults()) {
      return null;
    }

    const currentResults = getResultsForCategory(category);

    return (
      <Paper>
        <Box sx={{ p: 2, borderBottom: '1px solid', borderColor: 'divider' }}>
          <Typography variant="h6">
            {getTotalResults()} results found
            {query && ` for "${query}"`}
          </Typography>
        </Box>

        <List>
          {currentResults.map((result, index) => {
            const typeDisplay = searchService.getResultTypeDisplay(result.type);
            
            return (
              <React.Fragment key={`${result.type}-${result.id}`}>
                {index > 0 && <Divider />}
                <ListItem
                  button
                  onClick={() => handleResultClick(result)}
                  sx={{ py: 2 }}
                >
                  <ListItemIcon>
                    <Box
                      sx={{
                        width: 40,
                        height: 40,
                        borderRadius: 1,
                        backgroundColor: alpha(typeDisplay.color, 0.1),
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        color: typeDisplay.color
                      }}
                    >
                      {result.type === 'job' && <WorkIcon />}
                      {result.type === 'resume' && <DescriptionIcon />}
                      {result.type === 'recruiter' && <PersonIcon />}
                    </Box>
                  </ListItemIcon>
                  
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                        <Typography variant="subtitle1" sx={{ fontWeight: 500 }}>
                          {result.title}
                        </Typography>
                        <Chip
                          label={typeDisplay.label}
                          size="small"
                          sx={{ 
                            backgroundColor: alpha(typeDisplay.color, 0.1),
                            color: typeDisplay.color,
                            fontSize: '0.7rem'
                          }}
                        />
                        {result.matchScore && (
                          <Chip
                            label={`${result.matchScore}% match`}
                            size="small"
                            color={result.matchScore >= 80 ? 'success' : result.matchScore >= 60 ? 'info' : 'warning'}
                            sx={{ fontSize: '0.7rem' }}
                          />
                        )}
                      </Box>
                    }
                    secondary={
                      <Box>
                        <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                          {result.subtitle}
                        </Typography>
                        {result.description && (
                          <Typography variant="caption" display="block" color="text.secondary" sx={{ mb: 0.5 }}>
                            {result.description}
                          </Typography>
                        )}
                        {result.skills && result.skills.length > 0 && (
                          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                            {result.skills.slice(0, 5).map((skill, skillIndex) => (
                              <Chip
                                key={skillIndex}
                                label={typeof skill === 'string' ? skill : skill.name}
                                size="small"
                                variant="outlined"
                                sx={{ height: 20, fontSize: '0.65rem' }}
                              />
                            ))}
                            {result.skills.length > 5 && (
                              <Typography variant="caption" color="text.secondary">
                                +{result.skills.length - 5} more
                              </Typography>
                            )}
                          </Box>
                        )}
                      </Box>
                    }
                  />

                  <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                    <IconButton size="small">
                      <BookmarkIcon fontSize="small" />
                    </IconButton>
                    <IconButton size="small">
                      <ShareIcon fontSize="small" />
                    </IconButton>
                  </Box>
                </ListItem>
              </React.Fragment>
            );
          })}
        </List>
      </Paper>
    );
  };

  return (
    <MainLayout>
      <Container maxWidth="xl">
        <Box sx={{ py: 3 }}>
          <Typography variant="h4" gutterBottom>
            Search
          </Typography>
          
          {renderSearchInput()}
          
          {query && (
            <>
              {renderFilters()}
              {renderCategoryTabs()}
            </>
          )}
          
          {renderResults()}
        </Box>
      </Container>
    </MainLayout>
  );
};

export default SearchPage;

================
File: frontend/src/components/SettingsPage.js
================
// src/components/SettingsPage.js
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Card,
  CardContent,
  TextField,
  Button,
  Grid,
  Divider,
  Alert,
  Avatar,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Chip,
  LinearProgress,
  Paper,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  ListItemSecondaryAction
} from '@mui/material';
import {
  Person as PersonIcon,
  Security as SecurityIcon,
  Edit as EditIcon,
  Save as SaveIcon,
  Cancel as CancelIcon,
  Lock as LockIcon,
  Delete as DeleteIcon,
  Verified as VerifiedIcon,
  Warning as WarningIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { useTheme } from '@mui/material/styles';
import { useAuth } from '../context/AuthContext';
import MainLayout from './layout/MainLayout';
import settingsService from '../utils/settingsService';

console.log('🔧 SettingsPage component is being loaded...');

const SettingsPage = () => {
  console.log('🔧 SettingsPage component is rendering...');
  const theme = useTheme();
  const { currentUser, refreshUser } = useAuth();
  
  // Form state
  const [profileData, setProfileData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phoneNumber: ''
  });
  
  const [passwordData, setPasswordData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  // UI state
  const [isEditingProfile, setIsEditingProfile] = useState(false);
  const [isChangingPassword, setIsChangingPassword] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [deleteConfirmText, setDeleteConfirmText] = useState('');
  const [showPasswords, setShowPasswords] = useState({
    current: false,
    new: false,
    confirm: false
  });
  
  // Loading and error states
  const [loading, setLoading] = useState({
    profile: false,
    password: false,
    delete: false
  });
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // Initialize form data when user data loads
  useEffect(() => {
    if (currentUser) {
      setProfileData({
        firstName: currentUser.firstName || '',
        lastName: currentUser.lastName || '',
        email: currentUser.email || '',
        phoneNumber: currentUser.phoneNumber || ''
      });
    }
  }, [currentUser]);

  // Clear messages after 5 seconds
  useEffect(() => {
    if (error || success) {
      const timer = setTimeout(() => {
        setError('');
        setSuccess('');
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [error, success]);

  const handleProfileSave = async () => {
    try {
      setLoading(prev => ({ ...prev, profile: true }));
      setError('');
      
      // Validate form data
      const validation = settingsService.validateProfileData(profileData);
      if (!validation.isValid) {
        setError(validation.errors.join(', '));
        return;
      }
      
      // Call API to update profile
      const response = await settingsService.updateProfile(profileData);
      
      setSuccess(response.message || 'Profile updated successfully!');
      setIsEditingProfile(false);
      
      // Refresh user data
      if (refreshUser) {
        await refreshUser();
      }
      
    } catch (error) {
      console.error('Profile update failed:', error);
      setError(settingsService.getErrorMessage(error));
    } finally {
      setLoading(prev => ({ ...prev, profile: false }));
    }
  };

  const handlePasswordChange = async () => {
    try {
      setLoading(prev => ({ ...prev, password: true }));
      setError('');
      
      // Validate form data
      const validation = settingsService.validatePasswordData(passwordData);
      if (!validation.isValid) {
        setError(validation.errors.join(', '));
        return;
      }
      
      // Call API to change password
      const response = await settingsService.changePassword(passwordData);
      
      setSuccess(response.message || 'Password changed successfully!');
      setPasswordData({
        currentPassword: '',
        newPassword: '',
        confirmPassword: ''
      });
      setIsChangingPassword(false);
      
    } catch (error) {
      console.error('Password change failed:', error);
      setError(settingsService.getErrorMessage(error));
    } finally {
      setLoading(prev => ({ ...prev, password: false }));
    }
  };

  const handleDeleteAccount = async () => {
    try {
      setLoading(prev => ({ ...prev, delete: true }));
      setError('');
      
      // Call API to delete account
      const response = await settingsService.deleteAccount({ confirmationText: 'DELETE' });
      
      setSuccess(response.message || 'Account deletion initiated. You will be logged out shortly.');
      
      // Logout user after a delay
      setTimeout(() => {
        window.location.href = '/login';
      }, 3000);
      
    } catch (error) {
      console.error('Account deletion failed:', error);
      setError(settingsService.getErrorMessage(error));
    } finally {
      setLoading(prev => ({ ...prev, delete: false }));
      setShowDeleteDialog(false);
    }
  };

  const handleCancelEdit = () => {
    // Reset form data to original values
    setProfileData({
      firstName: currentUser?.firstName || '',
      lastName: currentUser?.lastName || '',
      email: currentUser?.email || '',
      phoneNumber: currentUser?.phoneNumber || ''
    });
    setIsEditingProfile(false);
  };

  const togglePasswordVisibility = (field) => {
    setShowPasswords(prev => ({
      ...prev,
      [field]: !prev[field]
    }));
  };

  const getPasswordStrength = (password) => {
    return settingsService.calculatePasswordStrength(password);
  };

  const passwordStrength = getPasswordStrength(passwordData.newPassword);

  return (
    <MainLayout>
      <Box sx={{ p: 3 }}>
        {/* Page Header - following ResumesPage pattern */}
        <Box sx={{ mb: 4 }}>
          <Typography variant="h4" component="h1" fontWeight={500}>
            Settings
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Manage your account preferences and security settings
          </Typography>
        </Box>

      {/* Status Messages */}
      {error && (
        <Alert 
          severity="error" 
          sx={{ mb: 3, borderRadius: 2 }}
          onClose={() => setError('')}
        >
          {error}
        </Alert>
      )}
      
      {success && (
        <Alert 
          severity="success" 
          sx={{ mb: 3, borderRadius: 2 }}
          onClose={() => setSuccess('')}
        >
          {success}
        </Alert>
      )}

      <Grid container spacing={3}>
        {/* User Profile Settings */}
        <Grid item xs={12} lg={8}>
          <Card sx={{ borderRadius: 3, mb: 3 }}>
            <CardContent sx={{ p: 4 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <Avatar
                  sx={{
                    width: 64,
                    height: 64,
                    bgcolor: theme.palette.primary.main,
                    fontSize: '1.5rem',
                    fontWeight: 600,
                    mr: 3
                  }}
                >
                  {profileData.firstName?.[0]}{profileData.lastName?.[0]}
                </Avatar>
                <Box sx={{ flex: 1 }}>
                  <Typography variant="h5" sx={{ fontWeight: 600, color: theme.palette.primary.main, mb: 1 }}>
                    <PersonIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Profile Information
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Update your personal information and contact details
                  </Typography>
                </Box>
                {!isEditingProfile && (
                  <Button
                    variant="outlined"
                    startIcon={<EditIcon />}
                    onClick={() => setIsEditingProfile(true)}
                    sx={{ borderRadius: 2 }}
                  >
                    Edit Profile
                  </Button>
                )}
              </Box>

              <Grid container spacing={3}>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="First Name"
                    value={profileData.firstName}
                    onChange={(e) => setProfileData(prev => ({ ...prev, firstName: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="Last Name"
                    value={profileData.lastName}
                    onChange={(e) => setProfileData(prev => ({ ...prev, lastName: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Email Address"
                    type="email"
                    value={profileData.email}
                    onChange={(e) => setProfileData(prev => ({ ...prev, email: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    InputProps={{
                      startAdornment: <EmailIcon sx={{ mr: 1, color: theme.palette.primary.main }} />,
                      endAdornment: currentUser?.isEmailVerified ? (
                        <Chip
                          label="Verified"
                          size="small"
                          icon={<VerifiedIcon />}
                          color="success"
                          variant="outlined"
                          sx={{ borderRadius: 1 }}
                        />
                      ) : (
                        <Chip
                          label="Unverified"
                          size="small"
                          icon={<WarningIcon />}
                          color="warning"
                          variant="outlined"
                          sx={{ borderRadius: 1 }}
                        />
                      )
                    }}
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Phone Number"
                    type="tel"
                    value={profileData.phoneNumber}
                    onChange={(e) => setProfileData(prev => ({ ...prev, phoneNumber: e.target.value }))}
                    disabled={!isEditingProfile}
                    variant="outlined"
                    placeholder="+1 (555) 123-4567"
                    InputProps={{
                      startAdornment: <PhoneIcon sx={{ mr: 1, color: theme.palette.secondary.main }} />
                    }}
                    sx={{
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2
                      }
                    }}
                  />
                </Grid>

                {isEditingProfile && (
                  <Grid item xs={12}>
                    <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
                      <Button
                        variant="outlined"
                        startIcon={<CancelIcon />}
                        onClick={handleCancelEdit}
                        sx={{ borderRadius: 2 }}
                      >
                        Cancel
                      </Button>
                      <Button
                        variant="contained"
                        startIcon={loading.profile ? <LinearProgress sx={{ width: 20 }} /> : <SaveIcon />}
                        onClick={handleProfileSave}
                        disabled={loading.profile}
                        sx={{ 
                          borderRadius: 2,
                          background: `linear-gradient(45deg, ${theme.palette.success.main}, ${theme.palette.success.dark})`
                        }}
                      >
                        {loading.profile ? 'Saving...' : 'Save Changes'}
                      </Button>
                    </Box>
                  </Grid>
                )}
              </Grid>
            </CardContent>
          </Card>

          {/* Security Settings */}
          <Card sx={{ borderRadius: 3 }}>
            <CardContent sx={{ p: 4 }}>
              <Typography variant="h5" sx={{ fontWeight: 600, color: theme.palette.error.main, mb: 1 }}>
                <SecurityIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
                Privacy & Security
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 4 }}>
                Manage your account security and privacy preferences
              </Typography>

              {/* Change Password Section */}
              <Box sx={{ mb: 4 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                  <Box>
                    <Typography variant="h6" sx={{ fontWeight: 600 }}>
                      Change Password
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Update your password to keep your account secure
                    </Typography>
                  </Box>
                  {!isChangingPassword && (
                    <Button
                      variant="outlined"
                      startIcon={<LockIcon />}
                      onClick={() => setIsChangingPassword(true)}
                      sx={{ borderRadius: 2 }}
                    >
                      Change Password
                    </Button>
                  )}
                </Box>

                {isChangingPassword && (
                  <Paper 
                    elevation={0} 
                    sx={{ 
                      p: 3, 
                      border: `1px solid ${theme.palette.divider}`, 
                      borderRadius: 2,
                      bgcolor: theme.palette.grey[50]
                    }}
                  >
                    <Grid container spacing={3}>
                      <Grid item xs={12}>
                        <TextField
                          fullWidth
                          label="Current Password"
                          type={showPasswords.current ? 'text' : 'password'}
                          value={passwordData.currentPassword}
                          onChange={(e) => setPasswordData(prev => ({ ...prev, currentPassword: e.target.value }))}
                          InputProps={{
                            endAdornment: (
                              <IconButton
                                onClick={() => togglePasswordVisibility('current')}
                                edge="end"
                              >
                                {showPasswords.current ? <VisibilityOffIcon /> : <VisibilityIcon />}
                              </IconButton>
                            )
                          }}
                          sx={{
                            '& .MuiOutlinedInput-root': {
                              borderRadius: 2
                            }
                          }}
                        />
                      </Grid>

                      <Grid item xs={12}>
                        <TextField
                          fullWidth
                          label="New Password"
                          type={showPasswords.new ? 'text' : 'password'}
                          value={passwordData.newPassword}
                          onChange={(e) => setPasswordData(prev => ({ ...prev, newPassword: e.target.value }))}
                          InputProps={{
                            endAdornment: (
                              <IconButton
                                onClick={() => togglePasswordVisibility('new')}
                                edge="end"
                              >
                                {showPasswords.new ? <VisibilityOffIcon /> : <VisibilityIcon />}
                              </IconButton>
                            )
                          }}
                          sx={{
                            '& .MuiOutlinedInput-root': {
                              borderRadius: 2
                            }
                          }}
                        />
                        {passwordData.newPassword && (
                          <Box sx={{ mt: 1 }}>
                            <LinearProgress
                              variant="determinate"
                              value={passwordStrength.strength}
                              color={passwordStrength.color}
                              sx={{ height: 6, borderRadius: 3 }}
                            />
                            <Typography variant="caption" color={`${passwordStrength.color}.main`} sx={{ mt: 0.5, display: 'block' }}>
                              Password strength: {passwordStrength.label}
                            </Typography>
                          </Box>
                        )}
                      </Grid>

                      <Grid item xs={12}>
                        <TextField
                          fullWidth
                          label="Confirm New Password"
                          type={showPasswords.confirm ? 'text' : 'password'}
                          value={passwordData.confirmPassword}
                          onChange={(e) => setPasswordData(prev => ({ ...prev, confirmPassword: e.target.value }))}
                          error={passwordData.confirmPassword && passwordData.newPassword !== passwordData.confirmPassword}
                          helperText={
                            passwordData.confirmPassword && passwordData.newPassword !== passwordData.confirmPassword
                              ? 'Passwords do not match'
                              : ''
                          }
                          InputProps={{
                            endAdornment: (
                              <IconButton
                                onClick={() => togglePasswordVisibility('confirm')}
                                edge="end"
                              >
                                {showPasswords.confirm ? <VisibilityOffIcon /> : <VisibilityIcon />}
                              </IconButton>
                            )
                          }}
                          sx={{
                            '& .MuiOutlinedInput-root': {
                              borderRadius: 2
                            }
                          }}
                        />
                      </Grid>

                      <Grid item xs={12}>
                        <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
                          <Button
                            variant="outlined"
                            onClick={() => {
                              setIsChangingPassword(false);
                              setPasswordData({
                                currentPassword: '',
                                newPassword: '',
                                confirmPassword: ''
                              });
                            }}
                            sx={{ borderRadius: 2 }}
                          >
                            Cancel
                          </Button>
                          <Button
                            variant="contained"
                            startIcon={loading.password ? <LinearProgress sx={{ width: 20 }} /> : <LockIcon />}
                            onClick={handlePasswordChange}
                            disabled={
                              loading.password ||
                              !passwordData.currentPassword ||
                              !passwordData.newPassword ||
                              passwordData.newPassword !== passwordData.confirmPassword
                            }
                            sx={{ 
                              borderRadius: 2,
                              background: `linear-gradient(45deg, ${theme.palette.warning.main}, ${theme.palette.warning.dark})`
                            }}
                          >
                            {loading.password ? 'Changing...' : 'Change Password'}
                          </Button>
                        </Box>
                      </Grid>
                    </Grid>
                  </Paper>
                )}
              </Box>

              <Divider sx={{ my: 4 }} />

              {/* Delete Account Section */}
              <Box>
                <Typography variant="h6" sx={{ fontWeight: 600, color: theme.palette.error.main, mb: 1 }}>
                  Delete Account
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
                  Permanently delete your account and all associated data. This action cannot be undone.
                </Typography>
                
                <Alert severity="warning" sx={{ mb: 3, borderRadius: 2 }}>
                  <Typography variant="body2" sx={{ fontWeight: 500 }}>
                    Before deleting your account, please note:
                  </Typography>
                  <List dense sx={{ mt: 1 }}>
                    <ListItem sx={{ py: 0.5 }}>
                      <ListItemText 
                        primary="• All your resumes and job applications will be permanently deleted"
                        primaryTypographyProps={{ variant: 'body2' }}
                      />
                    </ListItem>
                    <ListItem sx={{ py: 0.5 }}>
                      <ListItemText 
                        primary="• Your AI search history and preferences will be lost"
                        primaryTypographyProps={{ variant: 'body2' }}
                      />
                    </ListItem>
                    <ListItem sx={{ py: 0.5 }}>
                      <ListItemText 
                        primary="• Any active outreach campaigns will be terminated"
                        primaryTypographyProps={{ variant: 'body2' }}
                      />
                    </ListItem>
                  </List>
                </Alert>

                <Button
                  variant="outlined"
                  color="error"
                  startIcon={<DeleteIcon />}
                  onClick={() => setShowDeleteDialog(true)}
                  sx={{ borderRadius: 2 }}
                >
                  Delete My Account
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Sidebar - Account Summary */}
        <Grid item xs={12} lg={4}>
          <Card sx={{ borderRadius: 3, position: 'sticky', top: 24 }}>
            <CardContent sx={{ p: 3 }}>
              <Typography variant="h6" sx={{ fontWeight: 600, mb: 3 }}>
                Account Summary
              </Typography>
              
              <List>
                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <PersonIcon color="primary" />
                  </ListItemIcon>
                  <ListItemText
                    primary="Profile Completion"
                    secondary={`${settingsService.calculateProfileCompletion(currentUser)}% complete`}
                  />
                </ListItem>

                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <EmailIcon color={currentUser?.isEmailVerified ? 'success' : 'warning'} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Email Status"
                    secondary={currentUser?.isEmailVerified ? 'Verified' : 'Pending verification'}
                  />
                  <ListItemSecondaryAction>
                    <Chip
                      label={currentUser?.isEmailVerified ? 'Verified' : 'Unverified'}
                      size="small"
                      color={currentUser?.isEmailVerified ? 'success' : 'warning'}
                      variant="outlined"
                      sx={{ borderRadius: 1 }}
                    />
                  </ListItemSecondaryAction>
                </ListItem>

                <ListItem sx={{ px: 0 }}>
                  <ListItemIcon>
                    <SecurityIcon color="info" />
                  </ListItemIcon>
                  <ListItemText
                    primary="Account Security"
                    secondary="Password protected"
                  />
                  <ListItemSecondaryAction>
                    <Chip
                      label="Secure"
                      size="small"
                      color="success"
                      variant="outlined"
                      sx={{ borderRadius: 1 }}
                    />
                  </ListItemSecondaryAction>
                </ListItem>
              </List>

              <Divider sx={{ my: 2 }} />

              <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
                Member since {new Date(currentUser?.createdAt || Date.now()).toLocaleDateString('en-US', {
                  month: 'long',
                  year: 'numeric'
                })}
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Delete Account Confirmation Dialog */}
      <Dialog
        open={showDeleteDialog}
        onClose={() => setShowDeleteDialog(false)}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: { borderRadius: 3 }
        }}
      >
        <DialogTitle sx={{ 
          color: theme.palette.error.main,
          display: 'flex',
          alignItems: 'center',
          gap: 1
        }}>
          <DeleteIcon />
          Confirm Account Deletion
        </DialogTitle>
        <DialogContent>
          <Typography variant="body1" sx={{ mb: 2 }}>
            Are you absolutely sure you want to delete your account? This action is permanent and cannot be undone.
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Type <strong>DELETE</strong> below to confirm:
          </Typography>
          <TextField
            fullWidth
            placeholder="Type DELETE to confirm"
            value={deleteConfirmText}
            onChange={(e) => setDeleteConfirmText(e.target.value)}
            sx={{ mt: 2 }}
          />
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button 
            onClick={() => setShowDeleteDialog(false)}
            variant="outlined"
            sx={{ borderRadius: 2 }}
          >
            Cancel
          </Button>
          <Button
            onClick={handleDeleteAccount}
            variant="contained"
            color="error"
            startIcon={loading.delete ? <LinearProgress sx={{ width: 20 }} /> : <DeleteIcon />}
            disabled={loading.delete || deleteConfirmText !== 'DELETE'}
            sx={{ borderRadius: 2 }}
          >
            {loading.delete ? 'Deleting...' : 'Delete Account'}
          </Button>
        </DialogActions>
      </Dialog>
      </Box>
    </MainLayout>
  );
};

export default SettingsPage;

================
File: frontend/src/context/AiAssistantContext.js
================
// src/context/AiAssistantContext.js - RAG VERSION WITH NO MEMORY SYSTEM
import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';
import { useLocation } from 'react-router-dom';
import { useAuth } from './AuthContext';
import assistantService from '../utils/assistantService';

const AiAssistantContext = createContext();

export const useAiAssistant = () => {
  const context = useContext(AiAssistantContext);
  if (!context) {
    throw new Error('useAiAssistant must be used within an AiAssistantProvider');
  }
  return context;
};

export const AiAssistantProvider = ({ children }) => {
  const location = useLocation();
  const { currentUser, isAuthenticated } = useAuth();
  
  // 🔥 SIMPLIFIED STATE - No Memory System
  const [isOpen, setIsOpen] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);
  
  // Conversation state
  const [conversations, setConversations] = useState([]);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [currentConversation, setCurrentConversation] = useState(null);
  const [conversationsLoading, setConversationsLoading] = useState(false);
  
  // Chat state
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [contextualSuggestions, setContextualSuggestions] = useState([]);
  
  // 🆕 RAG Context state - attached resumes/jobs per conversation
  const [conversationContexts, setConversationContexts] = useState(new Map());
  
  // Performance tracking
  const [isInitialized, setIsInitialized] = useState(false);
  const initTimeoutRef = useRef(null);
  const lastUpdateRef = useRef(0);

  // 🔥 SIMPLIFIED storage keys - no memory
  const STORAGE_KEYS = {
    currentConversationId: `ai_conv_${currentUser?._id || 'anon'}`,
    isOpen: `ai_open_${currentUser?._id || 'anon'}`,
    conversationContexts: `ai_contexts_${currentUser?._id || 'anon'}`
  };

  // 🆕 RAG Context Management
  const getConversationContext = useCallback((conversationId) => {
    if (!conversationId) return { resumes: [], jobs: [] };
    return conversationContexts.get(conversationId) || { resumes: [], jobs: [] };
  }, [conversationContexts]);

  const setConversationContext = useCallback((conversationId, context) => {
    if (!conversationId) return;
    
    setConversationContexts(prev => {
      const newMap = new Map(prev);
      newMap.set(conversationId, context);
      
      // Cache to localStorage
      try {
        const cacheData = {};
        newMap.forEach((value, key) => {
          cacheData[key] = value;
        });
        localStorage.setItem(STORAGE_KEYS.conversationContexts, JSON.stringify(cacheData));
      } catch (e) {
        console.warn('Failed to cache conversation contexts:', e);
      }
      
      return newMap;
    });
  }, [STORAGE_KEYS.conversationContexts]);

  // 🔥 SIMPLIFIED: Basic context update (no external API calls)
  const updateBasicContext = useCallback(() => {
    const pathSegments = location.pathname.split('/').filter(Boolean);
    const page = pathSegments[0] || 'dashboard';
    
    // Generate simple suggestions based on page
    const suggestions = generateContextualSuggestions(page);
    setContextualSuggestions(suggestions);
    
    console.log('⚡ Basic context update for page:', page);
  }, [location.pathname]);

  // 🔥 SIMPLIFIED: Generate suggestions without heavy processing
  const generateContextualSuggestions = useCallback((page) => {
    const suggestions = {
      dashboard: ['Help with resume', 'Find jobs', 'Career advice', 'What should I focus on?'],
      resumes: ['Improve resume', 'Optimize for ATS', 'Add skills', 'Update experience'],
      jobs: ['Analyze job posting', 'Match to resume', 'Interview prep', 'Write cover letter'],
      recruiters: ['Find recruiters', 'Write outreach message', 'Track responses', 'Network strategy']
    };

    return suggestions[page] || suggestions.dashboard;
  }, []);

  // 🔥 SIMPLIFIED: Fast initialization without memory system
  const initializeAiAssistant = useCallback(async () => {
    if (isInitialized || !isAuthenticated || !currentUser) return;
    
    try {
      console.log('⚡ Fast AI Assistant initialization (RAG mode)...');
      
      // Load saved UI state immediately
      try {
        const savedIsOpen = localStorage.getItem(STORAGE_KEYS.isOpen) === 'true';
        const savedConversationId = localStorage.getItem(STORAGE_KEYS.currentConversationId);
        const savedContexts = localStorage.getItem(STORAGE_KEYS.conversationContexts);
        
        if (savedIsOpen !== undefined) setIsOpen(savedIsOpen);
        if (savedConversationId) setCurrentConversationId(savedConversationId);
        if (savedContexts) {
          try {
            const parsedContexts = JSON.parse(savedContexts);
            const contextMap = new Map(Object.entries(parsedContexts));
            setConversationContexts(contextMap);
          } catch (e) {
            console.warn('Failed to parse saved contexts');
          }
        }
      } catch (e) {
        console.warn('Failed to load saved state:', e);
      }

      // Load conversations in background
      setTimeout(async () => {
        try {
          await loadConversations();
        } catch (error) {
          console.warn('Background conversation loading failed:', error);
        }
      }, 0);

      // Update basic context
      updateBasicContext();
      
      setIsInitialized(true);
      console.log('✅ Fast AI Assistant initialization completed (RAG mode)');
      
    } catch (error) {
      console.error('AI Assistant initialization failed:', error);
      setError('Failed to initialize AI Assistant');
      setIsInitialized(true);
    }
  }, [isInitialized, isAuthenticated, currentUser, STORAGE_KEYS, updateBasicContext]);

  // 🔥 SIMPLIFIED: Fast conversation loading
  const loadConversations = useCallback(async (options = {}) => {
    try {
      setConversationsLoading(true);

      // Try cache first
      try {
        const cacheKey = `conversations_cache_${currentUser?._id}`;
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
          const parsedCache = JSON.parse(cached);
          if (Date.now() - parsedCache.timestamp < 2 * 60 * 1000) {
            console.log('📋 Using cached conversations');
            setConversations(parsedCache.conversations || []);
            setConversationsLoading(false);
            
            // Load fresh data in background
            setTimeout(async () => {
              try {
                const fresh = await assistantService.getConversations({ limit: 20 });
                setConversations(fresh.conversations || []);
                localStorage.setItem(cacheKey, JSON.stringify({
                  conversations: fresh.conversations || [],
                  timestamp: Date.now()
                }));
              } catch (error) {
                console.warn('Background conversation refresh failed:', error);
              }
            }, 0);
            return;
          }
        }
      } catch (cacheError) {
        console.warn('Cache retrieval failed:', cacheError);
      }

      // Load fresh data
      const response = await assistantService.getConversations({ 
        limit: 20,
        sortBy: 'lastActiveAt'
      });

      setConversations(response.conversations || []);
      
      // Cache the results
      try {
        const cacheKey = `conversations_cache_${currentUser?._id}`;
        localStorage.setItem(cacheKey, JSON.stringify({
          conversations: response.conversations || [],
          timestamp: Date.now()
        }));
      } catch (cacheError) {
        console.warn('Failed to cache conversations:', cacheError);
      }

      console.log(`✅ Loaded ${response.conversations?.length || 0} conversations`);

    } catch (error) {
      console.error('Failed to load conversations:', error);
      setError('Failed to load conversations');
      setConversations([]);
    } finally {
      setConversationsLoading(false);
    }
  }, [currentUser?._id]);

  // 🆕 ENHANCED: Send message with RAG context
  const sendMessage = useCallback(async (message, contextData = {}) => {
    try {
      setIsLoading(true);
      setError(null);

      // Validate message
      const validation = assistantService.validateMessage(message);
      if (!validation.valid) {
        throw new Error(validation.error);
      }

      // Add user message immediately
      const userMessage = {
        id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'user',
        content: message,
        timestamp: new Date(),
        createdAt: new Date()
      };
      setMessages(prev => [...prev, userMessage]);

      // Get current conversation context
      const currentContext = getConversationContext(currentConversationId);
      
      // Merge with any new context data
      const fullContext = {
        ...currentContext,
        ...contextData,
        conversationId: currentConversationId
      };

      // Determine if new conversation
      const isNewConversation = !currentConversationId || 
                              currentConversationId.startsWith('new-conversation-') ||
                              contextData.newConversation;

      console.log('🤖 Sending message with RAG context:', {
        hasResumes: fullContext.attachedResumes?.length > 0,
        hasJobs: fullContext.attachedJobs?.length > 0,
        conversationId: currentConversationId
      });

      // Send to AI with RAG context
      const response = await assistantService.sendMessage({
        message,
        context: fullContext,
        conversationId: isNewConversation ? null : currentConversationId,
        newConversation: isNewConversation
      });

      // Add AI response
      const aiMessage = {
        id: `msg_${Date.now() + 1}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'ai',
        content: response.message,
        timestamp: new Date(),
        createdAt: new Date(),
        suggestions: response.suggestions || [],
        metadata: response.performance || {}
      };

      setMessages(prev => [...prev, aiMessage]);

      // Handle conversation state
      if (response.conversationId) {
        if (isNewConversation) {
          console.log('💾 New conversation created:', response.conversationId);
          
          const newConversation = {
            _id: response.conversationId,
            title: response.conversationTitle || 'New Conversation',
            messages: [userMessage, aiMessage],
            messageCount: 2,
            createdAt: new Date(),
            lastActiveAt: new Date(),
            isActive: true
          };
          
          setCurrentConversationId(response.conversationId);
          setCurrentConversation(newConversation);
          setConversations(prev => [newConversation, ...prev]);
          
          localStorage.setItem(STORAGE_KEYS.currentConversationId, response.conversationId);
          
        } else {
          // Update existing conversation
          const updatedConversation = {
            ...currentConversation,
            messages: [...(currentConversation?.messages || []), userMessage, aiMessage],
            messageCount: (currentConversation?.messageCount || 0) + 2,
            lastActiveAt: new Date()
          };
          
          setCurrentConversation(updatedConversation);
          setConversations(prev => prev.map(conv => 
            conv._id === response.conversationId ? updatedConversation : conv
          ));
        }
      }

      // Update suggestions
      if (response.suggestions && response.suggestions.length > 0) {
        setContextualSuggestions(response.suggestions);
      }

      console.log('✅ Message sent successfully with RAG context');
      return response;

    } catch (error) {
      console.error('Failed to send message:', error);
      setError(error.message || 'Failed to send message');
      
      const errorMessage = {
        id: `msg_${Date.now() + 2}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'ai',
        content: "I'm having trouble connecting right now. Please try again in a moment.",
        timestamp: new Date(),
        createdAt: new Date(),
        isError: true
      };
      setMessages(prev => [...prev, errorMessage]);

    } finally {
      setIsLoading(false);
    }
  }, [currentConversationId, currentConversation, getConversationContext, STORAGE_KEYS.currentConversationId]);

  // 🔥 SIMPLIFIED: Fast conversation switching with context loading
  const switchConversation = useCallback(async (conversationId) => {
    if (conversationId === currentConversationId) return;
    
    console.log('⚡ Fast conversation switch:', conversationId);
    
    // Find conversation in current list first
    const foundConversation = conversations.find(conv => conv._id === conversationId);
    
    if (foundConversation) {
      setCurrentConversationId(conversationId);
      setCurrentConversation(foundConversation);
      setMessages(foundConversation.messages || []);
      setError(null);
      
      localStorage.setItem(STORAGE_KEYS.currentConversationId, conversationId);
      
      console.log('✅ Fast conversation switch completed');
    } else {
      // Load conversation in background
      setCurrentConversationId(conversationId);
      setMessages([]);
      setError(null);
      localStorage.setItem(STORAGE_KEYS.currentConversationId, conversationId);
      
      setTimeout(async () => {
        try {
          const conversation = await assistantService.getConversation(conversationId);
          setCurrentConversation(conversation);
          setMessages(conversation.messages || []);
        } catch (error) {
          console.error('Failed to load conversation:', error);
          setError('Failed to load conversation');
        }
      }, 0);
    }
  }, [currentConversationId, conversations, STORAGE_KEYS.currentConversationId]);

  // 🔥 SIMPLIFIED: Conversation creation
  const createNewConversation = useCallback(async (title, category = 'general') => {
    try {
      console.log('⚡ Creating new conversation...');
      // Create placeholder immediately
      const tempId = `new-conversation-${Date.now()}`;
      const placeholderConversation = {
        _id: tempId,
        title: title || 'New Conversation',
        category,
        messages: [],
        messageCount: 0,
        createdAt: new Date(),
        lastActiveAt: new Date(),
        isPlaceholder: true,
        isActive: true
      };
      
      setConversations(prev => [placeholderConversation, ...prev]);
      setCurrentConversationId(tempId);
      setCurrentConversation(placeholderConversation);
      setMessages([]);
      setError(null);
      
      // Initialize empty context for new conversation
      setConversationContext(tempId, { resumes: [], jobs: [] });
      
      console.log('✅ Placeholder conversation created');
      return placeholderConversation;

    } catch (error) {
      console.error('Failed to create conversation:', error);
      setError('Failed to create new conversation');
      return null;
    }
  }, [setConversationContext]);

  // 🔥 SIMPLIFIED: Conversation management
  const updateConversation = useCallback(async (conversationId, updates) => {
    try {
      if (conversationId.startsWith('new-conversation-')) {
        return null;
      }

      const updatedConversation = await assistantService.updateConversation(conversationId, updates);
      
      setConversations(prev => 
        prev.map(conv => 
          conv._id === conversationId ? { ...conv, ...updatedConversation } : conv
        )
      );

      if (conversationId === currentConversationId) {
        setCurrentConversation(prev => ({ ...prev, ...updatedConversation }));
      }

      return updatedConversation;

    } catch (error) {
      console.error('Failed to update conversation:', error);
      setError('Failed to update conversation');
      return null;
    }
  }, [currentConversationId]);

  const deleteConversation = useCallback(async (conversationId, permanent = false) => {
    console.log('🗑️ Starting conversation deletion process:', {
      conversationId,
      permanent,
      currentConversationId,
      conversationsCount: conversations.length
    });

    try {
      // Validate input
      if (!conversationId) {
        throw new Error('Conversation ID is required');
      }

      // Handle placeholder conversations (new conversations that haven't been saved yet)
      if (conversationId.startsWith('new-conversation-')) {
        console.log('🔄 Deleting placeholder conversation:', conversationId);
        
        // Remove from local state immediately
        setConversations(prev => {
          const filtered = prev.filter(conv => conv._id !== conversationId);
          console.log('✅ Placeholder conversation removed, remaining:', filtered.length);
          return filtered;
        });
        
        // Remove context for deleted conversation
        setConversationContexts(prev => {
          const newMap = new Map(prev);
          newMap.delete(conversationId);
          console.log('✅ Context removed for placeholder conversation');
          return newMap;
        });
        
        // Handle current conversation switching
        if (conversationId === currentConversationId) {
          console.log('🔄 Deleted conversation was current, switching...');
          const remaining = conversations.filter(conv => conv._id !== conversationId);
          if (remaining.length > 0) {
            console.log('✅ Switching to next conversation:', remaining[0]._id);
            setCurrentConversationId(remaining[0]._id);
            setCurrentConversation(remaining[0]);
            setMessages(remaining[0].messages || []);
          } else {
            console.log('✅ No remaining conversations, clearing state');
            setCurrentConversationId(null);
            setCurrentConversation(null);
            setMessages([]);
            localStorage.removeItem(STORAGE_KEYS.currentConversationId);
          }
        }
        
        console.log('✅ Placeholder conversation deletion completed');
        return { success: true, message: 'Conversation deleted successfully' };
      }

      // For real conversations, call the API
      console.log('🌐 Calling API to delete conversation:', conversationId);
      
      const result = await assistantService.deleteConversation(conversationId, permanent);
      console.log('✅ API delete response:', result);
      
      // Update local state after successful API call
      console.log('🔄 Updating local state after successful deletion...');
      
      setConversations(prev => {
        const filtered = prev.filter(conv => conv._id !== conversationId);
        console.log('✅ Conversation removed from state, remaining:', filtered.length);
        return filtered;
      });
      
      // Remove context for deleted conversation
      setConversationContexts(prev => {
        const newMap = new Map(prev);
        newMap.delete(conversationId);
        
        // Update localStorage cache
        try {
          const cacheData = {};
          newMap.forEach((value, key) => {
            cacheData[key] = value;
          });
          localStorage.setItem(STORAGE_KEYS.conversationContexts, JSON.stringify(cacheData));
          console.log('✅ Context cache updated');
        } catch (e) {
          console.warn('Failed to update context cache:', e);
        }
        
        console.log('✅ Context removed for real conversation');
        return newMap;
      });
      
      // Handle current conversation switching if needed
      if (conversationId === currentConversationId) {
        console.log('🔄 Deleted conversation was current, switching...');
        
        // Get the current list (before the deletion)
        const remaining = conversations.filter(conv => conv._id !== conversationId);
        
        if (remaining.length > 0) {
          const nextConv = remaining[0];
          console.log('✅ Switching to next conversation:', nextConv._id);
          
          setCurrentConversationId(nextConv._id);
          setCurrentConversation(nextConv);
          setMessages(nextConv.messages || []);
          localStorage.setItem(STORAGE_KEYS.currentConversationId, nextConv._id);
        } else {
          console.log('✅ No remaining conversations, clearing state');
          setCurrentConversationId(null);
          setCurrentConversation(null);
          setMessages([]);
          localStorage.removeItem(STORAGE_KEYS.currentConversationId);
        }
      }
      
      // Clear conversation cache
      try {
        const cacheKey = `conversations_cache_${currentUser?._id}`;
        localStorage.removeItem(cacheKey);
        console.log('✅ Conversation cache cleared');
      } catch (e) {
        console.warn('Failed to clear conversation cache:', e);
      }
      
      console.log('🎉 Conversation deletion completed successfully!');
      return result || { success: true, message: 'Conversation deleted successfully' };

    } catch (error) {
      console.error('❌ Error deleting conversation:', {
        conversationId,
        error: error.message,
        stack: error.stack
      });
      
      // Set error state for user feedback
      setError(`Failed to delete conversation: ${error.message}`);
      
      // Re-throw the error so the UI can handle it
      throw error;
    }
  }, [
    currentConversationId, 
    conversations, 
    currentUser?._id, 
    STORAGE_KEYS.currentConversationId,
    STORAGE_KEYS.conversationContexts
  ]);

  // Also add this helper function to check if assistantService.deleteConversation exists
  const checkApiMethod = useCallback(() => {
    console.log('🔍 Checking assistantService.deleteConversation method:', {
      exists: typeof assistantService.deleteConversation === 'function',
      assistantService: Object.keys(assistantService)
    });
  }, []);

  // Call this once when the component mounts to verify the API method exists
  useEffect(() => {
    if (isAuthenticated) {
      checkApiMethod();
    }
  }, [isAuthenticated, checkApiMethod]);

  // 🆕 RAG: Search functionality for @-mentions
  const searchMentionItems = useCallback(async (query) => {
    try {
      const results = await assistantService.getMentionSuggestions(query);
      return results;
    } catch (error) {
      console.error('Search mention items failed:', error);
      return { resumes: [], jobs: [] };
    }
  }, []);

  // 🔥 SIMPLIFIED: Basic search
  const searchEverything = useCallback(async (query) => {
    try {
      const results = await assistantService.search(query, { limit: 10 });
      return results;
    } catch (error) {
      console.error('Search failed:', error);
      return { conversations: [], results: [] };
    }
  }, []);

  // 🔥 SIMPLIFIED: Suggestion handler
  const handleSuggestionClick = useCallback((suggestion) => {
    return sendMessage(suggestion);
  }, [sendMessage]);

  // 🔥 Initialize on auth change
  useEffect(() => {
    if (isAuthenticated && currentUser && !isInitialized) {
      if (initTimeoutRef.current) {
        clearTimeout(initTimeoutRef.current);
      }
      
      initTimeoutRef.current = setTimeout(() => {
        initializeAiAssistant();
      }, 100);
    } else if (!isAuthenticated) {
      // Reset state when user logs out
      setConversations([]);
      setCurrentConversationId(null);
      setCurrentConversation(null);
      setMessages([]);
      setConversationContexts(new Map()); // Clear RAG contexts
      setError(null);
      setIsInitialized(false);
      
      // Clear stored state
      Object.values(STORAGE_KEYS).forEach(key => {
        try {
          localStorage.removeItem(key);
        } catch (e) {}
      });
    }

    return () => {
      if (initTimeoutRef.current) {
        clearTimeout(initTimeoutRef.current);
      }
    };
  }, [isAuthenticated, currentUser, isInitialized, initializeAiAssistant, STORAGE_KEYS]);

  // 🔥 Update context on location change (throttled)
  useEffect(() => {
    if (isAuthenticated && currentUser && isInitialized) {
      const now = Date.now();
      
      if (now - lastUpdateRef.current > 500) {
        updateBasicContext();
        lastUpdateRef.current = now;
      }
    }
  }, [location.pathname, isAuthenticated, currentUser, isInitialized, updateBasicContext]);

  // 🔥 Save UI state changes (debounced)
  useEffect(() => {
    if (currentUser?._id) {
      const timeout = setTimeout(() => {
        try {
          localStorage.setItem(STORAGE_KEYS.isOpen, isOpen.toString());
        } catch (e) {}
      }, 100);
      
      return () => clearTimeout(timeout);
    }
  }, [isOpen, STORAGE_KEYS.isOpen, currentUser?._id]);

  // 🔥 Save conversation ID changes (debounced)
  useEffect(() => {
    if (currentConversationId && currentUser?._id && 
        !currentConversationId.startsWith('new-conversation-')) {
      const timeout = setTimeout(() => {
        try {
          localStorage.setItem(STORAGE_KEYS.currentConversationId, currentConversationId);
        } catch (e) {}
      }, 100);
      
      return () => clearTimeout(timeout);
    }
  }, [currentConversationId, STORAGE_KEYS.currentConversationId, currentUser?._id]);

  // 🔥 SIMPLIFIED: Context value with RAG support, no memory system
  const contextValue = {
    // UI State
    isOpen,
    setIsOpen,
    isMinimized,
    setIsMinimized,
    
    // Conversation State
    conversations,
    currentConversationId,
    setCurrentConversationId,
    currentConversation,
    setCurrentConversation,
    conversationsLoading,
    isInitialized,
    
    // 🆕 RAG Context State
    getConversationContext,
    setConversationContext,
    conversationContexts,
    
    // Context & Suggestions
    contextualSuggestions,
    
    // Chat
    messages,
    setMessages,
    isLoading,
    error,
    setError,
    
    // Core Actions
    sendMessage,
    createNewConversation,
    switchConversation,
    updateConversation,
    deleteConversation,
    handleSuggestionClick,
    searchEverything,
    
    // 🆕 RAG Actions
    searchMentionItems,
    
    // Data Loading
    loadConversations,
    
    // Utilities
    refreshContext: updateBasicContext,
    clearCache: () => {
      try {
        assistantService.clearCache();
        // Clear local caches including conversation contexts
        Object.keys(localStorage).forEach(key => {
          if (key.includes('conversations_cache_') || 
              key.includes('conversation_') ||
              key.includes('ai_contexts_')) {
            localStorage.removeItem(key);
          }
        });
        console.log('🧹 AI Assistant cache cleared (RAG mode)');
      } catch (error) {
        console.warn('Failed to clear cache:', error);
      }
    }
  };

  return (
    <AiAssistantContext.Provider value={contextValue}>
      {children}
    </AiAssistantContext.Provider>
  );
};

// 🔥 SIMPLIFIED: Performance monitoring hook (no memory tracking)
export const useAiAssistantPerformance = () => {
  const [metrics, setMetrics] = useState(null);
  
  useEffect(() => {
    const updateMetrics = () => {
      try {
        const perfData = assistantService.getPerformanceInsights?.() || null;
        setMetrics(perfData);
      } catch (error) {
        console.warn('Failed to get performance metrics:', error);
      }
    };
    
    updateMetrics();
    const interval = setInterval(updateMetrics, 30000);
    
    return () => clearInterval(interval);
  }, []);
  
  return metrics;
};

// 🔥 Connection quality hook (unchanged)
export const useConnectionQuality = () => {
  const [quality, setQuality] = useState('unknown');
  const [lastCheck, setLastCheck] = useState(0);
  
  const checkQuality = useCallback(async () => {
    const now = Date.now();
    
    if (now - lastCheck < 60000) {
      return quality;
    }
    
    try {
      const startTime = Date.now();
      const healthy = await assistantService.isAvailable();
      const duration = Date.now() - startTime;
      
      let newQuality;
      if (!healthy) {
        newQuality = 'poor';
      } else if (duration < 1000) {
        newQuality = 'excellent';
      } else if (duration < 3000) {
        newQuality = 'good';
      } else {
        newQuality = 'fair';
      }
      
      setQuality(newQuality);
      setLastCheck(now);
      
      return newQuality;
    } catch (error) {
      setQuality('poor');
      setLastCheck(now);
      return 'poor';
    }
  }, [quality, lastCheck]);
  
  return { quality, checkQuality };
};

// 🔥 Smart retry hook (unchanged)
export const useSmartRetry = () => {
  const [retryCount, setRetryCount] = useState(0);
  const [isRetrying, setIsRetrying] = useState(false);
  
  const retry = useCallback(async (operation, maxRetries = 2) => {
    if (isRetrying) return;
    
    setIsRetrying(true);
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        setRetryCount(attempt);
        const result = await operation();
        setRetryCount(0);
        setIsRetrying(false);
        return result;
      } catch (error) {
        console.log(`Retry attempt ${attempt} failed:`, error.message);
        
        if (attempt === maxRetries) {
          setIsRetrying(false);
          throw error;
        }
        
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }, [isRetrying]);
  
  return { retry, retryCount, isRetrying };
};

export default AiAssistantContext;

================
File: frontend/src/context/AuthContext.js
================
// frontend/src/context/AuthContext.js - FIXED INFINITE LOOP ISSUE
import React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';
import api, { isRateLimitError, getErrorMessage } from '../utils/axios';

// Create and export the context
export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null);
  const [token, setToken] = useState(localStorage.getItem('token'));
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Use refs to track loading state and prevent infinite loops
  const isLoadingUser = useRef(false);
  const lastUserLoadAttempt = useRef(0);

  // Load user function - memoized properly to prevent infinite loops
  const loadUser = useCallback(async (force = false) => {
    const now = Date.now();
    const timeSinceLastAttempt = now - lastUserLoadAttempt.current;
    
    // Prevent rapid successive calls unless forced
    if (!force && (timeSinceLastAttempt < 3000 || isLoadingUser.current)) {
      console.log('🔄 Skipping user load - too recent or already loading');
      setLoading(false);
      return;
    }

    if (!token) {
      console.log('🔍 No token found, skipping user load');
      setLoading(false);
      return;
    }

    try {
      isLoadingUser.current = true;
      lastUserLoadAttempt.current = now;
      console.log('🔍 Loading user with token...');
      
      // Set the token in the Authorization header
      api.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      
      const response = await api.get('/auth/me');
      console.log('✅ User loaded successfully:', response.data);
      
      if (response.data.success && response.data.data?.user) {
        setCurrentUser(response.data.data.user);
        setIsAuthenticated(true);
        setError(null);
        console.log('✅ User authenticated successfully');
      } else {
        throw new Error('Invalid response format from /auth/me');
      }
    } catch (err) {
      console.error('❌ Error loading user:', err);
      
      // Handle different error types
      if (isRateLimitError(err)) {
        console.log('⏱️ Rate limited during user load - keeping current auth state');
        setError('Too many requests. Please wait a moment.');
        // Don't clear auth state for rate limiting
      } else if (err.response?.status === 401 || err.response?.status === 403) {
        console.log('🔒 Token expired or invalid - clearing auth state');
        // Clear invalid token
        localStorage.removeItem('token');
        delete api.defaults.headers.common['Authorization'];
        setToken(null);
        setCurrentUser(null);
        setIsAuthenticated(false);
        setError(null);
      } else {
        console.log('🔥 Other error during user load');
        setError('Failed to load user session');
      }
    } finally {
      isLoadingUser.current = false;
      setLoading(false);
    }
  }, [token]); // Only depend on token

  // Load user if token exists - but only run when token actually changes
  useEffect(() => {
    const currentToken = localStorage.getItem('token');
    if (currentToken && currentToken === token) {
      loadUser(true);
    } else if (!currentToken) {
      setLoading(false);
    }
  }, [token]); // Remove loadUser from dependencies to prevent infinite loop

  // Register new user
  const register = async (userData) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Attempting registration...');
      const response = await api.post('/auth/register', userData);
      console.log('✅ Registration response:', response.data);
      
      if (response.data.success && response.data.token) {
        const { token: newToken, data } = response.data;
        
        // Store token and set auth header
        localStorage.setItem('token', newToken);
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
        
        setToken(newToken);
        setCurrentUser(data.user);
        setIsAuthenticated(true);
        
        console.log('✅ Registration successful');
        return { success: true, user: data.user };
      } else {
        throw new Error(response.data.error || 'Invalid registration response');
      }
    } catch (err) {
      console.error('❌ Registration error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Login user
  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Attempting login for:', email);
      
      const response = await api.post('/auth/login', { 
        email: email.trim(), 
        password 
      });
      
      console.log('✅ Login response:', response.data);
      
      if (response.data.success && response.data.token) {
        const { token: newToken, data } = response.data;
        
        // Store token and set auth header
        localStorage.setItem('token', newToken);
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
        
        setToken(newToken);
        setCurrentUser(data.user);
        setIsAuthenticated(true);
        setError(null);
        
        console.log('✅ Login successful for user:', data.user.email);
        return { success: true, user: data.user };
      } else {
        throw new Error(response.data.error || 'Invalid login response');
      }
    } catch (err) {
      console.error('❌ Login error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Logout user
  const logout = async () => {
    try {
      console.log('🔍 Attempting logout...');
      
      // Try to call logout endpoint with timeout
      const logoutPromise = api.post('/auth/logout');
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Logout timeout')), 5000)
      );
      
      await Promise.race([logoutPromise, timeoutPromise]);
      console.log('✅ Logout successful');
    } catch (err) {
      console.error('❌ Logout error:', err);
      console.log('⚠️ Logout API call failed, but continuing with local cleanup');
      // Continue with local cleanup even if server request fails
    } finally {
      // Always clean up local state
      localStorage.removeItem('token');
      delete api.defaults.headers.common['Authorization'];
      setToken(null);
      setCurrentUser(null);
      setIsAuthenticated(false);
      setError(null);
      console.log('✅ Local session cleared');
    }
  };

  // Forgot password
  const forgotPassword = async (email) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Requesting password reset for:', email);
      const response = await api.post('/auth/forgot-password', { email });
      console.log('✅ Password reset response:', response.data);
      
      return { 
        success: true, 
        message: response.data.data?.message || 'Reset email sent' 
      };
    } catch (err) {
      console.error('❌ Forgot password error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Reset password
  const resetPassword = async (resetToken, password) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('🔍 Attempting password reset...');
      const response = await api.put(`/auth/reset-password/${resetToken}`, { password });
      console.log('✅ Password reset response:', response.data);
      
      if (response.data.success && response.data.token) {
        const { token: newToken } = response.data;
        
        // Store new token
        localStorage.setItem('token', newToken);
        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
        setToken(newToken);
        
        return { success: true };
      } else {
        throw new Error(response.data.error || 'Invalid reset response');
      }
    } catch (err) {
      console.error('❌ Password reset error:', err);
      const errorMessage = getErrorMessage(err);
      setError(errorMessage);
      return { 
        success: false, 
        error: errorMessage
      };
    } finally {
      setLoading(false);
    }
  };

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Force refresh user data
  const refreshUser = useCallback(() => {
    if (token) {
      return loadUser(true);
    }
  }, [token, loadUser]);

  const value = {
    currentUser,
    isAuthenticated,
    loading,
    error,
    register,
    login,
    logout,
    forgotPassword,
    resetPassword,
    clearError,
    refreshUser
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

// Custom hook for easier context usage
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

// Default export (some files might expect this)
export default AuthContext;

================
File: frontend/src/hooks/useSearch.js
================
// src/hooks/useSearch.js
import { useState, useEffect, useCallback, useRef } from 'react';
import searchService from '../utils/searchService';

/**
 * Custom hook for managing search functionality
 */
const useSearch = (options = {}) => {
  const {
    initialQuery = '',
    initialCategory = 'all',
    autoSearch = true,
    debounceDelay = 300,
    enableSuggestions = true,
    onSearchComplete = null,
    onError = null
  } = options;

  // State
  const [query, setQuery] = useState(initialQuery);
  const [category, setCategory] = useState(initialCategory);
  const [results, setResults] = useState(null);
  const [suggestions, setSuggestions] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [recentSearches, setRecentSearches] = useState([]);

  // Refs
  const debouncedSearchRef = useRef(null);
  const abortControllerRef = useRef(null);

  // Initialize debounced search
  useEffect(() => {
    debouncedSearchRef.current = searchService.createDebouncedSearch(
      performSearch,
      debounceDelay
    );
  }, [category, debounceDelay]);

  // Load recent searches on mount
  useEffect(() => {
    const recent = searchService.getRecentSearches();
    setRecentSearches(recent);
  }, []);

  // Auto-search when query changes
  useEffect(() => {
    if (autoSearch && query.trim().length >= 2) {
      if (debouncedSearchRef.current) {
        debouncedSearchRef.current(query);
      }
    } else if (query.trim().length === 0) {
      clearResults();
    }
  }, [query, autoSearch]);

  // Load suggestions when query changes
  useEffect(() => {
    if (enableSuggestions && query.length >= 1 && query.length < 2) {
      loadSuggestions(query);
    }
  }, [query, enableSuggestions]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  const performSearch = useCallback(async (searchQuery) => {
    if (!searchQuery || searchQuery.trim().length < 2) {
      return;
    }

    try {
      // Cancel previous request
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }

      setIsLoading(true);
      setError(null);

      // Create new abort controller
      abortControllerRef.current = new AbortController();

      const searchResults = await searchService.globalSearch(searchQuery, {
        category,
        limit: 20
      });

      if (searchResults.success) {
        const formattedResults = searchService.formatSearchResults(searchResults.data.results);
        setResults(formattedResults);
        
        // Save to recent searches
        searchService.saveRecentSearch(searchQuery, searchResults.data.results);
        
        // Update recent searches state
        const updatedRecent = searchService.getRecentSearches();
        setRecentSearches(updatedRecent);

        // Call completion callback
        if (onSearchComplete) {
          onSearchComplete(formattedResults, searchQuery);
        }
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        const errorMessage = err.response?.data?.error || err.message || 'Search failed';
        setError(errorMessage);
        
        if (onError) {
          onError(err);
        }
      }
    } finally {
      setIsLoading(false);
    }
  }, [category, onSearchComplete, onError]);

  const loadSuggestions = useCallback(async (searchQuery) => {
    try {
      const suggestionsData = await searchService.getSuggestions(searchQuery);
      setSuggestions(suggestionsData.suggestions || []);
    } catch (err) {
      console.error('Error loading suggestions:', err);
      setSuggestions([]);
    }
  }, []);

  const clearResults = useCallback(() => {
    setResults(null);
    setSuggestions([]);
    setError(null);
  }, []);

  const clearAll = useCallback(() => {
    setQuery('');
    clearResults();
  }, [clearResults]);

  const search = useCallback((searchQuery, searchCategory = category) => {
    setQuery(searchQuery);
    setCategory(searchCategory);
    performSearch(searchQuery);
  }, [category, performSearch]);

  const searchInCategory = useCallback((searchCategory) => {
    setCategory(searchCategory);
    if (query.trim().length >= 2) {
      performSearch(query);
    }
  }, [query, performSearch]);

  const retrySearch = useCallback(() => {
    if (query.trim().length >= 2) {
      performSearch(query);
    }
  }, [query, performSearch]);

  const getResultsForCategory = useCallback((categoryName) => {
    return results?.[categoryName] || [];
  }, [results]);

  const getTotalResults = useCallback(() => {
    return results?.totalCount || 0;
  }, [results]);

  const hasResults = useCallback(() => {
    return getTotalResults() > 0;
  }, [getTotalResults]);

  const hasResultsForCategory = useCallback((categoryName) => {
    return getResultsForCategory(categoryName).length > 0;
  }, [getResultsForCategory]);

  const searchSpecificCategory = useCallback(async (searchQuery, categoryName) => {
    try {
      setIsLoading(true);
      setError(null);

      let categoryResults = [];
      
      switch (categoryName) {
        case 'jobs':
          categoryResults = await searchService.searchJobs(searchQuery);
          break;
        case 'resumes':
          categoryResults = await searchService.searchResumes(searchQuery);
          break;
        case 'recruiters':
          categoryResults = await searchService.searchRecruiters(searchQuery);
          break;
        default:
          throw new Error('Invalid category');
      }

      return categoryResults;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const validateQuery = useCallback((searchQuery) => {
    return searchService.validateSearchQuery(searchQuery);
  }, []);

  const highlightText = useCallback((text, highlightQuery = query) => {
    return searchService.highlightSearchTerms(text, highlightQuery);
  }, [query]);

  const addToRecentSearches = useCallback((searchQuery) => {
    searchService.saveRecentSearch(searchQuery, results || { totalCount: 0 });
    const updatedRecent = searchService.getRecentSearches();
    setRecentSearches(updatedRecent);
  }, [results]);

  const clearRecentSearches = useCallback(() => {
    searchService.clearRecentSearches();
    setRecentSearches([]);
  }, []);

  // Return search state and methods
  return {
    // State
    query,
    category,
    results,
    suggestions,
    isLoading,
    error,
    recentSearches,

    // Actions
    setQuery,
    setCategory,
    search,
    searchInCategory,
    searchSpecificCategory,
    clearResults,
    clearAll,
    retrySearch,
    addToRecentSearches,
    clearRecentSearches,

    // Utilities
    getResultsForCategory,
    getTotalResults,
    hasResults,
    hasResultsForCategory,
    validateQuery,
    highlightText,

    // Categories
    categories: searchService.getSearchCategories(),

    // Keyboard shortcuts
    shortcuts: searchService.getKeyboardShortcuts()
  };
};

export default useSearch;

================
File: frontend/src/index.css
================
/* src/index.css */
html {
  font-size: 90%;
  -webkit-text-size-adjust: 90%;
  -ms-text-size-adjust: 90%;
  height: 100%;
  overflow: hidden; /* Prevent body scroll */
}

body {
  margin: 0;
  padding: 0;
  font-family: 'Inter', 'Roboto', 'Segoe UI', -apple-system, BlinkMacSystemFont, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  box-sizing: border-box;
  height: 100vh;
  overflow: hidden; /* Prevent body scroll */
}

*, *:before, *:after {
  box-sizing: inherit;
}

/* Apply to the root app container for consistent scaling */
#root {
  width: 100%;
  height: 100vh;
  overflow: hidden; /* Ensure root container doesn't scroll */
}

/* Adjust any fixed pixel sizes that might need manual adjustment */
.MuiDialog-paper {
  max-width: calc(600px * 1.11) !important;
}

/* For any components with fixed dimensions that need adjustment */
.fixed-width-element {
  width: calc(300px * 1.11) !important;
}

.fixed-height-element {
  height: calc(200px * 1.11) !important;
}

/* Ensure proper scrollbar styling globally */
* {
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
}

*::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

*::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.04);
  border-radius: 3px;
}

*::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

*::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.3);
}

*::-webkit-scrollbar-corner {
  background: transparent;
}

/* Ensure Material-UI components respect the layout */
.MuiAppBar-root {
  position: static !important;
}

/* Prevent any unwanted scrolling in layout components */
.layout-container {
  height: 100vh;
  overflow: hidden;
}

.content-container {
  height: 100%;
  overflow-y: auto;
}

================
File: frontend/src/index.js
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import ThemeProvider from './ThemeProvider'
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(
  <ThemeProvider>
    <App />
  </ThemeProvider>
)

================
File: frontend/src/ThemeProvider.js
================
// src/ThemeProvider.js
import { createTheme, ThemeProvider as MuiThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';

// Define the auto-job.ai theme with 90% scaling
const theme = createTheme({
  palette: {
    primary: {
      main: '#1a73e8', // Deep blue
      light: '#4285f4',
      dark: '#0d47a1',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#00c4b4', // Teal accent
      light: '#33d1c1',
      dark: '#00897b',
      contrastText: '#ffffff',
    },
    success: {
      main: '#34a853',
      light: '#5cb85c',
      dark: '#2e7d32',
    },
    warning: {
      main: '#fbbc04',
      light: '#ffcd38',
      dark: '#f57c00',
    },
    error: {
      main: '#ea4335',
      light: '#ef5350',
      dark: '#c62828',
    },
    info: {
      main: '#4285f4',
      light: '#64b5f6',
      dark: '#1976d2',
    },
    background: {
      default: '#f5f7fa', // Light gray background
      paper: '#ffffff',
    },
    text: {
      primary: '#202124',
      secondary: '#5f6368',
      disabled: '#9aa0a6',
    },
    divider: 'rgba(0, 0, 0, 0.12)',
  },
  typography: {
    // Apply 90% scaling to the base font size
    fontSize: 14 * 0.9,
    fontFamily: [
      'Inter',
      'Roboto',
      '"Segoe UI"',
      '-apple-system',
      'BlinkMacSystemFont',
      'Arial',
      'sans-serif',
    ].join(','),
    h1: {
      fontSize: '2.5rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 600,
      lineHeight: 1.3,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 600,
      lineHeight: 1.3,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h6: {
      fontSize: '1.125rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    subtitle1: {
      fontSize: '1rem',
      fontWeight: 500,
      lineHeight: 1.5,
    },
    subtitle2: {
      fontSize: '0.875rem',
      fontWeight: 500,
      lineHeight: 1.5,
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.5,
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.5,
    },
    button: {
      fontSize: '0.875rem',
      fontWeight: 600,
      textTransform: 'none',
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        html: {
          fontSize: '90%', // Set root font size to 90%
          WebkitTextSizeAdjust: '90%',
          MsTextSizeAdjust: '90%',
        },
        '*, *::before, *::after': {
          boxSizing: 'border-box',
        },
        body: {
          margin: 0,
          padding: 0,
          WebkitFontSmoothing: 'antialiased',
          MozOsxFontSmoothing: 'grayscale',
        },
        // Custom Scrollbar Styles - Minimal Design
        '*::-webkit-scrollbar': {
          width: '4px',
          height: '4px',
        },
        '*::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        '*::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.2)',
          borderRadius: '2px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.3)',
          },
          '&:active': {
            backgroundColor: 'rgba(0, 0, 0, 0.4)',
          },
        },
        '*::-webkit-scrollbar-corner': {
          backgroundColor: 'transparent',
        },
        // Firefox scrollbar styling
        '*': {
          scrollbarWidth: 'thin',
          scrollbarColor: 'rgba(0, 0, 0, 0.2) transparent',
        },
        // Dialog scrollbars - even thinner
        '.MuiDialog-paper::-webkit-scrollbar': {
          width: '3px',
        },
        '.MuiDialog-paper::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.15)',
          borderRadius: '1.5px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.25)',
          },
        },
        '.MuiDialog-paper::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        // Menu and dropdown scrollbars - ultra thin
        '.MuiMenu-paper::-webkit-scrollbar, .MuiSelect-paper::-webkit-scrollbar': {
          width: '2px',
        },
        '.MuiMenu-paper::-webkit-scrollbar-thumb, .MuiSelect-paper::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.15)',
          borderRadius: '1px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.25)',
          },
        },
        '.MuiMenu-paper::-webkit-scrollbar-track, .MuiSelect-paper::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
        // Textarea scrollbars
        'textarea::-webkit-scrollbar': {
          width: '4px',
        },
        'textarea::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.2)',
          borderRadius: '2px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.3)',
          },
        },
        'textarea::-webkit-scrollbar-track': {
          backgroundColor: 'transparent',
        },
      },
    },
    MuiButton: {
      defaultProps: {
        disableElevation: true,
      },
      styleOverrides: {
        root: {
          padding: '8px 16px',
          borderRadius: 8,
        },
        contained: {
          boxShadow: '0px 3px 5px -1px rgba(0,0,0,0.08), 0px 6px 10px 0px rgba(0,0,0,0.05), 0px 1px 18px 0px rgba(0,0,0,0.04)',
          '&:hover': {
            boxShadow: '0px 6px 10px -1px rgba(0,0,0,0.1), 0px 10px 14px 0px rgba(0,0,0,0.07), 0px 1px 18px 0px rgba(0,0,0,0.06)',
          },
        },
      },
    },
    MuiTextField: {
      defaultProps: {
        variant: 'outlined',
      },
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0px 4px 8px rgba(0, 0, 0, 0.05)',
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        elevation1: {
          boxShadow: '0px 4px 8px rgba(0, 0, 0, 0.05)',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.08)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiListItemButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          '&.Mui-selected': {
            backgroundColor: 'rgba(26, 115, 232, 0.1)',
            color: '#1a73e8',
            '&:hover': {
              backgroundColor: 'rgba(26, 115, 232, 0.15)',
            },
            '& .MuiListItemIcon-root': {
              color: '#1a73e8',
            },
          },
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          borderRight: '1px solid rgba(0, 0, 0, 0.12)',
        },
      },
    },
    MuiLinearProgress: {
      styleOverrides: {
        root: {
          borderRadius: 4,
          height: 8,
          backgroundColor: 'rgba(0, 0, 0, 0.06)',
        },
      },
    },
    MuiAvatar: {
      styleOverrides: {
        root: {
          backgroundColor: '#1a73e8',
        },
      },
    },
    // Adjust container widths to compensate for 90% scaling
    MuiContainer: {
      styleOverrides: {
        root: {
          // Counter the 90% scaling by making containers slightly larger
          '@media (min-width:600px)': {
            maxWidth: 'calc(600px * 1.11)',
          },
          '@media (min-width:900px)': {
            maxWidth: 'calc(900px * 1.11)',
          },
          '@media (min-width:1200px)': {
            maxWidth: 'calc(1200px * 1.11)',
          },
          '@media (min-width:1536px)': {
            maxWidth: 'calc(1536px * 1.11)',
          },
        },
      },
    },
  },
});

export default function ThemeProvider({ children }) {
  return (
    <MuiThemeProvider theme={theme}>
      <CssBaseline />
      {children}
    </MuiThemeProvider>
  );
}

================
File: frontend/src/utils/assistantService.js
================
// src/utils/assistantService.js - FIXED VERSION WITH WORKING DELETE
import api from './axios';

const assistantService = {
  // ===================================================================
  // 🆕 RAG: @-MENTION FUNCTIONALITY 
  // ===================================================================

  /**
   * Get mention suggestions for @-functionality (RAG)
   */
  getMentionSuggestions: async (query = '') => {
    try {
      console.log('🔍 Loading mention suggestions for:', query);
      
      const params = new URLSearchParams();
      if (query) params.append('query', query);
      
      const response = await api.get(`/assistant/mention-suggestions?${params}`, {
        timeout: 10000
      });
      
      const results = response.data;
      
      console.log('✅ Mention suggestions loaded:', {
        resumes: results.resumes?.length || 0,
        jobs: results.jobs?.length || 0
      });
      
      return {
        resumes: results.resumes || [],
        jobs: results.jobs || []
      };

    } catch (error) {
      console.error('Failed to load mention suggestions:', error);
      return { resumes: [], jobs: [] };
    }
  },

  /**
   * Get full context data for mentioned item (RAG)
   */
  getContextData: async (type, id) => {
    try {
      console.log('📄 Loading context data for:', type, id);
      
      const response = await api.get(`/assistant/context-data/${type}/${id}`, {
        timeout: 15000
      });
      
      console.log('✅ Context data loaded for:', type);
      return response.data;

    } catch (error) {
      console.error('Failed to load context data:', error);
      throw error;
    }
  },

  // ===================================================================
  // ENHANCED CHAT WITH RAG CONTEXT
  // ===================================================================

  /**
   * Send message to AI Assistant with RAG context
   */
  sendMessage: async (requestData) => {
    try {
      const {
        message,
        context = {},
        conversationId,
        newConversation = false
      } = requestData;

      console.log('🚀 RAG AI Request:', { 
        message: message.substring(0, 30) + '...', 
        conversationId, 
        newConversation,
        hasAttachedResumes: context.attachedResumes?.length > 0,
        hasAttachedJobs: context.attachedJobs?.length > 0
      });

      // 🆕 Enhanced context with RAG data
      const ragContext = {
        page: context.page || 'unknown',
        conversationId: context.conversationId,
        // RAG: Include full attached resume/job data
        attachedResumes: context.attachedResumes || [],
        attachedJobs: context.attachedJobs || [],
        // Legacy context support
        currentResume: context.currentResume || null,
        currentJob: context.currentJob || null
      };

      const response = await api.post('/assistant/chat', {
        message,
        context: ragContext,
        conversationId,
        newConversation
      }, {
        timeout: 60000 // Extended timeout for RAG processing
      });

      console.log('✅ RAG AI Response received:', {
        duration: response.data.performance?.totalDuration || 'unknown',
        hasContextualSuggestions: response.data.suggestions?.length > 0
      });

      return {
        message: response.data.message,
        suggestions: response.data.suggestions || [],
        actions: response.data.actions || [],
        confidence: response.data.confidence || 0.8,
        conversationId: response.data.conversationId,
        conversationTitle: response.data.conversationTitle,
        usage: response.data.usage || {},
        performance: response.data.performance || {},
        // Resume update data
        resumeUpdated: response.data.resumeUpdated || false,
        newAnalysis: response.data.newAnalysis || null,
        resumeChanges: response.data.resumeChanges || null,
        // RAG metadata
        contextUsed: response.data.contextUsed || false,
        ragInsights: response.data.ragInsights || null
      };

    } catch (error) {
      console.error('🔥 RAG AI Service Error:', error);
      
      // Enhanced error handling for RAG requests
      if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
        const hasContext = requestData.context?.attachedResumes?.length > 0 || 
                          requestData.context?.attachedJobs?.length > 0;
        
        if (hasContext) {
          throw new Error('Processing your request with the attached context is taking longer than expected. Please try a more specific question.');
        } else {
          throw new Error('AI response took longer than expected. Please try a shorter message.');
        }
      } else if (error.response?.status === 503) {
        throw new Error('AI service temporarily busy. Please try again in a moment.');
      } else if (error.response?.status === 429) {
        throw new Error('Too many requests. Please wait 30 seconds before trying again.');
      } else {
        const fallbackMessage = requestData.context?.attachedResumes?.length > 0 
          ? 'I can help with resume analysis, but I\'m experiencing connectivity issues. Please try again.'
          : requestData.context?.attachedJobs?.length > 0
          ? 'I can help with job analysis, but I\'m experiencing connectivity issues. Please try again.'
          : 'AI service temporarily unavailable. Please try again.';
        throw new Error(fallbackMessage);
      }
    }
  },

  // ===================================================================
  // CONVERSATION MANAGEMENT (unchanged)
  // ===================================================================

  getConversations: async (options = {}) => {
    try {
      const params = new URLSearchParams();
      
      if (options.limit) params.append('limit', Math.min(options.limit, 20));
      if (options.offset) params.append('offset', options.offset);
      params.append('sortBy', 'lastActiveAt');

      const response = await api.get(`/assistant/conversations?${params}`, {
        timeout: 15000
      });
      
      return response.data;

    } catch (error) {
      console.error('Error fetching conversations:', error);
      // Return cached data if available
      try {
        const cached = localStorage.getItem('conversations_cache');
        if (cached) {
          const parsedCache = JSON.parse(cached);
          if (Date.now() - parsedCache.timestamp < 5 * 60 * 1000) {
            console.log('📋 Using cached conversations due to error');
            return parsedCache.data;
          }
        }
      } catch (cacheError) {
        console.warn('Cache retrieval failed:', cacheError);
      }
      throw error;
    }
  },

  getConversation: async (conversationId) => {
    try {
      const response = await api.get(`/assistant/conversations/${conversationId}`, {
        timeout: 10000
      });
      
      // Cache the conversation for faster access
      try {
        const cacheKey = `conversation_${conversationId}`;
        localStorage.setItem(cacheKey, JSON.stringify({
          data: response.data.conversation,
          timestamp: Date.now()
        }));
      } catch (cacheError) {
        console.warn('Failed to cache conversation:', cacheError);
      }
      
      return response.data.conversation;
    } catch (error) {
      console.error('Error fetching conversation:', error);
      
      // Try cache fallback
      try {
        const cacheKey = `conversation_${conversationId}`;
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
          const parsedCache = JSON.parse(cached);
          if (Date.now() - parsedCache.timestamp < 10 * 60 * 1000) {
            console.log('📋 Using cached conversation due to error');
            return parsedCache.data;
          }
        }
      } catch (cacheError) {
        console.warn('Cache retrieval failed:', cacheError);
      }
      
      throw error;
    }
  },

  updateConversation: async (conversationId, updates) => {
    try {
      const response = await api.put(`/assistant/conversations/${conversationId}`, updates, {
        timeout: 5000
      });
      
      // Clear cached conversation
      try {
        localStorage.removeItem(`conversation_${conversationId}`);
      } catch (e) {}
      
      return response.data.conversation;
    } catch (error) {
      console.error('Error updating conversation:', error);
      throw error;
    }
  },

  /**
   * Delete a conversation - FIXED VERSION
   */
  deleteConversation: async (conversationId, permanent = false) => {
    console.log('🌐 assistantService.deleteConversation called:', {
      conversationId,
      permanent,
      baseURL: api.defaults.baseURL
    });

    try {
      // Validate input
      if (!conversationId) {
        throw new Error('Conversation ID is required for deletion');
      }

      // Make API call
      console.log('📡 Making DELETE request to:', `/assistant/conversations/${conversationId}`);
      
      const response = await api.delete(`/assistant/conversations/${conversationId}`, {
        params: { permanent: permanent.toString() },
        timeout: 10000 // 10 second timeout
      });

      console.log('✅ Delete conversation API response:', {
        status: response.status,
        data: response.data
      });

      // Handle the response
      if (response.data && response.data.success !== false) {
        // Clear cached conversation
        try {
          localStorage.removeItem(`conversation_${conversationId}`);
          // Also clear conversations cache to force refresh
          const cacheKeys = Object.keys(localStorage);
          cacheKeys.forEach(key => {
            if (key.includes('conversations_cache')) {
              localStorage.removeItem(key);
            }
          });
        } catch (e) {
          console.warn('Failed to clear cache:', e);
        }

        return {
          success: true,
          message: response.data.message || 'Conversation deleted successfully',
          data: response.data
        };
      } else {
        throw new Error(response.data?.error || 'Failed to delete conversation');
      }

    } catch (error) {
      console.error('❌ assistantService.deleteConversation error:', {
        message: error.message,
        status: error.response?.status,
        statusText: error.response?.statusText,
        responseData: error.response?.data,
        conversationId
      });

      // Handle different types of errors
      if (error.response) {
        // Server responded with error status
        const status = error.response.status;
        const errorMessage = error.response.data?.error || error.response.data?.message || 'Unknown server error';
        
        switch (status) {
          case 404:
            throw new Error('Conversation not found - it may have already been deleted');
          case 403:
            throw new Error('You do not have permission to delete this conversation');
          case 401:
            throw new Error('Authentication required - please log in again');
          case 500:
            throw new Error('Server error occurred while deleting conversation');
          default:
            throw new Error(`Server error (${status}): ${errorMessage}`);
        }
      } else if (error.code === 'ECONNABORTED') {
        throw new Error('Request timed out - please check your connection and try again');
      } else if (error.request) {
        throw new Error('Network error - please check your connection and try again');
      } else {
        throw new Error(`Request setup error: ${error.message}`);
      }
    }
  },

  // ===================================================================
  // 🆕 ENHANCED RESUME OPERATIONS WITH RAG
  // ===================================================================

  /**
   * Analyze resume with enhanced context
   */
  analyzeResume: async (resumeId, contextData = {}) => {
    try {
      const response = await api.post('/assistant/analyze-resume', {
        resumeId,
        context: contextData
      }, {
        timeout: 30000
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing resume:', error);
      throw error;
    }
  },

  /**
   * Apply resume changes with context
   */
  applyResumeChanges: async (resumeId, changes, contextData = {}) => {
    try {
      const response = await api.post('/assistant/apply-resume-changes', {
        resumeId,
        changes,
        context: contextData
      }, {
        timeout: 45000
      });

      return response.data;

    } catch (error) {
      console.error('Error applying resume changes:', error);
      throw error;
    }
  },

  /**
   * Optimize resume for ATS with job context
   */
  optimizeForATS: async (resumeId, targetJobData = null) => {
    try {
      const response = await api.post('/assistant/optimize-ats', {
        resumeId,
        targetJob: targetJobData
      }, {
        timeout: 45000
      });

      return response.data;

    } catch (error) {
      console.error('Error optimizing for ATS:', error);
      throw error;
    }
  },

  // ===================================================================
  // 🆕 JOB ANALYSIS WITH RAG
  // ===================================================================

  /**
   * Analyze job posting with resume context
   */
  analyzeJobMatch: async (jobId, resumeData = null) => {
    try {
      const response = await api.post('/assistant/analyze-job-match', {
        jobId,
        resume: resumeData
      }, {
        timeout: 30000
      });

      return response.data;

    } catch (error) {
      console.error('Error analyzing job match:', error);
      throw error;
    }
  },

  /**
   * Generate cover letter with full context
   */
  generateCoverLetter: async (resumeData, jobData, customizations = {}) => {
    try {
      const response = await api.post('/assistant/generate-cover-letter', {
        resume: resumeData,
        job: jobData,
        customizations
      }, {
        timeout: 30000
      });

      return response.data;

    } catch (error) {
      console.error('Error generating cover letter:', error);
      throw error;
    }
  },

  // ===================================================================
  // SEARCH & SYSTEM (updated)
  // ===================================================================

  /**
   * Search with enhanced filtering
   */
  search: async (query, options = {}) => {
    try {
      const params = new URLSearchParams();
      params.append('query', query);
      if (options.limit) params.append('limit', Math.min(options.limit, 10));
      if (options.type) params.append('type', options.type);

      const response = await api.get(`/assistant/search?${params}`, {
        timeout: 10000
      });
      return response.data.results;

    } catch (error) {
      console.error('Error searching:', error);
      return { conversations: [], results: [] };
    }
  },

  /**
   * Check AI Assistant health
   */
  checkHealth: async () => {
    try {
      const response = await api.get('/assistant/health', {
        timeout: 5000
      });
      return response.data;
    } catch (error) {
      console.error('Health check failed:', error);
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  },

  /**
   * Get AI capabilities (updated for RAG)
   */
  getCapabilities: async () => {
    try {
      const response = await api.get('/assistant/capabilities', {
        timeout: 5000
      });
      return response.data;
    } catch (error) {
      console.error('Error getting AI capabilities:', error);
      return {
        available: false,
        features: ['basic_chat', 'rag_context'],
        limitations: ['Service unavailable'],
        performance: {
          optimized: false,
          ragEnabled: false
        }
      };
    }
  },

  // ===================================================================
  // UTILITY FUNCTIONS (enhanced)
  // ===================================================================

  /**
   * Validate message before sending (updated)
   */
  validateMessage: (message) => {
    if (!message || typeof message !== 'string') {
      return { valid: false, error: 'Message must be a non-empty string' };
    }

    if (message.trim().length === 0) {
      return { valid: false, error: 'Message cannot be empty' };
    }

    if (message.length > 3000) { // Increased limit for RAG context
      return { valid: false, error: 'Message too long (max 3000 characters)' };
    }

    return { valid: true };
  },

  /**
   * Format AI response for display (enhanced)
   */
  formatResponse: (response) => {
    if (!response || typeof response !== 'string') {
      return 'I encountered an issue processing that request. Please try again.';
    }

    // Enhanced formatting for RAG responses
    let formatted = response
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/`(.*?)`/g, '<code>$1</code>')
      .trim();

    return formatted;
  },

  /**
   * Check if AI service is available
   */
  isAvailable: async () => {
    try {
      const health = await assistantService.checkHealth();
      return health.status === 'healthy';
    } catch (error) {
      return false;
    }
  },

  /**
   * Get contextual suggestions based on attached items (RAG)
   */
  getContextualSuggestions: (attachedResumes = [], attachedJobs = []) => {
    const hasResume = attachedResumes.length > 0;
    const hasJob = attachedJobs.length > 0;

    if (hasResume && hasJob) {
      return [
        'How well do I match this job?',
        'Tailor my resume for this role',
        'Generate interview questions',
        'Write a cover letter',
        'What skills am I missing?'
      ];
    }
    
    if (hasResume) {
      return [
        'Improve this resume',
        'Optimize for ATS',
        'Add missing skills',
        'Enhance work experience',
        'Check keyword optimization'
      ];
    }
    
    if (hasJob) {
      return [
        'Analyze this job posting',
        'What skills are required?',
        'Research the company',
        'Interview preparation tips',
        'Salary expectations'
      ];
    }

    return [
      'Help improve my resume',
      'Find job opportunities', 
      'Career guidance',
      'Interview preparation'
    ];
  },

  /**
   * Get fallback suggestions for errors
   */
  getFallbackSuggestions: (attachedResumes = [], attachedJobs = []) => {
    return assistantService.getContextualSuggestions(attachedResumes, attachedJobs);
  },

  /**
   * Get contextual fallback message (enhanced for RAG)
   */
  getContextualFallback: (message, attachedResumes = [], attachedJobs = []) => {
    const messageLower = message?.toLowerCase() || '';
    const hasResume = attachedResumes.length > 0;
    const hasJob = attachedJobs.length > 0;

    if (hasResume && hasJob) {
      return {
        message: `I can help you analyze how well your resume "${attachedResumes[0].name}" matches the "${attachedJobs[0].title}" position. What would you like me to focus on?`,
        suggestions: assistantService.getContextualSuggestions(attachedResumes, attachedJobs)
      };
    }

    if (hasResume) {
      return {
        message: `I can help improve your resume "${attachedResumes[0].name}"! I can edit content, optimize for ATS, and provide suggestions. What would you like me to help with?`,
        suggestions: assistantService.getContextualSuggestions(attachedResumes, attachedJobs)
      };
    }

    if (hasJob) {
      return {
        message: `I can help you with the "${attachedJobs[0].title}" position at ${attachedJobs[0].company}. What specific analysis would you like?`,
        suggestions: assistantService.getContextualSuggestions(attachedResumes, attachedJobs)
      };
    }

    if (messageLower.includes('resume')) {
      return {
        message: "I can help improve your resume! Use @ to select a specific resume for detailed assistance.",
        suggestions: [
          'Type @ to select a resume',
          'Upload a new resume',
          'Resume optimization tips',
          'ATS best practices'
        ]
      };
    }

    if (messageLower.includes('job')) {
      return {
        message: "I can help with job applications and matching! Use @ to select a specific job for analysis.",
        suggestions: [
          'Type @ to select a job',
          'Job search strategies',
          'Interview preparation',
          'Application tips'
        ]
      };
    }

    return {
      message: "I'm here to help with your career! Use @ to reference specific resumes or jobs for contextual assistance.",
      suggestions: [
        'Type @ to add context',
        'Improve my resume',
        'Find job opportunities',
        'Career advice'
      ]
    };
  },

  /**
   * Clear cached data (enhanced for RAG)
   */
  clearCache: () => {
    try {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.includes('conversation_') || 
            key.includes('conversations_cache') ||
            key.includes('ai_contexts_') ||
            key.includes('mention_cache_') ||
            key.includes('context_data_')) {
          localStorage.removeItem(key);
        }
      });
      console.log('🧹 AI Assistant cache cleared (RAG mode)');
    } catch (error) {
      console.warn('Failed to clear cache:', error);
    }
  },

  /**
   * Estimate tokens for message with context (enhanced)
   */
  estimateTokens: (text, contextData = {}) => {
    let baseTokens = Math.ceil(text.length / 4);
    
    // Add tokens for attached context
    if (contextData.attachedResumes?.length > 0) {
      baseTokens += 500; // Estimate for resume context
    }
    if (contextData.attachedJobs?.length > 0) {
      baseTokens += 300; // Estimate for job context
    }
    
    return baseTokens;
  }
};

export default assistantService;

================
File: frontend/src/utils/axios.js
================
// frontend/src/utils/axios.js - ENHANCED WITH RATE LIMITING PROTECTION
import axios from 'axios';

// Determine the API base URL based on environment
const getApiBaseUrl = () => {
  // Use environment variable if available, otherwise fallback to localhost
  return process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
};

// Create axios instance with base configuration
const api = axios.create({
  baseURL: getApiBaseUrl(),
  withCredentials: true, // Send cookies with requests
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
  timeout: 60000, // 60 second timeout for AI requests
});

// Debug log to see which API URL is being used
console.log('🔗 API Base URL:', getApiBaseUrl());

// Rate limiting state
let isRateLimited = false;
let rateLimitTimeout = null;
let retryQueue = [];

// Helper function to handle rate limit delays
const handleRateLimit = (retryAfter = 60) => {
  console.log(`⏱️ Rate limited - waiting ${retryAfter} seconds before retrying`);
  isRateLimited = true;
  
  if (rateLimitTimeout) {
    clearTimeout(rateLimitTimeout);
  }
  
  rateLimitTimeout = setTimeout(() => {
    console.log('✅ Rate limit window expired, resuming requests');
    isRateLimited = false;
    
    // Process any queued requests
    const queue = [...retryQueue];
    retryQueue = [];
    queue.forEach(({ resolve, config }) => {
      api.request(config).then(resolve).catch(err => {
        // If still rate limited, re-queue
        if (err.response?.status === 429) {
          retryQueue.push({ resolve, config });
        } else {
          resolve(Promise.reject(err));
        }
      });
    });
  }, retryAfter * 1000);
};

// Request interceptor to add auth token and handle requests
api.interceptors.request.use(
  (config) => {
    // Add timestamp to prevent caching issues
    config.metadata = { startTime: new Date() };
    
    // Get token from localStorage
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // Log request in development
    if (process.env.NODE_ENV === 'development') {
      console.log(`🚀 API Request: ${config.method?.toUpperCase()} ${config.baseURL}${config.url}`);
    }
    
    return config;
  },
  (error) => {
    console.error('❌ Request interceptor error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor to handle responses and errors
api.interceptors.response.use(
  (response) => {
    // Log response time in development
    if (process.env.NODE_ENV === 'development' && response.config.metadata) {
      const duration = new Date() - response.config.metadata.startTime;
      console.log(`✅ API Response: ${response.config.method?.toUpperCase()} ${response.config.url} - ${duration}ms - Status: ${response.status}`);
    }
    
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    
    // Log error details
    console.error('❌ API Error Details:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      url: error.config?.url,
      method: error.config?.method?.toUpperCase(),
      responseData: error.response?.data,
      timeout: error.config?.timeout
    });
    
    // Handle rate limiting (429) - NEW FEATURE
    if (error.response?.status === 429) {
      const retryAfter = parseInt(error.response.headers['retry-after']) || 60;
      
      console.warn(`⏱️ Rate limited - too many requests. Waiting ${retryAfter} seconds.`);
      
      // If not already handling rate limit, start the delay
      if (!isRateLimited) {
        handleRateLimit(retryAfter);
      }
      
      // Queue the request for retry
      return new Promise((resolve) => {
        retryQueue.push({ resolve, config: originalRequest });
      });
    }
    
    // Handle different types of errors
    if (error.response) {
      // Server responded with error status
      const { status, data } = error.response;
      
      switch (status) {
        case 401:
          // Unauthorized - token expired or invalid
          console.warn('🔒 Authentication error - clearing token and redirecting');
          localStorage.removeItem('token');
          delete api.defaults.headers.common['Authorization'];
          
          // Only redirect if not already on auth pages
          const currentPath = window.location.pathname;
          if (!currentPath.includes('/login') && 
              !currentPath.includes('/register') && 
              !currentPath.includes('/forgot-password') &&
              !currentPath.includes('/reset-password')) {
            
            // Use a small delay to prevent multiple redirects
            setTimeout(() => {
              window.location.href = '/login?expired=true';
            }, 100);
          }
          break;
          
        case 403:
          // Forbidden - user doesn't have permission
          console.warn('🚫 Access forbidden:', data?.error || 'Permission denied');
          break;
          
        case 404:
          // Not found - API endpoint doesn't exist
          console.warn('🔍 API endpoint not found:', error.config?.url);
          console.warn('💡 Check if the backend server is running and routes are properly configured');
          break;
          
        case 429:
          // Rate limited - already handled above
          console.warn('⏱️ Rate limited - request queued for retry');
          break;
          
        case 500:
          // Server error
          console.error('🔥 Server error occurred');
          break;
          
        default:
          console.error(`❌ HTTP ${status}:`, data?.error || error.message);
      }
      
      // Enhance error object with additional info
      error.isApiError = true;
      error.apiStatus = status;
      error.apiMessage = data?.error || data?.message || 'An error occurred';
      
    } else if (error.request) {
      // Network error - no response received
      if (error.code === 'ECONNABORTED' && error.message.includes('timeout')) {
        console.error('⏱️ Request timed out after', error.config?.timeout, 'ms');
        error.isTimeoutError = true;
        error.apiMessage = 'The request is taking longer than expected. AI processing can take up to 60 seconds for complex requests. Please try again.';
      } else {
        console.error('🌐 Network error - server may be down:', error.message);
        error.isNetworkError = true;
        error.apiMessage = 'Network error - please check your connection and try again';
        
        // Check if backend server is running
        if (error.code === 'ECONNREFUSED' || error.message.includes('Network Error')) {
          error.apiMessage = 'Cannot connect to server. Please ensure the backend is running on ' + getApiBaseUrl();
          console.error('💡 Backend server might not be running. Check: npm start in backend directory');
        }
      }
      
    } else {
      // Request setup error
      console.error('⚙️ Request setup error:', error.message);
      error.apiMessage = 'Request configuration error';
    }
    
    return Promise.reject(error);
  }
);

// Helper function to check if error is authentication related
export const isAuthError = (error) => {
  return error?.response?.status === 401 || 
         error?.apiStatus === 401 ||
         error?.message?.includes('token');
};

// Helper function to check if error is network related
export const isNetworkError = (error) => {
  return error?.isNetworkError || 
         error?.code === 'ECONNREFUSED' ||
         error?.message === 'Network Error';
};

// Helper function to check if error is timeout related
export const isTimeoutError = (error) => {
  return error?.isTimeoutError ||
         error?.code === 'ECONNABORTED' ||
         error?.message?.includes('timeout');
};

// Helper function to check if error is rate limit related - NEW
export const isRateLimitError = (error) => {
  return error?.response?.status === 429 ||
         error?.apiStatus === 429 ||
         error?.message?.includes('rate limit');
};

// Helper function to get user-friendly error message
export const getErrorMessage = (error) => {
  // Handle rate limiting with specific message
  if (isRateLimitError(error)) {
    return 'Too many requests. Please wait a moment before trying again.';
  }
  
  if (error?.apiMessage) {
    return error.apiMessage;
  }
  
  if (error?.response?.data?.error) {
    return error.response.data.error;
  }
  
  if (error?.response?.data?.message) {
    return error.response.data.message;
  }
  
  if (error?.message) {
    return error.message;
  }
  
  return 'An unexpected error occurred. Please try again.';
};

// Helper function to handle API responses consistently
export const handleApiResponse = (response) => {
  if (response?.data?.success === false) {
    throw new Error(response.data.error || 'API returned unsuccessful response');
  }
  return response.data;
};

// Helper function to check if we're currently rate limited - NEW
export const isCurrentlyRateLimited = () => isRateLimited;

// Helper function to clear rate limit state (for testing) - NEW
export const clearRateLimit = () => {
  isRateLimited = false;
  if (rateLimitTimeout) {
    clearTimeout(rateLimitTimeout);
    rateLimitTimeout = null;
  }
  retryQueue = [];
};

export default api;

================
File: frontend/src/utils/jobService.js
================
// src/utils/jobService.js - Updated with Analysis Status Polling
import api from './axios';

const jobService = {
  // Create a new job
  createJob: async (jobData) => {
    try {
      const response = await api.post('/jobs', jobData);
      return response.data;
    } catch (error) {
      console.error('Error creating job:', error);
      throw error;
    }
  },

  // Get all user jobs
  getUserJobs: async () => {
    try {
      const response = await api.get('/jobs');
      return response.data.jobs;
    } catch (error) {
      console.error('Error fetching user jobs:', error);
      throw error;
    }
  },

  // Alias for backward compatibility
  getAllJobs: async () => {
    try {
      const response = await api.get('/jobs');
      return response.data.jobs;
    } catch (error) {
      console.error('Error fetching user jobs:', error);
      throw error;
    }
  },

  // Get job by ID
  getJobById: async (jobId) => {
    try {
      const response = await api.get(`/jobs/${jobId}`);
      return response.data.job;
    } catch (error) {
      console.error('Error fetching job:', error);
      throw error;
    }
  },

  // Get job analysis status
  getJobAnalysisStatus: async (jobId) => {
    try {
      const response = await api.get(`/jobs/analysis-status/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching job analysis status:', error);
      throw error;
    }
  },

  pollJobAnalysisStatus: async (jobId, onProgress = null, maxAttempts = 30) => {
    let attempts = 0;
    
    while (attempts < maxAttempts) {
      try {
        console.log(`📊 Polling attempt ${attempts + 1} for job ${jobId}`);
        
        const statusData = await jobService.getJobAnalysisStatus(jobId);
        const { analysisStatus } = statusData;
        
        console.log(`📊 Status: ${analysisStatus.status} (${analysisStatus.progress}%) - ${analysisStatus.message}`);
        
        // Call progress callback if provided
        if (onProgress) {
          onProgress(analysisStatus);
        }
        
        // Check if analysis is complete
        if (analysisStatus.status === 'completed' || analysisStatus.status === 'error') {
          console.log(`✅ Polling completed for job ${jobId}: ${analysisStatus.status}`);
          return statusData;
        }
        
        // Wait before next poll (2 seconds)
        await new Promise(resolve => setTimeout(resolve, 2000));
        attempts++;
        
      } catch (error) {
        console.error(`❌ Error polling job analysis status (attempt ${attempts + 1}):`, error);
        attempts++;
        
        // Wait a bit longer on error
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }
    
    // Timeout reached
    console.error(`⏰ Analysis status polling timed out for job ${jobId}`);
    throw new Error('Analysis status polling timed out');
  },

  // NEW: Check if job can be viewed (analysis complete)
  canJobBeViewed: async (jobId) => {
    try {
      const statusData = await jobService.getJobAnalysisStatus(jobId);
      return statusData.analysisStatus.canViewJob;
    } catch (error) {
      console.error('Error checking if job can be viewed:', error);
      return false;
    }
  },

  // Get resume match status for a specific job
  getResumeMatchStatus: async (jobId) => {
    try {
      const response = await api.get(`/jobs/${jobId}/resume-match-status`);
      return response.data;
    } catch (error) {
      console.error('Error fetching resume match status:', error);
      throw error;
    }
  },

  // Update job
  updateJob: async (jobId, jobData) => {
    try {
      const response = await api.put(`/jobs/${jobId}`, jobData);
      return response.data;
    } catch (error) {
      console.error('Error updating job:', error);
      throw error;
    }
  },

  // Delete job
  deleteJob: async (jobId) => {
    try {
      const response = await api.delete(`/jobs/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting job:', error);
      throw error;
    }
  },

  // Enhanced match resume with job (now returns detailed analysis)
  matchResumeWithJob: async (jobId, resumeId) => {
    try {
      const response = await api.post(`/jobs/match/${jobId}/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error matching resume with job:', error);
      throw error;
    }
  },

  // Get tailoring recommendations
  getTailoringRecommendations: async (jobId, resumeId) => {
    try {
      const response = await api.post(`/jobs/tailor/${jobId}/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error getting tailoring recommendations:', error);
      throw error;
    }
  },

  // Re-analyze a job with updated AI algorithm
  reAnalyzeJob: async (jobId) => {
    try {
      const response = await api.post(`/jobs/re-analyze/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error re-analyzing job:', error);
      throw error;
    }
  },

  // Get job analysis insights and statistics
  getJobAnalysisInsights: async () => {
    try {
      const response = await api.get('/jobs/analysis-insights');
      return response.data;
    } catch (error) {
      console.error('Error fetching job analysis insights:', error);
      throw error;
    }
  },

  // Bulk match resume against multiple jobs
  bulkMatchResume: async (resumeId, jobIds) => {
    try {
      const response = await api.post(`/jobs/bulk-match/${resumeId}`, { jobIds });
      return response.data;
    } catch (error) {
      console.error('Error bulk matching resume:', error);
      throw error;
    }
  },

  // Enhanced: Find jobs with AI (now with better error handling and status)
  findJobsWithAi: async (resumeId) => {
    try {
      const response = await api.post(`/jobs/find-with-ai/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error finding jobs with AI:', error);
      throw error;
    }
  },

  // AI Job Search Management
  getAiSearches: async () => {
    try {
      const response = await api.get('/jobs/ai-searches');
      return response.data.searches;
    } catch (error) {
      console.error('Error fetching AI searches:', error);
      throw error;
    }
  },

  pauseAiSearch: async (searchId) => {
    try {
      const response = await api.post(`/jobs/ai-search/${searchId}/pause`);
      return response.data;
    } catch (error) {
      console.error('Error pausing AI search:', error);
      throw error;
    }
  },

  resumeAiSearch: async (searchId) => {
    try {
      const response = await api.post(`/jobs/ai-search/${searchId}/resume`);
      return response.data;
    } catch (error) {
      console.error('Error resuming AI search:', error);
      throw error;
    }
  },

  deleteAiSearch: async (searchId) => {
    try {
      const response = await api.delete(`/jobs/ai-search/${searchId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting AI search:', error);
      throw error;
    }
  },

  // Get detailed match history for a job
  getMatchHistory: async (jobId) => {
    try {
      const response = await api.get(`/jobs/match-history/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching match history:', error);
      throw error;
    }
  },

  // Analyze job description text (for manual job entry)
  analyzeJobDescription: async (jobId) => {
    try {
      const response = await api.post(`/jobs/analyze/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error analyzing job description:', error);
      throw error;
    }
  },

  // Get job matching trends and analytics
  getMatchingTrends: async (timeframe = '30d') => {
    try {
      const response = await api.get(`/jobs/trends?timeframe=${timeframe}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching matching trends:', error);
      throw error;
    }
  },

  // Re-match job with best available resume
  rematchJobWithBestResume: async (jobId) => {
    try {
      const response = await api.post(`/jobs/rematch-best/${jobId}`);
      return response.data;
    } catch (error) {
      console.error('Error re-matching job:', error);
      throw error;
    }
  },

  // UTILITY: Check if job analysis is complete
  isJobAnalysisComplete: (job) => {
    return job && 
           job.analysisStatus && 
           job.analysisStatus.status === 'completed' &&
           job.parsedData && 
           Object.keys(job.parsedData).length > 0 && 
           !job.parsedData.analysisError;
  },

  // UTILITY: Check if job has match analysis
  hasMatchAnalysis: (job) => {
    return job && 
           job.matchAnalysis && 
           job.matchAnalysis.overallScore !== undefined;
  },

  // UTILITY: Get match quality description
  getMatchQualityDescription: (score) => {
    if (score >= 85) return { label: 'Excellent', color: 'success' };
    if (score >= 70) return { label: 'Good', color: 'info' };
    if (score >= 55) return { label: 'Fair', color: 'warning' };
    return { label: 'Needs Work', color: 'error' };
  },

  // UTILITY: Get analysis status description
  getAnalysisStatusDescription: (status) => {
    switch (status) {
      case 'pending':
        return { label: 'Queued', color: 'info', icon: 'HourglassEmpty' };
      case 'analyzing':
        return { label: 'Analyzing', color: 'primary', icon: 'AutoAwesome' };
      case 'completed':
        return { label: 'Complete', color: 'success', icon: 'CheckCircle' };
      case 'error':
        return { label: 'Failed', color: 'error', icon: 'Error' };
      default:
        return { label: 'Unknown', color: 'default', icon: 'Help' };
    }
  },

  // UTILITY: Format skill importance level
  getSkillImportanceLabel: (importance) => {
    if (importance >= 9) return 'Critical';
    if (importance >= 7) return 'Very Important';
    if (importance >= 5) return 'Important';
    if (importance >= 3) return 'Nice to Have';
    return 'Optional';
  },

  // UTILITY: Extract skill name safely
  getSkillName: (skill) => {
    if (typeof skill === 'string') {
      return skill;
    }
    if (skill && typeof skill === 'object') {
      return skill.name || skill.skill || 'Unknown Skill';
    }
    return 'Unknown Skill';
  },

  // NEW: Create job with status tracking
  createJobWithStatusTracking: async (jobData, onProgress = null) => {
    try {
      // Create the job
      const createResponse = await jobService.createJob(jobData);
      const jobId = createResponse.job.id;
      
      // Start polling for status if callback provided
      if (onProgress) {
        setTimeout(() => {
          jobService.pollJobAnalysisStatus(jobId, onProgress).catch(error => {
            console.error('Error polling job status:', error);
            onProgress({
              status: 'error',
              message: 'Status polling failed',
              progress: 0
            });
          });
        }, 1000);
      }
      
      return createResponse;
    } catch (error) {
      console.error('Error creating job with status tracking:', error);
      throw error;
    }
  }
};

export default jobService;

================
File: frontend/src/utils/recruiterService.js
================
// frontend/src/utils/recruiterService.js - COMPLETE UPDATED VERSION
import api from './axios';

const recruiterService = {
  // ===================================================================
  // RECRUITER SEARCH & DISCOVERY
  // ===================================================================

  /**
   * Search recruiters with advanced filtering
   */
  searchRecruiters: async (filters = {}) => {
    try {
      const {
        query = '',
        company = '',
        industry = '',
        location = '',
        title = '',
        experienceMin = '',
        experienceMax = '',
        experience_min = '', // Support both formats
        experience_max = '', // Support both formats
        limit = 20,
        offset = 0,
        sortBy = 'last_active_date',
        sortOrder = 'DESC',
        sort_by = '', // Support both formats
        sort_order = '' // Support both formats
      } = filters;

      console.log('🔍 Searching recruiters with filters:', filters);

      const params = new URLSearchParams();
      if (query) params.append('query', query);
      if (company) params.append('company', company);
      if (industry) params.append('industry', industry);
      if (location) params.append('location', location);
      if (title) params.append('title', title);
      if (experienceMin || experience_min) params.append('experience_min', experienceMin || experience_min);
      if (experienceMax || experience_max) params.append('experience_max', experienceMax || experience_max);
      params.append('limit', limit);
      params.append('offset', offset);
      params.append('sort_by', sort_by || sortBy);
      params.append('sort_order', sort_order || sortOrder);

      const response = await api.get(`/recruiters/search?${params}`);
      
      console.log(`✅ Found ${response.data.recruiters.length} recruiters`);
      return response.data;

    } catch (error) {
      console.error('Search recruiters error:', error);
      throw error;
    }
  },

  /**
   * Get recruiter details by ID
   */
  getRecruiterDetails: async (recruiterId) => {
    try {
      console.log(`👤 Fetching details for recruiter ${recruiterId}`);
      const response = await api.get(`/recruiters/${recruiterId}`);
      
      console.log(`✅ Retrieved recruiter: ${response.data.recruiter.fullName}`);
      return response.data;

    } catch (error) {
      console.error('Get recruiter details error:', error);
      throw error;
    }
  },

  // Alias for compatibility with components
  getRecruiterById: async (recruiterId) => {
    return await recruiterService.getRecruiterDetails(recruiterId);
  },

  /**
   * Get filter options for search
   */
  getFilterOptions: async () => {
    try {
      console.log('📊 Fetching filter options');
      const response = await api.get('/recruiters/filters');
      
      console.log('✅ Retrieved filter options');
      return response.data;

    } catch (error) {
      console.error('Get filter options error:', error);
      throw error;
    }
  },

  // ===================================================================
  // OUTREACH MANAGEMENT
  // ===================================================================

  /**
   * Create outreach campaign
   */
  createOutreach: async (outreachData) => {
    try {
      const {
        recruiterId,
        jobId,
        messageContent,
        messageTemplate,
        sentVia = 'linkedin',
        customizations = []
      } = outreachData;

      console.log(`📧 Creating outreach for recruiter ${recruiterId}`);

      const response = await api.post('/recruiters/outreach', {
        recruiterId,
        jobId,
        messageContent,
        messageTemplate,
        sentVia,
        customizations
      });

      console.log(`✅ Created outreach campaign: ${response.data.outreach.id}`);
      return response.data;

    } catch (error) {
      console.error('Create outreach error:', error);
      throw error;
    }
  },

  /**
   * Update outreach campaign
   */
  updateOutreach: async (outreachId, updates) => {
    try {
      console.log(`📝 Updating outreach ${outreachId}`);
      const response = await api.put(`/recruiters/outreach/${outreachId}`, updates);
      
      console.log('✅ Outreach updated successfully');
      return response.data;

    } catch (error) {
      console.error('Update outreach error:', error);
      throw error;
    }
  },

  /**
   * Delete outreach campaign
   */
  deleteOutreach: async (outreachId) => {
    try {
      console.log(`🗑️ Deleting outreach ${outreachId}`);
      const response = await api.delete(`/recruiters/outreach/${outreachId}`);
      
      console.log('✅ Outreach deleted successfully');
      return response.data;

    } catch (error) {
      console.error('Delete outreach error:', error);
      throw error;
    }
  },

  /**
   * Send outreach message
   */
  sendOutreach: async (outreachId) => {
    try {
      console.log(`📤 Sending outreach ${outreachId}`);
      const response = await api.put(`/recruiters/outreach/${outreachId}/send`);
      
      console.log('✅ Outreach sent successfully');
      return response.data;

    } catch (error) {
      console.error('Send outreach error:', error);
      throw error;
    }
  },

  /**
   * Get user's outreach campaigns
   */
  getUserOutreach: async (filters = {}) => {
    try {
      const {
        status = '',
        limit = 20,
        offset = 0
      } = filters;

      console.log('📋 Fetching user outreach campaigns');

      const params = new URLSearchParams();
      if (status) params.append('status', status);
      params.append('limit', limit);
      params.append('offset', offset);

      const response = await api.get(`/recruiters/outreach?${params}`);
      
      console.log(`✅ Retrieved ${response.data.outreaches.length} outreach campaigns`);
      return response.data;

    } catch (error) {
      console.error('Get user outreach error:', error);
      throw error;
    }
  },

  // ===================================================================
  // AI-POWERED FEATURES
  // ===================================================================

  /**
   * Generate personalized message using AI
   */
  generatePersonalizedMessage: async (messageParams) => {
    try {
      const {
        recruiterId,
        resumeId,
        jobId,
        messageType = 'introduction',
        tone = 'professional',
        customRequirements = ''
      } = messageParams;

      console.log(`🤖 Generating personalized message for recruiter ${recruiterId}`);

      const response = await api.post('/recruiters/generate-message', {
        recruiterId,
        resumeId,
        jobId,
        messageType,
        tone,
        customRequirements
      });

      console.log(`✅ Generated ${response.data.message.length} character message`);
      return response.data;

    } catch (error) {
      console.error('Generate message error:', error);
      throw error;
    }
  },

  // ===================================================================
  // ANALYTICS & REPORTING
  // ===================================================================

  /**
   * Get outreach analytics
   */
  getAnalytics: async (timeframe = '30d') => {
    try {
      console.log(`📊 Fetching outreach analytics for ${timeframe}`);
      const response = await api.get(`/recruiters/analytics?timeframe=${timeframe}`);
      
      console.log('✅ Retrieved outreach analytics');
      
      // Ensure consistent response format
      if (response.data.analytics) {
        return response.data;
      } else {
        return { analytics: response.data };
      }

    } catch (error) {
      console.error('Get analytics error:', error);
      throw error;
    }
  },

  // ===================================================================
  // UTILITY FUNCTIONS
  // ===================================================================

  /**
   * Format recruiter data for display
   */
  formatRecruiterForDisplay: (recruiter) => {
    if (!recruiter) return null;

    return {
      ...recruiter,
      displayName: recruiter.fullName || `${recruiter.firstName} ${recruiter.lastName}`,
      companyDisplay: recruiter.company?.name || 'Unknown Company',
      locationDisplay: recruiter.location ? 
        `${recruiter.location.city || ''}${recruiter.location.state ? `, ${recruiter.location.state}` : ''}${recruiter.location.country ? `, ${recruiter.location.country}` : ''}`.replace(/^, /, '') :
        'Location not specified',
      experienceDisplay: recruiter.experienceYears ? 
        `${recruiter.experienceYears} year${recruiter.experienceYears !== 1 ? 's' : ''} experience` :
        'Experience not specified',
      lastActiveDisplay: recruiter.lastActiveDate ? 
        new Date(recruiter.lastActiveDate).toLocaleDateString() :
        'Last active not specified',
      hasContactInfo: !!(recruiter.email || recruiter.phone || recruiter.linkedinUrl),
      hasBeenContacted: recruiter.outreach?.hasContacted || false,
      outreachStatus: recruiter.outreach?.status || 'not_contacted'
    };
  },

  /**
   * Format outreach campaign for display
   */
  formatOutreachForDisplay: (outreach) => {
    if (!outreach) return null;

    return {
      ...outreach,
      recruiterDisplay: outreach.recruiter?.name || 'Unknown Recruiter',
      companyDisplay: outreach.recruiter?.company?.name || 'Unknown Company',
      statusDisplay: outreach.status.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase()),
      createdDisplay: new Date(outreach.createdAt).toLocaleDateString(),
      sentDisplay: outreach.sentAt ? new Date(outreach.sentAt).toLocaleDateString() : null,
      messagePreview: outreach.messageContent.length > 100 ? 
        outreach.messageContent.substring(0, 100) + '...' :
        outreach.messageContent,
      canSend: outreach.status === 'drafted',
      canEdit: outreach.status === 'drafted',
      hasReplies: outreach.repliesCount > 0,
      hasFollowUps: outreach.followUpsCount > 0
    };
  },

  /**
   * Validate outreach data before sending
   */
  validateOutreachData: (outreachData) => {
    const errors = [];

    if (!outreachData.recruiterId) {
      errors.push('Recruiter selection is required');
    }

    if (!outreachData.messageContent || outreachData.messageContent.trim().length < 10) {
      errors.push('Message content must be at least 10 characters');
    }

    if (outreachData.messageContent && outreachData.messageContent.length > 2000) {
      errors.push('Message content must be less than 2000 characters');
    }

    if (!['email', 'linkedin', 'phone', 'other'].includes(outreachData.sentVia)) {
      errors.push('Invalid communication method');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Get default message templates
   */
  getMessageTemplates: () => {
    return {
      introduction: {
        name: 'Introduction',
        description: 'Initial outreach to introduce yourself',
        defaultTone: 'professional',
        suggestedLength: '150-250 words'
      },
      follow_up: {
        name: 'Follow Up',
        description: 'Follow up on previous communication',
        defaultTone: 'friendly',
        suggestedLength: '100-200 words'
      },
      application: {
        name: 'Job Application',
        description: 'Express interest in a specific position',
        defaultTone: 'professional',
        suggestedLength: '200-300 words'
      },
      thank_you: {
        name: 'Thank You',
        description: 'Thank recruiter for their time or assistance',
        defaultTone: 'grateful',
        suggestedLength: '75-150 words'
      }
    };
  },

  /**
   * Get available tone options
   */
  getToneOptions: () => {
    return [
      { value: 'professional', label: 'Professional', description: 'Formal and business-appropriate' },
      { value: 'friendly', label: 'Friendly', description: 'Warm and approachable' },
      { value: 'casual', label: 'Casual', description: 'Relaxed and conversational' },
      { value: 'formal', label: 'Formal', description: 'Very structured and traditional' }
    ];
  },

  /**
   * Get experience level filters
   */
  getExperienceLevels: () => {
    return [
      { value: '0-2', label: '0-2 years', min: 0, max: 2 },
      { value: '3-5', label: '3-5 years', min: 3, max: 5 },
      { value: '6-10', label: '6-10 years', min: 6, max: 10 },
      { value: '11-15', label: '11-15 years', min: 11, max: 15 },
      { value: '16+', label: '16+ years', min: 16, max: 50 }
    ];
  },

  /**
   * Calculate outreach success metrics
   */
  calculateSuccessMetrics: (outreaches) => {
    if (!outreaches || outreaches.length === 0) {
      return {
        totalSent: 0,
        responseRate: 0,
        averageResponseTime: 0,
        topPerformingTemplate: null,
        engagementScore: 0
      };
    }

    const sent = outreaches.filter(o => ['sent', 'delivered', 'opened', 'replied'].includes(o.status));
    const replied = outreaches.filter(o => o.status === 'replied');
    
    const responseRate = sent.length > 0 ? (replied.length / sent.length) * 100 : 0;
    
    // Calculate template performance
    const templateStats = {};
    outreaches.forEach(outreach => {
      const template = outreach.messageTemplate || 'custom';
      if (!templateStats[template]) {
        templateStats[template] = { total: 0, replied: 0 };
      }
      templateStats[template].total++;
      if (outreach.status === 'replied') {
        templateStats[template].replied++;
      }
    });

    const topTemplate = Object.entries(templateStats)
      .map(([template, stats]) => ({
        template,
        responseRate: stats.total > 0 ? (stats.replied / stats.total) * 100 : 0,
        total: stats.total
      }))
      .sort((a, b) => b.responseRate - a.responseRate)[0];

    return {
      totalSent: sent.length,
      totalReplies: replied.length,
      responseRate: Math.round(responseRate * 100) / 100,
      topPerformingTemplate: topTemplate?.template || null,
      topPerformingRate: topTemplate?.responseRate || 0,
      engagementScore: Math.round(responseRate * 2) // Simple engagement calculation
    };
  },

  /**
   * Export outreach data for external use
   */
  exportOutreachData: async (format = 'csv', filters = {}) => {
    try {
      console.log(`📤 Exporting outreach data in ${format} format`);
      
      const outreachData = await recruiterService.getUserOutreach({
        ...filters,
        limit: 1000 // Get all data for export
      });

      if (format === 'csv') {
        return recruiterService.convertToCSV(outreachData.outreaches);
      } else if (format === 'json') {
        return JSON.stringify(outreachData.outreaches, null, 2);
      }

      throw new Error('Unsupported export format');

    } catch (error) {
      console.error('Export outreach data error:', error);
      throw error;
    }
  },

  /**
   * Convert outreach data to CSV format
   */
  convertToCSV: (outreaches) => {
    if (!outreaches || outreaches.length === 0) {
      return 'No data to export';
    }

    const headers = [
      'Recruiter Name',
      'Company',
      'Email',
      'Status',
      'Message Type',
      'Sent Via',
      'Created Date',
      'Sent Date',
      'Replies Count',
      'Message Preview'
    ];

    const rows = outreaches.map(outreach => [
      outreach.recruiter?.name || 'Unknown',
      outreach.recruiter?.company?.name || 'Unknown',
      outreach.recruiter?.email || '',
      outreach.status,
      outreach.messageTemplate || 'custom',
      outreach.sentVia,
      new Date(outreach.createdAt).toLocaleDateString(),
      outreach.sentAt ? new Date(outreach.sentAt).toLocaleDateString() : '',
      outreach.repliesCount || 0,
      outreach.messageContent.substring(0, 100) + '...'
    ]);

    const csvContent = [headers, ...rows]
      .map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
      .join('\n');

    return csvContent;
  },

  /**
   * Get intelligent recommendations for message improvements
   */
  getMessageRecommendations: (messageContent, recruiterData, userContext = {}) => {
    const recommendations = [];
    const content = messageContent.toLowerCase();

    // Length recommendations
    if (messageContent.length < 50) {
      recommendations.push({
        type: 'length',
        severity: 'warning',
        message: 'Message is quite short. Consider adding more context about your background or interest.'
      });
    } else if (messageContent.length > 1500) {
      recommendations.push({
        type: 'length',
        severity: 'warning',
        message: 'Message is quite long. Consider shortening it for better readability.'
      });
    }

    // Personalization recommendations
    if (!content.includes(recruiterData.firstName?.toLowerCase()) && 
        !content.includes(recruiterData.company?.name?.toLowerCase())) {
      recommendations.push({
        type: 'personalization',
        severity: 'info',
        message: 'Consider mentioning the recruiter\'s name or company for better personalization.'
      });
    }

    // Call-to-action recommendations
    if (!content.includes('would love to') && 
        !content.includes('would like to') && 
        !content.includes('schedule') && 
        !content.includes('discuss')) {
      recommendations.push({
        type: 'call_to_action',
        severity: 'info',
        message: 'Consider adding a clear call-to-action like "Would love to schedule a brief call".'
      });
    }

    // Subject matter recommendations
    if (userContext.targetRole && !content.includes(userContext.targetRole.toLowerCase())) {
      recommendations.push({
        type: 'relevance',
        severity: 'info',
        message: `Consider mentioning your target role (${userContext.targetRole}) to show clear intent.`
      });
    }

    return recommendations;
  }
};

export default recruiterService;

================
File: frontend/src/utils/resumeService.js
================
// src/utils/resumeService.js
import api from './axios';

const resumeService = {
  // Get all resumes for the user
  getUserResumes: async () => {
    try {
      const response = await api.get('/resumes');
      return response.data.resumes || [];
    } catch (error) {
      console.error('Error fetching resumes:', error);
      throw error;
    }
  },
  
  // Get a specific resume by ID
  getResumeById: async (resumeId) => {
    try {
      const response = await api.get(`/resumes/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching resume:', error);
      throw error;
    }
  },
  
  // Upload a new resume
  uploadResume: async (formData) => {
    try {
      const response = await api.post('/resumes/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading resume:', error);
      throw error;
    }
  },
  
  // Check resume processing status
  checkResumeStatus: async (resumeId) => {
    try {
      const response = await api.get(`/resumes/status/${resumeId}`);
      return response.data.processingStatus;
    } catch (error) {
      console.error('Error checking resume status:', error);
      throw error;
    }
  },
  
  // Poll resume status until completion or timeout
  pollResumeStatus: async (resumeId, onProgress, timeout = 300000) => {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const interval = 2000; // Poll every 2 seconds
      
      const checkStatus = async () => {
        try {
          if (Date.now() - startTime > timeout) {
            clearInterval(pollInterval);
            reject(new Error('Resume processing timed out'));
            return;
          }
          
          const status = await resumeService.checkResumeStatus(resumeId);
          
          if (onProgress) onProgress(status);
          
          if (status.status === 'completed') {
            clearInterval(pollInterval);
            resolve(status);
          }
          
          if (status.status === 'error') {
            clearInterval(pollInterval);
            reject(new Error(status.error || 'Processing failed'));
          }
        } catch (error) {
          console.error('Error polling status:', error);
        }
      };
      
      const pollInterval = setInterval(checkStatus, interval);
      checkStatus(); // Immediate first check
    });
  },
  
  // Analyze a resume
  analyzeResume: async (resumeId) => {
    try {
      const response = await api.post(`/resumes/analyze/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error analyzing resume:', error);
      throw error;
    }
  },
  
  // Add a new version to an existing resume
  addResumeVersion: async (resumeId, formData) => {
    try {
      const response = await api.post(`/resumes/versions/${resumeId}`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error adding resume version:', error);
      throw error;
    }
  },
  
  // Create a tailored resume
  createTailoredResume: async (resumeId, jobId, options = {}) => {
    try {
      const response = await api.post(`/resumes/tailor/${resumeId}/${jobId}`, options);
      return response.data;
    } catch (error) {
      console.error('Error creating tailored resume:', error);
      throw error;
    }
  },
  
  // Delete a resume
  deleteResume: async (resumeId) => {
    try {
      const response = await api.delete(`/resumes/${resumeId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting resume:', error);
      throw error;
    }
  }
};

export default resumeService;

================
File: frontend/src/utils/searchService.js
================
// src/utils/searchService.js
import api from './axios';

const searchService = {
  /**
   * Global search across all content types
   */
  globalSearch: async (query, options = {}) => {
    try {
      const {
        category = 'all',
        limit = 20,
        includeContent = false
      } = options;

      if (!query || query.trim().length < 2) {
        return {
          success: false,
          error: 'Search query must be at least 2 characters long'
        };
      }

      console.log(`🔍 Searching for: "${query}" in category: ${category}`);

      const params = new URLSearchParams();
      params.append('query', query.trim());
      params.append('category', category);
      params.append('limit', limit);
      if (includeContent) params.append('includeContent', 'true');

      const response = await api.get(`/search?${params}`);
      
      console.log(`✅ Search completed: ${response.data.data.results.totalCount} results`);
      return response.data;

    } catch (error) {
      console.error('Global search error:', error);
      throw error;
    }
  },

  /**
   * Get search suggestions as user types
   */
  getSuggestions: async (query, limit = 5) => {
    try {
      if (!query || query.length < 2) {
        return { suggestions: [] };
      }

      const params = new URLSearchParams();
      params.append('query', query);
      params.append('limit', limit);

      const response = await api.get(`/search/suggestions?${params}`);
      return response.data.data;

    } catch (error) {
      console.error('Get suggestions error:', error);
      return { suggestions: [] };
    }
  },

  /**
   * Get popular searches
   */
  getPopularSearches: async () => {
    try {
      const response = await api.get('/search/popular');
      return response.data.data;
    } catch (error) {
      console.error('Get popular searches error:', error);
      return { searches: [] };
    }
  },

  /**
   * Search specific category with custom parameters
   */
  searchJobs: async (query, options = {}) => {
    try {
      const result = await searchService.globalSearch(query, {
        ...options,
        category: 'jobs'
      });
      return result.data?.results?.jobs || [];
    } catch (error) {
      console.error('Search jobs error:', error);
      return [];
    }
  },

  searchResumes: async (query, options = {}) => {
    try {
      const result = await searchService.globalSearch(query, {
        ...options,
        category: 'resumes'
      });
      return result.data?.results?.resumes || [];
    } catch (error) {
      console.error('Search resumes error:', error);
      return [];
    }
  },

  searchRecruiters: async (query, options = {}) => {
    try {
      const result = await searchService.globalSearch(query, {
        ...options,
        category: 'recruiters'
      });
      return result.data?.results?.recruiters || [];
    } catch (error) {
      console.error('Search recruiters error:', error);
      return [];
    }
  },

  /**
   * Format search results for display
   */
  formatSearchResults: (results) => {
    const formatted = {
      all: [],
      jobs: [],
      resumes: [],
      recruiters: [],
      totalCount: 0
    };

    if (!results) return formatted;

    // Combine all results for 'all' category view
    const allResults = [
      ...(results.jobs || []),
      ...(results.resumes || []),
      ...(results.recruiters || [])
    ];

    // Sort all results by relevance/date
    allResults.sort((a, b) => {
      // Prioritize by type relevance, then by date
      const typeOrder = { job: 0, resume: 1, recruiter: 2 };
      if (typeOrder[a.type] !== typeOrder[b.type]) {
        return typeOrder[a.type] - typeOrder[b.type];
      }
      return new Date(b.createdAt || b.lastActiveDate) - new Date(a.createdAt || a.lastActiveDate);
    });

    formatted.all = allResults;
    formatted.jobs = results.jobs || [];
    formatted.resumes = results.resumes || [];
    formatted.recruiters = results.recruiters || [];
    formatted.totalCount = results.totalCount || 0;

    return formatted;
  },

  /**
   * Get result type icon and color
   */
  getResultTypeDisplay: (type) => {
    const displays = {
      job: {
        icon: 'Work',
        color: '#4285f4',
        label: 'Job'
      },
      resume: {
        icon: 'Description',
        color: '#34a853',
        label: 'Resume'
      },
      recruiter: {
        icon: 'Person',
        color: '#00c4b4',
        label: 'Recruiter'
      }
    };

    return displays[type] || {
      icon: 'Search',
      color: '#666',
      label: 'Unknown'
    };
  },

  /**
   * Highlight search terms in text
   */
  highlightSearchTerms: (text, searchQuery) => {
    if (!text || !searchQuery) return text;

    const regex = new RegExp(`(${searchQuery.split(' ').join('|')})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  },

  /**
   * Get search categories for filtering
   */
  getSearchCategories: () => {
    return [
      { value: 'all', label: 'All Results', icon: 'Search' },
      { value: 'jobs', label: 'Jobs', icon: 'Work' },
      { value: 'resumes', label: 'Resumes', icon: 'Description' },
      { value: 'recruiters', label: 'Recruiters', icon: 'Person' }
    ];
  },

  /**
   * Debounced search function
   */
  createDebouncedSearch: (callback, delay = 300) => {
    let timeoutId;
    
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => callback.apply(null, args), delay);
    };
  },

  /**
   * Save search to local storage for recent searches
   */
  saveRecentSearch: (query, results) => {
    try {
      const recentSearches = searchService.getRecentSearches();
      
      // Remove if already exists
      const filtered = recentSearches.filter(search => 
        search.query.toLowerCase() !== query.toLowerCase()
      );
      
      // Add to beginning
      filtered.unshift({
        query,
        timestamp: new Date().toISOString(),
        resultCount: results.totalCount || 0
      });
      
      // Keep only last 10 searches
      const limited = filtered.slice(0, 10);
      
      localStorage.setItem('recentSearches', JSON.stringify(limited));
    } catch (error) {
      console.error('Save recent search error:', error);
    }
  },

  /**
   * Get recent searches from local storage
   */
  getRecentSearches: () => {
    try {
      const stored = localStorage.getItem('recentSearches');
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Get recent searches error:', error);
      return [];
    }
  },

  /**
   * Clear recent searches
   */
  clearRecentSearches: () => {
    try {
      localStorage.removeItem('recentSearches');
    } catch (error) {
      console.error('Clear recent searches error:', error);
    }
  },

  /**
   * Validate search query
   */
  validateSearchQuery: (query) => {
    const errors = [];
    
    if (!query || query.trim().length === 0) {
      errors.push('Search query cannot be empty');
    }
    
    if (query && query.trim().length < 2) {
      errors.push('Search query must be at least 2 characters long');
    }
    
    if (query && query.length > 100) {
      errors.push('Search query must be less than 100 characters');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Get search keyboard shortcuts
   */
  getKeyboardShortcuts: () => {
    return {
      openSearch: ['/', 'Ctrl+K', 'Cmd+K'],
      closeSearch: ['Escape'],
      navigateResults: ['ArrowUp', 'ArrowDown'],
      selectResult: ['Enter'],
      nextCategory: ['Tab'],
      previousCategory: ['Shift+Tab']
    };
  }
};

export default searchService;

================
File: frontend/src/utils/settingsService.js
================
// src/utils/settingsService.js
import api from './axios';

const settingsService = {
  /**
   * Get user profile information
   */
  getProfile: async () => {
    try {
      console.log('📋 Fetching user profile...');
      const response = await api.get('/settings/profile');
      console.log('✅ Profile fetched successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Get profile error:', error);
      throw error;
    }
  },

  /**
   * Update user profile information
   */
  updateProfile: async (profileData) => {
    try {
      console.log('📝 Updating user profile...', profileData);
      const response = await api.put('/settings/profile', profileData);
      console.log('✅ Profile updated successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Update profile error:', error);
      throw error;
    }
  },

  /**
   * Change user password
   */
  changePassword: async (passwordData) => {
    try {
      console.log('🔒 Changing password...');
      const response = await api.put('/settings/change-password', passwordData);
      console.log('✅ Password changed successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Change password error:', error);
      throw error;
    }
  },

  /**
   * Delete user account
   */
  deleteAccount: async (confirmationData = {}) => {
    try {
      console.log('🗑️ Deleting account...');
      const response = await api.delete('/settings/delete-account', {
        data: confirmationData
      });
      console.log('✅ Account deleted successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Delete account error:', error);
      throw error;
    }
  },

  /**
   * Send email verification
   */
  sendVerificationEmail: async () => {
    try {
      console.log('📧 Sending verification email...');
      const response = await api.post('/settings/send-verification-email');
      console.log('✅ Verification email sent');
      return response.data;
    } catch (error) {
      console.error('❌ Send verification email error:', error);
      throw error;
    }
  },

  /**
   * Verify email address
   */
  verifyEmail: async (token) => {
    try {
      console.log('✉️ Verifying email...');
      const response = await api.get(`/settings/verify-email/${token}`);
      console.log('✅ Email verified successfully');
      return response.data;
    } catch (error) {
      console.error('❌ Verify email error:', error);
      throw error;
    }
  },

  /**
   * Validate profile data before submission
   */
  validateProfileData: (profileData) => {
    const errors = [];

    // Required fields
    if (!profileData.firstName?.trim()) {
      errors.push('First name is required');
    }

    if (!profileData.lastName?.trim()) {
      errors.push('Last name is required');
    }

    if (!profileData.email?.trim()) {
      errors.push('Email address is required');
    }

    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (profileData.email && !emailRegex.test(profileData.email)) {
      errors.push('Please enter a valid email address');
    }

    // Phone number validation (optional)
    if (profileData.phoneNumber) {
      const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/;
      if (!phoneRegex.test(profileData.phoneNumber.replace(/\D/g, ''))) {
        errors.push('Please enter a valid phone number');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Validate password data before submission
   */
  validatePasswordData: (passwordData) => {
    const errors = [];

    if (!passwordData.currentPassword) {
      errors.push('Current password is required');
    }

    if (!passwordData.newPassword) {
      errors.push('New password is required');
    }

    if (!passwordData.confirmPassword) {
      errors.push('Please confirm your new password');
    }

    if (passwordData.newPassword && passwordData.newPassword.length < 8) {
      errors.push('New password must be at least 8 characters long');
    }

    if (passwordData.newPassword && passwordData.confirmPassword && 
        passwordData.newPassword !== passwordData.confirmPassword) {
      errors.push('New passwords do not match');
    }

    if (passwordData.currentPassword && passwordData.newPassword && 
        passwordData.currentPassword === passwordData.newPassword) {
      errors.push('New password must be different from current password');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Calculate password strength
   */
  calculatePasswordStrength: (password) => {
    if (!password) return { strength: 0, label: '', color: 'default' };

    let score = 0;
    const checks = {
      length: password.length >= 8,
      lowercase: /[a-z]/.test(password),
      uppercase: /[A-Z]/.test(password),
      numbers: /\d/.test(password),
      symbols: /[^A-Za-z0-9]/.test(password)
    };

    // Calculate score
    Object.values(checks).forEach(check => {
      if (check) score += 20;
    });

    // Bonus for length
    if (password.length >= 12) score += 10;
    if (password.length >= 16) score += 10;

    // Determine strength level
    let strength, label, color;
    if (score < 40) {
      strength = score;
      label = 'Weak';
      color = 'error';
    } else if (score < 60) {
      strength = score;
      label = 'Fair';
      color = 'warning';
    } else if (score < 80) {
      strength = score;
      label = 'Good';
      color = 'info';
    } else {
      strength = Math.min(score, 100);
      label = 'Strong';
      color = 'success';
    }

    return { strength, label, color, checks };
  },

  /**
   * Format phone number for display
   */
  formatPhoneNumber: (phoneNumber) => {
    if (!phoneNumber) return '';
    
    // Remove all non-digit characters
    const digits = phoneNumber.replace(/\D/g, '');
    
    // Format US phone numbers
    if (digits.length === 10) {
      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
    } else if (digits.length === 11 && digits[0] === '1') {
      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
    }
    
    // Return original if can't format
    return phoneNumber;
  },

  /**
   * Get error message from API response
   */
  getErrorMessage: (error) => {
    if (error.response?.data?.error) {
      return error.response.data.error;
    } else if (error.response?.data?.message) {
      return error.response.data.message;
    } else if (error.message) {
      return error.message;
    } else {
      return 'An unexpected error occurred';
    }
  },

  /**
   * Check if email verification is needed
   */
  needsEmailVerification: (user) => {
    return user && !user.isEmailVerified;
  },

  /**
   * Calculate profile completion percentage
   */
  calculateProfileCompletion: (user) => {
    if (!user) return 0;

    const fields = [
      user.firstName,
      user.lastName,
      user.email,
      user.phoneNumber
    ];

    const completedFields = fields.filter(field => field && field.trim()).length;
    return Math.round((completedFields / fields.length) * 100);
  },

  /**
   * Get account security score
   */
  getSecurityScore: (user) => {
    if (!user) return 0;

    let score = 0;
    const maxScore = 100;

    // Email verification (40 points)
    if (user.isEmailVerified) score += 40;

    // Profile completeness (30 points)
    const completionPercentage = settingsService.calculateProfileCompletion(user);
    score += (completionPercentage / 100) * 30;

    // Account age (15 points)
    if (user.createdAt) {
      const accountAge = Date.now() - new Date(user.createdAt).getTime();
      const daysOld = accountAge / (1000 * 60 * 60 * 24);
      if (daysOld > 30) score += 15;
      else score += (daysOld / 30) * 15;
    }

    // Phone number (15 points)
    if (user.phoneNumber) score += 15;

    return Math.min(Math.round(score), maxScore);
  }
};

export default settingsService;

================
File: package.json
================
{
  "name": "auto-job-platform",
  "version": "1.0.0",
  "description": "Auto-Job.ai Platform - Backend and Frontend",
  "main": "backend/server.js",
  "scripts": {
    "start": "cd backend && npm start",
    "dev": "cd backend && npm run dev",
    "install:backend": "cd backend && npm install",
    "install:frontend": "cd frontend && npm install",
    "build:frontend": "cd frontend && npm run build"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "workspaces": [
    "backend",
    "frontend"
  ],
  "dependencies": {
    "cheerio": "^1.1.0",
    "puppeteer": "^24.10.2",
    "user-agents": "^1.1.582"
  }
}

================
File: railway.json
================
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "cd backend && npm start",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  },
  "environments": {
    "production": {
      "NIXPACKS_INSTALL_CMD": "cd backend && npm install",
      "NIXPACKS_BUILD_CMD": "echo 'Build complete'",
      "NIXPACKS_START_CMD": "cd backend && npm start"
    }
  }
}
